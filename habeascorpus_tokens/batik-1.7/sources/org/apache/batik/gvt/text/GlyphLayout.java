/* Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
gvt	TokenNameIdentifier	 gvt
.	TokenNameDOT	
text	TokenNameIdentifier	 text
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
BasicStroke	TokenNameIdentifier	 Basic Stroke
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
Graphics2D	TokenNameIdentifier	 Graphics2 D
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
Shape	TokenNameIdentifier	 Shape
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
Stroke	TokenNameIdentifier	 Stroke
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
font	TokenNameIdentifier	 font
.	TokenNameDOT	
FontRenderContext	TokenNameIdentifier	 Font Render Context
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
font	TokenNameIdentifier	 font
.	TokenNameDOT	
TextAttribute	TokenNameIdentifier	 Text Attribute
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
geom	TokenNameIdentifier	 geom
.	TokenNameDOT	
AffineTransform	TokenNameIdentifier	 Affine Transform
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
geom	TokenNameIdentifier	 geom
.	TokenNameDOT	
Area	TokenNameIdentifier	 Area
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
geom	TokenNameIdentifier	 geom
.	TokenNameDOT	
GeneralPath	TokenNameIdentifier	 General Path
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
geom	TokenNameIdentifier	 geom
.	TokenNameDOT	
PathIterator	TokenNameIdentifier	 Path Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
geom	TokenNameIdentifier	 geom
.	TokenNameDOT	
Point2D	TokenNameIdentifier	 Point2 D
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
geom	TokenNameIdentifier	 geom
.	TokenNameDOT	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
geom	TokenNameIdentifier	 geom
.	TokenNameDOT	
Line2D	TokenNameIdentifier	 Line2 D
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
AttributedCharacterIterator	TokenNameIdentifier	 Attributed Character Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
CharacterIterator	TokenNameIdentifier	 Character Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
HashSet	TokenNameIdentifier	 Hash Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Set	TokenNameIdentifier	 Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
gvt	TokenNameIdentifier	 gvt
.	TokenNameDOT	
font	TokenNameIdentifier	 font
.	TokenNameDOT	
AWTGVTFont	TokenNameIdentifier	 AWTGVT Font
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
gvt	TokenNameIdentifier	 gvt
.	TokenNameDOT	
font	TokenNameIdentifier	 font
.	TokenNameDOT	
AltGlyphHandler	TokenNameIdentifier	 Alt Glyph Handler
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
gvt	TokenNameIdentifier	 gvt
.	TokenNameDOT	
font	TokenNameIdentifier	 font
.	TokenNameDOT	
GVTFont	TokenNameIdentifier	 GVT Font
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
gvt	TokenNameIdentifier	 gvt
.	TokenNameDOT	
font	TokenNameIdentifier	 font
.	TokenNameDOT	
GVTGlyphMetrics	TokenNameIdentifier	 GVT Glyph Metrics
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
gvt	TokenNameIdentifier	 gvt
.	TokenNameDOT	
font	TokenNameIdentifier	 font
.	TokenNameDOT	
GVTGlyphVector	TokenNameIdentifier	 GVT Glyph Vector
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
gvt	TokenNameIdentifier	 gvt
.	TokenNameDOT	
font	TokenNameIdentifier	 font
.	TokenNameDOT	
GVTLineMetrics	TokenNameIdentifier	 GVT Line Metrics
;	TokenNameSEMICOLON	
/** * Implementation of TextSpanLayout which uses java.awt.font.GlyphVector. * @see org.apache.batik.gvt.text.TextSpanLayout * * @author <a href="mailto:bill.haneman@ireland.sun.com">Bill Haneman</a> * @version $Id: GlyphLayout.java 588550 2007-10-26 07:52:41Z dvholten $ */	TokenNameCOMMENT_JAVADOC	 Implementation of TextSpanLayout which uses java.awt.font.GlyphVector. @see org.apache.batik.gvt.text.TextSpanLayout * @author <a href="mailto:bill.haneman@ireland.sun.com">Bill Haneman</a> @version $Id: GlyphLayout.java 588550 2007-10-26 07:52:41Z dvholten $ 
public	TokenNamepublic	
class	TokenNameclass	
GlyphLayout	TokenNameIdentifier	 Glyph Layout
implements	TokenNameimplements	
TextSpanLayout	TokenNameIdentifier	 Text Span Layout
{	TokenNameLBRACE	
private	TokenNameprivate	
GVTGlyphVector	TokenNameIdentifier	 GVT Glyph Vector
gv	TokenNameIdentifier	 gv
;	TokenNameSEMICOLON	
private	TokenNameprivate	
GVTFont	TokenNameIdentifier	 GVT Font
font	TokenNameIdentifier	 font
;	TokenNameSEMICOLON	
private	TokenNameprivate	
GVTLineMetrics	TokenNameIdentifier	 GVT Line Metrics
metrics	TokenNameIdentifier	 metrics
;	TokenNameSEMICOLON	
private	TokenNameprivate	
AttributedCharacterIterator	TokenNameIdentifier	 Attributed Character Iterator
aci	TokenNameIdentifier	 aci
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Point2D	TokenNameIdentifier	 Point2 D
advance	TokenNameIdentifier	 advance
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Point2D	TokenNameIdentifier	 Point2 D
offset	TokenNameIdentifier	 offset
;	TokenNameSEMICOLON	
private	TokenNameprivate	
float	TokenNamefloat	
xScale	TokenNameIdentifier	 x Scale
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
float	TokenNamefloat	
yScale	TokenNameIdentifier	 y Scale
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
TextPath	TokenNameIdentifier	 Text Path
textPath	TokenNameIdentifier	 text Path
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Point2D	TokenNameIdentifier	 Point2 D
textPathAdvance	TokenNameIdentifier	 text Path Advance
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
charMap	TokenNameIdentifier	 char Map
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
vertical	TokenNameIdentifier	 vertical
,	TokenNameCOMMA	
adjSpacing	TokenNameIdentifier	 adj Spacing
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
float	TokenNamefloat	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
glyphAdvances	TokenNameIdentifier	 glyph Advances
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
isAltGlyph	TokenNameIdentifier	 is Alt Glyph
;	TokenNameSEMICOLON	
//false 	TokenNameCOMMENT_LINE	false 
// When layoutApplied is false it means that the glyph positions 	TokenNameCOMMENT_LINE	When layoutApplied is false it means that the glyph positions 
// are different from where they would be if you did 	TokenNameCOMMENT_LINE	are different from where they would be if you did 
// doExplicitGlyphLayout(). 	TokenNameCOMMENT_LINE	doExplicitGlyphLayout(). 
private	TokenNameprivate	
boolean	TokenNameboolean	
layoutApplied	TokenNameIdentifier	 layout Applied
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// When spacingApplied is false it means that xScale, yScale and 	TokenNameCOMMENT_LINE	When spacingApplied is false it means that xScale, yScale and 
// kerning/wordspacing stuff haven't been applied. This can 	TokenNameCOMMENT_LINE	kerning/wordspacing stuff haven't been applied. This can 
// be rectified by calling adjustTextSpacing(). Note that when 	TokenNameCOMMENT_LINE	be rectified by calling adjustTextSpacing(). Note that when 
// spacing is actually used layoutApplied will be cleared it 	TokenNameCOMMENT_LINE	spacing is actually used layoutApplied will be cleared it 
// is not garunteed that applying text spacing will cause it to 	TokenNameCOMMENT_LINE	is not garunteed that applying text spacing will cause it to 
// be cleared (it will only be cleared if the glyphs move). 	TokenNameCOMMENT_LINE	be cleared (it will only be cleared if the glyphs move). 
private	TokenNameprivate	
boolean	TokenNameboolean	
spacingApplied	TokenNameIdentifier	 spacing Applied
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// When pathApplied is false it means that the text has not been 	TokenNameCOMMENT_LINE	When pathApplied is false it means that the text has not been 
// layed out on the associated text path (if any). If there is an 	TokenNameCOMMENT_LINE	layed out on the associated text path (if any). If there is an 
// associated text path then this will clear both layoutApplied 	TokenNameCOMMENT_LINE	associated text path then this will clear both layoutApplied 
// and spacing applied but neither will be touched if no text path 	TokenNameCOMMENT_LINE	and spacing applied but neither will be touched if no text path 
// is present. 	TokenNameCOMMENT_LINE	is present. 
private	TokenNameprivate	
boolean	TokenNameboolean	
pathApplied	TokenNameIdentifier	 path Applied
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
AttributedCharacterIterator	TokenNameIdentifier	 Attributed Character Iterator
.	TokenNameDOT	
Attribute	TokenNameIdentifier	 Attribute
FLOW_LINE_BREAK	TokenNameIdentifier	 FLOW  LINE  BREAK
=	TokenNameEQUAL	
GVTAttributedCharacterIterator	TokenNameIdentifier	 GVT Attributed Character Iterator
.	TokenNameDOT	
TextAttribute	TokenNameIdentifier	 Text Attribute
.	TokenNameDOT	
FLOW_LINE_BREAK	TokenNameIdentifier	 FLOW  LINE  BREAK
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
AttributedCharacterIterator	TokenNameIdentifier	 Attributed Character Iterator
.	TokenNameDOT	
Attribute	TokenNameIdentifier	 Attribute
FLOW_PARAGRAPH	TokenNameIdentifier	 FLOW  PARAGRAPH
=	TokenNameEQUAL	
GVTAttributedCharacterIterator	TokenNameIdentifier	 GVT Attributed Character Iterator
.	TokenNameDOT	
TextAttribute	TokenNameIdentifier	 Text Attribute
.	TokenNameDOT	
FLOW_PARAGRAPH	TokenNameIdentifier	 FLOW  PARAGRAPH
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
AttributedCharacterIterator	TokenNameIdentifier	 Attributed Character Iterator
.	TokenNameDOT	
Attribute	TokenNameIdentifier	 Attribute
FLOW_EMPTY_PARAGRAPH	TokenNameIdentifier	 FLOW  EMPTY  PARAGRAPH
=	TokenNameEQUAL	
GVTAttributedCharacterIterator	TokenNameIdentifier	 GVT Attributed Character Iterator
.	TokenNameDOT	
TextAttribute	TokenNameIdentifier	 Text Attribute
.	TokenNameDOT	
FLOW_EMPTY_PARAGRAPH	TokenNameIdentifier	 FLOW  EMPTY  PARAGRAPH
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
AttributedCharacterIterator	TokenNameIdentifier	 Attributed Character Iterator
.	TokenNameDOT	
Attribute	TokenNameIdentifier	 Attribute
LINE_HEIGHT	TokenNameIdentifier	 LINE  HEIGHT
=	TokenNameEQUAL	
GVTAttributedCharacterIterator	TokenNameIdentifier	 GVT Attributed Character Iterator
.	TokenNameDOT	
TextAttribute	TokenNameIdentifier	 Text Attribute
.	TokenNameDOT	
LINE_HEIGHT	TokenNameIdentifier	 LINE  HEIGHT
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
AttributedCharacterIterator	TokenNameIdentifier	 Attributed Character Iterator
.	TokenNameDOT	
Attribute	TokenNameIdentifier	 Attribute
VERTICAL_ORIENTATION	TokenNameIdentifier	 VERTICAL  ORIENTATION
=	TokenNameEQUAL	
GVTAttributedCharacterIterator	TokenNameIdentifier	 GVT Attributed Character Iterator
.	TokenNameDOT	
TextAttribute	TokenNameIdentifier	 Text Attribute
.	TokenNameDOT	
VERTICAL_ORIENTATION	TokenNameIdentifier	 VERTICAL  ORIENTATION
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
AttributedCharacterIterator	TokenNameIdentifier	 Attributed Character Iterator
.	TokenNameDOT	
Attribute	TokenNameIdentifier	 Attribute
VERTICAL_ORIENTATION_ANGLE	TokenNameIdentifier	 VERTICAL  ORIENTATION  ANGLE
=	TokenNameEQUAL	
GVTAttributedCharacterIterator	TokenNameIdentifier	 GVT Attributed Character Iterator
.	TokenNameDOT	
TextAttribute	TokenNameIdentifier	 Text Attribute
.	TokenNameDOT	
VERTICAL_ORIENTATION_ANGLE	TokenNameIdentifier	 VERTICAL  ORIENTATION  ANGLE
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
AttributedCharacterIterator	TokenNameIdentifier	 Attributed Character Iterator
.	TokenNameDOT	
Attribute	TokenNameIdentifier	 Attribute
HORIZONTAL_ORIENTATION_ANGLE	TokenNameIdentifier	 HORIZONTAL  ORIENTATION  ANGLE
=	TokenNameEQUAL	
GVTAttributedCharacterIterator	TokenNameIdentifier	 GVT Attributed Character Iterator
.	TokenNameDOT	
TextAttribute	TokenNameIdentifier	 Text Attribute
.	TokenNameDOT	
HORIZONTAL_ORIENTATION_ANGLE	TokenNameIdentifier	 HORIZONTAL  ORIENTATION  ANGLE
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
AttributedCharacterIterator	TokenNameIdentifier	 Attributed Character Iterator
.	TokenNameDOT	
Attribute	TokenNameIdentifier	 Attribute
X	TokenNameIdentifier	 X
=	TokenNameEQUAL	
GVTAttributedCharacterIterator	TokenNameIdentifier	 GVT Attributed Character Iterator
.	TokenNameDOT	
TextAttribute	TokenNameIdentifier	 Text Attribute
.	TokenNameDOT	
X	TokenNameIdentifier	 X
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
AttributedCharacterIterator	TokenNameIdentifier	 Attributed Character Iterator
.	TokenNameDOT	
Attribute	TokenNameIdentifier	 Attribute
Y	TokenNameIdentifier	 Y
=	TokenNameEQUAL	
GVTAttributedCharacterIterator	TokenNameIdentifier	 GVT Attributed Character Iterator
.	TokenNameDOT	
TextAttribute	TokenNameIdentifier	 Text Attribute
.	TokenNameDOT	
Y	TokenNameIdentifier	 Y
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
AttributedCharacterIterator	TokenNameIdentifier	 Attributed Character Iterator
.	TokenNameDOT	
Attribute	TokenNameIdentifier	 Attribute
DX	TokenNameIdentifier	 DX
=	TokenNameEQUAL	
GVTAttributedCharacterIterator	TokenNameIdentifier	 GVT Attributed Character Iterator
.	TokenNameDOT	
TextAttribute	TokenNameIdentifier	 Text Attribute
.	TokenNameDOT	
DX	TokenNameIdentifier	 DX
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
AttributedCharacterIterator	TokenNameIdentifier	 Attributed Character Iterator
.	TokenNameDOT	
Attribute	TokenNameIdentifier	 Attribute
DY	TokenNameIdentifier	 DY
=	TokenNameEQUAL	
GVTAttributedCharacterIterator	TokenNameIdentifier	 GVT Attributed Character Iterator
.	TokenNameDOT	
TextAttribute	TokenNameIdentifier	 Text Attribute
.	TokenNameDOT	
DY	TokenNameIdentifier	 DY
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
AttributedCharacterIterator	TokenNameIdentifier	 Attributed Character Iterator
.	TokenNameDOT	
Attribute	TokenNameIdentifier	 Attribute
ROTATION	TokenNameIdentifier	 ROTATION
=	TokenNameEQUAL	
GVTAttributedCharacterIterator	TokenNameIdentifier	 GVT Attributed Character Iterator
.	TokenNameDOT	
TextAttribute	TokenNameIdentifier	 Text Attribute
.	TokenNameDOT	
ROTATION	TokenNameIdentifier	 ROTATION
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
AttributedCharacterIterator	TokenNameIdentifier	 Attributed Character Iterator
.	TokenNameDOT	
Attribute	TokenNameIdentifier	 Attribute
BASELINE_SHIFT	TokenNameIdentifier	 BASELINE  SHIFT
=	TokenNameEQUAL	
GVTAttributedCharacterIterator	TokenNameIdentifier	 GVT Attributed Character Iterator
.	TokenNameDOT	
TextAttribute	TokenNameIdentifier	 Text Attribute
.	TokenNameDOT	
BASELINE_SHIFT	TokenNameIdentifier	 BASELINE  SHIFT
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
AttributedCharacterIterator	TokenNameIdentifier	 Attributed Character Iterator
.	TokenNameDOT	
Attribute	TokenNameIdentifier	 Attribute
WRITING_MODE	TokenNameIdentifier	 WRITING  MODE
=	TokenNameEQUAL	
GVTAttributedCharacterIterator	TokenNameIdentifier	 GVT Attributed Character Iterator
.	TokenNameDOT	
TextAttribute	TokenNameIdentifier	 Text Attribute
.	TokenNameDOT	
WRITING_MODE	TokenNameIdentifier	 WRITING  MODE
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Integer	TokenNameIdentifier	 Integer
WRITING_MODE_TTB	TokenNameIdentifier	 WRITING  MODE  TTB
=	TokenNameEQUAL	
GVTAttributedCharacterIterator	TokenNameIdentifier	 GVT Attributed Character Iterator
.	TokenNameDOT	
TextAttribute	TokenNameIdentifier	 Text Attribute
.	TokenNameDOT	
WRITING_MODE_TTB	TokenNameIdentifier	 WRITING  MODE  TTB
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Integer	TokenNameIdentifier	 Integer
ORIENTATION_AUTO	TokenNameIdentifier	 ORIENTATION  AUTO
=	TokenNameEQUAL	
GVTAttributedCharacterIterator	TokenNameIdentifier	 GVT Attributed Character Iterator
.	TokenNameDOT	
TextAttribute	TokenNameIdentifier	 Text Attribute
.	TokenNameDOT	
ORIENTATION_AUTO	TokenNameIdentifier	 ORIENTATION  AUTO
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
AttributedCharacterIterator	TokenNameIdentifier	 Attributed Character Iterator
.	TokenNameDOT	
Attribute	TokenNameIdentifier	 Attribute
GVT_FONT	TokenNameIdentifier	 GVT  FONT
=	TokenNameEQUAL	
GVTAttributedCharacterIterator	TokenNameIdentifier	 GVT Attributed Character Iterator
.	TokenNameDOT	
TextAttribute	TokenNameIdentifier	 Text Attribute
.	TokenNameDOT	
GVT_FONT	TokenNameIdentifier	 GVT  FONT
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
Set	TokenNameIdentifier	 Set
runAtts	TokenNameIdentifier	 run Atts
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
{	TokenNameLBRACE	
runAtts	TokenNameIdentifier	 run Atts
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
X	TokenNameIdentifier	 X
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
runAtts	TokenNameIdentifier	 run Atts
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
Y	TokenNameIdentifier	 Y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
runAtts	TokenNameIdentifier	 run Atts
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
DX	TokenNameIdentifier	 DX
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
runAtts	TokenNameIdentifier	 run Atts
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
DY	TokenNameIdentifier	 DY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
runAtts	TokenNameIdentifier	 run Atts
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
ROTATION	TokenNameIdentifier	 ROTATION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
runAtts	TokenNameIdentifier	 run Atts
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
BASELINE_SHIFT	TokenNameIdentifier	 BASELINE  SHIFT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
static	TokenNamestatic	
Set	TokenNameIdentifier	 Set
szAtts	TokenNameIdentifier	 sz Atts
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
{	TokenNameLBRACE	
szAtts	TokenNameIdentifier	 sz Atts
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
TextAttribute	TokenNameIdentifier	 Text Attribute
.	TokenNameDOT	
SIZE	TokenNameIdentifier	 SIZE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
szAtts	TokenNameIdentifier	 sz Atts
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
GVT_FONT	TokenNameIdentifier	 GVT  FONT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
szAtts	TokenNameIdentifier	 sz Atts
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
LINE_HEIGHT	TokenNameIdentifier	 LINE  HEIGHT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Creates the specified text layout using the * specified AttributedCharacterIterator and rendering context. * * @param aci the AttributedCharacterIterator whose text is to * be laid out * @param charMap Indicates how chars in aci map to original * text char array. * @param offset The offset position of this text layout * @param frc the FontRenderContext to use for generating glyphs. */	TokenNameCOMMENT_JAVADOC	 Creates the specified text layout using the specified AttributedCharacterIterator and rendering context. * @param aci the AttributedCharacterIterator whose text is to be laid out @param charMap Indicates how chars in aci map to original text char array. @param offset The offset position of this text layout @param frc the FontRenderContext to use for generating glyphs. 
public	TokenNamepublic	
GlyphLayout	TokenNameIdentifier	 Glyph Layout
(	TokenNameLPAREN	
AttributedCharacterIterator	TokenNameIdentifier	 Attributed Character Iterator
aci	TokenNameIdentifier	 aci
,	TokenNameCOMMA	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
charMap	TokenNameIdentifier	 char Map
,	TokenNameCOMMA	
Point2D	TokenNameIdentifier	 Point2 D
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
FontRenderContext	TokenNameIdentifier	 Font Render Context
frc	TokenNameIdentifier	 frc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
aci	TokenNameIdentifier	 aci
=	TokenNameEQUAL	
aci	TokenNameIdentifier	 aci
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
=	TokenNameEQUAL	
offset	TokenNameIdentifier	 offset
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
font	TokenNameIdentifier	 font
=	TokenNameEQUAL	
getFont	TokenNameIdentifier	 get Font
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
charMap	TokenNameIdentifier	 char Map
=	TokenNameEQUAL	
charMap	TokenNameIdentifier	 char Map
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
metrics	TokenNameIdentifier	 metrics
=	TokenNameEQUAL	
font	TokenNameIdentifier	 font
.	TokenNameDOT	
getLineMetrics	TokenNameIdentifier	 get Line Metrics
(	TokenNameLPAREN	
aci	TokenNameIdentifier	 aci
,	TokenNameCOMMA	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
getBeginIndex	TokenNameIdentifier	 get Begin Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
getEndIndex	TokenNameIdentifier	 get End Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
frc	TokenNameIdentifier	 frc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// create the glyph vector 	TokenNameCOMMENT_LINE	create the glyph vector 
this	TokenNamethis	
.	TokenNameDOT	
gv	TokenNameIdentifier	 gv
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
first	TokenNameIdentifier	 first
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
vertical	TokenNameIdentifier	 vertical
=	TokenNameEQUAL	
(	TokenNameLPAREN	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
WRITING_MODE	TokenNameIdentifier	 WRITING  MODE
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
WRITING_MODE_TTB	TokenNameIdentifier	 WRITING  MODE  TTB
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
textPath	TokenNameIdentifier	 text Path
=	TokenNameEQUAL	
(	TokenNameLPAREN	
TextPath	TokenNameIdentifier	 Text Path
)	TokenNameRPAREN	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
GVTAttributedCharacterIterator	TokenNameIdentifier	 GVT Attributed Character Iterator
.	TokenNameDOT	
TextAttribute	TokenNameIdentifier	 Text Attribute
.	TokenNameDOT	
TEXTPATH	TokenNameIdentifier	 TEXTPATH
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AltGlyphHandler	TokenNameIdentifier	 Alt Glyph Handler
altGlyphHandler	TokenNameIdentifier	 alt Glyph Handler
=	TokenNameEQUAL	
(	TokenNameLPAREN	
AltGlyphHandler	TokenNameIdentifier	 Alt Glyph Handler
)	TokenNameRPAREN	
this	TokenNamethis	
.	TokenNameDOT	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
GVTAttributedCharacterIterator	TokenNameIdentifier	 GVT Attributed Character Iterator
.	TokenNameDOT	
TextAttribute	TokenNameIdentifier	 Text Attribute
.	TokenNameDOT	
ALT_GLYPH_HANDLER	TokenNameIdentifier	 ALT  GLYPH  HANDLER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
altGlyphHandler	TokenNameIdentifier	 alt Glyph Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// this must be an altGlyph text element, try and create 	TokenNameCOMMENT_LINE	this must be an altGlyph text element, try and create 
// the alternate glyphs 	TokenNameCOMMENT_LINE	the alternate glyphs 
this	TokenNamethis	
.	TokenNameDOT	
gv	TokenNameIdentifier	 gv
=	TokenNameEQUAL	
altGlyphHandler	TokenNameIdentifier	 alt Glyph Handler
.	TokenNameDOT	
createGlyphVector	TokenNameIdentifier	 create Glyph Vector
(	TokenNameLPAREN	
frc	TokenNameIdentifier	 frc
,	TokenNameCOMMA	
this	TokenNamethis	
.	TokenNameDOT	
font	TokenNameIdentifier	 font
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
this	TokenNamethis	
.	TokenNameDOT	
aci	TokenNameIdentifier	 aci
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
gv	TokenNameIdentifier	 gv
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
isAltGlyph	TokenNameIdentifier	 is Alt Glyph
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
gv	TokenNameIdentifier	 gv
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// either not an altGlyph or the altGlyphHandler failed to 	TokenNameCOMMENT_LINE	either not an altGlyph or the altGlyphHandler failed to 
// create a glyph vector 	TokenNameCOMMENT_LINE	create a glyph vector 
this	TokenNamethis	
.	TokenNameDOT	
gv	TokenNameIdentifier	 gv
=	TokenNameEQUAL	
font	TokenNameIdentifier	 font
.	TokenNameDOT	
createGlyphVector	TokenNameIdentifier	 create Glyph Vector
(	TokenNameLPAREN	
frc	TokenNameIdentifier	 frc
,	TokenNameCOMMA	
this	TokenNamethis	
.	TokenNameDOT	
aci	TokenNameIdentifier	 aci
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
GVTGlyphVector	TokenNameIdentifier	 GVT Glyph Vector
getGlyphVector	TokenNameIdentifier	 get Glyph Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
this	TokenNamethis	
.	TokenNameDOT	
gv	TokenNameIdentifier	 gv
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the current text position at the beginning * of glyph layout, before the application of explicit * glyph positioning attributes. */	TokenNameCOMMENT_JAVADOC	 Returns the current text position at the beginning of glyph layout, before the application of explicit glyph positioning attributes. 
public	TokenNamepublic	
Point2D	TokenNameIdentifier	 Point2 D
getOffset	TokenNameIdentifier	 get Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
offset	TokenNameIdentifier	 offset
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets the scaling factor to use for string. if ajdSpacing is * true then only the spacing between glyphs will be adjusted * otherwise the glyphs and the spaces between them will be * adjusted. Only the scale factor in the progression direction * is used (x for horizontal text, y for vertical text * ). * @param xScale Scale factor to apply in X direction. * @param yScale Scale factor to apply in Y direction. * @param adjSpacing True if only spaces should be adjusted. */	TokenNameCOMMENT_JAVADOC	 Sets the scaling factor to use for string. if ajdSpacing is true then only the spacing between glyphs will be adjusted otherwise the glyphs and the spaces between them will be adjusted. Only the scale factor in the progression direction is used (x for horizontal text, y for vertical text ). @param xScale Scale factor to apply in X direction. @param yScale Scale factor to apply in Y direction. @param adjSpacing True if only spaces should be adjusted. 
public	TokenNamepublic	
void	TokenNamevoid	
setScale	TokenNameIdentifier	 set Scale
(	TokenNameLPAREN	
float	TokenNamefloat	
xScale	TokenNameIdentifier	 x Scale
,	TokenNameCOMMA	
float	TokenNamefloat	
yScale	TokenNameIdentifier	 y Scale
,	TokenNameCOMMA	
boolean	TokenNameboolean	
adjSpacing	TokenNameIdentifier	 adj Spacing
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Fix the off axis scale factor. 	TokenNameCOMMENT_LINE	Fix the off axis scale factor. 
if	TokenNameif	
(	TokenNameLPAREN	
vertical	TokenNameIdentifier	 vertical
)	TokenNameRPAREN	
xScale	TokenNameIdentifier	 x Scale
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
else	TokenNameelse	
yScale	TokenNameIdentifier	 y Scale
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
xScale	TokenNameIdentifier	 x Scale
!=	TokenNameNOT_EQUAL	
this	TokenNamethis	
.	TokenNameDOT	
xScale	TokenNameIdentifier	 x Scale
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
yScale	TokenNameIdentifier	 y Scale
!=	TokenNameNOT_EQUAL	
this	TokenNamethis	
.	TokenNameDOT	
yScale	TokenNameIdentifier	 y Scale
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
adjSpacing	TokenNameIdentifier	 adj Spacing
!=	TokenNameNOT_EQUAL	
this	TokenNamethis	
.	TokenNameDOT	
adjSpacing	TokenNameIdentifier	 adj Spacing
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
xScale	TokenNameIdentifier	 x Scale
=	TokenNameEQUAL	
xScale	TokenNameIdentifier	 x Scale
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
yScale	TokenNameIdentifier	 y Scale
=	TokenNameEQUAL	
yScale	TokenNameIdentifier	 y Scale
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
adjSpacing	TokenNameIdentifier	 adj Spacing
=	TokenNameEQUAL	
adjSpacing	TokenNameIdentifier	 adj Spacing
;	TokenNameSEMICOLON	
// We don't affect layoutApplied directly... 	TokenNameCOMMENT_LINE	We don't affect layoutApplied directly... 
// System.out.println("layoutApplied: " + layoutApplied); 	TokenNameCOMMENT_LINE	System.out.println("layoutApplied: " + layoutApplied); 
// However if we did path layout or spacing it's all junk now... 	TokenNameCOMMENT_LINE	However if we did path layout or spacing it's all junk now... 
spacingApplied	TokenNameIdentifier	 spacing Applied
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
glyphAdvances	TokenNameIdentifier	 glyph Advances
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
pathApplied	TokenNameIdentifier	 path Applied
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Sets the text position used for the implicit origin * of glyph layout. Ignored if multiple explicit glyph * positioning attributes are present in ACI * (e.g. if the aci has multiple X or Y values). */	TokenNameCOMMENT_JAVADOC	 Sets the text position used for the implicit origin of glyph layout. Ignored if multiple explicit glyph positioning attributes are present in ACI (e.g. if the aci has multiple X or Y values). 
public	TokenNamepublic	
void	TokenNamevoid	
setOffset	TokenNameIdentifier	 set Offset
(	TokenNameLPAREN	
Point2D	TokenNameIdentifier	 Point2 D
offset	TokenNameIdentifier	 offset
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// System.err.println("SetOffset: " + offset + " - " + this.offset); 	TokenNameCOMMENT_LINE	System.err.println("SetOffset: " + offset + " - " + this.offset); 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
offset	TokenNameIdentifier	 offset
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
this	TokenNamethis	
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
offset	TokenNameIdentifier	 offset
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
this	TokenNamethis	
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
layoutApplied	TokenNameIdentifier	 layout Applied
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
spacingApplied	TokenNameIdentifier	 spacing Applied
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Already layed out need to shift glyph positions to 	TokenNameCOMMENT_LINE	Already layed out need to shift glyph positions to 
// account for new offset. 	TokenNameCOMMENT_LINE	account for new offset. 
float	TokenNamefloat	
dx	TokenNameIdentifier	 dx
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
offset	TokenNameIdentifier	 offset
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
this	TokenNamethis	
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
dy	TokenNameIdentifier	 dy
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
offset	TokenNameIdentifier	 offset
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
this	TokenNamethis	
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
numGlyphs	TokenNameIdentifier	 num Glyphs
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getNumGlyphs	TokenNameIdentifier	 get Num Glyphs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// System.out.println("DXY: [" + dx +","+dy+"]"); 	TokenNameCOMMENT_LINE	System.out.println("DXY: [" + dx +","+dy+"]"); 
float	TokenNamefloat	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
gp	TokenNameIdentifier	 gp
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphPositions	TokenNameIdentifier	 get Glyph Positions
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
numGlyphs	TokenNameIdentifier	 num Glyphs
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<=	TokenNameLESS_EQUAL	
numGlyphs	TokenNameIdentifier	 num Glyphs
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pos	TokenNameIdentifier	 pos
.	TokenNameDOT	
x	TokenNameIdentifier	 x
=	TokenNameEQUAL	
gp	TokenNameIdentifier	 gp
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
+	TokenNamePLUS	
dx	TokenNameIdentifier	 dx
;	TokenNameSEMICOLON	
pos	TokenNameIdentifier	 pos
.	TokenNameDOT	
y	TokenNameIdentifier	 y
=	TokenNameEQUAL	
gp	TokenNameIdentifier	 gp
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
+	TokenNamePLUS	
dy	TokenNameIdentifier	 dy
;	TokenNameSEMICOLON	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
setGlyphPosition	TokenNameIdentifier	 set Glyph Position
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// When not layed out (or after updating) just set the new 	TokenNameCOMMENT_LINE	When not layed out (or after updating) just set the new 
// offset this will be factored in for any future layout 	TokenNameCOMMENT_LINE	offset this will be factored in for any future layout 
// operations. 	TokenNameCOMMENT_LINE	operations. 
this	TokenNamethis	
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
=	TokenNameEQUAL	
offset	TokenNameIdentifier	 offset
;	TokenNameSEMICOLON	
// We don't affect layoutApplied or spacingApplied since 	TokenNameCOMMENT_LINE	We don't affect layoutApplied or spacingApplied since 
// they both work off the offset value. 	TokenNameCOMMENT_LINE	they both work off the offset value. 
// However if we did path layout it's all junk now... 	TokenNameCOMMENT_LINE	However if we did path layout it's all junk now... 
pathApplied	TokenNameIdentifier	 path Applied
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
GVTGlyphMetrics	TokenNameIdentifier	 GVT Glyph Metrics
getGlyphMetrics	TokenNameIdentifier	 get Glyph Metrics
(	TokenNameLPAREN	
int	TokenNameint	
glyphIndex	TokenNameIdentifier	 glyph Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphMetrics	TokenNameIdentifier	 get Glyph Metrics
(	TokenNameLPAREN	
glyphIndex	TokenNameIdentifier	 glyph Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
GVTLineMetrics	TokenNameIdentifier	 GVT Line Metrics
getLineMetrics	TokenNameIdentifier	 get Line Metrics
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metrics	TokenNameIdentifier	 metrics
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns true if the advance direction of this text is vertical. */	TokenNameCOMMENT_JAVADOC	 Returns true if the advance direction of this text is vertical. 
public	TokenNamepublic	
boolean	TokenNameboolean	
isVertical	TokenNameIdentifier	 is Vertical
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
vertical	TokenNameIdentifier	 vertical
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns true if this layout in on a text path. */	TokenNameCOMMENT_JAVADOC	 Returns true if this layout in on a text path. 
public	TokenNamepublic	
boolean	TokenNameboolean	
isOnATextPath	TokenNameIdentifier	 is On A Text Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
textPath	TokenNameIdentifier	 text Path
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the number of glyphs in this layout. */	TokenNameCOMMENT_JAVADOC	 Returns the number of glyphs in this layout. 
public	TokenNamepublic	
int	TokenNameint	
getGlyphCount	TokenNameIdentifier	 get Glyph Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getNumGlyphs	TokenNameIdentifier	 get Num Glyphs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the number of chars represented by the glyphs within the * specified range. * * @param startGlyphIndex The index of the first glyph in the range. * @param endGlyphIndex The index of the last glyph in the range. * * @return The number of chars. */	TokenNameCOMMENT_JAVADOC	 Returns the number of chars represented by the glyphs within the specified range. * @param startGlyphIndex The index of the first glyph in the range. @param endGlyphIndex The index of the last glyph in the range. * @return The number of chars. 
public	TokenNamepublic	
int	TokenNameint	
getCharacterCount	TokenNameIdentifier	 get Character Count
(	TokenNameLPAREN	
int	TokenNameint	
startGlyphIndex	TokenNameIdentifier	 start Glyph Index
,	TokenNameCOMMA	
int	TokenNameint	
endGlyphIndex	TokenNameIdentifier	 end Glyph Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getCharacterCount	TokenNameIdentifier	 get Character Count
(	TokenNameLPAREN	
startGlyphIndex	TokenNameIdentifier	 start Glyph Index
,	TokenNameCOMMA	
endGlyphIndex	TokenNameIdentifier	 end Glyph Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns true if the text direction in this layout is from left to right. */	TokenNameCOMMENT_JAVADOC	 Returns true if the text direction in this layout is from left to right. 
public	TokenNamepublic	
boolean	TokenNameboolean	
isLeftToRight	TokenNameIdentifier	 is Left To Right
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
first	TokenNameIdentifier	 first
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
bidiLevel	TokenNameIdentifier	 bidi Level
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Integer	TokenNameIdentifier	 Integer
)	TokenNameRPAREN	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
GVTAttributedCharacterIterator	TokenNameIdentifier	 GVT Attributed Character Iterator
.	TokenNameDOT	
TextAttribute	TokenNameIdentifier	 Text Attribute
.	TokenNameDOT	
BIDI_LEVEL	TokenNameIdentifier	 BIDI  LEVEL
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
intValue	TokenNameIdentifier	 int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Check if low bit is set if not then we are left to right 	TokenNameCOMMENT_LINE	Check if low bit is set if not then we are left to right 
// (even bidi level). 	TokenNameCOMMENT_LINE	(even bidi level). 
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
bidiLevel	TokenNameIdentifier	 bidi Level
&	TokenNameAND	
0x01	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * This method makes certain that the layout has been * completed at this point (much of the layout is done lazily). */	TokenNameCOMMENT_JAVADOC	 This method makes certain that the layout has been completed at this point (much of the layout is done lazily). 
private	TokenNameprivate	
final	TokenNamefinal	
void	TokenNamevoid	
syncLayout	TokenNameIdentifier	 sync Layout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
pathApplied	TokenNameIdentifier	 path Applied
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// System.out.println("Doing Path Layout: " + this); 	TokenNameCOMMENT_LINE	System.out.println("Doing Path Layout: " + this); 
doPathLayout	TokenNameIdentifier	 do Path Layout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Paints the text layout using the * specified Graphics2D and rendering context. * @param g2d the Graphics2D to use */	TokenNameCOMMENT_JAVADOC	 Paints the text layout using the specified Graphics2D and rendering context. @param g2d the Graphics2D to use 
public	TokenNamepublic	
void	TokenNamevoid	
draw	TokenNameIdentifier	 draw
(	TokenNameLPAREN	
Graphics2D	TokenNameIdentifier	 Graphics2 D
g2d	TokenNameIdentifier	 g2d
)	TokenNameRPAREN	
{	TokenNameLBRACE	
syncLayout	TokenNameIdentifier	 sync Layout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
draw	TokenNameIdentifier	 draw
(	TokenNameLPAREN	
g2d	TokenNameIdentifier	 g2d
,	TokenNameCOMMA	
aci	TokenNameIdentifier	 aci
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the current text position at the completion * of glyph layout. */	TokenNameCOMMENT_JAVADOC	 Returns the current text position at the completion of glyph layout. 
public	TokenNamepublic	
Point2D	TokenNameIdentifier	 Point2 D
getAdvance2D	TokenNameIdentifier	 get Advance2 D
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
adjustTextSpacing	TokenNameIdentifier	 adjust Text Spacing
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
advance	TokenNameIdentifier	 advance
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the outline of the completed glyph layout. */	TokenNameCOMMENT_JAVADOC	 Returns the outline of the completed glyph layout. 
public	TokenNamepublic	
Shape	TokenNameIdentifier	 Shape
getOutline	TokenNameIdentifier	 get Outline
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
syncLayout	TokenNameIdentifier	 sync Layout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getOutline	TokenNameIdentifier	 get Outline
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
float	TokenNamefloat	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getGlyphAdvances	TokenNameIdentifier	 get Glyph Advances
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
glyphAdvances	TokenNameIdentifier	 glyph Advances
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
glyphAdvances	TokenNameIdentifier	 glyph Advances
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
spacingApplied	TokenNameIdentifier	 spacing Applied
)	TokenNameRPAREN	
// This will layout the text if needed. 	TokenNameCOMMENT_LINE	This will layout the text if needed. 
adjustTextSpacing	TokenNameIdentifier	 adjust Text Spacing
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
numGlyphs	TokenNameIdentifier	 num Glyphs
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getNumGlyphs	TokenNameIdentifier	 get Num Glyphs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
glyphPos	TokenNameIdentifier	 glyph Pos
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphPositions	TokenNameIdentifier	 get Glyph Positions
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
numGlyphs	TokenNameIdentifier	 num Glyphs
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
glyphAdvances	TokenNameIdentifier	 glyph Advances
=	TokenNameEQUAL	
new	TokenNamenew	
float	TokenNamefloat	
[	TokenNameLBRACKET	
numGlyphs	TokenNameIdentifier	 num Glyphs
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
off	TokenNameIdentifier	 off
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isVertical	TokenNameIdentifier	 is Vertical
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
off	TokenNameIdentifier	 off
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
start	TokenNameIdentifier	 start
=	TokenNameEQUAL	
glyphPos	TokenNameIdentifier	 glyph Pos
[	TokenNameLBRACKET	
off	TokenNameIdentifier	 off
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numGlyphs	TokenNameIdentifier	 num Glyphs
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
glyphAdvances	TokenNameIdentifier	 glyph Advances
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
glyphPos	TokenNameIdentifier	 glyph Pos
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
off	TokenNameIdentifier	 off
]	TokenNameRBRACKET	
-	TokenNameMINUS	
start	TokenNameIdentifier	 start
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
glyphAdvances	TokenNameIdentifier	 glyph Advances
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the outline of the specified decorations on the glyphs, * @param decorationType an integer indicating the type(s) of decorations * included in this shape. May be the result of "OR-ing" several * values together: * e.g. <tt>DECORATION_UNDERLINE | DECORATION_STRIKETHROUGH</tt> */	TokenNameCOMMENT_JAVADOC	 Returns the outline of the specified decorations on the glyphs, @param decorationType an integer indicating the type(s) of decorations included in this shape. May be the result of "OR-ing" several values together: e.g. <tt>DECORATION_UNDERLINE | DECORATION_STRIKETHROUGH</tt> 
public	TokenNamepublic	
Shape	TokenNameIdentifier	 Shape
getDecorationOutline	TokenNameIdentifier	 get Decoration Outline
(	TokenNameLPAREN	
int	TokenNameint	
decorationType	TokenNameIdentifier	 decoration Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
syncLayout	TokenNameIdentifier	 sync Layout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Shape	TokenNameIdentifier	 Shape
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
new	TokenNamenew	
GeneralPath	TokenNameIdentifier	 General Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
decorationType	TokenNameIdentifier	 decoration Type
&	TokenNameAND	
DECORATION_UNDERLINE	TokenNameIdentifier	 DECORATION  UNDERLINE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
GeneralPath	TokenNameIdentifier	 General Path
)	TokenNameRPAREN	
g	TokenNameIdentifier	 g
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
getUnderlineShape	TokenNameIdentifier	 get Underline Shape
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
decorationType	TokenNameIdentifier	 decoration Type
&	TokenNameAND	
DECORATION_STRIKETHROUGH	TokenNameIdentifier	 DECORATION  STRIKETHROUGH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
GeneralPath	TokenNameIdentifier	 General Path
)	TokenNameRPAREN	
g	TokenNameIdentifier	 g
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
getStrikethroughShape	TokenNameIdentifier	 get Strikethrough Shape
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
decorationType	TokenNameIdentifier	 decoration Type
&	TokenNameAND	
DECORATION_OVERLINE	TokenNameIdentifier	 DECORATION  OVERLINE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
GeneralPath	TokenNameIdentifier	 General Path
)	TokenNameRPAREN	
g	TokenNameIdentifier	 g
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
getOverlineShape	TokenNameIdentifier	 get Overline Shape
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
g	TokenNameIdentifier	 g
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the rectangular bounds of the completed glyph layout. */	TokenNameCOMMENT_JAVADOC	 Returns the rectangular bounds of the completed glyph layout. 
public	TokenNamepublic	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
getBounds2D	TokenNameIdentifier	 get Bounds2 D
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
syncLayout	TokenNameIdentifier	 sync Layout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getBounds2D	TokenNameIdentifier	 get Bounds2 D
(	TokenNameLPAREN	
aci	TokenNameIdentifier	 aci
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the rectangular bounds of the completed glyph layout, * inclusive of "decoration" (underline, overline, etc.) */	TokenNameCOMMENT_JAVADOC	 Returns the rectangular bounds of the completed glyph layout, inclusive of "decoration" (underline, overline, etc.) 
public	TokenNamepublic	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
getGeometricBounds	TokenNameIdentifier	 get Geometric Bounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
syncLayout	TokenNameIdentifier	 sync Layout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
gvB	TokenNameIdentifier	 gv B
,	TokenNameCOMMA	
decB	TokenNameIdentifier	 dec B
;	TokenNameSEMICOLON	
gvB	TokenNameIdentifier	 gv B
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGeometricBounds	TokenNameIdentifier	 get Geometric Bounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
decB	TokenNameIdentifier	 dec B
=	TokenNameEQUAL	
getDecorationOutline	TokenNameIdentifier	 get Decoration Outline
(	TokenNameLPAREN	
DECORATION_ALL	TokenNameIdentifier	 DECORATION  ALL
)	TokenNameRPAREN	
.	TokenNameDOT	
getBounds2D	TokenNameIdentifier	 get Bounds2 D
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
gvB	TokenNameIdentifier	 gv B
.	TokenNameDOT	
createUnion	TokenNameIdentifier	 create Union
(	TokenNameLPAREN	
decB	TokenNameIdentifier	 dec B
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the position to used when drawing a text run after this one. * It takes into account the text path layout if there is one. */	TokenNameCOMMENT_JAVADOC	 Returns the position to used when drawing a text run after this one. It takes into account the text path layout if there is one. 
public	TokenNamepublic	
Point2D	TokenNameIdentifier	 Point2 D
getTextPathAdvance	TokenNameIdentifier	 get Text Path Advance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
syncLayout	TokenNameIdentifier	 sync Layout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
textPath	TokenNameIdentifier	 text Path
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
textPathAdvance	TokenNameIdentifier	 text Path Advance
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
getAdvance2D	TokenNameIdentifier	 get Advance2 D
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Returns the index of the first glyph that has the specified char index. * * @param charIndex The original index of the character in the text node's * text string. * @return The index of the matching glyph in this layout's glyph vector, * or -1 if a matching glyph could not be found. */	TokenNameCOMMENT_JAVADOC	 Returns the index of the first glyph that has the specified char index. * @param charIndex The original index of the character in the text node's text string. @return The index of the matching glyph in this layout's glyph vector, or -1 if a matching glyph could not be found. 
public	TokenNamepublic	
int	TokenNameint	
getGlyphIndex	TokenNameIdentifier	 get Glyph Index
(	TokenNameLPAREN	
int	TokenNameint	
charIndex	TokenNameIdentifier	 char Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
numGlyphs	TokenNameIdentifier	 num Glyphs
=	TokenNameEQUAL	
getGlyphCount	TokenNameIdentifier	 get Glyph Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numGlyphs	TokenNameIdentifier	 num Glyphs
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
getCharacterCount	TokenNameIdentifier	 get Character Count
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
n	TokenNameIdentifier	 n
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
n	TokenNameIdentifier	 n
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
glyphCharIndex	TokenNameIdentifier	 glyph Char Index
=	TokenNameEQUAL	
charMap	TokenNameIdentifier	 char Map
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
charIndex	TokenNameIdentifier	 char Index
==	TokenNameEQUAL_EQUAL	
glyphCharIndex	TokenNameIdentifier	 glyph Char Index
)	TokenNameRPAREN	
return	TokenNamereturn	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
>=	TokenNameGREATER_EQUAL	
charMap	TokenNameIdentifier	 char Map
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the index of the last glyph that has the specified char index. * * @param charIndex The original index of the character in the text node's * text string. * @return The index of the matching glyph in this layout's glyph vector, * or -1 if a matching glyph could not be found. */	TokenNameCOMMENT_JAVADOC	 Returns the index of the last glyph that has the specified char index. * @param charIndex The original index of the character in the text node's text string. @return The index of the matching glyph in this layout's glyph vector, or -1 if a matching glyph could not be found. 
public	TokenNamepublic	
int	TokenNameint	
getLastGlyphIndex	TokenNameIdentifier	 get Last Glyph Index
(	TokenNameLPAREN	
int	TokenNameint	
charIndex	TokenNameIdentifier	 char Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
numGlyphs	TokenNameIdentifier	 num Glyphs
=	TokenNameEQUAL	
getGlyphCount	TokenNameIdentifier	 get Glyph Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
charMap	TokenNameIdentifier	 char Map
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
numGlyphs	TokenNameIdentifier	 num Glyphs
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
getCharacterCount	TokenNameIdentifier	 get Character Count
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
n	TokenNameIdentifier	 n
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
n	TokenNameIdentifier	 n
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
glyphCharIndex	TokenNameIdentifier	 glyph Char Index
=	TokenNameEQUAL	
charMap	TokenNameIdentifier	 char Map
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
--	TokenNameMINUS_MINUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
charIndex	TokenNameIdentifier	 char Index
==	TokenNameEQUAL_EQUAL	
glyphCharIndex	TokenNameIdentifier	 glyph Char Index
)	TokenNameRPAREN	
return	TokenNamereturn	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return the angle value according to the orientation * of the character. */	TokenNameCOMMENT_JAVADOC	 Return the angle value according to the orientation of the character. 
public	TokenNamepublic	
double	TokenNamedouble	
getComputedOrientationAngle	TokenNameIdentifier	 get Computed Orientation Angle
(	TokenNameLPAREN	
int	TokenNameint	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isGlyphOrientationAuto	TokenNameIdentifier	 is Glyph Orientation Auto
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isVertical	TokenNameIdentifier	 is Vertical
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
char	TokenNamechar	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
setIndex	TokenNameIdentifier	 set Index
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isLatinChar	TokenNameIdentifier	 is Latin Char
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
90.0	TokenNameDoubleLiteral	
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
0.0	TokenNameDoubleLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
0.0	TokenNameDoubleLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
getGlyphOrientationAngle	TokenNameIdentifier	 get Glyph Orientation Angle
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Returns a Shape which encloses the currently selected glyphs * as specified by the character indices. * * @param beginCharIndex the index of the first char in the * contiguous selection. * @param endCharIndex the index of the last char in the * contiguous selection. * @return The highlight shape or null if the spacified char range * does not overlap with the chars in this layout. */	TokenNameCOMMENT_JAVADOC	 Returns a Shape which encloses the currently selected glyphs as specified by the character indices. * @param beginCharIndex the index of the first char in the contiguous selection. @param endCharIndex the index of the last char in the contiguous selection. @return The highlight shape or null if the spacified char range does not overlap with the chars in this layout. 
public	TokenNamepublic	
Shape	TokenNameIdentifier	 Shape
getHighlightShape	TokenNameIdentifier	 get Highlight Shape
(	TokenNameLPAREN	
int	TokenNameint	
beginCharIndex	TokenNameIdentifier	 begin Char Index
,	TokenNameCOMMA	
int	TokenNameint	
endCharIndex	TokenNameIdentifier	 end Char Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
syncLayout	TokenNameIdentifier	 sync Layout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
beginCharIndex	TokenNameIdentifier	 begin Char Index
>	TokenNameGREATER	
endCharIndex	TokenNameIdentifier	 end Char Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
temp	TokenNameIdentifier	 temp
=	TokenNameEQUAL	
beginCharIndex	TokenNameIdentifier	 begin Char Index
;	TokenNameSEMICOLON	
beginCharIndex	TokenNameIdentifier	 begin Char Index
=	TokenNameEQUAL	
endCharIndex	TokenNameIdentifier	 end Char Index
;	TokenNameSEMICOLON	
endCharIndex	TokenNameIdentifier	 end Char Index
=	TokenNameEQUAL	
temp	TokenNameIdentifier	 temp
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
GeneralPath	TokenNameIdentifier	 General Path
shape	TokenNameIdentifier	 shape
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
numGlyphs	TokenNameIdentifier	 num Glyphs
=	TokenNameEQUAL	
getGlyphCount	TokenNameIdentifier	 get Glyph Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
topPts	TokenNameIdentifier	 top Pts
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
numGlyphs	TokenNameIdentifier	 num Glyphs
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
botPts	TokenNameIdentifier	 bot Pts
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
numGlyphs	TokenNameIdentifier	 num Glyphs
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
ptIdx	TokenNameIdentifier	 pt Idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
currentChar	TokenNameIdentifier	 current Char
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numGlyphs	TokenNameIdentifier	 num Glyphs
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
glyphCharIndex	TokenNameIdentifier	 glyph Char Index
=	TokenNameEQUAL	
charMap	TokenNameIdentifier	 char Map
[	TokenNameLBRACKET	
currentChar	TokenNameIdentifier	 current Char
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
glyphCharIndex	TokenNameIdentifier	 glyph Char Index
>=	TokenNameGREATER_EQUAL	
beginCharIndex	TokenNameIdentifier	 begin Char Index
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
glyphCharIndex	TokenNameIdentifier	 glyph Char Index
<=	TokenNameLESS_EQUAL	
endCharIndex	TokenNameIdentifier	 end Char Index
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
isGlyphVisible	TokenNameIdentifier	 is Glyph Visible
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Shape	TokenNameIdentifier	 Shape
gbounds	TokenNameIdentifier	 gbounds
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphLogicalBounds	TokenNameIdentifier	 get Glyph Logical Bounds
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
gbounds	TokenNameIdentifier	 gbounds
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// We got something... 	TokenNameCOMMENT_LINE	We got something... 
if	TokenNameif	
(	TokenNameLPAREN	
shape	TokenNameIdentifier	 shape
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
shape	TokenNameIdentifier	 shape
=	TokenNameEQUAL	
new	TokenNamenew	
GeneralPath	TokenNameIdentifier	 General Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// We are pretty dumb here we assume that we always 	TokenNameCOMMENT_LINE	We are pretty dumb here we assume that we always 
// get back polygons with four sides to them if 	TokenNameCOMMENT_LINE	get back polygons with four sides to them if 
// isn't met we are SOL. 	TokenNameCOMMENT_LINE	isn't met we are SOL. 
float	TokenNamefloat	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
pts	TokenNameIdentifier	 pts
=	TokenNameEQUAL	
new	TokenNamenew	
float	TokenNamefloat	
[	TokenNameLBRACKET	
6	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
PathIterator	TokenNameIdentifier	 Path Iterator
pi	TokenNameIdentifier	 pi
=	TokenNameEQUAL	
gbounds	TokenNameIdentifier	 gbounds
.	TokenNameDOT	
getPathIterator	TokenNameIdentifier	 get Path Iterator
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
firstPt	TokenNameIdentifier	 first Pt
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
!	TokenNameNOT	
pi	TokenNameIdentifier	 pi
.	TokenNameDOT	
isDone	TokenNameIdentifier	 is Done
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
pi	TokenNameIdentifier	 pi
.	TokenNameDOT	
currentSegment	TokenNameIdentifier	 current Segment
(	TokenNameLPAREN	
pts	TokenNameIdentifier	 pts
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
PathIterator	TokenNameIdentifier	 Path Iterator
.	TokenNameDOT	
SEG_MOVETO	TokenNameIdentifier	 SEG  MOVETO
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
PathIterator	TokenNameIdentifier	 Path Iterator
.	TokenNameDOT	
SEG_LINETO	TokenNameIdentifier	 SEG  LINETO
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// LINETO or MOVETO 	TokenNameCOMMENT_LINE	LINETO or MOVETO 
if	TokenNameif	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
>	TokenNameGREATER	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
// too many lines... 	TokenNameCOMMENT_LINE	too many lines... 
if	TokenNameif	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
==	TokenNameEQUAL_EQUAL	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// make sure we are just closing it.. 	TokenNameCOMMENT_LINE	make sure we are just closing it.. 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
firstPt	TokenNameIdentifier	 first Pt
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
firstPt	TokenNameIdentifier	 first Pt
.	TokenNameDOT	
x	TokenNameIdentifier	 x
!=	TokenNameNOT_EQUAL	
pts	TokenNameIdentifier	 pts
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
firstPt	TokenNameIdentifier	 first Pt
.	TokenNameDOT	
y	TokenNameIdentifier	 y
!=	TokenNameNOT_EQUAL	
pts	TokenNameIdentifier	 pts
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
pt	TokenNameIdentifier	 pt
;	TokenNameSEMICOLON	
pt	TokenNameIdentifier	 pt
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
(	TokenNameLPAREN	
pts	TokenNameIdentifier	 pts
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
pts	TokenNameIdentifier	 pts
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
firstPt	TokenNameIdentifier	 first Pt
=	TokenNameEQUAL	
pt	TokenNameIdentifier	 pt
;	TokenNameSEMICOLON	
// Use sides of rectangle... 	TokenNameCOMMENT_LINE	Use sides of rectangle... 
switch	TokenNameswitch	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
botPts	TokenNameIdentifier	 bot Pts
[	TokenNameLBRACKET	
ptIdx	TokenNameIdentifier	 pt Idx
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
pt	TokenNameIdentifier	 pt
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
topPts	TokenNameIdentifier	 top Pts
[	TokenNameLBRACKET	
ptIdx	TokenNameIdentifier	 pt Idx
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
pt	TokenNameIdentifier	 pt
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
2	TokenNameIntegerLiteral	
:	TokenNameCOLON	
topPts	TokenNameIdentifier	 top Pts
[	TokenNameLBRACKET	
ptIdx	TokenNameIdentifier	 pt Idx
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
pt	TokenNameIdentifier	 pt
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
3	TokenNameIntegerLiteral	
:	TokenNameCOLON	
botPts	TokenNameIdentifier	 bot Pts
[	TokenNameLBRACKET	
ptIdx	TokenNameIdentifier	 pt Idx
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
pt	TokenNameIdentifier	 pt
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
PathIterator	TokenNameIdentifier	 Path Iterator
.	TokenNameDOT	
SEG_CLOSE	TokenNameIdentifier	 SEG  CLOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Close in the wrong spot? 	TokenNameCOMMENT_LINE	Close in the wrong spot? 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
<	TokenNameLESS	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
>	TokenNameGREATER	
5	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// QUADTO or CUBETO 	TokenNameCOMMENT_LINE	QUADTO or CUBETO 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
pi	TokenNameIdentifier	 pi
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
pi	TokenNameIdentifier	 pi
.	TokenNameDOT	
isDone	TokenNameIdentifier	 is Done
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Sucessfully Expressed as a quadralateral... 	TokenNameCOMMENT_LINE	Sucessfully Expressed as a quadralateral... 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
botPts	TokenNameIdentifier	 bot Pts
[	TokenNameLBRACKET	
ptIdx	TokenNameIdentifier	 pt Idx
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
topPts	TokenNameIdentifier	 top Pts
[	TokenNameLBRACKET	
ptIdx	TokenNameIdentifier	 pt Idx
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
!=	TokenNameNOT_EQUAL	
topPts	TokenNameIdentifier	 top Pts
[	TokenNameLBRACKET	
ptIdx	TokenNameIdentifier	 pt Idx
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
topPts	TokenNameIdentifier	 top Pts
[	TokenNameLBRACKET	
ptIdx	TokenNameIdentifier	 pt Idx
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
!=	TokenNameNOT_EQUAL	
topPts	TokenNameIdentifier	 top Pts
[	TokenNameLBRACKET	
ptIdx	TokenNameIdentifier	 pt Idx
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
// box isn't empty so use it's points... 	TokenNameCOMMENT_LINE	box isn't empty so use it's points... 
ptIdx	TokenNameIdentifier	 pt Idx
+=	TokenNamePLUS_EQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// System.out.println("Type: " + type + 	TokenNameCOMMENT_LINE	System.out.println("Type: " + type + 
// " count: " + count); 	TokenNameCOMMENT_LINE	" count: " + count); 
// Wasn't a quadralateral so just add it don't try 	TokenNameCOMMENT_LINE	Wasn't a quadralateral so just add it don't try 
// and merge it... 	TokenNameCOMMENT_LINE	and merge it... 
addPtsToPath	TokenNameIdentifier	 add Pts To Path
(	TokenNameLPAREN	
shape	TokenNameIdentifier	 shape
,	TokenNameCOMMA	
topPts	TokenNameIdentifier	 top Pts
,	TokenNameCOMMA	
botPts	TokenNameIdentifier	 bot Pts
,	TokenNameCOMMA	
ptIdx	TokenNameIdentifier	 pt Idx
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ptIdx	TokenNameIdentifier	 pt Idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
shape	TokenNameIdentifier	 shape
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
gbounds	TokenNameIdentifier	 gbounds
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
currentChar	TokenNameIdentifier	 current Char
+=	TokenNamePLUS_EQUAL	
getCharacterCount	TokenNameIdentifier	 get Character Count
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
currentChar	TokenNameIdentifier	 current Char
>=	TokenNameGREATER_EQUAL	
charMap	TokenNameIdentifier	 char Map
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
currentChar	TokenNameIdentifier	 current Char
=	TokenNameEQUAL	
charMap	TokenNameIdentifier	 char Map
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
addPtsToPath	TokenNameIdentifier	 add Pts To Path
(	TokenNameLPAREN	
shape	TokenNameIdentifier	 shape
,	TokenNameCOMMA	
topPts	TokenNameIdentifier	 top Pts
,	TokenNameCOMMA	
botPts	TokenNameIdentifier	 bot Pts
,	TokenNameCOMMA	
ptIdx	TokenNameIdentifier	 pt Idx
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
shape	TokenNameIdentifier	 shape
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
double	TokenNamedouble	
eps	TokenNameIdentifier	 eps
=	TokenNameEQUAL	
0.00001	TokenNameDoubleLiteral	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
epsEQ	TokenNameIdentifier	 eps EQ
(	TokenNameLPAREN	
double	TokenNamedouble	
a	TokenNameIdentifier	 a
,	TokenNameCOMMA	
double	TokenNamedouble	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
a	TokenNameIdentifier	 a
+	TokenNamePLUS	
eps	TokenNameIdentifier	 eps
>	TokenNameGREATER	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
a	TokenNameIdentifier	 a
-	TokenNameMINUS	
eps	TokenNameIdentifier	 eps
<	TokenNameLESS	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
int	TokenNameint	
makeConvexHull	TokenNameIdentifier	 make Convex Hull
(	TokenNameLPAREN	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
pts	TokenNameIdentifier	 pts
,	TokenNameCOMMA	
int	TokenNameint	
numPts	TokenNameIdentifier	 num Pts
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Sort the Pts in X... 	TokenNameCOMMENT_LINE	Sort the Pts in X... 
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
tmp	TokenNameIdentifier	 tmp
;	TokenNameSEMICOLON	
// System.out.print("Sorting..."); 	TokenNameCOMMENT_LINE	System.out.print("Sorting..."); 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numPts	TokenNameIdentifier	 num Pts
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Simple bubble sort (numPts should be small so shouldn't 	TokenNameCOMMENT_LINE	Simple bubble sort (numPts should be small so shouldn't 
// be too bad.). 	TokenNameCOMMENT_LINE	be too bad.). 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pts	TokenNameIdentifier	 pts
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
<	TokenNameLESS	
pts	TokenNameIdentifier	 pts
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pts	TokenNameIdentifier	 pts
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
==	TokenNameEQUAL_EQUAL	
pts	TokenNameIdentifier	 pts
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
pts	TokenNameIdentifier	 pts
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
<	TokenNameLESS	
pts	TokenNameIdentifier	 pts
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tmp	TokenNameIdentifier	 tmp
=	TokenNameEQUAL	
pts	TokenNameIdentifier	 pts
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
pts	TokenNameIdentifier	 pts
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
pts	TokenNameIdentifier	 pts
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
pts	TokenNameIdentifier	 pts
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
tmp	TokenNameIdentifier	 tmp
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// System.out.println("Sorted"); 	TokenNameCOMMENT_LINE	System.out.println("Sorted"); 
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
pt0	TokenNameIdentifier	 pt0
=	TokenNameEQUAL	
pts	TokenNameIdentifier	 pts
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
pt1	TokenNameIdentifier	 pt1
=	TokenNameEQUAL	
pts	TokenNameIdentifier	 pts
[	TokenNameLBRACKET	
numPts	TokenNameIdentifier	 num Pts
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
dxdy	TokenNameIdentifier	 dxdy
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
(	TokenNameLPAREN	
pt1	TokenNameIdentifier	 pt1
.	TokenNameDOT	
x	TokenNameIdentifier	 x
-	TokenNameMINUS	
pt0	TokenNameIdentifier	 pt0
.	TokenNameDOT	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
pt1	TokenNameIdentifier	 pt1
.	TokenNameDOT	
y	TokenNameIdentifier	 y
-	TokenNameMINUS	
pt0	TokenNameIdentifier	 pt0
.	TokenNameDOT	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
soln	TokenNameIdentifier	 soln
,	TokenNameCOMMA	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
dxdy	TokenNameIdentifier	 dxdy
.	TokenNameDOT	
y	TokenNameIdentifier	 y
*	TokenNameMULTIPLY	
pt0	TokenNameIdentifier	 pt0
.	TokenNameDOT	
x	TokenNameIdentifier	 x
-	TokenNameMINUS	
dxdy	TokenNameIdentifier	 dxdy
.	TokenNameDOT	
x	TokenNameIdentifier	 x
*	TokenNameMULTIPLY	
pt0	TokenNameIdentifier	 pt0
.	TokenNameDOT	
y	TokenNameIdentifier	 y
;	TokenNameSEMICOLON	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
topList	TokenNameIdentifier	 top List
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
[	TokenNameLBRACKET	
numPts	TokenNameIdentifier	 num Pts
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
botList	TokenNameIdentifier	 bot List
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
[	TokenNameLBRACKET	
numPts	TokenNameIdentifier	 num Pts
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
botList	TokenNameIdentifier	 bot List
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
topList	TokenNameIdentifier	 top List
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
pts	TokenNameIdentifier	 pts
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
nTopPts	TokenNameIdentifier	 n Top Pts
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
nBotPts	TokenNameIdentifier	 n Bot Pts
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numPts	TokenNameIdentifier	 num Pts
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
pt	TokenNameIdentifier	 pt
=	TokenNameEQUAL	
pts	TokenNameIdentifier	 pts
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
soln	TokenNameIdentifier	 soln
=	TokenNameEQUAL	
dxdy	TokenNameIdentifier	 dxdy
.	TokenNameDOT	
x	TokenNameIdentifier	 x
*	TokenNameMULTIPLY	
pt	TokenNameIdentifier	 pt
.	TokenNameDOT	
y	TokenNameIdentifier	 y
-	TokenNameMINUS	
dxdy	TokenNameIdentifier	 dxdy
.	TokenNameDOT	
y	TokenNameIdentifier	 y
*	TokenNameMULTIPLY	
pt	TokenNameIdentifier	 pt
.	TokenNameDOT	
x	TokenNameIdentifier	 x
+	TokenNamePLUS	
c	TokenNameIdentifier	 c
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
soln	TokenNameIdentifier	 soln
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Below line goes into bot pt list... 	TokenNameCOMMENT_LINE	Below line goes into bot pt list... 
while	TokenNamewhile	
(	TokenNameLPAREN	
nBotPts	TokenNameIdentifier	 n Bot Pts
>=	TokenNameGREATER_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pt0	TokenNameIdentifier	 pt0
=	TokenNameEQUAL	
botList	TokenNameIdentifier	 bot List
[	TokenNameLBRACKET	
nBotPts	TokenNameIdentifier	 n Bot Pts
-	TokenNameMINUS	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
pt1	TokenNameIdentifier	 pt1
=	TokenNameEQUAL	
botList	TokenNameIdentifier	 bot List
[	TokenNameLBRACKET	
nBotPts	TokenNameIdentifier	 n Bot Pts
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
dx	TokenNameIdentifier	 dx
=	TokenNameEQUAL	
pt1	TokenNameIdentifier	 pt1
.	TokenNameDOT	
x	TokenNameIdentifier	 x
-	TokenNameMINUS	
pt0	TokenNameIdentifier	 pt0
.	TokenNameDOT	
x	TokenNameIdentifier	 x
;	TokenNameSEMICOLON	
float	TokenNamefloat	
dy	TokenNameIdentifier	 dy
=	TokenNameEQUAL	
pt1	TokenNameIdentifier	 pt1
.	TokenNameDOT	
y	TokenNameIdentifier	 y
-	TokenNameMINUS	
pt0	TokenNameIdentifier	 pt0
.	TokenNameDOT	
y	TokenNameIdentifier	 y
;	TokenNameSEMICOLON	
float	TokenNamefloat	
c0	TokenNameIdentifier	 c0
=	TokenNameEQUAL	
dy	TokenNameIdentifier	 dy
*	TokenNameMULTIPLY	
pt0	TokenNameIdentifier	 pt0
.	TokenNameDOT	
x	TokenNameIdentifier	 x
-	TokenNameMINUS	
dx	TokenNameIdentifier	 dx
*	TokenNameMULTIPLY	
pt0	TokenNameIdentifier	 pt0
.	TokenNameDOT	
y	TokenNameIdentifier	 y
;	TokenNameSEMICOLON	
soln	TokenNameIdentifier	 soln
=	TokenNameEQUAL	
dx	TokenNameIdentifier	 dx
*	TokenNameMULTIPLY	
pt	TokenNameIdentifier	 pt
.	TokenNameDOT	
y	TokenNameIdentifier	 y
-	TokenNameMINUS	
dy	TokenNameIdentifier	 dy
*	TokenNameMULTIPLY	
pt	TokenNameIdentifier	 pt
.	TokenNameDOT	
x	TokenNameIdentifier	 x
+	TokenNamePLUS	
c0	TokenNameIdentifier	 c0
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
soln	TokenNameIdentifier	 soln
>	TokenNameGREATER	
eps	TokenNameIdentifier	 eps
)	TokenNameRPAREN	
// Left turn add and we are done.. 	TokenNameCOMMENT_LINE	Left turn add and we are done.. 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
soln	TokenNameIdentifier	 soln
>	TokenNameGREATER	
-	TokenNameMINUS	
eps	TokenNameIdentifier	 eps
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// On line take lowest Y of two and keep going 	TokenNameCOMMENT_LINE	On line take lowest Y of two and keep going 
if	TokenNameif	
(	TokenNameLPAREN	
pt1	TokenNameIdentifier	 pt1
.	TokenNameDOT	
y	TokenNameIdentifier	 y
<	TokenNameLESS	
pt	TokenNameIdentifier	 pt
.	TokenNameDOT	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
pt	TokenNameIdentifier	 pt
=	TokenNameEQUAL	
pt1	TokenNameIdentifier	 pt1
;	TokenNameSEMICOLON	
nBotPts	TokenNameIdentifier	 n Bot Pts
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// right turn drop prev pt; 	TokenNameCOMMENT_LINE	right turn drop prev pt; 
nBotPts	TokenNameIdentifier	 n Bot Pts
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
botList	TokenNameIdentifier	 bot List
[	TokenNameLBRACKET	
nBotPts	TokenNameIdentifier	 n Bot Pts
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
pt	TokenNameIdentifier	 pt
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Above line goes into top pt list... 	TokenNameCOMMENT_LINE	Above line goes into top pt list... 
while	TokenNamewhile	
(	TokenNameLPAREN	
nTopPts	TokenNameIdentifier	 n Top Pts
>=	TokenNameGREATER_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pt0	TokenNameIdentifier	 pt0
=	TokenNameEQUAL	
topList	TokenNameIdentifier	 top List
[	TokenNameLBRACKET	
nTopPts	TokenNameIdentifier	 n Top Pts
-	TokenNameMINUS	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
pt1	TokenNameIdentifier	 pt1
=	TokenNameEQUAL	
topList	TokenNameIdentifier	 top List
[	TokenNameLBRACKET	
nTopPts	TokenNameIdentifier	 n Top Pts
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
dx	TokenNameIdentifier	 dx
=	TokenNameEQUAL	
pt1	TokenNameIdentifier	 pt1
.	TokenNameDOT	
x	TokenNameIdentifier	 x
-	TokenNameMINUS	
pt0	TokenNameIdentifier	 pt0
.	TokenNameDOT	
x	TokenNameIdentifier	 x
;	TokenNameSEMICOLON	
float	TokenNamefloat	
dy	TokenNameIdentifier	 dy
=	TokenNameEQUAL	
pt1	TokenNameIdentifier	 pt1
.	TokenNameDOT	
y	TokenNameIdentifier	 y
-	TokenNameMINUS	
pt0	TokenNameIdentifier	 pt0
.	TokenNameDOT	
y	TokenNameIdentifier	 y
;	TokenNameSEMICOLON	
float	TokenNamefloat	
c0	TokenNameIdentifier	 c0
=	TokenNameEQUAL	
dy	TokenNameIdentifier	 dy
*	TokenNameMULTIPLY	
pt0	TokenNameIdentifier	 pt0
.	TokenNameDOT	
x	TokenNameIdentifier	 x
-	TokenNameMINUS	
dx	TokenNameIdentifier	 dx
*	TokenNameMULTIPLY	
pt0	TokenNameIdentifier	 pt0
.	TokenNameDOT	
y	TokenNameIdentifier	 y
;	TokenNameSEMICOLON	
soln	TokenNameIdentifier	 soln
=	TokenNameEQUAL	
dx	TokenNameIdentifier	 dx
*	TokenNameMULTIPLY	
pt	TokenNameIdentifier	 pt
.	TokenNameDOT	
y	TokenNameIdentifier	 y
-	TokenNameMINUS	
dy	TokenNameIdentifier	 dy
*	TokenNameMULTIPLY	
pt	TokenNameIdentifier	 pt
.	TokenNameDOT	
x	TokenNameIdentifier	 x
+	TokenNamePLUS	
c0	TokenNameIdentifier	 c0
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
soln	TokenNameIdentifier	 soln
<	TokenNameLESS	
-	TokenNameMINUS	
eps	TokenNameIdentifier	 eps
)	TokenNameRPAREN	
// Right turn add and check next point. 	TokenNameCOMMENT_LINE	Right turn add and check next point. 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
soln	TokenNameIdentifier	 soln
<	TokenNameLESS	
eps	TokenNameIdentifier	 eps
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// On line take greatest Y of two and keep going 	TokenNameCOMMENT_LINE	On line take greatest Y of two and keep going 
if	TokenNameif	
(	TokenNameLPAREN	
pt1	TokenNameIdentifier	 pt1
.	TokenNameDOT	
y	TokenNameIdentifier	 y
>	TokenNameGREATER	
pt	TokenNameIdentifier	 pt
.	TokenNameDOT	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
pt	TokenNameIdentifier	 pt
=	TokenNameEQUAL	
pt1	TokenNameIdentifier	 pt1
;	TokenNameSEMICOLON	
nTopPts	TokenNameIdentifier	 n Top Pts
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// left turn drop prev pt; 	TokenNameCOMMENT_LINE	left turn drop prev pt; 
nTopPts	TokenNameIdentifier	 n Top Pts
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
topList	TokenNameIdentifier	 top List
[	TokenNameLBRACKET	
nTopPts	TokenNameIdentifier	 n Top Pts
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
pt	TokenNameIdentifier	 pt
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Check last point in both sets... 	TokenNameCOMMENT_LINE	Check last point in both sets... 
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
pt	TokenNameIdentifier	 pt
=	TokenNameEQUAL	
pts	TokenNameIdentifier	 pts
[	TokenNameLBRACKET	
numPts	TokenNameIdentifier	 num Pts
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
nBotPts	TokenNameIdentifier	 n Bot Pts
>=	TokenNameGREATER_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pt0	TokenNameIdentifier	 pt0
=	TokenNameEQUAL	
botList	TokenNameIdentifier	 bot List
[	TokenNameLBRACKET	
nBotPts	TokenNameIdentifier	 n Bot Pts
-	TokenNameMINUS	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
pt1	TokenNameIdentifier	 pt1
=	TokenNameEQUAL	
botList	TokenNameIdentifier	 bot List
[	TokenNameLBRACKET	
nBotPts	TokenNameIdentifier	 n Bot Pts
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
dx	TokenNameIdentifier	 dx
=	TokenNameEQUAL	
pt1	TokenNameIdentifier	 pt1
.	TokenNameDOT	
x	TokenNameIdentifier	 x
-	TokenNameMINUS	
pt0	TokenNameIdentifier	 pt0
.	TokenNameDOT	
x	TokenNameIdentifier	 x
;	TokenNameSEMICOLON	
float	TokenNamefloat	
dy	TokenNameIdentifier	 dy
=	TokenNameEQUAL	
pt1	TokenNameIdentifier	 pt1
.	TokenNameDOT	
y	TokenNameIdentifier	 y
-	TokenNameMINUS	
pt0	TokenNameIdentifier	 pt0
.	TokenNameDOT	
y	TokenNameIdentifier	 y
;	TokenNameSEMICOLON	
float	TokenNamefloat	
c0	TokenNameIdentifier	 c0
=	TokenNameEQUAL	
dy	TokenNameIdentifier	 dy
*	TokenNameMULTIPLY	
pt0	TokenNameIdentifier	 pt0
.	TokenNameDOT	
x	TokenNameIdentifier	 x
-	TokenNameMINUS	
dx	TokenNameIdentifier	 dx
*	TokenNameMULTIPLY	
pt0	TokenNameIdentifier	 pt0
.	TokenNameDOT	
y	TokenNameIdentifier	 y
;	TokenNameSEMICOLON	
soln	TokenNameIdentifier	 soln
=	TokenNameEQUAL	
dx	TokenNameIdentifier	 dx
*	TokenNameMULTIPLY	
pt	TokenNameIdentifier	 pt
.	TokenNameDOT	
y	TokenNameIdentifier	 y
-	TokenNameMINUS	
dy	TokenNameIdentifier	 dy
*	TokenNameMULTIPLY	
pt	TokenNameIdentifier	 pt
.	TokenNameDOT	
x	TokenNameIdentifier	 x
+	TokenNamePLUS	
c0	TokenNameIdentifier	 c0
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
soln	TokenNameIdentifier	 soln
>	TokenNameGREATER	
eps	TokenNameIdentifier	 eps
)	TokenNameRPAREN	
// Left turn add and we are done.. 	TokenNameCOMMENT_LINE	Left turn add and we are done.. 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
soln	TokenNameIdentifier	 soln
>	TokenNameGREATER	
-	TokenNameMINUS	
eps	TokenNameIdentifier	 eps
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// On line take lowest Y of two and keep going 	TokenNameCOMMENT_LINE	On line take lowest Y of two and keep going 
if	TokenNameif	
(	TokenNameLPAREN	
pt1	TokenNameIdentifier	 pt1
.	TokenNameDOT	
y	TokenNameIdentifier	 y
>=	TokenNameGREATER_EQUAL	
pt	TokenNameIdentifier	 pt
.	TokenNameDOT	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
nBotPts	TokenNameIdentifier	 n Bot Pts
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// right turn drop prev pt; 	TokenNameCOMMENT_LINE	right turn drop prev pt; 
nBotPts	TokenNameIdentifier	 n Bot Pts
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
nTopPts	TokenNameIdentifier	 n Top Pts
>=	TokenNameGREATER_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pt0	TokenNameIdentifier	 pt0
=	TokenNameEQUAL	
topList	TokenNameIdentifier	 top List
[	TokenNameLBRACKET	
nTopPts	TokenNameIdentifier	 n Top Pts
-	TokenNameMINUS	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
pt1	TokenNameIdentifier	 pt1
=	TokenNameEQUAL	
topList	TokenNameIdentifier	 top List
[	TokenNameLBRACKET	
nTopPts	TokenNameIdentifier	 n Top Pts
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
dx	TokenNameIdentifier	 dx
=	TokenNameEQUAL	
pt1	TokenNameIdentifier	 pt1
.	TokenNameDOT	
x	TokenNameIdentifier	 x
-	TokenNameMINUS	
pt0	TokenNameIdentifier	 pt0
.	TokenNameDOT	
x	TokenNameIdentifier	 x
;	TokenNameSEMICOLON	
float	TokenNamefloat	
dy	TokenNameIdentifier	 dy
=	TokenNameEQUAL	
pt1	TokenNameIdentifier	 pt1
.	TokenNameDOT	
y	TokenNameIdentifier	 y
-	TokenNameMINUS	
pt0	TokenNameIdentifier	 pt0
.	TokenNameDOT	
y	TokenNameIdentifier	 y
;	TokenNameSEMICOLON	
float	TokenNamefloat	
c0	TokenNameIdentifier	 c0
=	TokenNameEQUAL	
dy	TokenNameIdentifier	 dy
*	TokenNameMULTIPLY	
pt0	TokenNameIdentifier	 pt0
.	TokenNameDOT	
x	TokenNameIdentifier	 x
-	TokenNameMINUS	
dx	TokenNameIdentifier	 dx
*	TokenNameMULTIPLY	
pt0	TokenNameIdentifier	 pt0
.	TokenNameDOT	
y	TokenNameIdentifier	 y
;	TokenNameSEMICOLON	
soln	TokenNameIdentifier	 soln
=	TokenNameEQUAL	
dx	TokenNameIdentifier	 dx
*	TokenNameMULTIPLY	
pt	TokenNameIdentifier	 pt
.	TokenNameDOT	
y	TokenNameIdentifier	 y
-	TokenNameMINUS	
dy	TokenNameIdentifier	 dy
*	TokenNameMULTIPLY	
pt	TokenNameIdentifier	 pt
.	TokenNameDOT	
x	TokenNameIdentifier	 x
+	TokenNamePLUS	
c0	TokenNameIdentifier	 c0
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
soln	TokenNameIdentifier	 soln
<	TokenNameLESS	
-	TokenNameMINUS	
eps	TokenNameIdentifier	 eps
)	TokenNameRPAREN	
// Right turn done... 	TokenNameCOMMENT_LINE	Right turn done... 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
soln	TokenNameIdentifier	 soln
<	TokenNameLESS	
eps	TokenNameIdentifier	 eps
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// On line take lowest Y of two and keep going 	TokenNameCOMMENT_LINE	On line take lowest Y of two and keep going 
if	TokenNameif	
(	TokenNameLPAREN	
pt1	TokenNameIdentifier	 pt1
.	TokenNameDOT	
y	TokenNameIdentifier	 y
<=	TokenNameLESS_EQUAL	
pt	TokenNameIdentifier	 pt
.	TokenNameDOT	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
nTopPts	TokenNameIdentifier	 n Top Pts
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// left turn drop prev pt; 	TokenNameCOMMENT_LINE	left turn drop prev pt; 
nTopPts	TokenNameIdentifier	 n Top Pts
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
topList	TokenNameIdentifier	 top List
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
pts	TokenNameIdentifier	 pts
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
nTopPts	TokenNameIdentifier	 n Top Pts
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
nTopPts	TokenNameIdentifier	 n Top Pts
;	TokenNameSEMICOLON	
// We always include the 'last' point as it is always on convex hull. 	TokenNameCOMMENT_LINE	We always include the 'last' point as it is always on convex hull. 
pts	TokenNameIdentifier	 pts
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
pts	TokenNameIdentifier	 pts
[	TokenNameLBRACKET	
numPts	TokenNameIdentifier	 num Pts
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// don't include botList[0] since it is the same as topList[0]. 	TokenNameCOMMENT_LINE	don't include botList[0] since it is the same as topList[0]. 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
nBotPts	TokenNameIdentifier	 n Bot Pts
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
n	TokenNameIdentifier	 n
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
n	TokenNameIdentifier	 n
--	TokenNameMINUS_MINUS	
,	TokenNameCOMMA	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
pts	TokenNameIdentifier	 pts
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
botList	TokenNameIdentifier	 bot List
[	TokenNameLBRACKET	
n	TokenNameIdentifier	 n
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// System.out.println("CHull has " + i + " pts"); 	TokenNameCOMMENT_LINE	System.out.println("CHull has " + i + " pts"); 
return	TokenNamereturn	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
addPtsToPath	TokenNameIdentifier	 add Pts To Path
(	TokenNameLPAREN	
GeneralPath	TokenNameIdentifier	 General Path
shape	TokenNameIdentifier	 shape
,	TokenNameCOMMA	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
topPts	TokenNameIdentifier	 top Pts
,	TokenNameCOMMA	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
botPts	TokenNameIdentifier	 bot Pts
,	TokenNameCOMMA	
int	TokenNameint	
numPts	TokenNameIdentifier	 num Pts
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
numPts	TokenNameIdentifier	 num Pts
<	TokenNameLESS	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
numPts	TokenNameIdentifier	 num Pts
==	TokenNameEQUAL_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
shape	TokenNameIdentifier	 shape
.	TokenNameDOT	
moveTo	TokenNameIdentifier	 move To
(	TokenNameLPAREN	
topPts	TokenNameIdentifier	 top Pts
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
topPts	TokenNameIdentifier	 top Pts
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
shape	TokenNameIdentifier	 shape
.	TokenNameDOT	
lineTo	TokenNameIdentifier	 line To
(	TokenNameLPAREN	
topPts	TokenNameIdentifier	 top Pts
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
topPts	TokenNameIdentifier	 top Pts
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
shape	TokenNameIdentifier	 shape
.	TokenNameDOT	
lineTo	TokenNameIdentifier	 line To
(	TokenNameLPAREN	
botPts	TokenNameIdentifier	 bot Pts
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
botPts	TokenNameIdentifier	 bot Pts
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
shape	TokenNameIdentifier	 shape
.	TokenNameDOT	
lineTo	TokenNameIdentifier	 line To
(	TokenNameLPAREN	
botPts	TokenNameIdentifier	 bot Pts
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
botPts	TokenNameIdentifier	 bot Pts
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
shape	TokenNameIdentifier	 shape
.	TokenNameDOT	
lineTo	TokenNameIdentifier	 line To
(	TokenNameLPAREN	
topPts	TokenNameIdentifier	 top Pts
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
topPts	TokenNameIdentifier	 top Pts
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Here we 'connect the dots' the best way we know how... 	TokenNameCOMMENT_LINE	Here we 'connect the dots' the best way we know how... 
// What I do is construct a convex hull between adjacent 	TokenNameCOMMENT_LINE	What I do is construct a convex hull between adjacent 
// character boxes, then I union that into the shape. this 	TokenNameCOMMENT_LINE	character boxes, then I union that into the shape. this 
// does a good job of bridging between adjacent characters, 	TokenNameCOMMENT_LINE	does a good job of bridging between adjacent characters, 
// but still closely tracking to text boxes. The use of the 	TokenNameCOMMENT_LINE	but still closely tracking to text boxes. The use of the 
// Area class is fairly heavy weight but it seems to keep up 	TokenNameCOMMENT_LINE	Area class is fairly heavy weight but it seems to keep up 
// in this instanace (probably because all the shapes are very 	TokenNameCOMMENT_LINE	in this instanace (probably because all the shapes are very 
// simple polygons). 	TokenNameCOMMENT_LINE	simple polygons). 
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
boxes	TokenNameIdentifier	 boxes
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
[	TokenNameLBRACKET	
8	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
chull	TokenNameIdentifier	 chull
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
[	TokenNameLBRACKET	
8	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
4	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
topPts	TokenNameIdentifier	 top Pts
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
5	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
topPts	TokenNameIdentifier	 top Pts
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
6	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
botPts	TokenNameIdentifier	 bot Pts
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
7	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
botPts	TokenNameIdentifier	 bot Pts
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
Area	TokenNameIdentifier	 Area
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
areas	TokenNameIdentifier	 areas
=	TokenNameEQUAL	
new	TokenNamenew	
Area	TokenNameIdentifier	 Area
[	TokenNameLBRACKET	
numPts	TokenNameIdentifier	 num Pts
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
nAreas	TokenNameIdentifier	 n Areas
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numPts	TokenNameIdentifier	 num Pts
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
+=	TokenNamePLUS_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
4	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
5	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
6	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
3	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
7	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
4	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
topPts	TokenNameIdentifier	 top Pts
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
5	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
topPts	TokenNameIdentifier	 top Pts
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
6	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
botPts	TokenNameIdentifier	 bot Pts
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
7	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
botPts	TokenNameIdentifier	 bot Pts
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
delta	TokenNameIdentifier	 delta
,	TokenNameCOMMA	
sz	TokenNameIdentifier	 sz
,	TokenNameCOMMA	
dist	TokenNameIdentifier	 dist
;	TokenNameSEMICOLON	
delta	TokenNameIdentifier	 delta
=	TokenNameEQUAL	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
-	TokenNameMINUS	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
;	TokenNameSEMICOLON	
dist	TokenNameIdentifier	 dist
=	TokenNameEQUAL	
delta	TokenNameIdentifier	 delta
*	TokenNameMULTIPLY	
delta	TokenNameIdentifier	 delta
;	TokenNameSEMICOLON	
delta	TokenNameIdentifier	 delta
=	TokenNameEQUAL	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
-	TokenNameMINUS	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
;	TokenNameSEMICOLON	
dist	TokenNameIdentifier	 dist
+=	TokenNamePLUS_EQUAL	
delta	TokenNameIdentifier	 delta
*	TokenNameMULTIPLY	
delta	TokenNameIdentifier	 delta
;	TokenNameSEMICOLON	
sz	TokenNameIdentifier	 sz
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
sqrt	TokenNameIdentifier	 sqrt
(	TokenNameLPAREN	
dist	TokenNameIdentifier	 dist
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
delta	TokenNameIdentifier	 delta
=	TokenNameEQUAL	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
6	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
-	TokenNameMINUS	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
4	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
;	TokenNameSEMICOLON	
dist	TokenNameIdentifier	 dist
=	TokenNameEQUAL	
delta	TokenNameIdentifier	 delta
*	TokenNameMULTIPLY	
delta	TokenNameIdentifier	 delta
;	TokenNameSEMICOLON	
delta	TokenNameIdentifier	 delta
=	TokenNameEQUAL	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
6	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
-	TokenNameMINUS	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
4	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
;	TokenNameSEMICOLON	
dist	TokenNameIdentifier	 dist
+=	TokenNamePLUS_EQUAL	
delta	TokenNameIdentifier	 delta
*	TokenNameMULTIPLY	
delta	TokenNameIdentifier	 delta
;	TokenNameSEMICOLON	
sz	TokenNameIdentifier	 sz
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
sqrt	TokenNameIdentifier	 sqrt
(	TokenNameLPAREN	
dist	TokenNameIdentifier	 dist
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
delta	TokenNameIdentifier	 delta
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
+	TokenNamePLUS	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
+	TokenNamePLUS	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
+	TokenNamePLUS	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
3	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
)	TokenNameRPAREN	
-	TokenNameMINUS	
(	TokenNameLPAREN	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
4	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
+	TokenNamePLUS	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
5	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
+	TokenNamePLUS	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
6	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
+	TokenNamePLUS	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
7	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
)	TokenNameRPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
dist	TokenNameIdentifier	 dist
=	TokenNameEQUAL	
delta	TokenNameIdentifier	 delta
*	TokenNameMULTIPLY	
delta	TokenNameIdentifier	 delta
;	TokenNameSEMICOLON	
delta	TokenNameIdentifier	 delta
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
+	TokenNamePLUS	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
+	TokenNamePLUS	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
+	TokenNamePLUS	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
3	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
-	TokenNameMINUS	
(	TokenNameLPAREN	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
4	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
+	TokenNamePLUS	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
5	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
+	TokenNamePLUS	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
6	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
+	TokenNamePLUS	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
7	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
dist	TokenNameIdentifier	 dist
+=	TokenNamePLUS_EQUAL	
delta	TokenNameIdentifier	 delta
*	TokenNameMULTIPLY	
delta	TokenNameIdentifier	 delta
;	TokenNameSEMICOLON	
dist	TokenNameIdentifier	 dist
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
sqrt	TokenNameIdentifier	 sqrt
(	TokenNameLPAREN	
dist	TokenNameIdentifier	 dist
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Note here that dist is the distance between center 	TokenNameCOMMENT_LINE	Note here that dist is the distance between center 
// points, and sz is the sum of the length of the 	TokenNameCOMMENT_LINE	points, and sz is the sum of the length of the 
// diagonals of the letter boxes. In normal cases one 	TokenNameCOMMENT_LINE	diagonals of the letter boxes. In normal cases one 
// would expect dist to be approximately equal to sz/2. 	TokenNameCOMMENT_LINE	would expect dist to be approximately equal to sz/2. 
// So here we merge if the two characters are within four 	TokenNameCOMMENT_LINE	So here we merge if the two characters are within four 
// character widths of each other. If they are farther 	TokenNameCOMMENT_LINE	character widths of each other. If they are farther 
// apart than that chances are it's a 'line break' or 	TokenNameCOMMENT_LINE	apart than that chances are it's a 'line break' or 
// something similar where we will get better results 	TokenNameCOMMENT_LINE	something similar where we will get better results 
// merging seperately, and anyways with this much space 	TokenNameCOMMENT_LINE	merging seperately, and anyways with this much space 
// between them the extra outline shouldn't hurt.. 	TokenNameCOMMENT_LINE	between them the extra outline shouldn't hurt.. 
GeneralPath	TokenNameIdentifier	 General Path
gp	TokenNameIdentifier	 gp
=	TokenNameEQUAL	
new	TokenNamenew	
GeneralPath	TokenNameIdentifier	 General Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dist	TokenNameIdentifier	 dist
<	TokenNameLESS	
sz	TokenNameIdentifier	 sz
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Close enough to merge with previous char... 	TokenNameCOMMENT_LINE	Close enough to merge with previous char... 
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
boxes	TokenNameIdentifier	 boxes
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
chull	TokenNameIdentifier	 chull
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
npts	TokenNameIdentifier	 npts
=	TokenNameEQUAL	
makeConvexHull	TokenNameIdentifier	 make Convex Hull
(	TokenNameLPAREN	
chull	TokenNameIdentifier	 chull
,	TokenNameCOMMA	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
gp	TokenNameIdentifier	 gp
.	TokenNameDOT	
moveTo	TokenNameIdentifier	 move To
(	TokenNameLPAREN	
chull	TokenNameIdentifier	 chull
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
chull	TokenNameIdentifier	 chull
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
n	TokenNameIdentifier	 n
<	TokenNameLESS	
npts	TokenNameIdentifier	 npts
;	TokenNameSEMICOLON	
n	TokenNameIdentifier	 n
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
gp	TokenNameIdentifier	 gp
.	TokenNameDOT	
lineTo	TokenNameIdentifier	 line To
(	TokenNameLPAREN	
chull	TokenNameIdentifier	 chull
[	TokenNameLBRACKET	
n	TokenNameIdentifier	 n
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
chull	TokenNameIdentifier	 chull
[	TokenNameLBRACKET	
n	TokenNameIdentifier	 n
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
gp	TokenNameIdentifier	 gp
.	TokenNameDOT	
closePath	TokenNameIdentifier	 close Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Merge all previous areas 	TokenNameCOMMENT_LINE	Merge all previous areas 
mergeAreas	TokenNameIdentifier	 merge Areas
(	TokenNameLPAREN	
shape	TokenNameIdentifier	 shape
,	TokenNameCOMMA	
areas	TokenNameIdentifier	 areas
,	TokenNameCOMMA	
nAreas	TokenNameIdentifier	 n Areas
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
nAreas	TokenNameIdentifier	 n Areas
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Start fresh... 	TokenNameCOMMENT_LINE	Start fresh... 
// Then just add box (add the previous char box if first pts) 	TokenNameCOMMENT_LINE	Then just add box (add the previous char box if first pts) 
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
==	TokenNameEQUAL_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
gp	TokenNameIdentifier	 gp
.	TokenNameDOT	
moveTo	TokenNameIdentifier	 move To
(	TokenNameLPAREN	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
gp	TokenNameIdentifier	 gp
.	TokenNameDOT	
lineTo	TokenNameIdentifier	 line To
(	TokenNameLPAREN	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
gp	TokenNameIdentifier	 gp
.	TokenNameDOT	
lineTo	TokenNameIdentifier	 line To
(	TokenNameLPAREN	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
gp	TokenNameIdentifier	 gp
.	TokenNameDOT	
lineTo	TokenNameIdentifier	 line To
(	TokenNameLPAREN	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
3	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
3	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
gp	TokenNameIdentifier	 gp
.	TokenNameDOT	
closePath	TokenNameIdentifier	 close Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
shape	TokenNameIdentifier	 shape
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
gp	TokenNameIdentifier	 gp
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
gp	TokenNameIdentifier	 gp
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
gp	TokenNameIdentifier	 gp
.	TokenNameDOT	
moveTo	TokenNameIdentifier	 move To
(	TokenNameLPAREN	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
4	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
4	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
gp	TokenNameIdentifier	 gp
.	TokenNameDOT	
lineTo	TokenNameIdentifier	 line To
(	TokenNameLPAREN	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
5	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
5	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
gp	TokenNameIdentifier	 gp
.	TokenNameDOT	
lineTo	TokenNameIdentifier	 line To
(	TokenNameLPAREN	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
6	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
6	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
gp	TokenNameIdentifier	 gp
.	TokenNameDOT	
lineTo	TokenNameIdentifier	 line To
(	TokenNameLPAREN	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
7	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
boxes	TokenNameIdentifier	 boxes
[	TokenNameLBRACKET	
7	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
gp	TokenNameIdentifier	 gp
.	TokenNameDOT	
closePath	TokenNameIdentifier	 close Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
areas	TokenNameIdentifier	 areas
[	TokenNameLBRACKET	
nAreas	TokenNameIdentifier	 n Areas
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
Area	TokenNameIdentifier	 Area
(	TokenNameLPAREN	
gp	TokenNameIdentifier	 gp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
mergeAreas	TokenNameIdentifier	 merge Areas
(	TokenNameLPAREN	
shape	TokenNameIdentifier	 shape
,	TokenNameCOMMA	
areas	TokenNameIdentifier	 areas
,	TokenNameCOMMA	
nAreas	TokenNameIdentifier	 n Areas
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
mergeAreas	TokenNameIdentifier	 merge Areas
(	TokenNameLPAREN	
GeneralPath	TokenNameIdentifier	 General Path
shape	TokenNameIdentifier	 shape
,	TokenNameCOMMA	
Area	TokenNameIdentifier	 Area
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
shapes	TokenNameIdentifier	 shapes
,	TokenNameCOMMA	
int	TokenNameint	
nShapes	TokenNameIdentifier	 n Shapes
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Merge areas hierarchically, this means that while there are 	TokenNameCOMMENT_LINE	Merge areas hierarchically, this means that while there are 
// the same number of Area.add calls (n-1) the great majority 	TokenNameCOMMENT_LINE	the same number of Area.add calls (n-1) the great majority 
// of them are very simple combinations. This helps to speed 	TokenNameCOMMENT_LINE	of them are very simple combinations. This helps to speed 
// things up a tad... 	TokenNameCOMMENT_LINE	things up a tad... 
while	TokenNamewhile	
(	TokenNameLPAREN	
nShapes	TokenNameIdentifier	 n Shapes
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
nShapes	TokenNameIdentifier	 n Shapes
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
+=	TokenNamePLUS_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
shapes	TokenNameIdentifier	 shapes
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
shapes	TokenNameIdentifier	 shapes
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
shapes	TokenNameIdentifier	 shapes
[	TokenNameLBRACKET	
n	TokenNameIdentifier	 n
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
shapes	TokenNameIdentifier	 shapes
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
shapes	TokenNameIdentifier	 shapes
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// make sure we include the last one if odd. 	TokenNameCOMMENT_LINE	make sure we include the last one if odd. 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
nShapes	TokenNameIdentifier	 n Shapes
&	TokenNameAND	
0x1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
shapes	TokenNameIdentifier	 shapes
[	TokenNameLBRACKET	
n	TokenNameIdentifier	 n
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
shapes	TokenNameIdentifier	 shapes
[	TokenNameLBRACKET	
nShapes	TokenNameIdentifier	 n Shapes
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
nShapes	TokenNameIdentifier	 n Shapes
=	TokenNameEQUAL	
nShapes	TokenNameIdentifier	 n Shapes
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
nShapes	TokenNameIdentifier	 n Shapes
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
shape	TokenNameIdentifier	 shape
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
shapes	TokenNameIdentifier	 shapes
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Perform hit testing for coordinate at x, y. * * @param x the x coordinate of the point to be tested. * @param y the y coordinate of the point to be tested. * * @return a TextHit object encapsulating the character index for * successful hits and whether the hit is on the character * leading edge. */	TokenNameCOMMENT_JAVADOC	 Perform hit testing for coordinate at x, y. * @param x the x coordinate of the point to be tested. @param y the y coordinate of the point to be tested. * @return a TextHit object encapsulating the character index for successful hits and whether the hit is on the character leading edge. 
public	TokenNamepublic	
TextHit	TokenNameIdentifier	 Text Hit
hitTestChar	TokenNameIdentifier	 hit Test Char
(	TokenNameLPAREN	
float	TokenNamefloat	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
float	TokenNamefloat	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
{	TokenNameLBRACE	
syncLayout	TokenNameIdentifier	 sync Layout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TextHit	TokenNameIdentifier	 Text Hit
textHit	TokenNameIdentifier	 text Hit
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
currentChar	TokenNameIdentifier	 current Char
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getNumGlyphs	TokenNameIdentifier	 get Num Glyphs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Shape	TokenNameIdentifier	 Shape
gbounds	TokenNameIdentifier	 gbounds
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphLogicalBounds	TokenNameIdentifier	 get Glyph Logical Bounds
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
gbounds	TokenNameIdentifier	 gbounds
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
gbounds2d	TokenNameIdentifier	 gbounds2d
=	TokenNameEQUAL	
gbounds	TokenNameIdentifier	 gbounds
.	TokenNameDOT	
getBounds2D	TokenNameIdentifier	 get Bounds2 D
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// System.out.println("Hit Test: [" + x + ", " + y + "] - " + 	TokenNameCOMMENT_LINE	System.out.println("Hit Test: [" + x + ", " + y + "] - " + 
// gbounds2d); 	TokenNameCOMMENT_LINE	gbounds2d); 
if	TokenNameif	
(	TokenNameLPAREN	
gbounds	TokenNameIdentifier	 gbounds
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
isRightHalf	TokenNameIdentifier	 is Right Half
=	TokenNameEQUAL	
(	TokenNameLPAREN	
x	TokenNameIdentifier	 x
>	TokenNameGREATER	
(	TokenNameLPAREN	
gbounds2d	TokenNameIdentifier	 gbounds2d
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
(	TokenNameLPAREN	
gbounds2d	TokenNameIdentifier	 gbounds2d
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
2d	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
isLeadingEdge	TokenNameIdentifier	 is Leading Edge
=	TokenNameEQUAL	
!	TokenNameNOT	
isRightHalf	TokenNameIdentifier	 is Right Half
;	TokenNameSEMICOLON	
int	TokenNameint	
charIndex	TokenNameIdentifier	 char Index
=	TokenNameEQUAL	
charMap	TokenNameIdentifier	 char Map
[	TokenNameLBRACKET	
currentChar	TokenNameIdentifier	 current Char
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
textHit	TokenNameIdentifier	 text Hit
=	TokenNameEQUAL	
new	TokenNamenew	
TextHit	TokenNameIdentifier	 Text Hit
(	TokenNameLPAREN	
charIndex	TokenNameIdentifier	 char Index
,	TokenNameCOMMA	
isLeadingEdge	TokenNameIdentifier	 is Leading Edge
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
textHit	TokenNameIdentifier	 text Hit
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
currentChar	TokenNameIdentifier	 current Char
+=	TokenNamePLUS_EQUAL	
getCharacterCount	TokenNameIdentifier	 get Character Count
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
currentChar	TokenNameIdentifier	 current Char
>=	TokenNameGREATER_EQUAL	
charMap	TokenNameIdentifier	 char Map
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
currentChar	TokenNameIdentifier	 current Char
=	TokenNameEQUAL	
charMap	TokenNameIdentifier	 char Map
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
textHit	TokenNameIdentifier	 text Hit
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//protected 	TokenNameCOMMENT_LINE	protected 
/** * Returns the GVTFont to use when rendering the specified * character iterator. This should already be set as an attribute * on the aci. * * @return The GVTFont to use. */	TokenNameCOMMENT_JAVADOC	 Returns the GVTFont to use when rendering the specified character iterator. This should already be set as an attribute on the aci. * @return The GVTFont to use. 
protected	TokenNameprotected	
GVTFont	TokenNameIdentifier	 GVT Font
getFont	TokenNameIdentifier	 get Font
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
first	TokenNameIdentifier	 first
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
GVTFont	TokenNameIdentifier	 GVT Font
gvtFont	TokenNameIdentifier	 gvt Font
=	TokenNameEQUAL	
(	TokenNameLPAREN	
GVTFont	TokenNameIdentifier	 GVT Font
)	TokenNameRPAREN	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
GVT_FONT	TokenNameIdentifier	 GVT  FONT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
gvtFont	TokenNameIdentifier	 gvt Font
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
gvtFont	TokenNameIdentifier	 gvt Font
;	TokenNameSEMICOLON	
// shouldn't get here 	TokenNameCOMMENT_LINE	shouldn't get here 
return	TokenNamereturn	
new	TokenNamenew	
AWTGVTFont	TokenNameIdentifier	 AWTGVT Font
(	TokenNameLPAREN	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
getAttributes	TokenNameIdentifier	 get Attributes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns a shape describing the overline decoration for a given ACI. */	TokenNameCOMMENT_JAVADOC	 Returns a shape describing the overline decoration for a given ACI. 
protected	TokenNameprotected	
Shape	TokenNameIdentifier	 Shape
getOverlineShape	TokenNameIdentifier	 get Overline Shape
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
double	TokenNamedouble	
y	TokenNameIdentifier	 y
=	TokenNameEQUAL	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
getOverlineOffset	TokenNameIdentifier	 get Overline Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
overlineThickness	TokenNameIdentifier	 overline Thickness
=	TokenNameEQUAL	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
getOverlineThickness	TokenNameIdentifier	 get Overline Thickness
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// need to move the overline a bit lower, 	TokenNameCOMMENT_LINE	need to move the overline a bit lower, 
// not sure if this is correct behaviour or not 	TokenNameCOMMENT_LINE	not sure if this is correct behaviour or not 
y	TokenNameIdentifier	 y
+=	TokenNamePLUS_EQUAL	
overlineThickness	TokenNameIdentifier	 overline Thickness
;	TokenNameSEMICOLON	
// Not certain what should be done here... 	TokenNameCOMMENT_LINE	Not certain what should be done here... 
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
first	TokenNameIdentifier	 first
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Float	TokenNameIdentifier	 Float
dy	TokenNameIdentifier	 dy
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Float	TokenNameIdentifier	 Float
)	TokenNameRPAREN	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
DY	TokenNameIdentifier	 DY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dy	TokenNameIdentifier	 dy
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
y	TokenNameIdentifier	 y
+=	TokenNamePLUS_EQUAL	
dy	TokenNameIdentifier	 dy
.	TokenNameDOT	
floatValue	TokenNameIdentifier	 float Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Stroke	TokenNameIdentifier	 Stroke
overlineStroke	TokenNameIdentifier	 overline Stroke
=	TokenNameEQUAL	
new	TokenNamenew	
BasicStroke	TokenNameIdentifier	 Basic Stroke
(	TokenNameLPAREN	
overlineThickness	TokenNameIdentifier	 overline Thickness
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
logicalBounds	TokenNameIdentifier	 logical Bounds
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getLogicalBounds	TokenNameIdentifier	 get Logical Bounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
overlineStroke	TokenNameIdentifier	 overline Stroke
.	TokenNameDOT	
createStrokedShape	TokenNameIdentifier	 create Stroked Shape
(	TokenNameLPAREN	
new	TokenNamenew	
Line2D	TokenNameIdentifier	 Line2 D
.	TokenNameDOT	
Double	TokenNameIdentifier	 Double
(	TokenNameLPAREN	
logicalBounds	TokenNameIdentifier	 logical Bounds
.	TokenNameDOT	
getMinX	TokenNameIdentifier	 get Min X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
overlineThickness	TokenNameIdentifier	 overline Thickness
/	TokenNameDIVIDE	
2.0	TokenNameDoubleLiteral	
,	TokenNameCOMMA	
offset	TokenNameIdentifier	 offset
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
y	TokenNameIdentifier	 y
,	TokenNameCOMMA	
logicalBounds	TokenNameIdentifier	 logical Bounds
.	TokenNameDOT	
getMaxX	TokenNameIdentifier	 get Max X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
overlineThickness	TokenNameIdentifier	 overline Thickness
/	TokenNameDIVIDE	
2.0	TokenNameDoubleLiteral	
,	TokenNameCOMMA	
offset	TokenNameIdentifier	 offset
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns a shape describing the undeline decoration for a given ACI. */	TokenNameCOMMENT_JAVADOC	 Returns a shape describing the undeline decoration for a given ACI. 
protected	TokenNameprotected	
Shape	TokenNameIdentifier	 Shape
getUnderlineShape	TokenNameIdentifier	 get Underline Shape
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
double	TokenNamedouble	
y	TokenNameIdentifier	 y
=	TokenNameEQUAL	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
getUnderlineOffset	TokenNameIdentifier	 get Underline Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
underlineThickness	TokenNameIdentifier	 underline Thickness
=	TokenNameEQUAL	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
getUnderlineThickness	TokenNameIdentifier	 get Underline Thickness
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// need to move the underline a bit lower, 	TokenNameCOMMENT_LINE	need to move the underline a bit lower, 
// not sure if this is correct behaviour or not 	TokenNameCOMMENT_LINE	not sure if this is correct behaviour or not 
y	TokenNameIdentifier	 y
+=	TokenNamePLUS_EQUAL	
underlineThickness	TokenNameIdentifier	 underline Thickness
*	TokenNameMULTIPLY	
1.5	TokenNameDoubleLiteral	
;	TokenNameSEMICOLON	
BasicStroke	TokenNameIdentifier	 Basic Stroke
underlineStroke	TokenNameIdentifier	 underline Stroke
=	TokenNameEQUAL	
new	TokenNamenew	
BasicStroke	TokenNameIdentifier	 Basic Stroke
(	TokenNameLPAREN	
underlineThickness	TokenNameIdentifier	 underline Thickness
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Not certain what should be done here... 	TokenNameCOMMENT_LINE	Not certain what should be done here... 
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
first	TokenNameIdentifier	 first
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Float	TokenNameIdentifier	 Float
dy	TokenNameIdentifier	 dy
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Float	TokenNameIdentifier	 Float
)	TokenNameRPAREN	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
DY	TokenNameIdentifier	 DY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dy	TokenNameIdentifier	 dy
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
y	TokenNameIdentifier	 y
+=	TokenNamePLUS_EQUAL	
dy	TokenNameIdentifier	 dy
.	TokenNameDOT	
floatValue	TokenNameIdentifier	 float Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
logicalBounds	TokenNameIdentifier	 logical Bounds
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getLogicalBounds	TokenNameIdentifier	 get Logical Bounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
underlineStroke	TokenNameIdentifier	 underline Stroke
.	TokenNameDOT	
createStrokedShape	TokenNameIdentifier	 create Stroked Shape
(	TokenNameLPAREN	
new	TokenNamenew	
Line2D	TokenNameIdentifier	 Line2 D
.	TokenNameDOT	
Double	TokenNameIdentifier	 Double
(	TokenNameLPAREN	
logicalBounds	TokenNameIdentifier	 logical Bounds
.	TokenNameDOT	
getMinX	TokenNameIdentifier	 get Min X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
underlineThickness	TokenNameIdentifier	 underline Thickness
/	TokenNameDIVIDE	
2.0	TokenNameDoubleLiteral	
,	TokenNameCOMMA	
offset	TokenNameIdentifier	 offset
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
y	TokenNameIdentifier	 y
,	TokenNameCOMMA	
logicalBounds	TokenNameIdentifier	 logical Bounds
.	TokenNameDOT	
getMaxX	TokenNameIdentifier	 get Max X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
underlineThickness	TokenNameIdentifier	 underline Thickness
/	TokenNameDIVIDE	
2.0	TokenNameDoubleLiteral	
,	TokenNameCOMMA	
offset	TokenNameIdentifier	 offset
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns a shape describing the strikethrough line for a given ACI. */	TokenNameCOMMENT_JAVADOC	 Returns a shape describing the strikethrough line for a given ACI. 
protected	TokenNameprotected	
Shape	TokenNameIdentifier	 Shape
getStrikethroughShape	TokenNameIdentifier	 get Strikethrough Shape
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
double	TokenNamedouble	
y	TokenNameIdentifier	 y
=	TokenNameEQUAL	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
getStrikethroughOffset	TokenNameIdentifier	 get Strikethrough Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
strikethroughThickness	TokenNameIdentifier	 strikethrough Thickness
=	TokenNameEQUAL	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
getStrikethroughThickness	TokenNameIdentifier	 get Strikethrough Thickness
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Stroke	TokenNameIdentifier	 Stroke
strikethroughStroke	TokenNameIdentifier	 strikethrough Stroke
=	TokenNameEQUAL	
new	TokenNamenew	
BasicStroke	TokenNameIdentifier	 Basic Stroke
(	TokenNameLPAREN	
strikethroughThickness	TokenNameIdentifier	 strikethrough Thickness
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Not certain what should be done here... 	TokenNameCOMMENT_LINE	Not certain what should be done here... 
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
first	TokenNameIdentifier	 first
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Float	TokenNameIdentifier	 Float
dy	TokenNameIdentifier	 dy
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Float	TokenNameIdentifier	 Float
)	TokenNameRPAREN	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
DY	TokenNameIdentifier	 DY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dy	TokenNameIdentifier	 dy
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
y	TokenNameIdentifier	 y
+=	TokenNamePLUS_EQUAL	
dy	TokenNameIdentifier	 dy
.	TokenNameDOT	
floatValue	TokenNameIdentifier	 float Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
logicalBounds	TokenNameIdentifier	 logical Bounds
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getLogicalBounds	TokenNameIdentifier	 get Logical Bounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
strikethroughStroke	TokenNameIdentifier	 strikethrough Stroke
.	TokenNameDOT	
createStrokedShape	TokenNameIdentifier	 create Stroked Shape
(	TokenNameLPAREN	
new	TokenNamenew	
Line2D	TokenNameIdentifier	 Line2 D
.	TokenNameDOT	
Double	TokenNameIdentifier	 Double
(	TokenNameLPAREN	
logicalBounds	TokenNameIdentifier	 logical Bounds
.	TokenNameDOT	
getMinX	TokenNameIdentifier	 get Min X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
strikethroughThickness	TokenNameIdentifier	 strikethrough Thickness
/	TokenNameDIVIDE	
2.0	TokenNameDoubleLiteral	
,	TokenNameCOMMA	
offset	TokenNameIdentifier	 offset
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
y	TokenNameIdentifier	 y
,	TokenNameCOMMA	
logicalBounds	TokenNameIdentifier	 logical Bounds
.	TokenNameDOT	
getMaxX	TokenNameIdentifier	 get Max X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
strikethroughThickness	TokenNameIdentifier	 strikethrough Thickness
/	TokenNameDIVIDE	
2.0	TokenNameDoubleLiteral	
,	TokenNameCOMMA	
offset	TokenNameIdentifier	 offset
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Explicitly lays out each of the glyphs in the glyph * vector. This will handle any glyph position adjustments such as * dx, dy and baseline offsets. It will also handle vertical * layouts. */	TokenNameCOMMENT_JAVADOC	 Explicitly lays out each of the glyphs in the glyph vector. This will handle any glyph position adjustments such as dx, dy and baseline offsets. It will also handle vertical layouts. 
protected	TokenNameprotected	
void	TokenNamevoid	
doExplicitGlyphLayout	TokenNameIdentifier	 do Explicit Glyph Layout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
performDefaultLayout	TokenNameIdentifier	 perform Default Layout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
baselineAscent	TokenNameIdentifier	 baseline Ascent
=	TokenNameEQUAL	
vertical	TokenNameIdentifier	 vertical
?	TokenNameQUESTION	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getLogicalBounds	TokenNameIdentifier	 get Logical Bounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
(	TokenNameLPAREN	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
getAscent	TokenNameIdentifier	 get Ascent
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
abs	TokenNameIdentifier	 abs
(	TokenNameLPAREN	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
getDescent	TokenNameIdentifier	 get Descent
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
numGlyphs	TokenNameIdentifier	 num Glyphs
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getNumGlyphs	TokenNameIdentifier	 get Num Glyphs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// System.out.println("NumGlyphs: " + numGlyphs); 	TokenNameCOMMENT_LINE	System.out.println("NumGlyphs: " + numGlyphs); 
float	TokenNamefloat	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
gp	TokenNameIdentifier	 gp
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphPositions	TokenNameIdentifier	 get Glyph Positions
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
numGlyphs	TokenNameIdentifier	 num Glyphs
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
verticalFirstOffset	TokenNameIdentifier	 vertical First Offset
=	TokenNameEQUAL	
0f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
horizontalFirstOffset	TokenNameIdentifier	 horizontal First Offset
=	TokenNameEQUAL	
0f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
glyphOrientationAuto	TokenNameIdentifier	 glyph Orientation Auto
=	TokenNameEQUAL	
isGlyphOrientationAuto	TokenNameIdentifier	 is Glyph Orientation Auto
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
glyphOrientationAuto	TokenNameIdentifier	 glyph Orientation Auto
)	TokenNameRPAREN	
{	TokenNameLBRACE	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
=	TokenNameEQUAL	
getGlyphOrientationAngle	TokenNameIdentifier	 get Glyph Orientation Angle
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
aciStart	TokenNameIdentifier	 aci Start
=	TokenNameEQUAL	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
getBeginIndex	TokenNameIdentifier	 get Begin Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
aciIndex	TokenNameIdentifier	 aci Index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
char	TokenNamechar	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
first	TokenNameIdentifier	 first
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
runLimit	TokenNameIdentifier	 run Limit
=	TokenNameEQUAL	
aciIndex	TokenNameIdentifier	 aci Index
+	TokenNamePLUS	
aciStart	TokenNameIdentifier	 aci Start
;	TokenNameSEMICOLON	
Float	TokenNameIdentifier	 Float
x	TokenNameIdentifier	 x
=	TokenNameEQUAL	
null	TokenNamenull	
,	TokenNameCOMMA	
y	TokenNameIdentifier	 y
=	TokenNameEQUAL	
null	TokenNamenull	
,	TokenNameCOMMA	
dx	TokenNameIdentifier	 dx
=	TokenNameEQUAL	
null	TokenNamenull	
,	TokenNameCOMMA	
dy	TokenNameIdentifier	 dy
=	TokenNameEQUAL	
null	TokenNamenull	
,	TokenNameCOMMA	
rotation	TokenNameIdentifier	 rotation
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
Object	TokenNameIdentifier	 Object
baseline	TokenNameIdentifier	 baseline
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
shift_x_pos	TokenNameIdentifier	 shift x pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
shift_y_pos	TokenNameIdentifier	 shift y pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
curr_x_pos	TokenNameIdentifier	 curr x pos
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
offset	TokenNameIdentifier	 offset
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
curr_y_pos	TokenNameIdentifier	 curr y pos
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
offset	TokenNameIdentifier	 offset
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
hasArabicTransparent	TokenNameIdentifier	 has Arabic Transparent
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numGlyphs	TokenNameIdentifier	 num Glyphs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println("limit: " + runLimit + ", " + aciIndex); 	TokenNameCOMMENT_LINE	System.out.println("limit: " + runLimit + ", " + aciIndex); 
if	TokenNameif	
(	TokenNameLPAREN	
aciIndex	TokenNameIdentifier	 aci Index
+	TokenNamePLUS	
aciStart	TokenNameIdentifier	 aci Start
>=	TokenNameGREATER_EQUAL	
runLimit	TokenNameIdentifier	 run Limit
)	TokenNameRPAREN	
{	TokenNameLBRACE	
runLimit	TokenNameIdentifier	 run Limit
=	TokenNameEQUAL	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
getRunLimit	TokenNameIdentifier	 get Run Limit
(	TokenNameLPAREN	
runAtts	TokenNameIdentifier	 run Atts
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
x	TokenNameIdentifier	 x
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Float	TokenNameIdentifier	 Float
)	TokenNameRPAREN	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
X	TokenNameIdentifier	 X
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
y	TokenNameIdentifier	 y
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Float	TokenNameIdentifier	 Float
)	TokenNameRPAREN	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
Y	TokenNameIdentifier	 Y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dx	TokenNameIdentifier	 dx
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Float	TokenNameIdentifier	 Float
)	TokenNameRPAREN	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
DX	TokenNameIdentifier	 DX
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dy	TokenNameIdentifier	 dy
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Float	TokenNameIdentifier	 Float
)	TokenNameRPAREN	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
DY	TokenNameIdentifier	 DY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rotation	TokenNameIdentifier	 rotation
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Float	TokenNameIdentifier	 Float
)	TokenNameRPAREN	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
ROTATION	TokenNameIdentifier	 ROTATION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
baseline	TokenNameIdentifier	 baseline
=	TokenNameEQUAL	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
BASELINE_SHIFT	TokenNameIdentifier	 BASELINE  SHIFT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
GVTGlyphMetrics	TokenNameIdentifier	 GVT Glyph Metrics
gm	TokenNameIdentifier	 gm
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphMetrics	TokenNameIdentifier	 get Glyph Metrics
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isVertical	TokenNameIdentifier	 is Vertical
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
glyphOrientationAuto	TokenNameIdentifier	 glyph Orientation Auto
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isLatinChar	TokenNameIdentifier	 is Latin Char
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// it will be rotated 90 	TokenNameCOMMENT_LINE	it will be rotated 90 
verticalFirstOffset	TokenNameIdentifier	 vertical First Offset
=	TokenNameEQUAL	
0f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// it won't be rotated 	TokenNameCOMMENT_LINE	it won't be rotated 
float	TokenNamefloat	
advY	TokenNameIdentifier	 adv Y
=	TokenNameEQUAL	
gm	TokenNameIdentifier	 gm
.	TokenNameDOT	
getVerticalAdvance	TokenNameIdentifier	 get Vertical Advance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
asc	TokenNameIdentifier	 asc
=	TokenNameEQUAL	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
getAscent	TokenNameIdentifier	 get Ascent
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
dsc	TokenNameIdentifier	 dsc
=	TokenNameEQUAL	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
getDescent	TokenNameIdentifier	 get Descent
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
verticalFirstOffset	TokenNameIdentifier	 vertical First Offset
=	TokenNameEQUAL	
asc	TokenNameIdentifier	 asc
+	TokenNamePLUS	
(	TokenNameLPAREN	
advY	TokenNameIdentifier	 adv Y
-	TokenNameMINUS	
(	TokenNameLPAREN	
asc	TokenNameIdentifier	 asc
+	TokenNamePLUS	
dsc	TokenNameIdentifier	 dsc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
float	TokenNamefloat	
advY	TokenNameIdentifier	 adv Y
=	TokenNameEQUAL	
gm	TokenNameIdentifier	 gm
.	TokenNameDOT	
getVerticalAdvance	TokenNameIdentifier	 get Vertical Advance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
asc	TokenNameIdentifier	 asc
=	TokenNameEQUAL	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
getAscent	TokenNameIdentifier	 get Ascent
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
dsc	TokenNameIdentifier	 dsc
=	TokenNameEQUAL	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
getDescent	TokenNameIdentifier	 get Descent
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
verticalFirstOffset	TokenNameIdentifier	 vertical First Offset
=	TokenNameEQUAL	
asc	TokenNameIdentifier	 asc
+	TokenNamePLUS	
(	TokenNameLPAREN	
advY	TokenNameIdentifier	 adv Y
-	TokenNameMINUS	
(	TokenNameLPAREN	
asc	TokenNameIdentifier	 asc
+	TokenNamePLUS	
dsc	TokenNameIdentifier	 dsc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// 90, 180, 270 	TokenNameCOMMENT_LINE	90, 180, 270 
verticalFirstOffset	TokenNameIdentifier	 vertical First Offset
=	TokenNameEQUAL	
0f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// not vertical 	TokenNameCOMMENT_LINE	not vertical 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
==	TokenNameEQUAL_EQUAL	
270	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
horizontalFirstOffset	TokenNameIdentifier	 horizontal First Offset
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
gm	TokenNameIdentifier	 gm
.	TokenNameDOT	
getBounds2D	TokenNameIdentifier	 get Bounds2 D
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// 0, 90, 180 	TokenNameCOMMENT_LINE	0, 90, 180 
horizontalFirstOffset	TokenNameIdentifier	 horizontal First Offset
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// not the first char 	TokenNameCOMMENT_LINE	not the first char 
if	TokenNameif	
(	TokenNameLPAREN	
glyphOrientationAuto	TokenNameIdentifier	 glyph Orientation Auto
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
verticalFirstOffset	TokenNameIdentifier	 vertical First Offset
==	TokenNameEQUAL_EQUAL	
0f	TokenNameFloatingPointLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
isLatinChar	TokenNameIdentifier	 is Latin Char
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
float	TokenNamefloat	
advY	TokenNameIdentifier	 adv Y
=	TokenNameEQUAL	
gm	TokenNameIdentifier	 gm
.	TokenNameDOT	
getVerticalAdvance	TokenNameIdentifier	 get Vertical Advance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
asc	TokenNameIdentifier	 asc
=	TokenNameEQUAL	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
getAscent	TokenNameIdentifier	 get Ascent
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
dsc	TokenNameIdentifier	 dsc
=	TokenNameEQUAL	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
getDescent	TokenNameIdentifier	 get Descent
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
verticalFirstOffset	TokenNameIdentifier	 vertical First Offset
=	TokenNameEQUAL	
asc	TokenNameIdentifier	 asc
+	TokenNamePLUS	
(	TokenNameLPAREN	
advY	TokenNameIdentifier	 adv Y
-	TokenNameMINUS	
(	TokenNameLPAREN	
asc	TokenNameIdentifier	 asc
+	TokenNamePLUS	
dsc	TokenNameIdentifier	 dsc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// ox and oy are origin adjustments for each glyph, 	TokenNameCOMMENT_LINE	ox and oy are origin adjustments for each glyph, 
// computed on the basis of baseline-shifts, etc. 	TokenNameCOMMENT_LINE	computed on the basis of baseline-shifts, etc. 
float	TokenNamefloat	
ox	TokenNameIdentifier	 ox
=	TokenNameEQUAL	
0f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
oy	TokenNameIdentifier	 oy
=	TokenNameEQUAL	
0f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
glyphOrientationRotation	TokenNameIdentifier	 glyph Orientation Rotation
=	TokenNameEQUAL	
0f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
glyphRotation	TokenNameIdentifier	 glyph Rotation
=	TokenNameEQUAL	
0f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
!=	TokenNameNOT_EQUAL	
CharacterIterator	TokenNameIdentifier	 Character Iterator
.	TokenNameDOT	
DONE	TokenNameIdentifier	 DONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
vertical	TokenNameIdentifier	 vertical
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
glyphOrientationAuto	TokenNameIdentifier	 glyph Orientation Auto
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isLatinChar	TokenNameIdentifier	 is Latin Char
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If character is Latin, then rotate by 	TokenNameCOMMENT_LINE	If character is Latin, then rotate by 
// 90 degrees 	TokenNameCOMMENT_LINE	90 degrees 
glyphOrientationRotation	TokenNameIdentifier	 glyph Orientation Rotation
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
PI	TokenNameIdentifier	 PI
/	TokenNameDIVIDE	
2f	TokenNameFloatingPointLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
glyphOrientationRotation	TokenNameIdentifier	 glyph Orientation Rotation
=	TokenNameEQUAL	
0f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
glyphOrientationRotation	TokenNameIdentifier	 glyph Orientation Rotation
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
toRadians	TokenNameIdentifier	 to Radians
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
textPath	TokenNameIdentifier	 text Path
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if vertical and on a path, any x's are ignored 	TokenNameCOMMENT_LINE	if vertical and on a path, any x's are ignored 
x	TokenNameIdentifier	 x
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
glyphOrientationRotation	TokenNameIdentifier	 glyph Orientation Rotation
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
toRadians	TokenNameIdentifier	 to Radians
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
textPath	TokenNameIdentifier	 text Path
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if horizontal and on a path, any y's are ignored 	TokenNameCOMMENT_LINE	if horizontal and on a path, any y's are ignored 
y	TokenNameIdentifier	 y
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// calculate the total rotation for this glyph 	TokenNameCOMMENT_LINE	calculate the total rotation for this glyph 
if	TokenNameif	
(	TokenNameLPAREN	
rotation	TokenNameIdentifier	 rotation
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
rotation	TokenNameIdentifier	 rotation
.	TokenNameDOT	
isNaN	TokenNameIdentifier	 is Na N
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
glyphRotation	TokenNameIdentifier	 glyph Rotation
=	TokenNameEQUAL	
glyphOrientationRotation	TokenNameIdentifier	 glyph Orientation Rotation
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
glyphRotation	TokenNameIdentifier	 glyph Rotation
=	TokenNameEQUAL	
(	TokenNameLPAREN	
rotation	TokenNameIdentifier	 rotation
.	TokenNameDOT	
floatValue	TokenNameIdentifier	 float Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
glyphOrientationRotation	TokenNameIdentifier	 glyph Orientation Rotation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
x	TokenNameIdentifier	 x
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
x	TokenNameIdentifier	 x
.	TokenNameDOT	
isNaN	TokenNameIdentifier	 is Na N
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
shift_x_pos	TokenNameIdentifier	 shift x pos
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
x	TokenNameIdentifier	 x
.	TokenNameDOT	
floatValue	TokenNameIdentifier	 float Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
offset	TokenNameIdentifier	 offset
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
curr_x_pos	TokenNameIdentifier	 curr x pos
=	TokenNameEQUAL	
x	TokenNameIdentifier	 x
.	TokenNameDOT	
floatValue	TokenNameIdentifier	 float Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
shift_x_pos	TokenNameIdentifier	 shift x pos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
dx	TokenNameIdentifier	 dx
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
dx	TokenNameIdentifier	 dx
.	TokenNameDOT	
isNaN	TokenNameIdentifier	 is Na N
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
curr_x_pos	TokenNameIdentifier	 curr x pos
+=	TokenNamePLUS_EQUAL	
dx	TokenNameIdentifier	 dx
.	TokenNameDOT	
floatValue	TokenNameIdentifier	 float Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
y	TokenNameIdentifier	 y
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
y	TokenNameIdentifier	 y
.	TokenNameDOT	
isNaN	TokenNameIdentifier	 is Na N
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
shift_y_pos	TokenNameIdentifier	 shift y pos
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
y	TokenNameIdentifier	 y
.	TokenNameDOT	
floatValue	TokenNameIdentifier	 float Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
offset	TokenNameIdentifier	 offset
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
curr_y_pos	TokenNameIdentifier	 curr y pos
=	TokenNameEQUAL	
y	TokenNameIdentifier	 y
.	TokenNameDOT	
floatValue	TokenNameIdentifier	 float Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
shift_y_pos	TokenNameIdentifier	 shift y pos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
dy	TokenNameIdentifier	 dy
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
dy	TokenNameIdentifier	 dy
.	TokenNameDOT	
isNaN	TokenNameIdentifier	 is Na N
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
curr_y_pos	TokenNameIdentifier	 curr y pos
+=	TokenNamePLUS_EQUAL	
dy	TokenNameIdentifier	 dy
.	TokenNameDOT	
floatValue	TokenNameIdentifier	 float Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
curr_y_pos	TokenNameIdentifier	 curr y pos
+=	TokenNamePLUS_EQUAL	
gp	TokenNameIdentifier	 gp
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
-	TokenNameMINUS	
gp	TokenNameIdentifier	 gp
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
float	TokenNamefloat	
baselineAdjust	TokenNameIdentifier	 baseline Adjust
=	TokenNameEQUAL	
0f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
baseline	TokenNameIdentifier	 baseline
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
baseline	TokenNameIdentifier	 baseline
instanceof	TokenNameinstanceof	
Integer	TokenNameIdentifier	 Integer
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
baseline	TokenNameIdentifier	 baseline
==	TokenNameEQUAL_EQUAL	
TextAttribute	TokenNameIdentifier	 Text Attribute
.	TokenNameDOT	
SUPERSCRIPT_SUPER	TokenNameIdentifier	 SUPERSCRIPT  SUPER
)	TokenNameRPAREN	
{	TokenNameLBRACE	
baselineAdjust	TokenNameIdentifier	 baseline Adjust
=	TokenNameEQUAL	
baselineAscent	TokenNameIdentifier	 baseline Ascent
*	TokenNameMULTIPLY	
0.5f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
baseline	TokenNameIdentifier	 baseline
==	TokenNameEQUAL_EQUAL	
TextAttribute	TokenNameIdentifier	 Text Attribute
.	TokenNameDOT	
SUPERSCRIPT_SUB	TokenNameIdentifier	 SUPERSCRIPT  SUB
)	TokenNameRPAREN	
{	TokenNameLBRACE	
baselineAdjust	TokenNameIdentifier	 baseline Adjust
=	TokenNameEQUAL	
-	TokenNameMINUS	
baselineAscent	TokenNameIdentifier	 baseline Ascent
*	TokenNameMULTIPLY	
0.5f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
baseline	TokenNameIdentifier	 baseline
instanceof	TokenNameinstanceof	
Float	TokenNameIdentifier	 Float
)	TokenNameRPAREN	
{	TokenNameLBRACE	
baselineAdjust	TokenNameIdentifier	 baseline Adjust
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Float	TokenNameIdentifier	 Float
)	TokenNameRPAREN	
baseline	TokenNameIdentifier	 baseline
)	TokenNameRPAREN	
.	TokenNameDOT	
floatValue	TokenNameIdentifier	 float Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
vertical	TokenNameIdentifier	 vertical
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ox	TokenNameIdentifier	 ox
=	TokenNameEQUAL	
baselineAdjust	TokenNameIdentifier	 baseline Adjust
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
oy	TokenNameIdentifier	 oy
=	TokenNameEQUAL	
-	TokenNameMINUS	
baselineAdjust	TokenNameIdentifier	 baseline Adjust
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
vertical	TokenNameIdentifier	 vertical
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// offset due to rotation of first character 	TokenNameCOMMENT_LINE	offset due to rotation of first character 
oy	TokenNameIdentifier	 oy
+=	TokenNamePLUS_EQUAL	
verticalFirstOffset	TokenNameIdentifier	 vertical First Offset
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
glyphOrientationAuto	TokenNameIdentifier	 glyph Orientation Auto
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isLatinChar	TokenNameIdentifier	 is Latin Char
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ox	TokenNameIdentifier	 ox
+=	TokenNamePLUS_EQUAL	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
getStrikethroughOffset	TokenNameIdentifier	 get Strikethrough Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
glyphBounds	TokenNameIdentifier	 glyph Bounds
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphVisualBounds	TokenNameIdentifier	 get Glyph Visual Bounds
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
.	TokenNameDOT	
getBounds2D	TokenNameIdentifier	 get Bounds2 D
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ox	TokenNameIdentifier	 ox
-=	TokenNameMINUS_EQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
glyphBounds	TokenNameIdentifier	 glyph Bounds
.	TokenNameDOT	
getMaxX	TokenNameIdentifier	 get Max X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
gp	TokenNameIdentifier	 gp
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
-	TokenNameMINUS	
glyphBounds	TokenNameIdentifier	 glyph Bounds
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// center the character if it's not auto orient 	TokenNameCOMMENT_LINE	center the character if it's not auto orient 
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
glyphBounds	TokenNameIdentifier	 glyph Bounds
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphVisualBounds	TokenNameIdentifier	 get Glyph Visual Bounds
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
.	TokenNameDOT	
getBounds2D	TokenNameIdentifier	 get Bounds2 D
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ox	TokenNameIdentifier	 ox
-=	TokenNameMINUS_EQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
glyphBounds	TokenNameIdentifier	 glyph Bounds
.	TokenNameDOT	
getMaxX	TokenNameIdentifier	 get Max X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
gp	TokenNameIdentifier	 gp
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
-	TokenNameMINUS	
glyphBounds	TokenNameIdentifier	 glyph Bounds
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
==	TokenNameEQUAL_EQUAL	
180	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ox	TokenNameIdentifier	 ox
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
glyphBounds	TokenNameIdentifier	 glyph Bounds
.	TokenNameDOT	
getMaxX	TokenNameIdentifier	 get Max X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
gp	TokenNameIdentifier	 gp
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
-	TokenNameMINUS	
glyphBounds	TokenNameIdentifier	 glyph Bounds
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
==	TokenNameEQUAL_EQUAL	
90	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ox	TokenNameIdentifier	 ox
+=	TokenNamePLUS_EQUAL	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
getStrikethroughOffset	TokenNameIdentifier	 get Strikethrough Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// 270 	TokenNameCOMMENT_LINE	270 
ox	TokenNameIdentifier	 ox
-=	TokenNameMINUS_EQUAL	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
getStrikethroughOffset	TokenNameIdentifier	 get Strikethrough Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
ox	TokenNameIdentifier	 ox
+=	TokenNamePLUS_EQUAL	
horizontalFirstOffset	TokenNameIdentifier	 horizontal First Offset
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
==	TokenNameEQUAL_EQUAL	
90	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
oy	TokenNameIdentifier	 oy
-=	TokenNameMINUS_EQUAL	
gm	TokenNameIdentifier	 gm
.	TokenNameDOT	
getHorizontalAdvance	TokenNameIdentifier	 get Horizontal Advance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
==	TokenNameEQUAL_EQUAL	
180	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
oy	TokenNameIdentifier	 oy
-=	TokenNameMINUS_EQUAL	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
getAscent	TokenNameIdentifier	 get Ascent
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// set the new glyph position 	TokenNameCOMMENT_LINE	set the new glyph position 
pos	TokenNameIdentifier	 pos
.	TokenNameDOT	
x	TokenNameIdentifier	 x
=	TokenNameEQUAL	
curr_x_pos	TokenNameIdentifier	 curr x pos
+	TokenNamePLUS	
ox	TokenNameIdentifier	 ox
;	TokenNameSEMICOLON	
pos	TokenNameIdentifier	 pos
.	TokenNameDOT	
y	TokenNameIdentifier	 y
=	TokenNameEQUAL	
curr_y_pos	TokenNameIdentifier	 curr y pos
+	TokenNamePLUS	
oy	TokenNameIdentifier	 oy
;	TokenNameSEMICOLON	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
setGlyphPosition	TokenNameIdentifier	 set Glyph Position
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// calculate the position of the next glyph 	TokenNameCOMMENT_LINE	calculate the position of the next glyph 
if	TokenNameif	
(	TokenNameLPAREN	
ArabicTextHandler	TokenNameIdentifier	 Arabic Text Handler
.	TokenNameDOT	
arabicCharTransparent	TokenNameIdentifier	 arabic Char Transparent
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
hasArabicTransparent	TokenNameIdentifier	 has Arabic Transparent
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Apply the advance if the current char is not transparent 	TokenNameCOMMENT_LINE	Apply the advance if the current char is not transparent 
if	TokenNameif	
(	TokenNameLPAREN	
vertical	TokenNameIdentifier	 vertical
)	TokenNameRPAREN	
{	TokenNameLBRACE	
float	TokenNamefloat	
advanceY	TokenNameIdentifier	 advance Y
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
glyphOrientationAuto	TokenNameIdentifier	 glyph Orientation Auto
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isLatinChar	TokenNameIdentifier	 is Latin Char
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
advanceY	TokenNameIdentifier	 advance Y
=	TokenNameEQUAL	
gm	TokenNameIdentifier	 gm
.	TokenNameDOT	
getHorizontalAdvance	TokenNameIdentifier	 get Horizontal Advance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
advanceY	TokenNameIdentifier	 advance Y
=	TokenNameEQUAL	
gm	TokenNameIdentifier	 gm
.	TokenNameDOT	
getVerticalAdvance	TokenNameIdentifier	 get Vertical Advance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
==	TokenNameEQUAL_EQUAL	
180	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
advanceY	TokenNameIdentifier	 advance Y
=	TokenNameEQUAL	
gm	TokenNameIdentifier	 gm
.	TokenNameDOT	
getVerticalAdvance	TokenNameIdentifier	 get Vertical Advance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
==	TokenNameEQUAL_EQUAL	
90	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
advanceY	TokenNameIdentifier	 advance Y
=	TokenNameEQUAL	
gm	TokenNameIdentifier	 gm
.	TokenNameDOT	
getHorizontalAdvance	TokenNameIdentifier	 get Horizontal Advance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// 270 	TokenNameCOMMENT_LINE	270 
advanceY	TokenNameIdentifier	 advance Y
=	TokenNameEQUAL	
gm	TokenNameIdentifier	 gm
.	TokenNameDOT	
getHorizontalAdvance	TokenNameIdentifier	 get Horizontal Advance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// need to translate so that the spacing 	TokenNameCOMMENT_LINE	need to translate so that the spacing 
// between chars is correct 	TokenNameCOMMENT_LINE	between chars is correct 
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
setGlyphTransform	TokenNameIdentifier	 set Glyph Transform
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
AffineTransform	TokenNameIdentifier	 Affine Transform
.	TokenNameDOT	
getTranslateInstance	TokenNameIdentifier	 get Translate Instance
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
advanceY	TokenNameIdentifier	 advance Y
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
curr_y_pos	TokenNameIdentifier	 curr y pos
+=	TokenNamePLUS_EQUAL	
advanceY	TokenNameIdentifier	 advance Y
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
float	TokenNamefloat	
advanceX	TokenNameIdentifier	 advance X
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
advanceX	TokenNameIdentifier	 advance X
=	TokenNameEQUAL	
gm	TokenNameIdentifier	 gm
.	TokenNameDOT	
getHorizontalAdvance	TokenNameIdentifier	 get Horizontal Advance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
==	TokenNameEQUAL_EQUAL	
180	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
advanceX	TokenNameIdentifier	 advance X
=	TokenNameEQUAL	
gm	TokenNameIdentifier	 gm
.	TokenNameDOT	
getHorizontalAdvance	TokenNameIdentifier	 get Horizontal Advance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// need to translate so that the spacing 	TokenNameCOMMENT_LINE	need to translate so that the spacing 
// between chars is correct 	TokenNameCOMMENT_LINE	between chars is correct 
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
setGlyphTransform	TokenNameIdentifier	 set Glyph Transform
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
AffineTransform	TokenNameIdentifier	 Affine Transform
.	TokenNameDOT	
getTranslateInstance	TokenNameIdentifier	 get Translate Instance
(	TokenNameLPAREN	
advanceX	TokenNameIdentifier	 advance X
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// 90, 270 	TokenNameCOMMENT_LINE	90, 270 
advanceX	TokenNameIdentifier	 advance X
=	TokenNameEQUAL	
gm	TokenNameIdentifier	 gm
.	TokenNameDOT	
getVerticalAdvance	TokenNameIdentifier	 get Vertical Advance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
curr_x_pos	TokenNameIdentifier	 curr x pos
+=	TokenNamePLUS_EQUAL	
advanceX	TokenNameIdentifier	 advance X
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// rotate the glyph 	TokenNameCOMMENT_LINE	rotate the glyph 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
epsEQ	TokenNameIdentifier	 eps EQ
(	TokenNameLPAREN	
glyphRotation	TokenNameIdentifier	 glyph Rotation
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
AffineTransform	TokenNameIdentifier	 Affine Transform
glyphTransform	TokenNameIdentifier	 glyph Transform
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphTransform	TokenNameIdentifier	 get Glyph Transform
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
glyphTransform	TokenNameIdentifier	 glyph Transform
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
glyphTransform	TokenNameIdentifier	 glyph Transform
=	TokenNameEQUAL	
new	TokenNamenew	
AffineTransform	TokenNameIdentifier	 Affine Transform
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
AffineTransform	TokenNameIdentifier	 Affine Transform
rotAt	TokenNameIdentifier	 rot At
;	TokenNameSEMICOLON	
// Make the 90Deg rotations slightly 'snap to'. 	TokenNameCOMMENT_LINE	Make the 90Deg rotations slightly 'snap to'. 
// Also use explicit matrix to avoid round-off. 	TokenNameCOMMENT_LINE	Also use explicit matrix to avoid round-off. 
if	TokenNameif	
(	TokenNameLPAREN	
epsEQ	TokenNameIdentifier	 eps EQ
(	TokenNameLPAREN	
glyphRotation	TokenNameIdentifier	 glyph Rotation
,	TokenNameCOMMA	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
PI	TokenNameIdentifier	 PI
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
rotAt	TokenNameIdentifier	 rot At
=	TokenNameEQUAL	
new	TokenNamenew	
AffineTransform	TokenNameIdentifier	 Affine Transform
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
epsEQ	TokenNameIdentifier	 eps EQ
(	TokenNameLPAREN	
glyphRotation	TokenNameIdentifier	 glyph Rotation
,	TokenNameCOMMA	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
PI	TokenNameIdentifier	 PI
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
rotAt	TokenNameIdentifier	 rot At
=	TokenNameEQUAL	
new	TokenNamenew	
AffineTransform	TokenNameIdentifier	 Affine Transform
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
epsEQ	TokenNameIdentifier	 eps EQ
(	TokenNameLPAREN	
glyphRotation	TokenNameIdentifier	 glyph Rotation
,	TokenNameCOMMA	
3	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
PI	TokenNameIdentifier	 PI
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
rotAt	TokenNameIdentifier	 rot At
=	TokenNameEQUAL	
new	TokenNamenew	
AffineTransform	TokenNameIdentifier	 Affine Transform
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
rotAt	TokenNameIdentifier	 rot At
=	TokenNameEQUAL	
AffineTransform	TokenNameIdentifier	 Affine Transform
.	TokenNameDOT	
getRotateInstance	TokenNameIdentifier	 get Rotate Instance
(	TokenNameLPAREN	
glyphRotation	TokenNameIdentifier	 glyph Rotation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
glyphTransform	TokenNameIdentifier	 glyph Transform
.	TokenNameDOT	
concatenate	TokenNameIdentifier	 concatenate
(	TokenNameLPAREN	
rotAt	TokenNameIdentifier	 rot At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
setGlyphTransform	TokenNameIdentifier	 set Glyph Transform
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
glyphTransform	TokenNameIdentifier	 glyph Transform
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
aciIndex	TokenNameIdentifier	 aci Index
+=	TokenNamePLUS_EQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getCharacterCount	TokenNameIdentifier	 get Character Count
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
aciIndex	TokenNameIdentifier	 aci Index
>=	TokenNameGREATER_EQUAL	
charMap	TokenNameIdentifier	 char Map
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
aciIndex	TokenNameIdentifier	 aci Index
=	TokenNameEQUAL	
charMap	TokenNameIdentifier	 char Map
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
setIndex	TokenNameIdentifier	 set Index
(	TokenNameLPAREN	
aciIndex	TokenNameIdentifier	 aci Index
+	TokenNamePLUS	
aciStart	TokenNameIdentifier	 aci Start
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Update last glyph pos 	TokenNameCOMMENT_LINE	Update last glyph pos 
pos	TokenNameIdentifier	 pos
.	TokenNameDOT	
x	TokenNameIdentifier	 x
=	TokenNameEQUAL	
curr_x_pos	TokenNameIdentifier	 curr x pos
;	TokenNameSEMICOLON	
pos	TokenNameIdentifier	 pos
.	TokenNameDOT	
y	TokenNameIdentifier	 y
=	TokenNameEQUAL	
curr_y_pos	TokenNameIdentifier	 curr y pos
;	TokenNameSEMICOLON	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
setGlyphPosition	TokenNameIdentifier	 set Glyph Position
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
advance	TokenNameIdentifier	 advance
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
(	TokenNameLPAREN	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
curr_x_pos	TokenNameIdentifier	 curr x pos
-	TokenNameMINUS	
offset	TokenNameIdentifier	 offset
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
curr_y_pos	TokenNameIdentifier	 curr y pos
-	TokenNameMINUS	
offset	TokenNameIdentifier	 offset
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Do a last pass positioning the transparent/mark glyphs on the 	TokenNameCOMMENT_LINE	Do a last pass positioning the transparent/mark glyphs on the 
// base glyphs. 	TokenNameCOMMENT_LINE	base glyphs. 
if	TokenNameif	
(	TokenNameLPAREN	
hasArabicTransparent	TokenNameIdentifier	 has Arabic Transparent
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
first	TokenNameIdentifier	 first
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
aciIndex	TokenNameIdentifier	 aci Index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
transparentStart	TokenNameIdentifier	 transparent Start
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numGlyphs	TokenNameIdentifier	 num Glyphs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ArabicTextHandler	TokenNameIdentifier	 Arabic Text Handler
.	TokenNameDOT	
arabicCharTransparent	TokenNameIdentifier	 arabic Char Transparent
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
transparentStart	TokenNameIdentifier	 transparent Start
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
transparentStart	TokenNameIdentifier	 transparent Start
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
transparentStart	TokenNameIdentifier	 transparent Start
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Point2D	TokenNameIdentifier	 Point2 D
loc	TokenNameIdentifier	 loc
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphPosition	TokenNameIdentifier	 get Glyph Position
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
GVTGlyphMetrics	TokenNameIdentifier	 GVT Glyph Metrics
gm	TokenNameIdentifier	 gm
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphMetrics	TokenNameIdentifier	 get Glyph Metrics
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
tyS	TokenNameIdentifier	 ty S
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
txS	TokenNameIdentifier	 tx S
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// these never changed ?? todo 	TokenNameCOMMENT_LINE	these never changed ?? todo 
float	TokenNamefloat	
advX	TokenNameIdentifier	 adv X
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
advY	TokenNameIdentifier	 adv Y
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
vertical	TokenNameIdentifier	 vertical
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
glyphOrientationAuto	TokenNameIdentifier	 glyph Orientation Auto
||	TokenNameOR_OR	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
==	TokenNameEQUAL_EQUAL	
90	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
advY	TokenNameIdentifier	 adv Y
=	TokenNameEQUAL	
gm	TokenNameIdentifier	 gm
.	TokenNameDOT	
getHorizontalAdvance	TokenNameIdentifier	 get Horizontal Advance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
==	TokenNameEQUAL_EQUAL	
270	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
advY	TokenNameIdentifier	 adv Y
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
advX	TokenNameIdentifier	 adv X
=	TokenNameEQUAL	
gm	TokenNameIdentifier	 gm
.	TokenNameDOT	
getHorizontalAdvance	TokenNameIdentifier	 get Horizontal Advance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
// 180 	TokenNameCOMMENT_LINE	180 
advX	TokenNameIdentifier	 adv X
=	TokenNameEQUAL	
-	TokenNameMINUS	
gm	TokenNameIdentifier	 gm
.	TokenNameDOT	
getHorizontalAdvance	TokenNameIdentifier	 get Horizontal Advance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
advX	TokenNameIdentifier	 adv X
=	TokenNameEQUAL	
gm	TokenNameIdentifier	 gm
.	TokenNameDOT	
getHorizontalAdvance	TokenNameIdentifier	 get Horizontal Advance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
==	TokenNameEQUAL_EQUAL	
90	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
advY	TokenNameIdentifier	 adv Y
=	TokenNameEQUAL	
gm	TokenNameIdentifier	 gm
.	TokenNameDOT	
getHorizontalAdvance	TokenNameIdentifier	 get Horizontal Advance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
==	TokenNameEQUAL_EQUAL	
180	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
advX	TokenNameIdentifier	 adv X
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
else	TokenNameelse	
// 270 	TokenNameCOMMENT_LINE	270 
advY	TokenNameIdentifier	 adv Y
=	TokenNameEQUAL	
-	TokenNameMINUS	
gm	TokenNameIdentifier	 gm
.	TokenNameDOT	
getHorizontalAdvance	TokenNameIdentifier	 get Horizontal Advance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
float	TokenNamefloat	
baseX	TokenNameIdentifier	 base X
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
loc	TokenNameIdentifier	 loc
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
advX	TokenNameIdentifier	 adv X
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
baseY	TokenNameIdentifier	 base Y
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
loc	TokenNameIdentifier	 loc
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
advY	TokenNameIdentifier	 adv Y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
transparentStart	TokenNameIdentifier	 transparent Start
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Point2D	TokenNameIdentifier	 Point2 D
locT	TokenNameIdentifier	 loc T
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphPosition	TokenNameIdentifier	 get Glyph Position
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
GVTGlyphMetrics	TokenNameIdentifier	 GVT Glyph Metrics
gmT	TokenNameIdentifier	 gm T
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphMetrics	TokenNameIdentifier	 get Glyph Metrics
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
locX	TokenNameIdentifier	 loc X
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
locT	TokenNameIdentifier	 loc T
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
locY	TokenNameIdentifier	 loc Y
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
locT	TokenNameIdentifier	 loc T
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
tx	TokenNameIdentifier	 tx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
ty	TokenNameIdentifier	 ty
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
advT	TokenNameIdentifier	 adv T
=	TokenNameEQUAL	
gmT	TokenNameIdentifier	 gm T
.	TokenNameDOT	
getHorizontalAdvance	TokenNameIdentifier	 get Horizontal Advance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
vertical	TokenNameIdentifier	 vertical
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
glyphOrientationAuto	TokenNameIdentifier	 glyph Orientation Auto
||	TokenNameOR_OR	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
==	TokenNameEQUAL_EQUAL	
90	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
locY	TokenNameIdentifier	 loc Y
=	TokenNameEQUAL	
baseY	TokenNameIdentifier	 base Y
-	TokenNameMINUS	
advT	TokenNameIdentifier	 adv T
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
==	TokenNameEQUAL_EQUAL	
270	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
locY	TokenNameIdentifier	 loc Y
=	TokenNameEQUAL	
baseY	TokenNameIdentifier	 base Y
+	TokenNamePLUS	
advT	TokenNameIdentifier	 adv T
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
locX	TokenNameIdentifier	 loc X
=	TokenNameEQUAL	
baseX	TokenNameIdentifier	 base X
-	TokenNameMINUS	
advT	TokenNameIdentifier	 adv T
;	TokenNameSEMICOLON	
else	TokenNameelse	
// 180deg 	TokenNameCOMMENT_LINE	180deg 
locX	TokenNameIdentifier	 loc X
=	TokenNameEQUAL	
baseX	TokenNameIdentifier	 base X
+	TokenNamePLUS	
advT	TokenNameIdentifier	 adv T
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
locX	TokenNameIdentifier	 loc X
=	TokenNameEQUAL	
baseX	TokenNameIdentifier	 base X
-	TokenNameMINUS	
advT	TokenNameIdentifier	 adv T
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
==	TokenNameEQUAL_EQUAL	
90	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
locY	TokenNameIdentifier	 loc Y
=	TokenNameEQUAL	
baseY	TokenNameIdentifier	 base Y
-	TokenNameMINUS	
advT	TokenNameIdentifier	 adv T
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
==	TokenNameEQUAL_EQUAL	
180	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
locX	TokenNameIdentifier	 loc X
=	TokenNameEQUAL	
baseX	TokenNameIdentifier	 base X
+	TokenNamePLUS	
advT	TokenNameIdentifier	 adv T
;	TokenNameSEMICOLON	
else	TokenNameelse	
// 270 	TokenNameCOMMENT_LINE	270 
locY	TokenNameIdentifier	 loc Y
=	TokenNameEQUAL	
baseY	TokenNameIdentifier	 base Y
+	TokenNamePLUS	
advT	TokenNameIdentifier	 adv T
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
locT	TokenNameIdentifier	 loc T
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Double	TokenNameIdentifier	 Double
(	TokenNameLPAREN	
locX	TokenNameIdentifier	 loc X
,	TokenNameCOMMA	
locY	TokenNameIdentifier	 loc Y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
setGlyphPosition	TokenNameIdentifier	 set Glyph Position
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
,	TokenNameCOMMA	
locT	TokenNameIdentifier	 loc T
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
txS	TokenNameIdentifier	 tx S
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
tyS	TokenNameIdentifier	 ty S
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// because txS, tyS are set to 0 and not 	TokenNameCOMMENT_LINE	because txS, tyS are set to 0 and not 
AffineTransform	TokenNameIdentifier	 Affine Transform
at	TokenNameIdentifier	 at
;	TokenNameSEMICOLON	
// changed, this path is never used todo 	TokenNameCOMMENT_LINE	changed, this path is never used todo 
at	TokenNameIdentifier	 at
=	TokenNameEQUAL	
AffineTransform	TokenNameIdentifier	 Affine Transform
.	TokenNameDOT	
getTranslateInstance	TokenNameIdentifier	 get Translate Instance
(	TokenNameLPAREN	
tx	TokenNameIdentifier	 tx
,	TokenNameCOMMA	
ty	TokenNameIdentifier	 ty
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
at	TokenNameIdentifier	 at
.	TokenNameDOT	
concatenate	TokenNameIdentifier	 concatenate
(	TokenNameLPAREN	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphTransform	TokenNameIdentifier	 get Glyph Transform
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
setGlyphTransform	TokenNameIdentifier	 set Glyph Transform
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
at	TokenNameIdentifier	 at
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
transparentStart	TokenNameIdentifier	 transparent Start
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
aciIndex	TokenNameIdentifier	 aci Index
+=	TokenNamePLUS_EQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getCharacterCount	TokenNameIdentifier	 get Character Count
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
aciIndex	TokenNameIdentifier	 aci Index
>=	TokenNameGREATER_EQUAL	
charMap	TokenNameIdentifier	 char Map
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
aciIndex	TokenNameIdentifier	 aci Index
=	TokenNameEQUAL	
charMap	TokenNameIdentifier	 char Map
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
setIndex	TokenNameIdentifier	 set Index
(	TokenNameLPAREN	
aciIndex	TokenNameIdentifier	 aci Index
+	TokenNamePLUS	
aciStart	TokenNameIdentifier	 aci Start
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
layoutApplied	TokenNameIdentifier	 layout Applied
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
spacingApplied	TokenNameIdentifier	 spacing Applied
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
glyphAdvances	TokenNameIdentifier	 glyph Advances
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
pathApplied	TokenNameIdentifier	 path Applied
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Does any spacing adjustments that may have been specified. */	TokenNameCOMMENT_JAVADOC	 Does any spacing adjustments that may have been specified. 
protected	TokenNameprotected	
void	TokenNamevoid	
adjustTextSpacing	TokenNameIdentifier	 adjust Text Spacing
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
spacingApplied	TokenNameIdentifier	 spacing Applied
)	TokenNameRPAREN	
// Nothing to do... 	TokenNameCOMMENT_LINE	Nothing to do... 
return	TokenNamereturn	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
layoutApplied	TokenNameIdentifier	 layout Applied
)	TokenNameRPAREN	
// Must have clean layout to do spacing... 	TokenNameCOMMENT_LINE	Must have clean layout to do spacing... 
doExplicitGlyphLayout	TokenNameIdentifier	 do Explicit Glyph Layout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
first	TokenNameIdentifier	 first
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Boolean	TokenNameIdentifier	 Boolean
customSpacing	TokenNameIdentifier	 custom Spacing
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Boolean	TokenNameIdentifier	 Boolean
)	TokenNameRPAREN	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
GVTAttributedCharacterIterator	TokenNameIdentifier	 GVT Attributed Character Iterator
.	TokenNameDOT	
TextAttribute	TokenNameIdentifier	 Text Attribute
.	TokenNameDOT	
CUSTOM_SPACING	TokenNameIdentifier	 CUSTOM  SPACING
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
customSpacing	TokenNameIdentifier	 custom Spacing
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
customSpacing	TokenNameIdentifier	 custom Spacing
.	TokenNameDOT	
booleanValue	TokenNameIdentifier	 boolean Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
advance	TokenNameIdentifier	 advance
=	TokenNameEQUAL	
doSpacing	TokenNameIdentifier	 do Spacing
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Float	TokenNameIdentifier	 Float
)	TokenNameRPAREN	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
GVTAttributedCharacterIterator	TokenNameIdentifier	 GVT Attributed Character Iterator
.	TokenNameDOT	
TextAttribute	TokenNameIdentifier	 Text Attribute
.	TokenNameDOT	
KERNING	TokenNameIdentifier	 KERNING
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
Float	TokenNameIdentifier	 Float
)	TokenNameRPAREN	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
GVTAttributedCharacterIterator	TokenNameIdentifier	 GVT Attributed Character Iterator
.	TokenNameDOT	
TextAttribute	TokenNameIdentifier	 Text Attribute
.	TokenNameDOT	
LETTER_SPACING	TokenNameIdentifier	 LETTER  SPACING
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
Float	TokenNameIdentifier	 Float
)	TokenNameRPAREN	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
GVTAttributedCharacterIterator	TokenNameIdentifier	 GVT Attributed Character Iterator
.	TokenNameDOT	
TextAttribute	TokenNameIdentifier	 Text Attribute
.	TokenNameDOT	
WORD_SPACING	TokenNameIdentifier	 WORD  SPACING
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Basic layout is now messed up... 	TokenNameCOMMENT_LINE	Basic layout is now messed up... 
layoutApplied	TokenNameIdentifier	 layout Applied
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// This will clear layoutApplied if it mucks with the current 	TokenNameCOMMENT_LINE	This will clear layoutApplied if it mucks with the current 
// character positions. 	TokenNameCOMMENT_LINE	character positions. 
applyStretchTransform	TokenNameIdentifier	 apply Stretch Transform
(	TokenNameLPAREN	
!	TokenNameNOT	
adjSpacing	TokenNameIdentifier	 adj Spacing
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
spacingApplied	TokenNameIdentifier	 spacing Applied
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
pathApplied	TokenNameIdentifier	 path Applied
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Performs any spacing adjustments required and returns the new advance * value. * * @param kern The kerning adjustment to apply to the space * between each char. * @param letterSpacing The amount of spacing required between each char. * @param wordSpacing The amount of spacing required between each word. */	TokenNameCOMMENT_JAVADOC	 Performs any spacing adjustments required and returns the new advance value. * @param kern The kerning adjustment to apply to the space between each char. @param letterSpacing The amount of spacing required between each char. @param wordSpacing The amount of spacing required between each word. 
protected	TokenNameprotected	
Point2D	TokenNameIdentifier	 Point2 D
doSpacing	TokenNameIdentifier	 do Spacing
(	TokenNameLPAREN	
Float	TokenNameIdentifier	 Float
kern	TokenNameIdentifier	 kern
,	TokenNameCOMMA	
Float	TokenNameIdentifier	 Float
letterSpacing	TokenNameIdentifier	 letter Spacing
,	TokenNameCOMMA	
Float	TokenNameIdentifier	 Float
wordSpacing	TokenNameIdentifier	 word Spacing
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
autoKern	TokenNameIdentifier	 auto Kern
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
doWordSpacing	TokenNameIdentifier	 do Word Spacing
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
doLetterSpacing	TokenNameIdentifier	 do Letter Spacing
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
kernVal	TokenNameIdentifier	 kern Val
=	TokenNameEQUAL	
0f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
letterSpacingVal	TokenNameIdentifier	 letter Spacing Val
=	TokenNameEQUAL	
0f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
kern	TokenNameIdentifier	 kern
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
!	TokenNameNOT	
kern	TokenNameIdentifier	 kern
.	TokenNameDOT	
isNaN	TokenNameIdentifier	 is Na N
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
kernVal	TokenNameIdentifier	 kern Val
=	TokenNameEQUAL	
kern	TokenNameIdentifier	 kern
.	TokenNameDOT	
floatValue	TokenNameIdentifier	 float Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
autoKern	TokenNameIdentifier	 auto Kern
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
//System.out.println("KERNING: "+kernVal); 	TokenNameCOMMENT_LINE	System.out.println("KERNING: "+kernVal); 
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
letterSpacing	TokenNameIdentifier	 letter Spacing
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
!	TokenNameNOT	
letterSpacing	TokenNameIdentifier	 letter Spacing
.	TokenNameDOT	
isNaN	TokenNameIdentifier	 is Na N
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
letterSpacingVal	TokenNameIdentifier	 letter Spacing Val
=	TokenNameEQUAL	
letterSpacing	TokenNameIdentifier	 letter Spacing
.	TokenNameDOT	
floatValue	TokenNameIdentifier	 float Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
doLetterSpacing	TokenNameIdentifier	 do Letter Spacing
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
//System.out.println("LETTER-SPACING: "+letterSpacingVal); 	TokenNameCOMMENT_LINE	System.out.println("LETTER-SPACING: "+letterSpacingVal); 
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
wordSpacing	TokenNameIdentifier	 word Spacing
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
!	TokenNameNOT	
wordSpacing	TokenNameIdentifier	 word Spacing
.	TokenNameDOT	
isNaN	TokenNameIdentifier	 is Na N
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
doWordSpacing	TokenNameIdentifier	 do Word Spacing
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
numGlyphs	TokenNameIdentifier	 num Glyphs
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getNumGlyphs	TokenNameIdentifier	 get Num Glyphs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
dx	TokenNameIdentifier	 dx
=	TokenNameEQUAL	
0f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
dy	TokenNameIdentifier	 dy
=	TokenNameEQUAL	
0f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
Point2D	TokenNameIdentifier	 Point2 D
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newPositions	TokenNameIdentifier	 new Positions
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
[	TokenNameLBRACKET	
numGlyphs	TokenNameIdentifier	 num Glyphs
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
Point2D	TokenNameIdentifier	 Point2 D
prevPos	TokenNameIdentifier	 prev Pos
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphPosition	TokenNameIdentifier	 get Glyph Position
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
prevCode	TokenNameIdentifier	 prev Code
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphCode	TokenNameIdentifier	 get Glyph Code
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
x	TokenNameIdentifier	 x
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
prevPos	TokenNameIdentifier	 prev Pos
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
y	TokenNameIdentifier	 y
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
prevPos	TokenNameIdentifier	 prev Pos
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Point2D	TokenNameIdentifier	 Point2 D
lastCharAdvance	TokenNameIdentifier	 last Char Advance
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Double	TokenNameIdentifier	 Double
(	TokenNameLPAREN	
advance	TokenNameIdentifier	 advance
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
(	TokenNameLPAREN	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphPosition	TokenNameIdentifier	 get Glyph Position
(	TokenNameLPAREN	
numGlyphs	TokenNameIdentifier	 num Glyphs
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
x	TokenNameIdentifier	 x
)	TokenNameRPAREN	
,	TokenNameCOMMA	
advance	TokenNameIdentifier	 advance
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
(	TokenNameLPAREN	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphPosition	TokenNameIdentifier	 get Glyph Position
(	TokenNameLPAREN	
numGlyphs	TokenNameIdentifier	 num Glyphs
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
GVTFont	TokenNameIdentifier	 GVT Font
font	TokenNameIdentifier	 font
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getFont	TokenNameIdentifier	 get Font
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// do letter spacing first 	TokenNameCOMMENT_LINE	do letter spacing first 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
numGlyphs	TokenNameIdentifier	 num Glyphs
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
doLetterSpacing	TokenNameIdentifier	 do Letter Spacing
||	TokenNameOR_OR	
!	TokenNameNOT	
autoKern	TokenNameIdentifier	 auto Kern
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<=	TokenNameLESS_EQUAL	
numGlyphs	TokenNameIdentifier	 num Glyphs
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Point2D	TokenNameIdentifier	 Point2 D
gpos	TokenNameIdentifier	 gpos
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphPosition	TokenNameIdentifier	 get Glyph Position
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
currCode	TokenNameIdentifier	 curr Code
;	TokenNameSEMICOLON	
currCode	TokenNameIdentifier	 curr Code
=	TokenNameEQUAL	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
==	TokenNameEQUAL_EQUAL	
numGlyphs	TokenNameIdentifier	 num Glyphs
)	TokenNameRPAREN	
?	TokenNameQUESTION	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphCode	TokenNameIdentifier	 get Glyph Code
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dx	TokenNameIdentifier	 dx
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
gpos	TokenNameIdentifier	 gpos
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
prevPos	TokenNameIdentifier	 prev Pos
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dy	TokenNameIdentifier	 dy
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
gpos	TokenNameIdentifier	 gpos
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
prevPos	TokenNameIdentifier	 prev Pos
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
autoKern	TokenNameIdentifier	 auto Kern
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
vertical	TokenNameIdentifier	 vertical
)	TokenNameRPAREN	
dy	TokenNameIdentifier	 dy
+=	TokenNamePLUS_EQUAL	
letterSpacingVal	TokenNameIdentifier	 letter Spacing Val
;	TokenNameSEMICOLON	
else	TokenNameelse	
dx	TokenNameIdentifier	 dx
+=	TokenNamePLUS_EQUAL	
letterSpacingVal	TokenNameIdentifier	 letter Spacing Val
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// apply explicit kerning adjustments, 	TokenNameCOMMENT_LINE	apply explicit kerning adjustments, 
// removing any auto-kern values 	TokenNameCOMMENT_LINE	removing any auto-kern values 
if	TokenNameif	
(	TokenNameLPAREN	
vertical	TokenNameIdentifier	 vertical
)	TokenNameRPAREN	
{	TokenNameLBRACE	
float	TokenNamefloat	
vKern	TokenNameIdentifier	 v Kern
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
currCode	TokenNameIdentifier	 curr Code
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
vKern	TokenNameIdentifier	 v Kern
=	TokenNameEQUAL	
font	TokenNameIdentifier	 font
.	TokenNameDOT	
getVKern	TokenNameIdentifier	 get V Kern
(	TokenNameLPAREN	
prevCode	TokenNameIdentifier	 prev Code
,	TokenNameCOMMA	
currCode	TokenNameIdentifier	 curr Code
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dy	TokenNameIdentifier	 dy
+=	TokenNamePLUS_EQUAL	
kernVal	TokenNameIdentifier	 kern Val
-	TokenNameMINUS	
vKern	TokenNameIdentifier	 v Kern
+	TokenNamePLUS	
letterSpacingVal	TokenNameIdentifier	 letter Spacing Val
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
float	TokenNamefloat	
hKern	TokenNameIdentifier	 h Kern
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
currCode	TokenNameIdentifier	 curr Code
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
hKern	TokenNameIdentifier	 h Kern
=	TokenNameEQUAL	
font	TokenNameIdentifier	 font
.	TokenNameDOT	
getHKern	TokenNameIdentifier	 get H Kern
(	TokenNameLPAREN	
prevCode	TokenNameIdentifier	 prev Code
,	TokenNameCOMMA	
currCode	TokenNameIdentifier	 curr Code
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dx	TokenNameIdentifier	 dx
+=	TokenNamePLUS_EQUAL	
kernVal	TokenNameIdentifier	 kern Val
-	TokenNameMINUS	
hKern	TokenNameIdentifier	 h Kern
+	TokenNamePLUS	
letterSpacingVal	TokenNameIdentifier	 letter Spacing Val
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
x	TokenNameIdentifier	 x
+=	TokenNamePLUS_EQUAL	
dx	TokenNameIdentifier	 dx
;	TokenNameSEMICOLON	
y	TokenNameIdentifier	 y
+=	TokenNamePLUS_EQUAL	
dy	TokenNameIdentifier	 dy
;	TokenNameSEMICOLON	
newPositions	TokenNameIdentifier	 new Positions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
(	TokenNameLPAREN	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
prevPos	TokenNameIdentifier	 prev Pos
=	TokenNameEQUAL	
gpos	TokenNameIdentifier	 gpos
;	TokenNameSEMICOLON	
prevCode	TokenNameIdentifier	 prev Code
=	TokenNameEQUAL	
currCode	TokenNameIdentifier	 curr Code
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<=	TokenNameLESS_EQUAL	
numGlyphs	TokenNameIdentifier	 num Glyphs
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// assign the new positions 	TokenNameCOMMENT_LINE	assign the new positions 
if	TokenNameif	
(	TokenNameLPAREN	
newPositions	TokenNameIdentifier	 new Positions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
setGlyphPosition	TokenNameIdentifier	 set Glyph Position
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
newPositions	TokenNameIdentifier	 new Positions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// adjust the advance of the last character 	TokenNameCOMMENT_LINE	adjust the advance of the last character 
if	TokenNameif	
(	TokenNameLPAREN	
vertical	TokenNameIdentifier	 vertical
)	TokenNameRPAREN	
{	TokenNameLBRACE	
lastCharAdvance	TokenNameIdentifier	 last Char Advance
.	TokenNameDOT	
setLocation	TokenNameIdentifier	 set Location
(	TokenNameLPAREN	
lastCharAdvance	TokenNameIdentifier	 last Char Advance
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
lastCharAdvance	TokenNameIdentifier	 last Char Advance
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
kernVal	TokenNameIdentifier	 kern Val
+	TokenNamePLUS	
letterSpacingVal	TokenNameIdentifier	 letter Spacing Val
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
lastCharAdvance	TokenNameIdentifier	 last Char Advance
.	TokenNameDOT	
setLocation	TokenNameIdentifier	 set Location
(	TokenNameLPAREN	
lastCharAdvance	TokenNameIdentifier	 last Char Advance
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
kernVal	TokenNameIdentifier	 kern Val
+	TokenNamePLUS	
letterSpacingVal	TokenNameIdentifier	 letter Spacing Val
,	TokenNameCOMMA	
lastCharAdvance	TokenNameIdentifier	 last Char Advance
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// now do word spacing 	TokenNameCOMMENT_LINE	now do word spacing 
dx	TokenNameIdentifier	 dx
=	TokenNameEQUAL	
0f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
dy	TokenNameIdentifier	 dy
=	TokenNameEQUAL	
0f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
prevPos	TokenNameIdentifier	 prev Pos
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphPosition	TokenNameIdentifier	 get Glyph Position
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
x	TokenNameIdentifier	 x
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
prevPos	TokenNameIdentifier	 prev Pos
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
y	TokenNameIdentifier	 y
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
prevPos	TokenNameIdentifier	 prev Pos
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
numGlyphs	TokenNameIdentifier	 num Glyphs
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
doWordSpacing	TokenNameIdentifier	 do Word Spacing
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numGlyphs	TokenNameIdentifier	 num Glyphs
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Point2D	TokenNameIdentifier	 Point2 D
gpos	TokenNameIdentifier	 gpos
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphPosition	TokenNameIdentifier	 get Glyph Position
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dx	TokenNameIdentifier	 dx
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
gpos	TokenNameIdentifier	 gpos
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
prevPos	TokenNameIdentifier	 prev Pos
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dy	TokenNameIdentifier	 dy
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
gpos	TokenNameIdentifier	 gpos
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
prevPos	TokenNameIdentifier	 prev Pos
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
inWS	TokenNameIdentifier	 in WS
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// while this is whitespace, increment 	TokenNameCOMMENT_LINE	while this is whitespace, increment 
int	TokenNameint	
beginWS	TokenNameIdentifier	 begin WS
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
int	TokenNameint	
endWS	TokenNameIdentifier	 end WS
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
GVTGlyphMetrics	TokenNameIdentifier	 GVT Glyph Metrics
gm	TokenNameIdentifier	 gm
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphMetrics	TokenNameIdentifier	 get Glyph Metrics
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// BUG: gm.isWhitespace() fails for latin SPACE glyph! 	TokenNameCOMMENT_LINE	BUG: gm.isWhitespace() fails for latin SPACE glyph! 
while	TokenNamewhile	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
gm	TokenNameIdentifier	 gm
.	TokenNameDOT	
getBounds2D	TokenNameIdentifier	 get Bounds2 D
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<	TokenNameLESS	
0.01d	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
gm	TokenNameIdentifier	 gm
.	TokenNameDOT	
isWhitespace	TokenNameIdentifier	 is Whitespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
inWS	TokenNameIdentifier	 in WS
)	TokenNameRPAREN	
inWS	TokenNameIdentifier	 in WS
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
==	TokenNameEQUAL_EQUAL	
numGlyphs	TokenNameIdentifier	 num Glyphs
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// white space at the end 	TokenNameCOMMENT_LINE	white space at the end 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
endWS	TokenNameIdentifier	 end WS
;	TokenNameSEMICOLON	
gpos	TokenNameIdentifier	 gpos
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphPosition	TokenNameIdentifier	 get Glyph Position
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
gm	TokenNameIdentifier	 gm
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphMetrics	TokenNameIdentifier	 get Glyph Metrics
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
inWS	TokenNameIdentifier	 in WS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// apply wordSpacing 	TokenNameCOMMENT_LINE	apply wordSpacing 
int	TokenNameint	
nWS	TokenNameIdentifier	 n WS
=	TokenNameEQUAL	
endWS	TokenNameIdentifier	 end WS
-	TokenNameMINUS	
beginWS	TokenNameIdentifier	 begin WS
;	TokenNameSEMICOLON	
float	TokenNamefloat	
px	TokenNameIdentifier	 px
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
prevPos	TokenNameIdentifier	 prev Pos
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
py	TokenNameIdentifier	 py
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
prevPos	TokenNameIdentifier	 prev Pos
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dx	TokenNameIdentifier	 dx
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
gpos	TokenNameIdentifier	 gpos
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
px	TokenNameIdentifier	 px
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
(	TokenNameLPAREN	
nWS	TokenNameIdentifier	 n WS
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dy	TokenNameIdentifier	 dy
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
gpos	TokenNameIdentifier	 gpos
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
py	TokenNameIdentifier	 py
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
(	TokenNameLPAREN	
nWS	TokenNameIdentifier	 n WS
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
vertical	TokenNameIdentifier	 vertical
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dy	TokenNameIdentifier	 dy
+=	TokenNamePLUS_EQUAL	
wordSpacing	TokenNameIdentifier	 word Spacing
.	TokenNameDOT	
floatValue	TokenNameIdentifier	 float Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
(	TokenNameLPAREN	
nWS	TokenNameIdentifier	 n WS
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
dx	TokenNameIdentifier	 dx
+=	TokenNamePLUS_EQUAL	
wordSpacing	TokenNameIdentifier	 word Spacing
.	TokenNameDOT	
floatValue	TokenNameIdentifier	 float Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
(	TokenNameLPAREN	
nWS	TokenNameIdentifier	 n WS
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
beginWS	TokenNameIdentifier	 begin WS
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<=	TokenNameLESS_EQUAL	
endWS	TokenNameIdentifier	 end WS
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
{	TokenNameLBRACE	
x	TokenNameIdentifier	 x
+=	TokenNamePLUS_EQUAL	
dx	TokenNameIdentifier	 dx
;	TokenNameSEMICOLON	
y	TokenNameIdentifier	 y
+=	TokenNamePLUS_EQUAL	
dy	TokenNameIdentifier	 dy
;	TokenNameSEMICOLON	
newPositions	TokenNameIdentifier	 new Positions
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
(	TokenNameLPAREN	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
dx	TokenNameIdentifier	 dx
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
gpos	TokenNameIdentifier	 gpos
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
prevPos	TokenNameIdentifier	 prev Pos
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dy	TokenNameIdentifier	 dy
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
gpos	TokenNameIdentifier	 gpos
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
prevPos	TokenNameIdentifier	 prev Pos
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
x	TokenNameIdentifier	 x
+=	TokenNamePLUS_EQUAL	
dx	TokenNameIdentifier	 dx
;	TokenNameSEMICOLON	
y	TokenNameIdentifier	 y
+=	TokenNamePLUS_EQUAL	
dy	TokenNameIdentifier	 dy
;	TokenNameSEMICOLON	
newPositions	TokenNameIdentifier	 new Positions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
(	TokenNameLPAREN	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
prevPos	TokenNameIdentifier	 prev Pos
=	TokenNameEQUAL	
gpos	TokenNameIdentifier	 gpos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Point2D	TokenNameIdentifier	 Point2 D
gPos	TokenNameIdentifier	 g Pos
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphPosition	TokenNameIdentifier	 get Glyph Position
(	TokenNameLPAREN	
numGlyphs	TokenNameIdentifier	 num Glyphs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
x	TokenNameIdentifier	 x
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
gPos	TokenNameIdentifier	 g Pos
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
prevPos	TokenNameIdentifier	 prev Pos
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
y	TokenNameIdentifier	 y
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
gPos	TokenNameIdentifier	 g Pos
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
prevPos	TokenNameIdentifier	 prev Pos
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
newPositions	TokenNameIdentifier	 new Positions
[	TokenNameLBRACKET	
numGlyphs	TokenNameIdentifier	 num Glyphs
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
(	TokenNameLPAREN	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<=	TokenNameLESS_EQUAL	
numGlyphs	TokenNameIdentifier	 num Glyphs
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// assign the new positions 	TokenNameCOMMENT_LINE	assign the new positions 
if	TokenNameif	
(	TokenNameLPAREN	
newPositions	TokenNameIdentifier	 new Positions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
setGlyphPosition	TokenNameIdentifier	 set Glyph Position
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
newPositions	TokenNameIdentifier	 new Positions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
printStackTrace	TokenNameIdentifier	 print Stack Trace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// calculate the new advance 	TokenNameCOMMENT_LINE	calculate the new advance 
double	TokenNamedouble	
advX	TokenNameIdentifier	 adv X
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphPosition	TokenNameIdentifier	 get Glyph Position
(	TokenNameLPAREN	
numGlyphs	TokenNameIdentifier	 num Glyphs
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphPosition	TokenNameIdentifier	 get Glyph Position
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
advY	TokenNameIdentifier	 adv Y
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphPosition	TokenNameIdentifier	 get Glyph Position
(	TokenNameLPAREN	
numGlyphs	TokenNameIdentifier	 num Glyphs
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphPosition	TokenNameIdentifier	 get Glyph Position
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Point2D	TokenNameIdentifier	 Point2 D
newAdvance	TokenNameIdentifier	 new Advance
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Double	TokenNameIdentifier	 Double
(	TokenNameLPAREN	
advX	TokenNameIdentifier	 adv X
+	TokenNamePLUS	
lastCharAdvance	TokenNameIdentifier	 last Char Advance
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
advY	TokenNameIdentifier	 adv Y
+	TokenNamePLUS	
lastCharAdvance	TokenNameIdentifier	 last Char Advance
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
newAdvance	TokenNameIdentifier	 new Advance
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Stretches the text so that it becomes the specified length. * * @param stretchGlyphs if true xScale, yScale will be applied to * each glyphs transform. */	TokenNameCOMMENT_JAVADOC	 Stretches the text so that it becomes the specified length. * @param stretchGlyphs if true xScale, yScale will be applied to each glyphs transform. 
protected	TokenNameprotected	
void	TokenNamevoid	
applyStretchTransform	TokenNameIdentifier	 apply Stretch Transform
(	TokenNameLPAREN	
boolean	TokenNameboolean	
stretchGlyphs	TokenNameIdentifier	 stretch Glyphs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
xScale	TokenNameIdentifier	 x Scale
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
yScale	TokenNameIdentifier	 y Scale
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
AffineTransform	TokenNameIdentifier	 Affine Transform
scaleAT	TokenNameIdentifier	 scale AT
=	TokenNameEQUAL	
AffineTransform	TokenNameIdentifier	 Affine Transform
.	TokenNameDOT	
getScaleInstance	TokenNameIdentifier	 get Scale Instance
(	TokenNameLPAREN	
xScale	TokenNameIdentifier	 x Scale
,	TokenNameCOMMA	
yScale	TokenNameIdentifier	 y Scale
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
numGlyphs	TokenNameIdentifier	 num Glyphs
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getNumGlyphs	TokenNameIdentifier	 get Num Glyphs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
gp	TokenNameIdentifier	 gp
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphPositions	TokenNameIdentifier	 get Glyph Positions
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
numGlyphs	TokenNameIdentifier	 num Glyphs
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
initX	TokenNameIdentifier	 init X
=	TokenNameEQUAL	
gp	TokenNameIdentifier	 gp
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
initY	TokenNameIdentifier	 init Y
=	TokenNameEQUAL	
gp	TokenNameIdentifier	 gp
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<=	TokenNameLESS_EQUAL	
numGlyphs	TokenNameIdentifier	 num Glyphs
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
float	TokenNamefloat	
dx	TokenNameIdentifier	 dx
=	TokenNameEQUAL	
gp	TokenNameIdentifier	 gp
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
-	TokenNameMINUS	
initX	TokenNameIdentifier	 init X
;	TokenNameSEMICOLON	
float	TokenNamefloat	
dy	TokenNameIdentifier	 dy
=	TokenNameEQUAL	
gp	TokenNameIdentifier	 gp
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
-	TokenNameMINUS	
initY	TokenNameIdentifier	 init Y
;	TokenNameSEMICOLON	
pos	TokenNameIdentifier	 pos
.	TokenNameDOT	
x	TokenNameIdentifier	 x
=	TokenNameEQUAL	
initX	TokenNameIdentifier	 init X
+	TokenNamePLUS	
dx	TokenNameIdentifier	 dx
*	TokenNameMULTIPLY	
xScale	TokenNameIdentifier	 x Scale
;	TokenNameSEMICOLON	
pos	TokenNameIdentifier	 pos
.	TokenNameDOT	
y	TokenNameIdentifier	 y
=	TokenNameEQUAL	
initY	TokenNameIdentifier	 init Y
+	TokenNamePLUS	
dy	TokenNameIdentifier	 dy
*	TokenNameMULTIPLY	
yScale	TokenNameIdentifier	 y Scale
;	TokenNameSEMICOLON	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
setGlyphPosition	TokenNameIdentifier	 set Glyph Position
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
stretchGlyphs	TokenNameIdentifier	 stretch Glyphs
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
numGlyphs	TokenNameIdentifier	 num Glyphs
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// stretch the glyph 	TokenNameCOMMENT_LINE	stretch the glyph 
AffineTransform	TokenNameIdentifier	 Affine Transform
glyphTransform	TokenNameIdentifier	 glyph Transform
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphTransform	TokenNameIdentifier	 get Glyph Transform
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
glyphTransform	TokenNameIdentifier	 glyph Transform
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
glyphTransform	TokenNameIdentifier	 glyph Transform
.	TokenNameDOT	
preConcatenate	TokenNameIdentifier	 pre Concatenate
(	TokenNameLPAREN	
scaleAT	TokenNameIdentifier	 scale AT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
setGlyphTransform	TokenNameIdentifier	 set Glyph Transform
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
glyphTransform	TokenNameIdentifier	 glyph Transform
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
setGlyphTransform	TokenNameIdentifier	 set Glyph Transform
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
scaleAT	TokenNameIdentifier	 scale AT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
advance	TokenNameIdentifier	 advance
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
(	TokenNameLPAREN	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
advance	TokenNameIdentifier	 advance
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
xScale	TokenNameIdentifier	 x Scale
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
advance	TokenNameIdentifier	 advance
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
yScale	TokenNameIdentifier	 y Scale
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Basic layout is now messed up... 	TokenNameCOMMENT_LINE	Basic layout is now messed up... 
layoutApplied	TokenNameIdentifier	 layout Applied
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * If this layout is on a text path, positions the characters * along the path. */	TokenNameCOMMENT_JAVADOC	 If this layout is on a text path, positions the characters along the path. 
protected	TokenNameprotected	
void	TokenNamevoid	
doPathLayout	TokenNameIdentifier	 do Path Layout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
pathApplied	TokenNameIdentifier	 path Applied
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
spacingApplied	TokenNameIdentifier	 spacing Applied
)	TokenNameRPAREN	
// This will layout the text if needed. 	TokenNameCOMMENT_LINE	This will layout the text if needed. 
adjustTextSpacing	TokenNameIdentifier	 adjust Text Spacing
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
getGlyphAdvances	TokenNameIdentifier	 get Glyph Advances
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// if doesn't have an attached text path, just return 	TokenNameCOMMENT_LINE	if doesn't have an attached text path, just return 
if	TokenNameif	
(	TokenNameLPAREN	
textPath	TokenNameIdentifier	 text Path
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// We applied the empty path (i.e. do nothing). 	TokenNameCOMMENT_LINE	We applied the empty path (i.e. do nothing). 
pathApplied	TokenNameIdentifier	 path Applied
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
boolean	TokenNameboolean	
horizontal	TokenNameIdentifier	 horizontal
=	TokenNameEQUAL	
!	TokenNameNOT	
isVertical	TokenNameIdentifier	 is Vertical
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
glyphOrientationAuto	TokenNameIdentifier	 glyph Orientation Auto
=	TokenNameEQUAL	
isGlyphOrientationAuto	TokenNameIdentifier	 is Glyph Orientation Auto
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
glyphOrientationAuto	TokenNameIdentifier	 glyph Orientation Auto
)	TokenNameRPAREN	
{	TokenNameLBRACE	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
=	TokenNameEQUAL	
getGlyphOrientationAngle	TokenNameIdentifier	 get Glyph Orientation Angle
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
float	TokenNamefloat	
pathLength	TokenNameIdentifier	 path Length
=	TokenNameEQUAL	
textPath	TokenNameIdentifier	 text Path
.	TokenNameDOT	
lengthOfPath	TokenNameIdentifier	 length Of Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
startOffset	TokenNameIdentifier	 start Offset
=	TokenNameEQUAL	
textPath	TokenNameIdentifier	 text Path
.	TokenNameDOT	
getStartOffset	TokenNameIdentifier	 get Start Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
numGlyphs	TokenNameIdentifier	 num Glyphs
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getNumGlyphs	TokenNameIdentifier	 get Num Glyphs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// make sure all glyphs visible again, this maybe just a change in 	TokenNameCOMMENT_LINE	make sure all glyphs visible again, this maybe just a change in 
// offset so they may have been made invisible in a previous 	TokenNameCOMMENT_LINE	offset so they may have been made invisible in a previous 
// pathLayout call 	TokenNameCOMMENT_LINE	pathLayout call 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numGlyphs	TokenNameIdentifier	 num Glyphs
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
setGlyphVisible	TokenNameIdentifier	 set Glyph Visible
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// calculate the total length of the glyphs, this will become be 	TokenNameCOMMENT_LINE	calculate the total length of the glyphs, this will become be 
// the length along the path that is used by the text 	TokenNameCOMMENT_LINE	the length along the path that is used by the text 
float	TokenNamefloat	
glyphsLength	TokenNameIdentifier	 glyphs Length
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
horizontal	TokenNameIdentifier	 horizontal
)	TokenNameRPAREN	
{	TokenNameLBRACE	
glyphsLength	TokenNameIdentifier	 glyphs Length
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getLogicalBounds	TokenNameIdentifier	 get Logical Bounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
glyphsLength	TokenNameIdentifier	 glyphs Length
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getLogicalBounds	TokenNameIdentifier	 get Logical Bounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// check that pathLength and glyphsLength are not 0 	TokenNameCOMMENT_LINE	check that pathLength and glyphsLength are not 0 
if	TokenNameif	
(	TokenNameLPAREN	
pathLength	TokenNameIdentifier	 path Length
==	TokenNameEQUAL_EQUAL	
0f	TokenNameFloatingPointLiteral	
||	TokenNameOR_OR	
glyphsLength	TokenNameIdentifier	 glyphs Length
==	TokenNameEQUAL_EQUAL	
0f	TokenNameFloatingPointLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// We applied the empty path. 	TokenNameCOMMENT_LINE	We applied the empty path. 
pathApplied	TokenNameIdentifier	 path Applied
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
textPathAdvance	TokenNameIdentifier	 text Path Advance
=	TokenNameEQUAL	
advance	TokenNameIdentifier	 advance
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// the current start point of the character on the path 	TokenNameCOMMENT_LINE	the current start point of the character on the path 
// calculate the offset of the first glyph the offset will be 	TokenNameCOMMENT_LINE	calculate the offset of the first glyph the offset will be 
// 0 if the glyph is on the path (ie. not adjusted by a dy or 	TokenNameCOMMENT_LINE	0 if the glyph is on the path (ie. not adjusted by a dy or 
// dx) 	TokenNameCOMMENT_LINE	dx) 
Point2D	TokenNameIdentifier	 Point2 D
firstGlyphPosition	TokenNameIdentifier	 first Glyph Position
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphPosition	TokenNameIdentifier	 get Glyph Position
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
glyphOffset	TokenNameIdentifier	 glyph Offset
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// offset perpendicular to path 	TokenNameCOMMENT_LINE	offset perpendicular to path 
float	TokenNamefloat	
currentPosition	TokenNameIdentifier	 current Position
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
horizontal	TokenNameIdentifier	 horizontal
)	TokenNameRPAREN	
{	TokenNameLBRACE	
glyphOffset	TokenNameIdentifier	 glyph Offset
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
firstGlyphPosition	TokenNameIdentifier	 first Glyph Position
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
currentPosition	TokenNameIdentifier	 current Position
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
firstGlyphPosition	TokenNameIdentifier	 first Glyph Position
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
startOffset	TokenNameIdentifier	 start Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
glyphOffset	TokenNameIdentifier	 glyph Offset
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
firstGlyphPosition	TokenNameIdentifier	 first Glyph Position
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
currentPosition	TokenNameIdentifier	 current Position
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
firstGlyphPosition	TokenNameIdentifier	 first Glyph Position
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
startOffset	TokenNameIdentifier	 start Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
char	TokenNamechar	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
first	TokenNameIdentifier	 first
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
start	TokenNameIdentifier	 start
=	TokenNameEQUAL	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
getBeginIndex	TokenNameIdentifier	 get Begin Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
currentChar	TokenNameIdentifier	 current Char
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
lastGlyphDrawn	TokenNameIdentifier	 last Glyph Drawn
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
lastGlyphAdvance	TokenNameIdentifier	 last Glyph Advance
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// iterate through the GlyphVector placing each glyph 	TokenNameCOMMENT_LINE	iterate through the GlyphVector placing each glyph 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numGlyphs	TokenNameIdentifier	 num Glyphs
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Point2D	TokenNameIdentifier	 Point2 D
currentGlyphPos	TokenNameIdentifier	 current Glyph Pos
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphPosition	TokenNameIdentifier	 get Glyph Position
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// calculate the advance and offset for the next glyph, do it 	TokenNameCOMMENT_LINE	calculate the advance and offset for the next glyph, do it 
// now before we modify the current glyph position 	TokenNameCOMMENT_LINE	now before we modify the current glyph position 
float	TokenNamefloat	
glyphAdvance	TokenNameIdentifier	 glyph Advance
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// along path 	TokenNameCOMMENT_LINE	along path 
float	TokenNamefloat	
nextGlyphOffset	TokenNameIdentifier	 next Glyph Offset
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// perpendicular to path eg dy or dx 	TokenNameCOMMENT_LINE	perpendicular to path eg dy or dx 
Point2D	TokenNameIdentifier	 Point2 D
nextGlyphPosition	TokenNameIdentifier	 next Glyph Position
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphPosition	TokenNameIdentifier	 get Glyph Position
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
horizontal	TokenNameIdentifier	 horizontal
)	TokenNameRPAREN	
{	TokenNameLBRACE	
glyphAdvance	TokenNameIdentifier	 glyph Advance
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
nextGlyphPosition	TokenNameIdentifier	 next Glyph Position
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
currentGlyphPos	TokenNameIdentifier	 current Glyph Pos
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
nextGlyphOffset	TokenNameIdentifier	 next Glyph Offset
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
nextGlyphPosition	TokenNameIdentifier	 next Glyph Position
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
currentGlyphPos	TokenNameIdentifier	 current Glyph Pos
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
glyphAdvance	TokenNameIdentifier	 glyph Advance
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
nextGlyphPosition	TokenNameIdentifier	 next Glyph Position
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
currentGlyphPos	TokenNameIdentifier	 current Glyph Pos
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
nextGlyphOffset	TokenNameIdentifier	 next Glyph Offset
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
nextGlyphPosition	TokenNameIdentifier	 next Glyph Position
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
currentGlyphPos	TokenNameIdentifier	 current Glyph Pos
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// calculate the center line position for the glyph 	TokenNameCOMMENT_LINE	calculate the center line position for the glyph 
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
glyphBounds	TokenNameIdentifier	 glyph Bounds
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphOutline	TokenNameIdentifier	 get Glyph Outline
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
.	TokenNameDOT	
getBounds2D	TokenNameIdentifier	 get Bounds2 D
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
glyphWidth	TokenNameIdentifier	 glyph Width
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
glyphBounds	TokenNameIdentifier	 glyph Bounds
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
glyphHeight	TokenNameIdentifier	 glyph Height
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
glyphBounds	TokenNameIdentifier	 glyph Bounds
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
glyphMidX	TokenNameIdentifier	 glyph Mid X
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
glyphWidth	TokenNameIdentifier	 glyph Width
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
glyphMidX	TokenNameIdentifier	 glyph Mid X
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
glyphBounds	TokenNameIdentifier	 glyph Bounds
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
glyphWidth	TokenNameIdentifier	 glyph Width
/	TokenNameDIVIDE	
2f	TokenNameFloatingPointLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
glyphMidX	TokenNameIdentifier	 glyph Mid X
-=	TokenNameMINUS_EQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
currentGlyphPos	TokenNameIdentifier	 current Glyph Pos
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
float	TokenNamefloat	
glyphMidY	TokenNameIdentifier	 glyph Mid Y
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
glyphHeight	TokenNameIdentifier	 glyph Height
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
glyphMidY	TokenNameIdentifier	 glyph Mid Y
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
glyphBounds	TokenNameIdentifier	 glyph Bounds
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
glyphHeight	TokenNameIdentifier	 glyph Height
/	TokenNameDIVIDE	
2f	TokenNameFloatingPointLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
glyphMidY	TokenNameIdentifier	 glyph Mid Y
-=	TokenNameMINUS_EQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
currentGlyphPos	TokenNameIdentifier	 current Glyph Pos
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// System.err.println("GMX: " + glyphMidX + 	TokenNameCOMMENT_LINE	System.err.println("GMX: " + glyphMidX + 
// " W2: " + (glyphWidth/2) + 	TokenNameCOMMENT_LINE	" W2: " + (glyphWidth/2) + 
// " PosX: " + currentGlyphPos.getX() + 	TokenNameCOMMENT_LINE	" PosX: " + currentGlyphPos.getX() + 
// " BX: " + glyphBounds.getX()); 	TokenNameCOMMENT_LINE	" BX: " + glyphBounds.getX()); 
// 	TokenNameCOMMENT_LINE	 
// System.err.println("GMY: " + glyphMidY + 	TokenNameCOMMENT_LINE	System.err.println("GMY: " + glyphMidY + 
// " H2: " + (glyphHeight/2) + 	TokenNameCOMMENT_LINE	" H2: " + (glyphHeight/2) + 
// " PosY: " + currentGlyphPos.getY() + 	TokenNameCOMMENT_LINE	" PosY: " + currentGlyphPos.getY() + 
// " BY: " + glyphBounds.getY()); 	TokenNameCOMMENT_LINE	" BY: " + glyphBounds.getY()); 
float	TokenNamefloat	
charMidPos	TokenNameIdentifier	 char Mid Pos
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
horizontal	TokenNameIdentifier	 horizontal
)	TokenNameRPAREN	
{	TokenNameLBRACE	
charMidPos	TokenNameIdentifier	 char Mid Pos
=	TokenNameEQUAL	
currentPosition	TokenNameIdentifier	 current Position
+	TokenNamePLUS	
glyphMidX	TokenNameIdentifier	 glyph Mid X
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
charMidPos	TokenNameIdentifier	 char Mid Pos
=	TokenNameEQUAL	
currentPosition	TokenNameIdentifier	 current Position
+	TokenNamePLUS	
glyphMidY	TokenNameIdentifier	 glyph Mid Y
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Calculate the actual point to place the glyph around 	TokenNameCOMMENT_LINE	Calculate the actual point to place the glyph around 
Point2D	TokenNameIdentifier	 Point2 D
charMidPoint	TokenNameIdentifier	 char Mid Point
=	TokenNameEQUAL	
textPath	TokenNameIdentifier	 text Path
.	TokenNameDOT	
pointAtLength	TokenNameIdentifier	 point At Length
(	TokenNameLPAREN	
charMidPos	TokenNameIdentifier	 char Mid Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Check if the glyph is actually on the path 	TokenNameCOMMENT_LINE	Check if the glyph is actually on the path 
if	TokenNameif	
(	TokenNameLPAREN	
charMidPoint	TokenNameIdentifier	 char Mid Point
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Calculate the normal to the path (midline of glyph) 	TokenNameCOMMENT_LINE	Calculate the normal to the path (midline of glyph) 
float	TokenNamefloat	
angle	TokenNameIdentifier	 angle
=	TokenNameEQUAL	
textPath	TokenNameIdentifier	 text Path
.	TokenNameDOT	
angleAtLength	TokenNameIdentifier	 angle At Length
(	TokenNameLPAREN	
charMidPos	TokenNameIdentifier	 char Mid Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Define the transform of the glyph 	TokenNameCOMMENT_LINE	Define the transform of the glyph 
AffineTransform	TokenNameIdentifier	 Affine Transform
glyphPathTransform	TokenNameIdentifier	 glyph Path Transform
=	TokenNameEQUAL	
new	TokenNamenew	
AffineTransform	TokenNameIdentifier	 Affine Transform
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// rotate midline of glyph to be normal to path 	TokenNameCOMMENT_LINE	rotate midline of glyph to be normal to path 
if	TokenNameif	
(	TokenNameLPAREN	
horizontal	TokenNameIdentifier	 horizontal
)	TokenNameRPAREN	
{	TokenNameLBRACE	
glyphPathTransform	TokenNameIdentifier	 glyph Path Transform
.	TokenNameDOT	
rotate	TokenNameIdentifier	 rotate
(	TokenNameLPAREN	
angle	TokenNameIdentifier	 angle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
glyphPathTransform	TokenNameIdentifier	 glyph Path Transform
.	TokenNameDOT	
rotate	TokenNameIdentifier	 rotate
(	TokenNameLPAREN	
angle	TokenNameIdentifier	 angle
-	TokenNameMINUS	
(	TokenNameLPAREN	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
PI	TokenNameIdentifier	 PI
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// re-apply any offset eg from tspan, or spacing adjust 	TokenNameCOMMENT_LINE	re-apply any offset eg from tspan, or spacing adjust 
if	TokenNameif	
(	TokenNameLPAREN	
horizontal	TokenNameIdentifier	 horizontal
)	TokenNameRPAREN	
{	TokenNameLBRACE	
glyphPathTransform	TokenNameIdentifier	 glyph Path Transform
.	TokenNameDOT	
translate	TokenNameIdentifier	 translate
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
glyphOffset	TokenNameIdentifier	 glyph Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
glyphPathTransform	TokenNameIdentifier	 glyph Path Transform
.	TokenNameDOT	
translate	TokenNameIdentifier	 translate
(	TokenNameLPAREN	
glyphOffset	TokenNameIdentifier	 glyph Offset
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// translate glyph backwards so we rotate about the 	TokenNameCOMMENT_LINE	translate glyph backwards so we rotate about the 
// center of the glyph 	TokenNameCOMMENT_LINE	center of the glyph 
if	TokenNameif	
(	TokenNameLPAREN	
horizontal	TokenNameIdentifier	 horizontal
)	TokenNameRPAREN	
{	TokenNameLBRACE	
glyphPathTransform	TokenNameIdentifier	 glyph Path Transform
.	TokenNameDOT	
translate	TokenNameIdentifier	 translate
(	TokenNameLPAREN	
-	TokenNameMINUS	
glyphMidX	TokenNameIdentifier	 glyph Mid X
,	TokenNameCOMMA	
0f	TokenNameFloatingPointLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
glyphPathTransform	TokenNameIdentifier	 glyph Path Transform
.	TokenNameDOT	
translate	TokenNameIdentifier	 translate
(	TokenNameLPAREN	
0f	TokenNameFloatingPointLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
glyphMidY	TokenNameIdentifier	 glyph Mid Y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// set the new glyph position and transform 	TokenNameCOMMENT_LINE	set the new glyph position and transform 
AffineTransform	TokenNameIdentifier	 Affine Transform
glyphTransform	TokenNameIdentifier	 glyph Transform
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphTransform	TokenNameIdentifier	 get Glyph Transform
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
glyphTransform	TokenNameIdentifier	 glyph Transform
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
glyphPathTransform	TokenNameIdentifier	 glyph Path Transform
.	TokenNameDOT	
concatenate	TokenNameIdentifier	 concatenate
(	TokenNameLPAREN	
glyphTransform	TokenNameIdentifier	 glyph Transform
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
setGlyphTransform	TokenNameIdentifier	 set Glyph Transform
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
glyphPathTransform	TokenNameIdentifier	 glyph Path Transform
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
setGlyphPosition	TokenNameIdentifier	 set Glyph Position
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
charMidPoint	TokenNameIdentifier	 char Mid Point
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// keep track of the last glyph drawn to make calculating the 	TokenNameCOMMENT_LINE	keep track of the last glyph drawn to make calculating the 
// textPathAdvance value easier later 	TokenNameCOMMENT_LINE	textPathAdvance value easier later 
lastGlyphDrawn	TokenNameIdentifier	 last Glyph Drawn
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
lastGlyphAdvance	TokenNameIdentifier	 last Glyph Advance
=	TokenNameEQUAL	
glyphAdvance	TokenNameIdentifier	 glyph Advance
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// not on path so don't render 	TokenNameCOMMENT_LINE	not on path so don't render 
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
setGlyphVisible	TokenNameIdentifier	 set Glyph Visible
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
currentPosition	TokenNameIdentifier	 current Position
+=	TokenNamePLUS_EQUAL	
glyphAdvance	TokenNameIdentifier	 glyph Advance
;	TokenNameSEMICOLON	
glyphOffset	TokenNameIdentifier	 glyph Offset
+=	TokenNamePLUS_EQUAL	
nextGlyphOffset	TokenNameIdentifier	 next Glyph Offset
;	TokenNameSEMICOLON	
currentChar	TokenNameIdentifier	 current Char
+=	TokenNamePLUS_EQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getCharacterCount	TokenNameIdentifier	 get Character Count
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
currentChar	TokenNameIdentifier	 current Char
>=	TokenNameGREATER_EQUAL	
charMap	TokenNameIdentifier	 char Map
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
currentChar	TokenNameIdentifier	 current Char
=	TokenNameEQUAL	
charMap	TokenNameIdentifier	 char Map
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
setIndex	TokenNameIdentifier	 set Index
(	TokenNameLPAREN	
currentChar	TokenNameIdentifier	 current Char
+	TokenNamePLUS	
start	TokenNameIdentifier	 start
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// store the position where a following glyph should be drawn, 	TokenNameCOMMENT_LINE	store the position where a following glyph should be drawn, 
// note: this will only be used if the following text layout is not 	TokenNameCOMMENT_LINE	note: this will only be used if the following text layout is not 
// on a text path 	TokenNameCOMMENT_LINE	on a text path 
if	TokenNameif	
(	TokenNameLPAREN	
lastGlyphDrawn	TokenNameIdentifier	 last Glyph Drawn
>	TokenNameGREATER	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Point2D	TokenNameIdentifier	 Point2 D
lastGlyphPos	TokenNameIdentifier	 last Glyph Pos
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphPosition	TokenNameIdentifier	 get Glyph Position
(	TokenNameLPAREN	
lastGlyphDrawn	TokenNameIdentifier	 last Glyph Drawn
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
horizontal	TokenNameIdentifier	 horizontal
)	TokenNameRPAREN	
{	TokenNameLBRACE	
textPathAdvance	TokenNameIdentifier	 text Path Advance
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Double	TokenNameIdentifier	 Double
(	TokenNameLPAREN	
lastGlyphPos	TokenNameIdentifier	 last Glyph Pos
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
lastGlyphAdvance	TokenNameIdentifier	 last Glyph Advance
,	TokenNameCOMMA	
lastGlyphPos	TokenNameIdentifier	 last Glyph Pos
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
textPathAdvance	TokenNameIdentifier	 text Path Advance
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Double	TokenNameIdentifier	 Double
(	TokenNameLPAREN	
lastGlyphPos	TokenNameIdentifier	 last Glyph Pos
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
lastGlyphPos	TokenNameIdentifier	 last Glyph Pos
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
lastGlyphAdvance	TokenNameIdentifier	 last Glyph Advance
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
textPathAdvance	TokenNameIdentifier	 text Path Advance
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Double	TokenNameIdentifier	 Double
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// The default layout is junk now... 	TokenNameCOMMENT_LINE	The default layout is junk now... 
layoutApplied	TokenNameIdentifier	 layout Applied
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// The spacing stuff is junk now. 	TokenNameCOMMENT_LINE	The spacing stuff is junk now. 
spacingApplied	TokenNameIdentifier	 spacing Applied
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
pathApplied	TokenNameIdentifier	 path Applied
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns true if the specified character is within one of the Latin * unicode character blocks. * * @param c The char to test. * * @return True if c is latin. */	TokenNameCOMMENT_JAVADOC	 Returns true if the specified character is within one of the Latin unicode character blocks. * @param c The char to test. * @return True if c is latin. 
protected	TokenNameprotected	
boolean	TokenNameboolean	
isLatinChar	TokenNameIdentifier	 is Latin Char
(	TokenNameLPAREN	
char	TokenNamechar	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
<	TokenNameLESS	
255	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
isLetterOrDigit	TokenNameIdentifier	 is Letter Or Digit
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// cheap quick check, should catch most lation-chars 	TokenNameCOMMENT_LINE	cheap quick check, should catch most lation-chars 
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
UnicodeBlock	TokenNameIdentifier	 Unicode Block
block	TokenNameIdentifier	 block
=	TokenNameEQUAL	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
UnicodeBlock	TokenNameIdentifier	 Unicode Block
.	TokenNameDOT	
of	TokenNameIdentifier	 of
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
block	TokenNameIdentifier	 block
==	TokenNameEQUAL_EQUAL	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
UnicodeBlock	TokenNameIdentifier	 Unicode Block
.	TokenNameDOT	
BASIC_LATIN	TokenNameIdentifier	 BASIC  LATIN
||	TokenNameOR_OR	
block	TokenNameIdentifier	 block
==	TokenNameEQUAL_EQUAL	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
UnicodeBlock	TokenNameIdentifier	 Unicode Block
.	TokenNameDOT	
LATIN_1_SUPPLEMENT	TokenNameIdentifier	 LATIN 1  SUPPLEMENT
||	TokenNameOR_OR	
block	TokenNameIdentifier	 block
==	TokenNameEQUAL_EQUAL	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
UnicodeBlock	TokenNameIdentifier	 Unicode Block
.	TokenNameDOT	
LATIN_EXTENDED_ADDITIONAL	TokenNameIdentifier	 LATIN  EXTENDED  ADDITIONAL
||	TokenNameOR_OR	
block	TokenNameIdentifier	 block
==	TokenNameEQUAL_EQUAL	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
UnicodeBlock	TokenNameIdentifier	 Unicode Block
.	TokenNameDOT	
LATIN_EXTENDED_A	TokenNameIdentifier	 LATIN  EXTENDED  A
||	TokenNameOR_OR	
block	TokenNameIdentifier	 block
==	TokenNameEQUAL_EQUAL	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
UnicodeBlock	TokenNameIdentifier	 Unicode Block
.	TokenNameDOT	
LATIN_EXTENDED_B	TokenNameIdentifier	 LATIN  EXTENDED  B
||	TokenNameOR_OR	
block	TokenNameIdentifier	 block
==	TokenNameEQUAL_EQUAL	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
UnicodeBlock	TokenNameIdentifier	 Unicode Block
.	TokenNameDOT	
ARABIC	TokenNameIdentifier	 ARABIC
||	TokenNameOR_OR	
block	TokenNameIdentifier	 block
==	TokenNameEQUAL_EQUAL	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
UnicodeBlock	TokenNameIdentifier	 Unicode Block
.	TokenNameDOT	
ARABIC_PRESENTATION_FORMS_A	TokenNameIdentifier	 ARABIC  PRESENTATION  FORMS  A
||	TokenNameOR_OR	
block	TokenNameIdentifier	 block
==	TokenNameEQUAL_EQUAL	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
UnicodeBlock	TokenNameIdentifier	 Unicode Block
.	TokenNameDOT	
ARABIC_PRESENTATION_FORMS_B	TokenNameIdentifier	 ARABIC  PRESENTATION  FORMS  B
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns whether or not the vertical glyph orientation value is "auto". */	TokenNameCOMMENT_JAVADOC	 Returns whether or not the vertical glyph orientation value is "auto". 
protected	TokenNameprotected	
boolean	TokenNameboolean	
isGlyphOrientationAuto	TokenNameIdentifier	 is Glyph Orientation Auto
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isVertical	TokenNameIdentifier	 is Vertical
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
first	TokenNameIdentifier	 first
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Integer	TokenNameIdentifier	 Integer
vOrient	TokenNameIdentifier	 v Orient
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Integer	TokenNameIdentifier	 Integer
)	TokenNameRPAREN	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
VERTICAL_ORIENTATION	TokenNameIdentifier	 VERTICAL  ORIENTATION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
vOrient	TokenNameIdentifier	 v Orient
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
vOrient	TokenNameIdentifier	 v Orient
==	TokenNameEQUAL_EQUAL	
ORIENTATION_AUTO	TokenNameIdentifier	 ORIENTATION  AUTO
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the value of the vertical glyph orientation angle. This will be * one of 0, 90, 180 or 270. */	TokenNameCOMMENT_JAVADOC	 Returns the value of the vertical glyph orientation angle. This will be one of 0, 90, 180 or 270. 
protected	TokenNameprotected	
int	TokenNameint	
getGlyphOrientationAngle	TokenNameIdentifier	 get Glyph Orientation Angle
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
first	TokenNameIdentifier	 first
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Float	TokenNameIdentifier	 Float
angle	TokenNameIdentifier	 angle
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isVertical	TokenNameIdentifier	 is Vertical
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
angle	TokenNameIdentifier	 angle
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Float	TokenNameIdentifier	 Float
)	TokenNameRPAREN	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
VERTICAL_ORIENTATION_ANGLE	TokenNameIdentifier	 VERTICAL  ORIENTATION  ANGLE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
angle	TokenNameIdentifier	 angle
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Float	TokenNameIdentifier	 Float
)	TokenNameRPAREN	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
HORIZONTAL_ORIENTATION_ANGLE	TokenNameIdentifier	 HORIZONTAL  ORIENTATION  ANGLE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
angle	TokenNameIdentifier	 angle
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
angle	TokenNameIdentifier	 angle
.	TokenNameDOT	
floatValue	TokenNameIdentifier	 float Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if not one of 0, 90, 180 or 270, round to nearest value 	TokenNameCOMMENT_LINE	if not one of 0, 90, 180 or 270, round to nearest value 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
!=	TokenNameNOT_EQUAL	
90	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
// todo - this logic expression 	TokenNameCOMMENT_LINE	todo - this logic expression 
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
!=	TokenNameNOT_EQUAL	
180	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
!=	TokenNameNOT_EQUAL	
270	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// is true for all values..... 	TokenNameCOMMENT_LINE	is true for all values..... 
while	TokenNamewhile	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
+=	TokenNamePLUS_EQUAL	
360	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
>=	TokenNameGREATER_EQUAL	
360	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
-=	TokenNameMINUS_EQUAL	
360	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
<=	TokenNameLESS_EQUAL	
45	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
>	TokenNameGREATER	
315	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
>	TokenNameGREATER	
45	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
<=	TokenNameLESS_EQUAL	
135	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
=	TokenNameEQUAL	
90	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
>	TokenNameGREATER	
135	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
<=	TokenNameLESS_EQUAL	
225	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
=	TokenNameEQUAL	
180	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
=	TokenNameEQUAL	
270	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
glyphOrientationAngle	TokenNameIdentifier	 glyph Orientation Angle
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return true is the character index is represented by glyphs * in this layout. * * @param index index of the character in the ACI. * @return true if the layout represents that character. */	TokenNameCOMMENT_JAVADOC	 Return true is the character index is represented by glyphs in this layout. * @param index index of the character in the ACI. @return true if the layout represents that character. 
public	TokenNamepublic	
boolean	TokenNameboolean	
hasCharacterIndex	TokenNameIdentifier	 has Character Index
(	TokenNameLPAREN	
int	TokenNameint	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
n	TokenNameIdentifier	 n
<	TokenNameLESS	
charMap	TokenNameIdentifier	 char Map
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
n	TokenNameIdentifier	 n
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
==	TokenNameEQUAL_EQUAL	
charMap	TokenNameIdentifier	 char Map
[	TokenNameLBRACKET	
n	TokenNameIdentifier	 n
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return true if this text run represents * an alt glyph. */	TokenNameCOMMENT_JAVADOC	 Return true if this text run represents an alt glyph. 
public	TokenNamepublic	
boolean	TokenNameboolean	
isAltGlyph	TokenNameIdentifier	 is Alt Glyph
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
this	TokenNamethis	
.	TokenNameDOT	
isAltGlyph	TokenNameIdentifier	 is Alt Glyph
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
