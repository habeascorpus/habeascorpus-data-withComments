package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
spell	TokenNameIdentifier	 spell
;	TokenNameSEMICOLON	
/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_JAVADOC	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Comparator	TokenNameIdentifier	 Comparator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
List	TokenNameIdentifier	 List
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
WhitespaceAnalyzer	TokenNameIdentifier	 Whitespace Analyzer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
document	TokenNameIdentifier	 document
.	TokenNameDOT	
Document	TokenNameIdentifier	 Document
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
document	TokenNameIdentifier	 document
.	TokenNameDOT	
Field	TokenNameIdentifier	 Field
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
FieldInfo	TokenNameIdentifier	 Field Info
.	TokenNameDOT	
IndexOptions	TokenNameIdentifier	 Index Options
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
IndexReader	TokenNameIdentifier	 Index Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
IndexWriter	TokenNameIdentifier	 Index Writer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
IndexWriterConfig	TokenNameIdentifier	 Index Writer Config
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
Term	TokenNameIdentifier	 Term
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
IndexWriterConfig	TokenNameIdentifier	 Index Writer Config
.	TokenNameDOT	
OpenMode	TokenNameIdentifier	 Open Mode
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
BooleanClause	TokenNameIdentifier	 Boolean Clause
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
BooleanQuery	TokenNameIdentifier	 Boolean Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
IndexSearcher	TokenNameIdentifier	 Index Searcher
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
Query	TokenNameIdentifier	 Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
ScoreDoc	TokenNameIdentifier	 Score Doc
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
TermQuery	TokenNameIdentifier	 Term Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
AlreadyClosedException	TokenNameIdentifier	 Already Closed Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
Directory	TokenNameIdentifier	 Directory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
BytesRef	TokenNameIdentifier	 Bytes Ref
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
BytesRefIterator	TokenNameIdentifier	 Bytes Ref Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ReaderUtil	TokenNameIdentifier	 Reader Util
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Version	TokenNameIdentifier	 Version
;	TokenNameSEMICOLON	
/** * <p> * Spell Checker class (Main class) <br/> * (initially inspired by the David Spencer code). * </p> * * <p>Example Usage: * * <pre> * SpellChecker spellchecker = new SpellChecker(spellIndexDirectory); * // To index a field of a user index: * spellchecker.indexDictionary(new LuceneDictionary(my_lucene_reader, a_field)); * // To index a file containing words: * spellchecker.indexDictionary(new PlainTextDictionary(new File("myfile.txt"))); * String[] suggestions = spellchecker.suggestSimilar("misspelt", 5); * </pre> * * * @version 1.0 */	TokenNameCOMMENT_JAVADOC	 <p> Spell Checker class (Main class) <br/> (initially inspired by the David Spencer code). </p> * <p>Example Usage: * <pre> SpellChecker spellchecker = new SpellChecker(spellIndexDirectory); // To index a field of a user index: spellchecker.indexDictionary(new LuceneDictionary(my_lucene_reader, a_field)); // To index a file containing words: spellchecker.indexDictionary(new PlainTextDictionary(new File("myfile.txt"))); String[] suggestions = spellchecker.suggestSimilar("misspelt", 5); </pre> * @version 1.0 
public	TokenNamepublic	
class	TokenNameclass	
SpellChecker	TokenNameIdentifier	 Spell Checker
implements	TokenNameimplements	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
Closeable	TokenNameIdentifier	 Closeable
{	TokenNameLBRACE	
/** * The default minimum score to use, if not specified by calling {@link #setAccuracy(float)} . */	TokenNameCOMMENT_JAVADOC	 The default minimum score to use, if not specified by calling {@link #setAccuracy(float)} . 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
float	TokenNamefloat	
DEFAULT_ACCURACY	TokenNameIdentifier	 DEFAULT  ACCURACY
=	TokenNameEQUAL	
0.5f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
/** * Field name for each word in the ngram index. */	TokenNameCOMMENT_JAVADOC	 Field name for each word in the ngram index. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
F_WORD	TokenNameIdentifier	 F  WORD
=	TokenNameEQUAL	
"word"	TokenNameStringLiteral	word
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Term	TokenNameIdentifier	 Term
F_WORD_TERM	TokenNameIdentifier	 F  WORD  TERM
=	TokenNameEQUAL	
new	TokenNamenew	
Term	TokenNameIdentifier	 Term
(	TokenNameLPAREN	
F_WORD	TokenNameIdentifier	 F  WORD
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * the spell index */	TokenNameCOMMENT_JAVADOC	 the spell index 
// don't modify the directory directly - see #swapSearcher() 	TokenNameCOMMENT_LINE	don't modify the directory directly - see #swapSearcher() 
// TODO: why is this package private? 	TokenNameCOMMENT_LINE	TODO: why is this package private? 
Directory	TokenNameIdentifier	 Directory
spellIndex	TokenNameIdentifier	 spell Index
;	TokenNameSEMICOLON	
/** * Boost value for start and end grams */	TokenNameCOMMENT_JAVADOC	 Boost value for start and end grams 
private	TokenNameprivate	
float	TokenNamefloat	
bStart	TokenNameIdentifier	 b Start
=	TokenNameEQUAL	
2.0f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
float	TokenNamefloat	
bEnd	TokenNameIdentifier	 b End
=	TokenNameEQUAL	
1.0f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
// don't use this searcher directly - see #swapSearcher() 	TokenNameCOMMENT_LINE	don't use this searcher directly - see #swapSearcher() 
private	TokenNameprivate	
IndexSearcher	TokenNameIdentifier	 Index Searcher
searcher	TokenNameIdentifier	 searcher
;	TokenNameSEMICOLON	
/* * this locks all modifications to the current searcher. */	TokenNameCOMMENT_BLOCK	 this locks all modifications to the current searcher. 
private	TokenNameprivate	
final	TokenNamefinal	
Object	TokenNameIdentifier	 Object
searcherLock	TokenNameIdentifier	 searcher Lock
=	TokenNameEQUAL	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* * this lock synchronizes all possible modifications to the * current index directory. It should not be possible to try modifying * the same index concurrently. Note: Do not acquire the searcher lock * before acquiring this lock! */	TokenNameCOMMENT_BLOCK	 this lock synchronizes all possible modifications to the current index directory. It should not be possible to try modifying the same index concurrently. Note: Do not acquire the searcher lock before acquiring this lock! 
private	TokenNameprivate	
final	TokenNamefinal	
Object	TokenNameIdentifier	 Object
modifyCurrentIndexLock	TokenNameIdentifier	 modify Current Index Lock
=	TokenNameEQUAL	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
volatile	TokenNamevolatile	
boolean	TokenNameboolean	
closed	TokenNameIdentifier	 closed
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// minimum score for hits generated by the spell checker query 	TokenNameCOMMENT_LINE	minimum score for hits generated by the spell checker query 
private	TokenNameprivate	
float	TokenNamefloat	
accuracy	TokenNameIdentifier	 accuracy
=	TokenNameEQUAL	
DEFAULT_ACCURACY	TokenNameIdentifier	 DEFAULT  ACCURACY
;	TokenNameSEMICOLON	
private	TokenNameprivate	
StringDistance	TokenNameIdentifier	 String Distance
sd	TokenNameIdentifier	 sd
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Comparator	TokenNameIdentifier	 Comparator
<	TokenNameLESS	
SuggestWord	TokenNameIdentifier	 Suggest Word
>	TokenNameGREATER	
comparator	TokenNameIdentifier	 comparator
;	TokenNameSEMICOLON	
/** * Use the given directory as a spell checker index. The directory * is created if it doesn't exist yet. * @param spellIndex the spell index directory * @param sd the {@link StringDistance} measurement to use * @throws IOException if Spellchecker can not open the directory */	TokenNameCOMMENT_JAVADOC	 Use the given directory as a spell checker index. The directory is created if it doesn't exist yet. @param spellIndex the spell index directory @param sd the {@link StringDistance} measurement to use @throws IOException if Spellchecker can not open the directory 
public	TokenNamepublic	
SpellChecker	TokenNameIdentifier	 Spell Checker
(	TokenNameLPAREN	
Directory	TokenNameIdentifier	 Directory
spellIndex	TokenNameIdentifier	 spell Index
,	TokenNameCOMMA	
StringDistance	TokenNameIdentifier	 String Distance
sd	TokenNameIdentifier	 sd
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
this	TokenNamethis	
(	TokenNameLPAREN	
spellIndex	TokenNameIdentifier	 spell Index
,	TokenNameCOMMA	
sd	TokenNameIdentifier	 sd
,	TokenNameCOMMA	
SuggestWordQueue	TokenNameIdentifier	 Suggest Word Queue
.	TokenNameDOT	
DEFAULT_COMPARATOR	TokenNameIdentifier	 DEFAULT  COMPARATOR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Use the given directory as a spell checker index with a * {@link LevensteinDistance} as the default {@link StringDistance}. The * directory is created if it doesn't exist yet. * * @param spellIndex * the spell index directory * @throws IOException * if spellchecker can not open the directory */	TokenNameCOMMENT_JAVADOC	 Use the given directory as a spell checker index with a {@link LevensteinDistance} as the default {@link StringDistance}. The directory is created if it doesn't exist yet. * @param spellIndex the spell index directory @throws IOException if spellchecker can not open the directory 
public	TokenNamepublic	
SpellChecker	TokenNameIdentifier	 Spell Checker
(	TokenNameLPAREN	
Directory	TokenNameIdentifier	 Directory
spellIndex	TokenNameIdentifier	 spell Index
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
this	TokenNamethis	
(	TokenNameLPAREN	
spellIndex	TokenNameIdentifier	 spell Index
,	TokenNameCOMMA	
new	TokenNamenew	
LevensteinDistance	TokenNameIdentifier	 Levenstein Distance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Use the given directory as a spell checker index with the given {@link org.apache.lucene.search.spell.StringDistance} measure * and the given {@link java.util.Comparator} for sorting the results. * @param spellIndex The spelling index * @param sd The distance * @param comparator The comparator * @throws IOException if there is a problem opening the index */	TokenNameCOMMENT_JAVADOC	 Use the given directory as a spell checker index with the given {@link org.apache.lucene.search.spell.StringDistance} measure and the given {@link java.util.Comparator} for sorting the results. @param spellIndex The spelling index @param sd The distance @param comparator The comparator @throws IOException if there is a problem opening the index 
public	TokenNamepublic	
SpellChecker	TokenNameIdentifier	 Spell Checker
(	TokenNameLPAREN	
Directory	TokenNameIdentifier	 Directory
spellIndex	TokenNameIdentifier	 spell Index
,	TokenNameCOMMA	
StringDistance	TokenNameIdentifier	 String Distance
sd	TokenNameIdentifier	 sd
,	TokenNameCOMMA	
Comparator	TokenNameIdentifier	 Comparator
<	TokenNameLESS	
SuggestWord	TokenNameIdentifier	 Suggest Word
>	TokenNameGREATER	
comparator	TokenNameIdentifier	 comparator
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
setSpellIndex	TokenNameIdentifier	 set Spell Index
(	TokenNameLPAREN	
spellIndex	TokenNameIdentifier	 spell Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setStringDistance	TokenNameIdentifier	 set String Distance
(	TokenNameLPAREN	
sd	TokenNameIdentifier	 sd
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
comparator	TokenNameIdentifier	 comparator
=	TokenNameEQUAL	
comparator	TokenNameIdentifier	 comparator
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Use a different index as the spell checker index or re-open * the existing index if <code>spellIndex</code> is the same value * as given in the constructor. * @param spellIndexDir the spell directory to use * @throws AlreadyClosedException if the Spellchecker is already closed * @throws IOException if spellchecker can not open the directory */	TokenNameCOMMENT_JAVADOC	 Use a different index as the spell checker index or re-open the existing index if <code>spellIndex</code> is the same value as given in the constructor. @param spellIndexDir the spell directory to use @throws AlreadyClosedException if the Spellchecker is already closed @throws IOException if spellchecker can not open the directory 
// TODO: we should make this final as it is called in the constructor 	TokenNameCOMMENT_LINE	TODO: we should make this final as it is called in the constructor 
public	TokenNamepublic	
void	TokenNamevoid	
setSpellIndex	TokenNameIdentifier	 set Spell Index
(	TokenNameLPAREN	
Directory	TokenNameIdentifier	 Directory
spellIndexDir	TokenNameIdentifier	 spell Index Dir
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// this could be the same directory as the current spellIndex 	TokenNameCOMMENT_LINE	this could be the same directory as the current spellIndex 
// modifications to the directory should be synchronized 	TokenNameCOMMENT_LINE	modifications to the directory should be synchronized 
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
modifyCurrentIndexLock	TokenNameIdentifier	 modify Current Index Lock
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ensureOpen	TokenNameIdentifier	 ensure Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
IndexReader	TokenNameIdentifier	 Index Reader
.	TokenNameDOT	
indexExists	TokenNameIdentifier	 index Exists
(	TokenNameLPAREN	
spellIndexDir	TokenNameIdentifier	 spell Index Dir
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
IndexWriter	TokenNameIdentifier	 Index Writer
writer	TokenNameIdentifier	 writer
=	TokenNameEQUAL	
new	TokenNamenew	
IndexWriter	TokenNameIdentifier	 Index Writer
(	TokenNameLPAREN	
spellIndexDir	TokenNameIdentifier	 spell Index Dir
,	TokenNameCOMMA	
new	TokenNamenew	
IndexWriterConfig	TokenNameIdentifier	 Index Writer Config
(	TokenNameLPAREN	
Version	TokenNameIdentifier	 Version
.	TokenNameDOT	
LUCENE_CURRENT	TokenNameIdentifier	 LUCENE  CURRENT
,	TokenNameCOMMA	
new	TokenNamenew	
WhitespaceAnalyzer	TokenNameIdentifier	 Whitespace Analyzer
(	TokenNameLPAREN	
Version	TokenNameIdentifier	 Version
.	TokenNameDOT	
LUCENE_CURRENT	TokenNameIdentifier	 LUCENE  CURRENT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
swapSearcher	TokenNameIdentifier	 swap Searcher
(	TokenNameLPAREN	
spellIndexDir	TokenNameIdentifier	 spell Index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Sets the {@link java.util.Comparator} for the {@link SuggestWordQueue}. * @param comparator the comparator */	TokenNameCOMMENT_JAVADOC	 Sets the {@link java.util.Comparator} for the {@link SuggestWordQueue}. @param comparator the comparator 
public	TokenNamepublic	
void	TokenNamevoid	
setComparator	TokenNameIdentifier	 set Comparator
(	TokenNameLPAREN	
Comparator	TokenNameIdentifier	 Comparator
<	TokenNameLESS	
SuggestWord	TokenNameIdentifier	 Suggest Word
>	TokenNameGREATER	
comparator	TokenNameIdentifier	 comparator
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
comparator	TokenNameIdentifier	 comparator
=	TokenNameEQUAL	
comparator	TokenNameIdentifier	 comparator
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Comparator	TokenNameIdentifier	 Comparator
<	TokenNameLESS	
SuggestWord	TokenNameIdentifier	 Suggest Word
>	TokenNameGREATER	
getComparator	TokenNameIdentifier	 get Comparator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
comparator	TokenNameIdentifier	 comparator
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets the {@link StringDistance} implementation for this * {@link SpellChecker} instance. * * @param sd the {@link StringDistance} implementation for this * {@link SpellChecker} instance */	TokenNameCOMMENT_JAVADOC	 Sets the {@link StringDistance} implementation for this {@link SpellChecker} instance. * @param sd the {@link StringDistance} implementation for this {@link SpellChecker} instance 
public	TokenNamepublic	
void	TokenNamevoid	
setStringDistance	TokenNameIdentifier	 set String Distance
(	TokenNameLPAREN	
StringDistance	TokenNameIdentifier	 String Distance
sd	TokenNameIdentifier	 sd
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
sd	TokenNameIdentifier	 sd
=	TokenNameEQUAL	
sd	TokenNameIdentifier	 sd
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the {@link StringDistance} instance used by this * {@link SpellChecker} instance. * * @return the {@link StringDistance} instance used by this * {@link SpellChecker} instance. */	TokenNameCOMMENT_JAVADOC	 Returns the {@link StringDistance} instance used by this {@link SpellChecker} instance. * @return the {@link StringDistance} instance used by this {@link SpellChecker} instance. 
public	TokenNamepublic	
StringDistance	TokenNameIdentifier	 String Distance
getStringDistance	TokenNameIdentifier	 get String Distance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
sd	TokenNameIdentifier	 sd
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets the accuracy 0 &lt; minScore &lt; 1; default {@link #DEFAULT_ACCURACY} * @param acc The new accuracy */	TokenNameCOMMENT_JAVADOC	 Sets the accuracy 0 &lt; minScore &lt; 1; default {@link #DEFAULT_ACCURACY} @param acc The new accuracy 
public	TokenNamepublic	
void	TokenNamevoid	
setAccuracy	TokenNameIdentifier	 set Accuracy
(	TokenNameLPAREN	
float	TokenNamefloat	
acc	TokenNameIdentifier	 acc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
accuracy	TokenNameIdentifier	 accuracy
=	TokenNameEQUAL	
acc	TokenNameIdentifier	 acc
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The accuracy (minimum score) to be used, unless overridden in {@link #suggestSimilar(String, int, org.apache.lucene.index.IndexReader, String, boolean, float)}, to * decide whether a suggestion is included or not. * @return The current accuracy setting */	TokenNameCOMMENT_JAVADOC	 The accuracy (minimum score) to be used, unless overridden in {@link #suggestSimilar(String, int, org.apache.lucene.index.IndexReader, String, boolean, float)}, to decide whether a suggestion is included or not. @return The current accuracy setting 
public	TokenNamepublic	
float	TokenNamefloat	
getAccuracy	TokenNameIdentifier	 get Accuracy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
accuracy	TokenNameIdentifier	 accuracy
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Suggest similar words. * * <p>As the Lucene similarity that is used to fetch the most relevant n-grammed terms * is not the same as the edit distance strategy used to calculate the best * matching spell-checked word from the hits that Lucene found, one usually has * to retrieve a couple of numSug's in order to get the true best match. * * <p>I.e. if numSug == 1, don't count on that suggestion being the best one. * Thus, you should set this value to <b>at least</b> 5 for a good suggestion. * * @param word the word you want a spell check done on * @param numSug the number of suggested words * @throws IOException if the underlying index throws an {@link IOException} * @throws AlreadyClosedException if the Spellchecker is already closed * @return String[] * * @see #suggestSimilar(String, int, org.apache.lucene.index.IndexReader, String, boolean, float) */	TokenNameCOMMENT_JAVADOC	 Suggest similar words. * <p>As the Lucene similarity that is used to fetch the most relevant n-grammed terms is not the same as the edit distance strategy used to calculate the best matching spell-checked word from the hits that Lucene found, one usually has to retrieve a couple of numSug's in order to get the true best match. * <p>I.e. if numSug == 1, don't count on that suggestion being the best one. Thus, you should set this value to <b>at least</b> 5 for a good suggestion. * @param word the word you want a spell check done on @param numSug the number of suggested words @throws IOException if the underlying index throws an {@link IOException} @throws AlreadyClosedException if the Spellchecker is already closed @return String[] * @see #suggestSimilar(String, int, org.apache.lucene.index.IndexReader, String, boolean, float) 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
suggestSimilar	TokenNameIdentifier	 suggest Similar
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
word	TokenNameIdentifier	 word
,	TokenNameCOMMA	
int	TokenNameint	
numSug	TokenNameIdentifier	 num Sug
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
this	TokenNamethis	
.	TokenNameDOT	
suggestSimilar	TokenNameIdentifier	 suggest Similar
(	TokenNameLPAREN	
word	TokenNameIdentifier	 word
,	TokenNameCOMMA	
numSug	TokenNameIdentifier	 num Sug
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
SuggestMode	TokenNameIdentifier	 Suggest Mode
.	TokenNameDOT	
SUGGEST_WHEN_NOT_IN_INDEX	TokenNameIdentifier	 SUGGEST  WHEN  NOT  IN  INDEX
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Suggest similar words. * * <p>As the Lucene similarity that is used to fetch the most relevant n-grammed terms * is not the same as the edit distance strategy used to calculate the best * matching spell-checked word from the hits that Lucene found, one usually has * to retrieve a couple of numSug's in order to get the true best match. * * <p>I.e. if numSug == 1, don't count on that suggestion being the best one. * Thus, you should set this value to <b>at least</b> 5 for a good suggestion. * * @param word the word you want a spell check done on * @param numSug the number of suggested words * @param accuracy The minimum score a suggestion must have in order to qualify for inclusion in the results * @throws IOException if the underlying index throws an {@link IOException} * @throws AlreadyClosedException if the Spellchecker is already closed * @return String[] * * @see #suggestSimilar(String, int, org.apache.lucene.index.IndexReader, String, boolean, float) */	TokenNameCOMMENT_JAVADOC	 Suggest similar words. * <p>As the Lucene similarity that is used to fetch the most relevant n-grammed terms is not the same as the edit distance strategy used to calculate the best matching spell-checked word from the hits that Lucene found, one usually has to retrieve a couple of numSug's in order to get the true best match. * <p>I.e. if numSug == 1, don't count on that suggestion being the best one. Thus, you should set this value to <b>at least</b> 5 for a good suggestion. * @param word the word you want a spell check done on @param numSug the number of suggested words @param accuracy The minimum score a suggestion must have in order to qualify for inclusion in the results @throws IOException if the underlying index throws an {@link IOException} @throws AlreadyClosedException if the Spellchecker is already closed @return String[] * @see #suggestSimilar(String, int, org.apache.lucene.index.IndexReader, String, boolean, float) 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
suggestSimilar	TokenNameIdentifier	 suggest Similar
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
word	TokenNameIdentifier	 word
,	TokenNameCOMMA	
int	TokenNameint	
numSug	TokenNameIdentifier	 num Sug
,	TokenNameCOMMA	
float	TokenNamefloat	
accuracy	TokenNameIdentifier	 accuracy
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
this	TokenNamethis	
.	TokenNameDOT	
suggestSimilar	TokenNameIdentifier	 suggest Similar
(	TokenNameLPAREN	
word	TokenNameIdentifier	 word
,	TokenNameCOMMA	
numSug	TokenNameIdentifier	 num Sug
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
SuggestMode	TokenNameIdentifier	 Suggest Mode
.	TokenNameDOT	
SUGGEST_WHEN_NOT_IN_INDEX	TokenNameIdentifier	 SUGGEST  WHEN  NOT  IN  INDEX
,	TokenNameCOMMA	
accuracy	TokenNameIdentifier	 accuracy
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Suggest similar words (optionally restricted to a field of an index). * * <p>As the Lucene similarity that is used to fetch the most relevant n-grammed terms * is not the same as the edit distance strategy used to calculate the best * matching spell-checked word from the hits that Lucene found, one usually has * to retrieve a couple of numSug's in order to get the true best match. * * <p>I.e. if numSug == 1, don't count on that suggestion being the best one. * Thus, you should set this value to <b>at least</b> 5 for a good suggestion. * * <p>Uses the {@link #getAccuracy()} value passed into the constructor as the accuracy. * * @param word the word you want a spell check done on * @param numSug the number of suggested words * @param ir the indexReader of the user index (can be null see field param) * @param field the field of the user index: if field is not null, the suggested * words are restricted to the words present in this field. * @param morePopular return only the suggest words that are as frequent or more frequent than the searched word * (only if restricted mode = (indexReader!=null and field!=null) * @throws IOException if the underlying index throws an {@link IOException} * @throws AlreadyClosedException if the Spellchecker is already closed * @return String[] the sorted list of the suggest words with these 2 criteria: * first criteria: the edit distance, second criteria (only if restricted mode): the popularity * of the suggest words in the field of the user index * * @see #suggestSimilar(String, int, IndexReader, String, SuggestMode, float) * * @deprecated * use suggestSimilar(String, int, IndexReader, String, SuggestMode) * <ul> * <li>SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX instead of morePopular=false</li> * <li>SuggestMode.SuGGEST_MORE_POPULAR instead of morePopular=true</li> * </ul> */	TokenNameCOMMENT_JAVADOC	 Suggest similar words (optionally restricted to a field of an index). * <p>As the Lucene similarity that is used to fetch the most relevant n-grammed terms is not the same as the edit distance strategy used to calculate the best matching spell-checked word from the hits that Lucene found, one usually has to retrieve a couple of numSug's in order to get the true best match. * <p>I.e. if numSug == 1, don't count on that suggestion being the best one. Thus, you should set this value to <b>at least</b> 5 for a good suggestion. * <p>Uses the {@link #getAccuracy()} value passed into the constructor as the accuracy. * @param word the word you want a spell check done on @param numSug the number of suggested words @param ir the indexReader of the user index (can be null see field param) @param field the field of the user index: if field is not null, the suggested words are restricted to the words present in this field. @param morePopular return only the suggest words that are as frequent or more frequent than the searched word (only if restricted mode = (indexReader!=null and field!=null) @throws IOException if the underlying index throws an {@link IOException} @throws AlreadyClosedException if the Spellchecker is already closed @return String[] the sorted list of the suggest words with these 2 criteria: first criteria: the edit distance, second criteria (only if restricted mode): the popularity of the suggest words in the field of the user index * @see #suggestSimilar(String, int, IndexReader, String, SuggestMode, float) * @deprecated use suggestSimilar(String, int, IndexReader, String, SuggestMode) <ul> <li>SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX instead of morePopular=false</li> <li>SuggestMode.SuGGEST_MORE_POPULAR instead of morePopular=true</li> </ul> 
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
suggestSimilar	TokenNameIdentifier	 suggest Similar
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
word	TokenNameIdentifier	 word
,	TokenNameCOMMA	
int	TokenNameint	
numSug	TokenNameIdentifier	 num Sug
,	TokenNameCOMMA	
IndexReader	TokenNameIdentifier	 Index Reader
ir	TokenNameIdentifier	 ir
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
boolean	TokenNameboolean	
morePopular	TokenNameIdentifier	 more Popular
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
suggestSimilar	TokenNameIdentifier	 suggest Similar
(	TokenNameLPAREN	
word	TokenNameIdentifier	 word
,	TokenNameCOMMA	
numSug	TokenNameIdentifier	 num Sug
,	TokenNameCOMMA	
ir	TokenNameIdentifier	 ir
,	TokenNameCOMMA	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
morePopular	TokenNameIdentifier	 more Popular
,	TokenNameCOMMA	
accuracy	TokenNameIdentifier	 accuracy
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Suggest similar words (optionally restricted to a field of an index). * * <p>As the Lucene similarity that is used to fetch the most relevant n-grammed terms * is not the same as the edit distance strategy used to calculate the best * matching spell-checked word from the hits that Lucene found, one usually has * to retrieve a couple of numSug's in order to get the true best match. * * <p>I.e. if numSug == 1, don't count on that suggestion being the best one. * Thus, you should set this value to <b>at least</b> 5 for a good suggestion. * * @param word the word you want a spell check done on * @param numSug the number of suggested words * @param ir the indexReader of the user index (can be null see field param) * @param field the field of the user index: if field is not null, the suggested * words are restricted to the words present in this field. * @param morePopular return only the suggest words that are as frequent or more frequent than the searched word * (only if restricted mode = (indexReader!=null and field!=null) * @param accuracy The minimum score a suggestion must have in order to qualify for inclusion in the results * @throws IOException if the underlying index throws an {@link IOException} * @throws AlreadyClosedException if the Spellchecker is already closed * @return String[] the sorted list of the suggest words with these 2 criteria: * first criteria: the edit distance, second criteria (only if restricted mode): the popularity * of the suggest words in the field of the user index * * @see #suggestSimilar(String, int, IndexReader, String, SuggestMode, float) * * @deprecated * use suggestSimilar(String, int, IndexReader, String, SuggestMode, float) * <ul> * <li>SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX instead of morePopular=false</li> * <li>SuggestMode.SuGGEST_MORE_POPULAR instead of morePopular=true</li> * </ul> */	TokenNameCOMMENT_JAVADOC	 Suggest similar words (optionally restricted to a field of an index). * <p>As the Lucene similarity that is used to fetch the most relevant n-grammed terms is not the same as the edit distance strategy used to calculate the best matching spell-checked word from the hits that Lucene found, one usually has to retrieve a couple of numSug's in order to get the true best match. * <p>I.e. if numSug == 1, don't count on that suggestion being the best one. Thus, you should set this value to <b>at least</b> 5 for a good suggestion. * @param word the word you want a spell check done on @param numSug the number of suggested words @param ir the indexReader of the user index (can be null see field param) @param field the field of the user index: if field is not null, the suggested words are restricted to the words present in this field. @param morePopular return only the suggest words that are as frequent or more frequent than the searched word (only if restricted mode = (indexReader!=null and field!=null) @param accuracy The minimum score a suggestion must have in order to qualify for inclusion in the results @throws IOException if the underlying index throws an {@link IOException} @throws AlreadyClosedException if the Spellchecker is already closed @return String[] the sorted list of the suggest words with these 2 criteria: first criteria: the edit distance, second criteria (only if restricted mode): the popularity of the suggest words in the field of the user index * @see #suggestSimilar(String, int, IndexReader, String, SuggestMode, float) * @deprecated use suggestSimilar(String, int, IndexReader, String, SuggestMode, float) <ul> <li>SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX instead of morePopular=false</li> <li>SuggestMode.SuGGEST_MORE_POPULAR instead of morePopular=true</li> </ul> 
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
suggestSimilar	TokenNameIdentifier	 suggest Similar
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
word	TokenNameIdentifier	 word
,	TokenNameCOMMA	
int	TokenNameint	
numSug	TokenNameIdentifier	 num Sug
,	TokenNameCOMMA	
IndexReader	TokenNameIdentifier	 Index Reader
ir	TokenNameIdentifier	 ir
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
boolean	TokenNameboolean	
morePopular	TokenNameIdentifier	 more Popular
,	TokenNameCOMMA	
float	TokenNamefloat	
accuracy	TokenNameIdentifier	 accuracy
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
suggestSimilar	TokenNameIdentifier	 suggest Similar
(	TokenNameLPAREN	
word	TokenNameIdentifier	 word
,	TokenNameCOMMA	
numSug	TokenNameIdentifier	 num Sug
,	TokenNameCOMMA	
ir	TokenNameIdentifier	 ir
,	TokenNameCOMMA	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
morePopular	TokenNameIdentifier	 more Popular
?	TokenNameQUESTION	
SuggestMode	TokenNameIdentifier	 Suggest Mode
.	TokenNameDOT	
SUGGEST_MORE_POPULAR	TokenNameIdentifier	 SUGGEST  MORE  POPULAR
:	TokenNameCOLON	
SuggestMode	TokenNameIdentifier	 Suggest Mode
.	TokenNameDOT	
SUGGEST_WHEN_NOT_IN_INDEX	TokenNameIdentifier	 SUGGEST  WHEN  NOT  IN  INDEX
,	TokenNameCOMMA	
accuracy	TokenNameIdentifier	 accuracy
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Calls {@link #suggestSimilar(String, int, IndexReader, String, SuggestMode, float) * suggestSimilar(word, numSug, ir, suggestMode, field, this.accuracy)} * */	TokenNameCOMMENT_JAVADOC	 Calls {@link #suggestSimilar(String, int, IndexReader, String, SuggestMode, float) suggestSimilar(word, numSug, ir, suggestMode, field, this.accuracy)} 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
suggestSimilar	TokenNameIdentifier	 suggest Similar
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
word	TokenNameIdentifier	 word
,	TokenNameCOMMA	
int	TokenNameint	
numSug	TokenNameIdentifier	 num Sug
,	TokenNameCOMMA	
IndexReader	TokenNameIdentifier	 Index Reader
ir	TokenNameIdentifier	 ir
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
SuggestMode	TokenNameIdentifier	 Suggest Mode
suggestMode	TokenNameIdentifier	 suggest Mode
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
suggestSimilar	TokenNameIdentifier	 suggest Similar
(	TokenNameLPAREN	
word	TokenNameIdentifier	 word
,	TokenNameCOMMA	
numSug	TokenNameIdentifier	 num Sug
,	TokenNameCOMMA	
ir	TokenNameIdentifier	 ir
,	TokenNameCOMMA	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
suggestMode	TokenNameIdentifier	 suggest Mode
,	TokenNameCOMMA	
this	TokenNamethis	
.	TokenNameDOT	
accuracy	TokenNameIdentifier	 accuracy
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Suggest similar words (optionally restricted to a field of an index). * * <p>As the Lucene similarity that is used to fetch the most relevant n-grammed terms * is not the same as the edit distance strategy used to calculate the best * matching spell-checked word from the hits that Lucene found, one usually has * to retrieve a couple of numSug's in order to get the true best match. * * <p>I.e. if numSug == 1, don't count on that suggestion being the best one. * Thus, you should set this value to <b>at least</b> 5 for a good suggestion. * * @param word the word you want a spell check done on * @param numSug the number of suggested words * @param ir the indexReader of the user index (can be null see field param) * @param field the field of the user index: if field is not null, the suggested * words are restricted to the words present in this field. * @param suggestMode * (NOTE: if indexReader==null and/or field==null, then this is overridden with SuggestMode.SUGGEST_ALWAYS) * @param accuracy The minimum score a suggestion must have in order to qualify for inclusion in the results * @throws IOException if the underlying index throws an {@link IOException} * @throws AlreadyClosedException if the Spellchecker is already closed * @return String[] the sorted list of the suggest words with these 2 criteria: * first criteria: the edit distance, second criteria (only if restricted mode): the popularity * of the suggest words in the field of the user index * */	TokenNameCOMMENT_JAVADOC	 Suggest similar words (optionally restricted to a field of an index). * <p>As the Lucene similarity that is used to fetch the most relevant n-grammed terms is not the same as the edit distance strategy used to calculate the best matching spell-checked word from the hits that Lucene found, one usually has to retrieve a couple of numSug's in order to get the true best match. * <p>I.e. if numSug == 1, don't count on that suggestion being the best one. Thus, you should set this value to <b>at least</b> 5 for a good suggestion. * @param word the word you want a spell check done on @param numSug the number of suggested words @param ir the indexReader of the user index (can be null see field param) @param field the field of the user index: if field is not null, the suggested words are restricted to the words present in this field. @param suggestMode (NOTE: if indexReader==null and/or field==null, then this is overridden with SuggestMode.SUGGEST_ALWAYS) @param accuracy The minimum score a suggestion must have in order to qualify for inclusion in the results @throws IOException if the underlying index throws an {@link IOException} @throws AlreadyClosedException if the Spellchecker is already closed @return String[] the sorted list of the suggest words with these 2 criteria: first criteria: the edit distance, second criteria (only if restricted mode): the popularity of the suggest words in the field of the user index 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
suggestSimilar	TokenNameIdentifier	 suggest Similar
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
word	TokenNameIdentifier	 word
,	TokenNameCOMMA	
int	TokenNameint	
numSug	TokenNameIdentifier	 num Sug
,	TokenNameCOMMA	
IndexReader	TokenNameIdentifier	 Index Reader
ir	TokenNameIdentifier	 ir
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
SuggestMode	TokenNameIdentifier	 Suggest Mode
suggestMode	TokenNameIdentifier	 suggest Mode
,	TokenNameCOMMA	
float	TokenNamefloat	
accuracy	TokenNameIdentifier	 accuracy
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// obtainSearcher calls ensureOpen 	TokenNameCOMMENT_LINE	obtainSearcher calls ensureOpen 
final	TokenNamefinal	
IndexSearcher	TokenNameIdentifier	 Index Searcher
indexSearcher	TokenNameIdentifier	 index Searcher
=	TokenNameEQUAL	
obtainSearcher	TokenNameIdentifier	 obtain Searcher
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ir	TokenNameIdentifier	 ir
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
field	TokenNameIdentifier	 field
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
suggestMode	TokenNameIdentifier	 suggest Mode
=	TokenNameEQUAL	
SuggestMode	TokenNameIdentifier	 Suggest Mode
.	TokenNameDOT	
SUGGEST_ALWAYS	TokenNameIdentifier	 SUGGEST  ALWAYS
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
suggestMode	TokenNameIdentifier	 suggest Mode
==	TokenNameEQUAL_EQUAL	
SuggestMode	TokenNameIdentifier	 Suggest Mode
.	TokenNameDOT	
SUGGEST_ALWAYS	TokenNameIdentifier	 SUGGEST  ALWAYS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ir	TokenNameIdentifier	 ir
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
field	TokenNameIdentifier	 field
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
int	TokenNameint	
lengthWord	TokenNameIdentifier	 length Word
=	TokenNameEQUAL	
word	TokenNameIdentifier	 word
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
freq	TokenNameIdentifier	 freq
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ir	TokenNameIdentifier	 ir
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
field	TokenNameIdentifier	 field
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
ir	TokenNameIdentifier	 ir
.	TokenNameDOT	
docFreq	TokenNameIdentifier	 doc Freq
(	TokenNameLPAREN	
new	TokenNamenew	
Term	TokenNameIdentifier	 Term
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
word	TokenNameIdentifier	 word
)	TokenNameRPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
goalFreq	TokenNameIdentifier	 goal Freq
=	TokenNameEQUAL	
suggestMode	TokenNameIdentifier	 suggest Mode
==	TokenNameEQUAL_EQUAL	
SuggestMode	TokenNameIdentifier	 Suggest Mode
.	TokenNameDOT	
SUGGEST_MORE_POPULAR	TokenNameIdentifier	 SUGGEST  MORE  POPULAR
?	TokenNameQUESTION	
freq	TokenNameIdentifier	 freq
:	TokenNameCOLON	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// if the word exists in the real index and we don't care for word frequency, return the word itself 	TokenNameCOMMENT_LINE	if the word exists in the real index and we don't care for word frequency, return the word itself 
if	TokenNameif	
(	TokenNameLPAREN	
suggestMode	TokenNameIdentifier	 suggest Mode
==	TokenNameEQUAL_EQUAL	
SuggestMode	TokenNameIdentifier	 Suggest Mode
.	TokenNameDOT	
SUGGEST_WHEN_NOT_IN_INDEX	TokenNameIdentifier	 SUGGEST  WHEN  NOT  IN  INDEX
&&	TokenNameAND_AND	
freq	TokenNameIdentifier	 freq
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
word	TokenNameIdentifier	 word
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
BooleanQuery	TokenNameIdentifier	 Boolean Query
query	TokenNameIdentifier	 query
=	TokenNameEQUAL	
new	TokenNamenew	
BooleanQuery	TokenNameIdentifier	 Boolean Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
grams	TokenNameIdentifier	 grams
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
ng	TokenNameIdentifier	 ng
=	TokenNameEQUAL	
getMin	TokenNameIdentifier	 get Min
(	TokenNameLPAREN	
lengthWord	TokenNameIdentifier	 length Word
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ng	TokenNameIdentifier	 ng
<=	TokenNameLESS_EQUAL	
getMax	TokenNameIdentifier	 get Max
(	TokenNameLPAREN	
lengthWord	TokenNameIdentifier	 length Word
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ng	TokenNameIdentifier	 ng
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
"gram"	TokenNameStringLiteral	gram
+	TokenNamePLUS	
ng	TokenNameIdentifier	 ng
;	TokenNameSEMICOLON	
// form key 	TokenNameCOMMENT_LINE	form key 
grams	TokenNameIdentifier	 grams
=	TokenNameEQUAL	
formGrams	TokenNameIdentifier	 form Grams
(	TokenNameLPAREN	
word	TokenNameIdentifier	 word
,	TokenNameCOMMA	
ng	TokenNameIdentifier	 ng
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// form word into ngrams (allow dups too) 	TokenNameCOMMENT_LINE	form word into ngrams (allow dups too) 
if	TokenNameif	
(	TokenNameLPAREN	
grams	TokenNameIdentifier	 grams
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
// hmm 	TokenNameCOMMENT_LINE	hmm 
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
bStart	TokenNameIdentifier	 b Start
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// should we boost prefixes? 	TokenNameCOMMENT_LINE	should we boost prefixes? 
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
"start"	TokenNameStringLiteral	start
+	TokenNamePLUS	
ng	TokenNameIdentifier	 ng
,	TokenNameCOMMA	
grams	TokenNameIdentifier	 grams
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
bStart	TokenNameIdentifier	 b Start
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// matches start of word 	TokenNameCOMMENT_LINE	matches start of word 
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
bEnd	TokenNameIdentifier	 b End
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// should we boost suffixes 	TokenNameCOMMENT_LINE	should we boost suffixes 
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
"end"	TokenNameStringLiteral	end
+	TokenNamePLUS	
ng	TokenNameIdentifier	 ng
,	TokenNameCOMMA	
grams	TokenNameIdentifier	 grams
[	TokenNameLBRACKET	
grams	TokenNameIdentifier	 grams
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
bEnd	TokenNameIdentifier	 b End
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// matches end of word 	TokenNameCOMMENT_LINE	matches end of word 
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
grams	TokenNameIdentifier	 grams
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
grams	TokenNameIdentifier	 grams
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
int	TokenNameint	
maxHits	TokenNameIdentifier	 max Hits
=	TokenNameEQUAL	
10	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
numSug	TokenNameIdentifier	 num Sug
;	TokenNameSEMICOLON	
// System.out.println("Q: " + query); 	TokenNameCOMMENT_LINE	System.out.println("Q: " + query); 
ScoreDoc	TokenNameIdentifier	 Score Doc
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
hits	TokenNameIdentifier	 hits
=	TokenNameEQUAL	
indexSearcher	TokenNameIdentifier	 index Searcher
.	TokenNameDOT	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
maxHits	TokenNameIdentifier	 max Hits
)	TokenNameRPAREN	
.	TokenNameDOT	
scoreDocs	TokenNameIdentifier	 score Docs
;	TokenNameSEMICOLON	
// System.out.println("HITS: " + hits.length()); 	TokenNameCOMMENT_LINE	System.out.println("HITS: " + hits.length()); 
SuggestWordQueue	TokenNameIdentifier	 Suggest Word Queue
sugQueue	TokenNameIdentifier	 sug Queue
=	TokenNameEQUAL	
new	TokenNamenew	
SuggestWordQueue	TokenNameIdentifier	 Suggest Word Queue
(	TokenNameLPAREN	
numSug	TokenNameIdentifier	 num Sug
,	TokenNameCOMMA	
comparator	TokenNameIdentifier	 comparator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// go thru more than 'maxr' matches in case the distance filter triggers 	TokenNameCOMMENT_LINE	go thru more than 'maxr' matches in case the distance filter triggers 
int	TokenNameint	
stop	TokenNameIdentifier	 stop
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
min	TokenNameIdentifier	 min
(	TokenNameLPAREN	
hits	TokenNameIdentifier	 hits
.	TokenNameDOT	
length	TokenNameIdentifier	 length
,	TokenNameCOMMA	
maxHits	TokenNameIdentifier	 max Hits
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SuggestWord	TokenNameIdentifier	 Suggest Word
sugWord	TokenNameIdentifier	 sug Word
=	TokenNameEQUAL	
new	TokenNamenew	
SuggestWord	TokenNameIdentifier	 Suggest Word
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
stop	TokenNameIdentifier	 stop
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sugWord	TokenNameIdentifier	 sug Word
.	TokenNameDOT	
string	TokenNameIdentifier	 string
=	TokenNameEQUAL	
indexSearcher	TokenNameIdentifier	 index Searcher
.	TokenNameDOT	
doc	TokenNameIdentifier	 doc
(	TokenNameLPAREN	
hits	TokenNameIdentifier	 hits
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
doc	TokenNameIdentifier	 doc
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
F_WORD	TokenNameIdentifier	 F  WORD
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// get orig word 	TokenNameCOMMENT_LINE	get orig word 
// don't suggest a word for itself, that would be silly 	TokenNameCOMMENT_LINE	don't suggest a word for itself, that would be silly 
if	TokenNameif	
(	TokenNameLPAREN	
sugWord	TokenNameIdentifier	 sug Word
.	TokenNameDOT	
string	TokenNameIdentifier	 string
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
word	TokenNameIdentifier	 word
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// edit distance 	TokenNameCOMMENT_LINE	edit distance 
sugWord	TokenNameIdentifier	 sug Word
.	TokenNameDOT	
score	TokenNameIdentifier	 score
=	TokenNameEQUAL	
sd	TokenNameIdentifier	 sd
.	TokenNameDOT	
getDistance	TokenNameIdentifier	 get Distance
(	TokenNameLPAREN	
word	TokenNameIdentifier	 word
,	TokenNameCOMMA	
sugWord	TokenNameIdentifier	 sug Word
.	TokenNameDOT	
string	TokenNameIdentifier	 string
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sugWord	TokenNameIdentifier	 sug Word
.	TokenNameDOT	
score	TokenNameIdentifier	 score
<	TokenNameLESS	
accuracy	TokenNameIdentifier	 accuracy
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ir	TokenNameIdentifier	 ir
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
field	TokenNameIdentifier	 field
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// use the user index 	TokenNameCOMMENT_LINE	use the user index 
sugWord	TokenNameIdentifier	 sug Word
.	TokenNameDOT	
freq	TokenNameIdentifier	 freq
=	TokenNameEQUAL	
ir	TokenNameIdentifier	 ir
.	TokenNameDOT	
docFreq	TokenNameIdentifier	 doc Freq
(	TokenNameLPAREN	
new	TokenNamenew	
Term	TokenNameIdentifier	 Term
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
sugWord	TokenNameIdentifier	 sug Word
.	TokenNameDOT	
string	TokenNameIdentifier	 string
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// freq in the index 	TokenNameCOMMENT_LINE	freq in the index 
// don't suggest a word that is not present in the field 	TokenNameCOMMENT_LINE	don't suggest a word that is not present in the field 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
suggestMode	TokenNameIdentifier	 suggest Mode
==	TokenNameEQUAL_EQUAL	
SuggestMode	TokenNameIdentifier	 Suggest Mode
.	TokenNameDOT	
SUGGEST_MORE_POPULAR	TokenNameIdentifier	 SUGGEST  MORE  POPULAR
&&	TokenNameAND_AND	
goalFreq	TokenNameIdentifier	 goal Freq
>	TokenNameGREATER	
sugWord	TokenNameIdentifier	 sug Word
.	TokenNameDOT	
freq	TokenNameIdentifier	 freq
)	TokenNameRPAREN	
||	TokenNameOR_OR	
sugWord	TokenNameIdentifier	 sug Word
.	TokenNameDOT	
freq	TokenNameIdentifier	 freq
<	TokenNameLESS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
sugQueue	TokenNameIdentifier	 sug Queue
.	TokenNameDOT	
insertWithOverflow	TokenNameIdentifier	 insert With Overflow
(	TokenNameLPAREN	
sugWord	TokenNameIdentifier	 sug Word
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sugQueue	TokenNameIdentifier	 sug Queue
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
numSug	TokenNameIdentifier	 num Sug
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if queue full, maintain the minScore score 	TokenNameCOMMENT_LINE	if queue full, maintain the minScore score 
accuracy	TokenNameIdentifier	 accuracy
=	TokenNameEQUAL	
sugQueue	TokenNameIdentifier	 sug Queue
.	TokenNameDOT	
top	TokenNameIdentifier	 top
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
score	TokenNameIdentifier	 score
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
sugWord	TokenNameIdentifier	 sug Word
=	TokenNameEQUAL	
new	TokenNamenew	
SuggestWord	TokenNameIdentifier	 Suggest Word
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// convert to array string 	TokenNameCOMMENT_LINE	convert to array string 
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
list	TokenNameIdentifier	 list
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
sugQueue	TokenNameIdentifier	 sug Queue
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
sugQueue	TokenNameIdentifier	 sug Queue
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
list	TokenNameIdentifier	 list
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
sugQueue	TokenNameIdentifier	 sug Queue
.	TokenNameDOT	
pop	TokenNameIdentifier	 pop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
string	TokenNameIdentifier	 string
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
list	TokenNameIdentifier	 list
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
releaseSearcher	TokenNameIdentifier	 release Searcher
(	TokenNameLPAREN	
indexSearcher	TokenNameIdentifier	 index Searcher
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Add a clause to a boolean query. */	TokenNameCOMMENT_JAVADOC	 Add a clause to a boolean query. 
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
BooleanQuery	TokenNameIdentifier	 Boolean Query
q	TokenNameIdentifier	 q
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
float	TokenNamefloat	
boost	TokenNameIdentifier	 boost
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Query	TokenNameIdentifier	 Query
tq	TokenNameIdentifier	 tq
=	TokenNameEQUAL	
new	TokenNamenew	
TermQuery	TokenNameIdentifier	 Term Query
(	TokenNameLPAREN	
new	TokenNamenew	
Term	TokenNameIdentifier	 Term
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tq	TokenNameIdentifier	 tq
.	TokenNameDOT	
setBoost	TokenNameIdentifier	 set Boost
(	TokenNameLPAREN	
boost	TokenNameIdentifier	 boost
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
q	TokenNameIdentifier	 q
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
BooleanClause	TokenNameIdentifier	 Boolean Clause
(	TokenNameLPAREN	
tq	TokenNameIdentifier	 tq
,	TokenNameCOMMA	
BooleanClause	TokenNameIdentifier	 Boolean Clause
.	TokenNameDOT	
Occur	TokenNameIdentifier	 Occur
.	TokenNameDOT	
SHOULD	TokenNameIdentifier	 SHOULD
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Add a clause to a boolean query. */	TokenNameCOMMENT_JAVADOC	 Add a clause to a boolean query. 
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
BooleanQuery	TokenNameIdentifier	 Boolean Query
q	TokenNameIdentifier	 q
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
q	TokenNameIdentifier	 q
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
BooleanClause	TokenNameIdentifier	 Boolean Clause
(	TokenNameLPAREN	
new	TokenNamenew	
TermQuery	TokenNameIdentifier	 Term Query
(	TokenNameLPAREN	
new	TokenNamenew	
Term	TokenNameIdentifier	 Term
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
BooleanClause	TokenNameIdentifier	 Boolean Clause
.	TokenNameDOT	
Occur	TokenNameIdentifier	 Occur
.	TokenNameDOT	
SHOULD	TokenNameIdentifier	 SHOULD
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Form all ngrams for a given word. * @param text the word to parse * @param ng the ngram length e.g. 3 * @return an array of all ngrams in the word and note that duplicates are not removed */	TokenNameCOMMENT_JAVADOC	 Form all ngrams for a given word. @param text the word to parse @param ng the ngram length e.g. 3 @return an array of all ngrams in the word and note that duplicates are not removed 
private	TokenNameprivate	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
formGrams	TokenNameIdentifier	 form Grams
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
int	TokenNameint	
ng	TokenNameIdentifier	 ng
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
res	TokenNameIdentifier	 res
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
len	TokenNameIdentifier	 len
-	TokenNameMINUS	
ng	TokenNameIdentifier	 ng
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
-	TokenNameMINUS	
ng	TokenNameIdentifier	 ng
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
res	TokenNameIdentifier	 res
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
ng	TokenNameIdentifier	 ng
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
res	TokenNameIdentifier	 res
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Removes all terms from the spell check index. * @throws IOException * @throws AlreadyClosedException if the Spellchecker is already closed */	TokenNameCOMMENT_JAVADOC	 Removes all terms from the spell check index. @throws IOException @throws AlreadyClosedException if the Spellchecker is already closed 
public	TokenNamepublic	
void	TokenNamevoid	
clearIndex	TokenNameIdentifier	 clear Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
modifyCurrentIndexLock	TokenNameIdentifier	 modify Current Index Lock
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ensureOpen	TokenNameIdentifier	 ensure Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Directory	TokenNameIdentifier	 Directory
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
this	TokenNamethis	
.	TokenNameDOT	
spellIndex	TokenNameIdentifier	 spell Index
;	TokenNameSEMICOLON	
final	TokenNamefinal	
IndexWriter	TokenNameIdentifier	 Index Writer
writer	TokenNameIdentifier	 writer
=	TokenNameEQUAL	
new	TokenNamenew	
IndexWriter	TokenNameIdentifier	 Index Writer
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
new	TokenNamenew	
IndexWriterConfig	TokenNameIdentifier	 Index Writer Config
(	TokenNameLPAREN	
Version	TokenNameIdentifier	 Version
.	TokenNameDOT	
LUCENE_CURRENT	TokenNameIdentifier	 LUCENE  CURRENT
,	TokenNameCOMMA	
new	TokenNamenew	
WhitespaceAnalyzer	TokenNameIdentifier	 Whitespace Analyzer
(	TokenNameLPAREN	
Version	TokenNameIdentifier	 Version
.	TokenNameDOT	
LUCENE_CURRENT	TokenNameIdentifier	 LUCENE  CURRENT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
setOpenMode	TokenNameIdentifier	 set Open Mode
(	TokenNameLPAREN	
OpenMode	TokenNameIdentifier	 Open Mode
.	TokenNameDOT	
CREATE	TokenNameIdentifier	 CREATE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
swapSearcher	TokenNameIdentifier	 swap Searcher
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Check whether the word exists in the index. * @param word * @throws IOException * @throws AlreadyClosedException if the Spellchecker is already closed * @return true if the word exists in the index */	TokenNameCOMMENT_JAVADOC	 Check whether the word exists in the index. @param word @throws IOException @throws AlreadyClosedException if the Spellchecker is already closed @return true if the word exists in the index 
public	TokenNamepublic	
boolean	TokenNameboolean	
exist	TokenNameIdentifier	 exist
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
word	TokenNameIdentifier	 word
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// obtainSearcher calls ensureOpen 	TokenNameCOMMENT_LINE	obtainSearcher calls ensureOpen 
final	TokenNamefinal	
IndexSearcher	TokenNameIdentifier	 Index Searcher
indexSearcher	TokenNameIdentifier	 index Searcher
=	TokenNameEQUAL	
obtainSearcher	TokenNameIdentifier	 obtain Searcher
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
return	TokenNamereturn	
indexSearcher	TokenNameIdentifier	 index Searcher
.	TokenNameDOT	
docFreq	TokenNameIdentifier	 doc Freq
(	TokenNameLPAREN	
F_WORD_TERM	TokenNameIdentifier	 F  WORD  TERM
.	TokenNameDOT	
createTerm	TokenNameIdentifier	 create Term
(	TokenNameLPAREN	
word	TokenNameIdentifier	 word
)	TokenNameRPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
releaseSearcher	TokenNameIdentifier	 release Searcher
(	TokenNameLPAREN	
indexSearcher	TokenNameIdentifier	 index Searcher
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Indexes the data from the given {@link Dictionary}. * @param dict Dictionary to index * @param config {@link IndexWriterConfig} to use * @param fullMerge whether or not the spellcheck index should be fully merged * @throws AlreadyClosedException if the Spellchecker is already closed * @throws IOException */	TokenNameCOMMENT_JAVADOC	 Indexes the data from the given {@link Dictionary}. @param dict Dictionary to index @param config {@link IndexWriterConfig} to use @param fullMerge whether or not the spellcheck index should be fully merged @throws AlreadyClosedException if the Spellchecker is already closed @throws IOException 
public	TokenNamepublic	
final	TokenNamefinal	
void	TokenNamevoid	
indexDictionary	TokenNameIdentifier	 index Dictionary
(	TokenNameLPAREN	
Dictionary	TokenNameIdentifier	 Dictionary
dict	TokenNameIdentifier	 dict
,	TokenNameCOMMA	
IndexWriterConfig	TokenNameIdentifier	 Index Writer Config
config	TokenNameIdentifier	 config
,	TokenNameCOMMA	
boolean	TokenNameboolean	
fullMerge	TokenNameIdentifier	 full Merge
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
modifyCurrentIndexLock	TokenNameIdentifier	 modify Current Index Lock
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ensureOpen	TokenNameIdentifier	 ensure Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Directory	TokenNameIdentifier	 Directory
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
this	TokenNamethis	
.	TokenNameDOT	
spellIndex	TokenNameIdentifier	 spell Index
;	TokenNameSEMICOLON	
final	TokenNamefinal	
IndexWriter	TokenNameIdentifier	 Index Writer
writer	TokenNameIdentifier	 writer
=	TokenNameEQUAL	
new	TokenNamenew	
IndexWriter	TokenNameIdentifier	 Index Writer
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
config	TokenNameIdentifier	 config
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
IndexSearcher	TokenNameIdentifier	 Index Searcher
indexSearcher	TokenNameIdentifier	 index Searcher
=	TokenNameEQUAL	
obtainSearcher	TokenNameIdentifier	 obtain Searcher
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
IndexReader	TokenNameIdentifier	 Index Reader
>	TokenNameGREATER	
readers	TokenNameIdentifier	 readers
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
IndexReader	TokenNameIdentifier	 Index Reader
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
searcher	TokenNameIdentifier	 searcher
.	TokenNameDOT	
maxDoc	TokenNameIdentifier	 max Doc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ReaderUtil	TokenNameIdentifier	 Reader Util
.	TokenNameDOT	
gatherSubReaders	TokenNameIdentifier	 gather Sub Readers
(	TokenNameLPAREN	
readers	TokenNameIdentifier	 readers
,	TokenNameCOMMA	
searcher	TokenNameIdentifier	 searcher
.	TokenNameDOT	
getIndexReader	TokenNameIdentifier	 get Index Reader
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
boolean	TokenNameboolean	
isEmpty	TokenNameIdentifier	 is Empty
=	TokenNameEQUAL	
readers	TokenNameIdentifier	 readers
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
BytesRefIterator	TokenNameIdentifier	 Bytes Ref Iterator
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
dict	TokenNameIdentifier	 dict
.	TokenNameDOT	
getWordsIterator	TokenNameIdentifier	 get Words Iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
BytesRef	TokenNameIdentifier	 Bytes Ref
spare	TokenNameIdentifier	 spare
;	TokenNameSEMICOLON	
terms	TokenNameIdentifier	 terms
:	TokenNameCOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
spare	TokenNameIdentifier	 spare
=	TokenNameEQUAL	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
word	TokenNameIdentifier	 word
=	TokenNameEQUAL	
spare	TokenNameIdentifier	 spare
.	TokenNameDOT	
utf8ToString	TokenNameIdentifier	 utf8 To String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
word	TokenNameIdentifier	 word
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
len	TokenNameIdentifier	 len
<	TokenNameLESS	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
// too short we bail but "too long" is fine... 	TokenNameCOMMENT_LINE	too short we bail but "too long" is fine... 
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isEmpty	TokenNameIdentifier	 is Empty
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// we have a non-empty index, check if the term exists 	TokenNameCOMMENT_LINE	we have a non-empty index, check if the term exists 
Term	TokenNameIdentifier	 Term
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
F_WORD_TERM	TokenNameIdentifier	 F  WORD  TERM
.	TokenNameDOT	
createTerm	TokenNameIdentifier	 create Term
(	TokenNameLPAREN	
word	TokenNameIdentifier	 word
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
IndexReader	TokenNameIdentifier	 Index Reader
ir	TokenNameIdentifier	 ir
:	TokenNameCOLON	
readers	TokenNameIdentifier	 readers
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ir	TokenNameIdentifier	 ir
.	TokenNameDOT	
docFreq	TokenNameIdentifier	 doc Freq
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
terms	TokenNameIdentifier	 terms
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// ok index the word 	TokenNameCOMMENT_LINE	ok index the word 
Document	TokenNameIdentifier	 Document
doc	TokenNameIdentifier	 doc
=	TokenNameEQUAL	
createDocument	TokenNameIdentifier	 create Document
(	TokenNameLPAREN	
word	TokenNameIdentifier	 word
,	TokenNameCOMMA	
getMin	TokenNameIdentifier	 get Min
(	TokenNameLPAREN	
len	TokenNameIdentifier	 len
)	TokenNameRPAREN	
,	TokenNameCOMMA	
getMax	TokenNameIdentifier	 get Max
(	TokenNameLPAREN	
len	TokenNameIdentifier	 len
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
addDocument	TokenNameIdentifier	 add Document
(	TokenNameLPAREN	
doc	TokenNameIdentifier	 doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
releaseSearcher	TokenNameIdentifier	 release Searcher
(	TokenNameLPAREN	
indexSearcher	TokenNameIdentifier	 index Searcher
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fullMerge	TokenNameIdentifier	 full Merge
)	TokenNameRPAREN	
{	TokenNameLBRACE	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
forceMerge	TokenNameIdentifier	 force Merge
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// close writer 	TokenNameCOMMENT_LINE	close writer 
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// TODO: this isn't that great, maybe in the future SpellChecker should take 	TokenNameCOMMENT_LINE	TODO: this isn't that great, maybe in the future SpellChecker should take 
// IWC in its ctor / keep its writer open? 	TokenNameCOMMENT_LINE	IWC in its ctor / keep its writer open? 
// also re-open the spell index to see our own changes when the next suggestion 	TokenNameCOMMENT_LINE	also re-open the spell index to see our own changes when the next suggestion 
// is fetched: 	TokenNameCOMMENT_LINE	is fetched: 
swapSearcher	TokenNameIdentifier	 swap Searcher
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
int	TokenNameint	
getMin	TokenNameIdentifier	 get Min
(	TokenNameLPAREN	
int	TokenNameint	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
l	TokenNameIdentifier	 l
>	TokenNameGREATER	
5	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
l	TokenNameIdentifier	 l
==	TokenNameEQUAL_EQUAL	
5	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
int	TokenNameint	
getMax	TokenNameIdentifier	 get Max
(	TokenNameLPAREN	
int	TokenNameint	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
l	TokenNameIdentifier	 l
>	TokenNameGREATER	
5	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
l	TokenNameIdentifier	 l
==	TokenNameEQUAL_EQUAL	
5	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
Document	TokenNameIdentifier	 Document
createDocument	TokenNameIdentifier	 create Document
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
int	TokenNameint	
ng1	TokenNameIdentifier	 ng1
,	TokenNameCOMMA	
int	TokenNameint	
ng2	TokenNameIdentifier	 ng2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Document	TokenNameIdentifier	 Document
doc	TokenNameIdentifier	 doc
=	TokenNameEQUAL	
new	TokenNamenew	
Document	TokenNameIdentifier	 Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// the word field is never queried on... its indexed so it can be quickly 	TokenNameCOMMENT_LINE	the word field is never queried on... its indexed so it can be quickly 
// checked for rebuild (and stored for retrieval). Doesn't need norms or TF/pos 	TokenNameCOMMENT_LINE	checked for rebuild (and stored for retrieval). Doesn't need norms or TF/pos 
Field	TokenNameIdentifier	 Field
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
new	TokenNamenew	
Field	TokenNameIdentifier	 Field
(	TokenNameLPAREN	
F_WORD	TokenNameIdentifier	 F  WORD
,	TokenNameCOMMA	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Store	TokenNameIdentifier	 Store
.	TokenNameDOT	
YES	TokenNameIdentifier	 YES
,	TokenNameCOMMA	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Index	TokenNameIdentifier	 Index
.	TokenNameDOT	
NOT_ANALYZED	TokenNameIdentifier	 NOT  ANALYZED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
f	TokenNameIdentifier	 f
.	TokenNameDOT	
setIndexOptions	TokenNameIdentifier	 set Index Options
(	TokenNameLPAREN	
IndexOptions	TokenNameIdentifier	 Index Options
.	TokenNameDOT	
DOCS_ONLY	TokenNameIdentifier	 DOCS  ONLY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
f	TokenNameIdentifier	 f
.	TokenNameDOT	
setOmitNorms	TokenNameIdentifier	 set Omit Norms
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
doc	TokenNameIdentifier	 doc
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
f	TokenNameIdentifier	 f
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// orig term 	TokenNameCOMMENT_LINE	orig term 
addGram	TokenNameIdentifier	 add Gram
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
doc	TokenNameIdentifier	 doc
,	TokenNameCOMMA	
ng1	TokenNameIdentifier	 ng1
,	TokenNameCOMMA	
ng2	TokenNameIdentifier	 ng2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
doc	TokenNameIdentifier	 doc
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
addGram	TokenNameIdentifier	 add Gram
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
Document	TokenNameIdentifier	 Document
doc	TokenNameIdentifier	 doc
,	TokenNameCOMMA	
int	TokenNameint	
ng1	TokenNameIdentifier	 ng1
,	TokenNameCOMMA	
int	TokenNameint	
ng2	TokenNameIdentifier	 ng2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
ng	TokenNameIdentifier	 ng
=	TokenNameEQUAL	
ng1	TokenNameIdentifier	 ng1
;	TokenNameSEMICOLON	
ng	TokenNameIdentifier	 ng
<=	TokenNameLESS_EQUAL	
ng2	TokenNameIdentifier	 ng2
;	TokenNameSEMICOLON	
ng	TokenNameIdentifier	 ng
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
"gram"	TokenNameStringLiteral	gram
+	TokenNamePLUS	
ng	TokenNameIdentifier	 ng
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
end	TokenNameIdentifier	 end
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
-	TokenNameMINUS	
ng	TokenNameIdentifier	 ng
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
gram	TokenNameIdentifier	 gram
=	TokenNameEQUAL	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
ng	TokenNameIdentifier	 ng
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Field	TokenNameIdentifier	 Field
ngramField	TokenNameIdentifier	 ngram Field
=	TokenNameEQUAL	
new	TokenNamenew	
Field	TokenNameIdentifier	 Field
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
gram	TokenNameIdentifier	 gram
,	TokenNameCOMMA	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Store	TokenNameIdentifier	 Store
.	TokenNameDOT	
NO	TokenNameIdentifier	 NO
,	TokenNameCOMMA	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Index	TokenNameIdentifier	 Index
.	TokenNameDOT	
NOT_ANALYZED	TokenNameIdentifier	 NOT  ANALYZED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// spellchecker does not use positional queries, but we want freqs 	TokenNameCOMMENT_LINE	spellchecker does not use positional queries, but we want freqs 
// for scoring these multivalued n-gram fields. 	TokenNameCOMMENT_LINE	for scoring these multivalued n-gram fields. 
ngramField	TokenNameIdentifier	 ngram Field
.	TokenNameDOT	
setIndexOptions	TokenNameIdentifier	 set Index Options
(	TokenNameLPAREN	
IndexOptions	TokenNameIdentifier	 Index Options
.	TokenNameDOT	
DOCS_AND_FREQS	TokenNameIdentifier	 DOCS  AND  FREQS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
doc	TokenNameIdentifier	 doc
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
ngramField	TokenNameIdentifier	 ngram Field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// only one term possible in the startXXField, TF/pos and norms aren't needed. 	TokenNameCOMMENT_LINE	only one term possible in the startXXField, TF/pos and norms aren't needed. 
Field	TokenNameIdentifier	 Field
startField	TokenNameIdentifier	 start Field
=	TokenNameEQUAL	
new	TokenNamenew	
Field	TokenNameIdentifier	 Field
(	TokenNameLPAREN	
"start"	TokenNameStringLiteral	start
+	TokenNamePLUS	
ng	TokenNameIdentifier	 ng
,	TokenNameCOMMA	
gram	TokenNameIdentifier	 gram
,	TokenNameCOMMA	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Store	TokenNameIdentifier	 Store
.	TokenNameDOT	
NO	TokenNameIdentifier	 NO
,	TokenNameCOMMA	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Index	TokenNameIdentifier	 Index
.	TokenNameDOT	
NOT_ANALYZED	TokenNameIdentifier	 NOT  ANALYZED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
startField	TokenNameIdentifier	 start Field
.	TokenNameDOT	
setIndexOptions	TokenNameIdentifier	 set Index Options
(	TokenNameLPAREN	
IndexOptions	TokenNameIdentifier	 Index Options
.	TokenNameDOT	
DOCS_ONLY	TokenNameIdentifier	 DOCS  ONLY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
startField	TokenNameIdentifier	 start Field
.	TokenNameDOT	
setOmitNorms	TokenNameIdentifier	 set Omit Norms
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
doc	TokenNameIdentifier	 doc
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
startField	TokenNameIdentifier	 start Field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
end	TokenNameIdentifier	 end
=	TokenNameEQUAL	
gram	TokenNameIdentifier	 gram
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
end	TokenNameIdentifier	 end
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// may not be present if len==ng1 	TokenNameCOMMENT_LINE	may not be present if len==ng1 
// only one term possible in the endXXField, TF/pos and norms aren't needed. 	TokenNameCOMMENT_LINE	only one term possible in the endXXField, TF/pos and norms aren't needed. 
Field	TokenNameIdentifier	 Field
endField	TokenNameIdentifier	 end Field
=	TokenNameEQUAL	
new	TokenNamenew	
Field	TokenNameIdentifier	 Field
(	TokenNameLPAREN	
"end"	TokenNameStringLiteral	end
+	TokenNamePLUS	
ng	TokenNameIdentifier	 ng
,	TokenNameCOMMA	
end	TokenNameIdentifier	 end
,	TokenNameCOMMA	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Store	TokenNameIdentifier	 Store
.	TokenNameDOT	
NO	TokenNameIdentifier	 NO
,	TokenNameCOMMA	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Index	TokenNameIdentifier	 Index
.	TokenNameDOT	
NOT_ANALYZED	TokenNameIdentifier	 NOT  ANALYZED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
endField	TokenNameIdentifier	 end Field
.	TokenNameDOT	
setIndexOptions	TokenNameIdentifier	 set Index Options
(	TokenNameLPAREN	
IndexOptions	TokenNameIdentifier	 Index Options
.	TokenNameDOT	
DOCS_ONLY	TokenNameIdentifier	 DOCS  ONLY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
endField	TokenNameIdentifier	 end Field
.	TokenNameDOT	
setOmitNorms	TokenNameIdentifier	 set Omit Norms
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
doc	TokenNameIdentifier	 doc
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
endField	TokenNameIdentifier	 end Field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
IndexSearcher	TokenNameIdentifier	 Index Searcher
obtainSearcher	TokenNameIdentifier	 obtain Searcher
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
searcherLock	TokenNameIdentifier	 searcher Lock
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ensureOpen	TokenNameIdentifier	 ensure Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
searcher	TokenNameIdentifier	 searcher
.	TokenNameDOT	
getIndexReader	TokenNameIdentifier	 get Index Reader
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
incRef	TokenNameIdentifier	 inc Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
searcher	TokenNameIdentifier	 searcher
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
releaseSearcher	TokenNameIdentifier	 release Searcher
(	TokenNameLPAREN	
final	TokenNamefinal	
IndexSearcher	TokenNameIdentifier	 Index Searcher
aSearcher	TokenNameIdentifier	 a Searcher
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// don't check if open - always decRef 	TokenNameCOMMENT_LINE	don't check if open - always decRef 
// don't decrement the private searcher - could have been swapped 	TokenNameCOMMENT_LINE	don't decrement the private searcher - could have been swapped 
aSearcher	TokenNameIdentifier	 a Searcher
.	TokenNameDOT	
getIndexReader	TokenNameIdentifier	 get Index Reader
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
decRef	TokenNameIdentifier	 dec Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
ensureOpen	TokenNameIdentifier	 ensure Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
closed	TokenNameIdentifier	 closed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
AlreadyClosedException	TokenNameIdentifier	 Already Closed Exception
(	TokenNameLPAREN	
"Spellchecker has been closed"	TokenNameStringLiteral	Spellchecker has been closed
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Close the IndexSearcher used by this SpellChecker * @throws IOException if the close operation causes an {@link IOException} * @throws AlreadyClosedException if the {@link SpellChecker} is already closed */	TokenNameCOMMENT_JAVADOC	 Close the IndexSearcher used by this SpellChecker @throws IOException if the close operation causes an {@link IOException} @throws AlreadyClosedException if the {@link SpellChecker} is already closed 
public	TokenNamepublic	
void	TokenNamevoid	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
searcherLock	TokenNameIdentifier	 searcher Lock
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ensureOpen	TokenNameIdentifier	 ensure Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
closed	TokenNameIdentifier	 closed
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
searcher	TokenNameIdentifier	 searcher
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
searcher	TokenNameIdentifier	 searcher
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
searcher	TokenNameIdentifier	 searcher
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
swapSearcher	TokenNameIdentifier	 swap Searcher
(	TokenNameLPAREN	
final	TokenNamefinal	
Directory	TokenNameIdentifier	 Directory
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
/* * opening a searcher is possibly very expensive. * We rather close it again if the Spellchecker was closed during * this operation than block access to the current searcher while opening. */	TokenNameCOMMENT_BLOCK	 opening a searcher is possibly very expensive. We rather close it again if the Spellchecker was closed during this operation than block access to the current searcher while opening. 
final	TokenNamefinal	
IndexSearcher	TokenNameIdentifier	 Index Searcher
indexSearcher	TokenNameIdentifier	 index Searcher
=	TokenNameEQUAL	
createSearcher	TokenNameIdentifier	 create Searcher
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
searcherLock	TokenNameIdentifier	 searcher Lock
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
closed	TokenNameIdentifier	 closed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
indexSearcher	TokenNameIdentifier	 index Searcher
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
AlreadyClosedException	TokenNameIdentifier	 Already Closed Exception
(	TokenNameLPAREN	
"Spellchecker has been closed"	TokenNameStringLiteral	Spellchecker has been closed
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
searcher	TokenNameIdentifier	 searcher
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
searcher	TokenNameIdentifier	 searcher
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// set the spellindex in the sync block - ensure consistency. 	TokenNameCOMMENT_LINE	set the spellindex in the sync block - ensure consistency. 
searcher	TokenNameIdentifier	 searcher
=	TokenNameEQUAL	
indexSearcher	TokenNameIdentifier	 index Searcher
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
spellIndex	TokenNameIdentifier	 spell Index
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Creates a new read-only IndexSearcher * @param dir the directory used to open the searcher * @return a new read-only IndexSearcher * @throws IOException f there is a low-level IO error */	TokenNameCOMMENT_JAVADOC	 Creates a new read-only IndexSearcher @param dir the directory used to open the searcher @return a new read-only IndexSearcher @throws IOException f there is a low-level IO error 
// for testing purposes 	TokenNameCOMMENT_LINE	for testing purposes 
IndexSearcher	TokenNameIdentifier	 Index Searcher
createSearcher	TokenNameIdentifier	 create Searcher
(	TokenNameLPAREN	
final	TokenNamefinal	
Directory	TokenNameIdentifier	 Directory
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
IndexSearcher	TokenNameIdentifier	 Index Searcher
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns <code>true</code> if and only if the {@link SpellChecker} is * closed, otherwise <code>false</code>. * * @return <code>true</code> if and only if the {@link SpellChecker} is * closed, otherwise <code>false</code>. */	TokenNameCOMMENT_JAVADOC	 Returns <code>true</code> if and only if the {@link SpellChecker} is closed, otherwise <code>false</code>. * @return <code>true</code> if and only if the {@link SpellChecker} is closed, otherwise <code>false</code>. 
boolean	TokenNameboolean	
isClosed	TokenNameIdentifier	 is Closed
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
closed	TokenNameIdentifier	 closed
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
