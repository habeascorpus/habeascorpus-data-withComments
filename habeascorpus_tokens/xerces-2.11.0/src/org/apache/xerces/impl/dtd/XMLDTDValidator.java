/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dtd	TokenNameIdentifier	 dtd
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
Constants	TokenNameIdentifier	 Constants
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
RevalidationHandler	TokenNameIdentifier	 Revalidation Handler
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
XMLEntityManager	TokenNameIdentifier	 XML Entity Manager
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dtd	TokenNameIdentifier	 dtd
.	TokenNameDOT	
models	TokenNameIdentifier	 models
.	TokenNameDOT	
ContentModelValidator	TokenNameIdentifier	 Content Model Validator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
DTDDVFactory	TokenNameIdentifier	 DTDDV Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
DatatypeValidator	TokenNameIdentifier	 Datatype Validator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
msg	TokenNameIdentifier	 msg
.	TokenNameDOT	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
validation	TokenNameIdentifier	 validation
.	TokenNameDOT	
ValidationManager	TokenNameIdentifier	 Validation Manager
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
validation	TokenNameIdentifier	 validation
.	TokenNameDOT	
ValidationState	TokenNameIdentifier	 Validation State
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
SymbolTable	TokenNameIdentifier	 Symbol Table
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
XMLChar	TokenNameIdentifier	 XML Char
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
XMLSymbols	TokenNameIdentifier	 XML Symbols
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
Augmentations	TokenNameIdentifier	 Augmentations
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
NamespaceContext	TokenNameIdentifier	 Namespace Context
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
QName	TokenNameIdentifier	 Q Name
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XMLAttributes	TokenNameIdentifier	 XML Attributes
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XMLDocumentHandler	TokenNameIdentifier	 XML Document Handler
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XMLLocator	TokenNameIdentifier	 XML Locator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XMLResourceIdentifier	TokenNameIdentifier	 XML Resource Identifier
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XMLString	TokenNameIdentifier	 XML String
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XNIException	TokenNameIdentifier	 XNI Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
grammars	TokenNameIdentifier	 grammars
.	TokenNameDOT	
Grammar	TokenNameIdentifier	 Grammar
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
grammars	TokenNameIdentifier	 grammars
.	TokenNameDOT	
XMLGrammarDescription	TokenNameIdentifier	 XML Grammar Description
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
grammars	TokenNameIdentifier	 grammars
.	TokenNameDOT	
XMLGrammarPool	TokenNameIdentifier	 XML Grammar Pool
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLComponent	TokenNameIdentifier	 XML Component
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLComponentManager	TokenNameIdentifier	 XML Component Manager
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLDocumentFilter	TokenNameIdentifier	 XML Document Filter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLDocumentSource	TokenNameIdentifier	 XML Document Source
;	TokenNameSEMICOLON	
/** * The DTD validator. The validator implements a document * filter: receiving document events from the scanner; validating * the content and structure; augmenting the InfoSet, if applicable; * and notifying the parser of the information resulting from the * validation process. * <p> Formerly, this component also handled DTD events and grammar construction. * To facilitate the development of a meaningful DTD grammar caching/preparsing * framework, this functionality has been moved into the XMLDTDLoader * class. Therefore, this class no longer implements the DTDFilter * or DTDContentModelFilter interfaces. * <p> * This component requires the following features and properties from the * component manager that uses it: * <ul> * <li>http://xml.org/sax/features/namespaces</li> * <li>http://xml.org/sax/features/validation</li> * <li>http://apache.org/xml/features/validation/dynamic</li> * <li>http://apache.org/xml/properties/internal/symbol-table</li> * <li>http://apache.org/xml/properties/internal/error-reporter</li> * <li>http://apache.org/xml/properties/internal/grammar-pool</li> * <li>http://apache.org/xml/properties/internal/datatype-validator-factory</li> * </ul> * * @xerces.internal * * @author Eric Ye, IBM * @author Andy Clark, IBM * @author Jeffrey Rodriguez IBM * @author Neil Graham, IBM * * @version $Id: XMLDTDValidator.java 965250 2010-07-18 16:04:58Z mrglavas $ */	TokenNameCOMMENT_JAVADOC	 The DTD validator. The validator implements a document filter: receiving document events from the scanner; validating the content and structure; augmenting the InfoSet, if applicable; and notifying the parser of the information resulting from the validation process. <p> Formerly, this component also handled DTD events and grammar construction. To facilitate the development of a meaningful DTD grammar caching/preparsing framework, this functionality has been moved into the XMLDTDLoader class. Therefore, this class no longer implements the DTDFilter or DTDContentModelFilter interfaces. <p> This component requires the following features and properties from the component manager that uses it: <ul> <li>http://xml.org/sax/features/namespaces</li> <li>http://xml.org/sax/features/validation</li> <li>http://apache.org/xml/features/validation/dynamic</li> <li>http://apache.org/xml/properties/internal/symbol-table</li> <li>http://apache.org/xml/properties/internal/error-reporter</li> <li>http://apache.org/xml/properties/internal/grammar-pool</li> <li>http://apache.org/xml/properties/internal/datatype-validator-factory</li> </ul> * @xerces.internal * @author Eric Ye, IBM @author Andy Clark, IBM @author Jeffrey Rodriguez IBM @author Neil Graham, IBM * @version $Id: XMLDTDValidator.java 965250 2010-07-18 16:04:58Z mrglavas $ 
public	TokenNamepublic	
class	TokenNameclass	
XMLDTDValidator	TokenNameIdentifier	 XMLDTD Validator
implements	TokenNameimplements	
XMLComponent	TokenNameIdentifier	 XML Component
,	TokenNameCOMMA	
XMLDocumentFilter	TokenNameIdentifier	 XML Document Filter
,	TokenNameCOMMA	
XMLDTDValidatorFilter	TokenNameIdentifier	 XMLDTD Validator Filter
,	TokenNameCOMMA	
RevalidationHandler	TokenNameIdentifier	 Revalidation Handler
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// Constants 	TokenNameCOMMENT_LINE	Constants 
// 	TokenNameCOMMENT_LINE	 
/** Symbol: "&lt;&lt;datatypes>>". */	TokenNameCOMMENT_JAVADOC	 Symbol: "&lt;&lt;datatypes>>". 
/** Top level scope (-1). */	TokenNameCOMMENT_JAVADOC	 Top level scope (-1). 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
TOP_LEVEL_SCOPE	TokenNameIdentifier	 TOP  LEVEL  SCOPE
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// feature identifiers 	TokenNameCOMMENT_LINE	feature identifiers 
/** Feature identifier: namespaces. */	TokenNameCOMMENT_JAVADOC	 Feature identifier: namespaces. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
NAMESPACES	TokenNameIdentifier	 NAMESPACES
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SAX_FEATURE_PREFIX	TokenNameIdentifier	 SAX  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
NAMESPACES_FEATURE	TokenNameIdentifier	 NAMESPACES  FEATURE
;	TokenNameSEMICOLON	
/** Feature identifier: validation. */	TokenNameCOMMENT_JAVADOC	 Feature identifier: validation. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
VALIDATION	TokenNameIdentifier	 VALIDATION
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SAX_FEATURE_PREFIX	TokenNameIdentifier	 SAX  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
VALIDATION_FEATURE	TokenNameIdentifier	 VALIDATION  FEATURE
;	TokenNameSEMICOLON	
/** Feature identifier: dynamic validation. */	TokenNameCOMMENT_JAVADOC	 Feature identifier: dynamic validation. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
DYNAMIC_VALIDATION	TokenNameIdentifier	 DYNAMIC  VALIDATION
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
DYNAMIC_VALIDATION_FEATURE	TokenNameIdentifier	 DYNAMIC  VALIDATION  FEATURE
;	TokenNameSEMICOLON	
/** Feature identifier: balance syntax trees. */	TokenNameCOMMENT_JAVADOC	 Feature identifier: balance syntax trees. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
BALANCE_SYNTAX_TREES	TokenNameIdentifier	 BALANCE  SYNTAX  TREES
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
BALANCE_SYNTAX_TREES	TokenNameIdentifier	 BALANCE  SYNTAX  TREES
;	TokenNameSEMICOLON	
/** Feature identifier: warn on duplicate attdef */	TokenNameCOMMENT_JAVADOC	 Feature identifier: warn on duplicate attdef 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
WARN_ON_DUPLICATE_ATTDEF	TokenNameIdentifier	 WARN  ON  DUPLICATE  ATTDEF
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
WARN_ON_DUPLICATE_ATTDEF_FEATURE	TokenNameIdentifier	 WARN  ON  DUPLICATE  ATTDEF  FEATURE
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
PARSER_SETTINGS	TokenNameIdentifier	 PARSER  SETTINGS
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
PARSER_SETTINGS	TokenNameIdentifier	 PARSER  SETTINGS
;	TokenNameSEMICOLON	
// property identifiers 	TokenNameCOMMENT_LINE	property identifiers 
/** Property identifier: symbol table. */	TokenNameCOMMENT_JAVADOC	 Property identifier: symbol table. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
SYMBOL_TABLE	TokenNameIdentifier	 SYMBOL  TABLE
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SYMBOL_TABLE_PROPERTY	TokenNameIdentifier	 SYMBOL  TABLE  PROPERTY
;	TokenNameSEMICOLON	
/** Property identifier: error reporter. */	TokenNameCOMMENT_JAVADOC	 Property identifier: error reporter. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
ERROR_REPORTER	TokenNameIdentifier	 ERROR  REPORTER
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ERROR_REPORTER_PROPERTY	TokenNameIdentifier	 ERROR  REPORTER  PROPERTY
;	TokenNameSEMICOLON	
/** Property identifier: grammar pool. */	TokenNameCOMMENT_JAVADOC	 Property identifier: grammar pool. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
GRAMMAR_POOL	TokenNameIdentifier	 GRAMMAR  POOL
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XMLGRAMMAR_POOL_PROPERTY	TokenNameIdentifier	 XMLGRAMMAR  POOL  PROPERTY
;	TokenNameSEMICOLON	
/** Property identifier: datatype validator factory. */	TokenNameCOMMENT_JAVADOC	 Property identifier: datatype validator factory. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
DATATYPE_VALIDATOR_FACTORY	TokenNameIdentifier	 DATATYPE  VALIDATOR  FACTORY
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
DATATYPE_VALIDATOR_FACTORY_PROPERTY	TokenNameIdentifier	 DATATYPE  VALIDATOR  FACTORY  PROPERTY
;	TokenNameSEMICOLON	
// property identifier: ValidationManager 	TokenNameCOMMENT_LINE	property identifier: ValidationManager 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
VALIDATION_MANAGER	TokenNameIdentifier	 VALIDATION  MANAGER
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
VALIDATION_MANAGER_PROPERTY	TokenNameIdentifier	 VALIDATION  MANAGER  PROPERTY
;	TokenNameSEMICOLON	
// recognized features and properties 	TokenNameCOMMENT_LINE	recognized features and properties 
/** Recognized features. */	TokenNameCOMMENT_JAVADOC	 Recognized features. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
RECOGNIZED_FEATURES	TokenNameIdentifier	 RECOGNIZED  FEATURES
=	TokenNameEQUAL	
{	TokenNameLBRACE	
NAMESPACES	TokenNameIdentifier	 NAMESPACES
,	TokenNameCOMMA	
VALIDATION	TokenNameIdentifier	 VALIDATION
,	TokenNameCOMMA	
DYNAMIC_VALIDATION	TokenNameIdentifier	 DYNAMIC  VALIDATION
,	TokenNameCOMMA	
BALANCE_SYNTAX_TREES	TokenNameIdentifier	 BALANCE  SYNTAX  TREES
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** Feature defaults. */	TokenNameCOMMENT_JAVADOC	 Feature defaults. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Boolean	TokenNameIdentifier	 Boolean
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
FEATURE_DEFAULTS	TokenNameIdentifier	 FEATURE  DEFAULTS
=	TokenNameEQUAL	
{	TokenNameLBRACE	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
FALSE	TokenNameIdentifier	 FALSE
,	TokenNameCOMMA	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
FALSE	TokenNameIdentifier	 FALSE
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** Recognized properties. */	TokenNameCOMMENT_JAVADOC	 Recognized properties. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
RECOGNIZED_PROPERTIES	TokenNameIdentifier	 RECOGNIZED  PROPERTIES
=	TokenNameEQUAL	
{	TokenNameLBRACE	
SYMBOL_TABLE	TokenNameIdentifier	 SYMBOL  TABLE
,	TokenNameCOMMA	
ERROR_REPORTER	TokenNameIdentifier	 ERROR  REPORTER
,	TokenNameCOMMA	
GRAMMAR_POOL	TokenNameIdentifier	 GRAMMAR  POOL
,	TokenNameCOMMA	
DATATYPE_VALIDATOR_FACTORY	TokenNameIdentifier	 DATATYPE  VALIDATOR  FACTORY
,	TokenNameCOMMA	
VALIDATION_MANAGER	TokenNameIdentifier	 VALIDATION  MANAGER
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** Property defaults. */	TokenNameCOMMENT_JAVADOC	 Property defaults. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
PROPERTY_DEFAULTS	TokenNameIdentifier	 PROPERTY  DEFAULTS
=	TokenNameEQUAL	
{	TokenNameLBRACE	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
// debugging 	TokenNameCOMMENT_LINE	debugging 
/** Compile to true to debug attributes. */	TokenNameCOMMENT_JAVADOC	 Compile to true to debug attributes. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
DEBUG_ATTRIBUTES	TokenNameIdentifier	 DEBUG  ATTRIBUTES
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** Compile to true to debug element children. */	TokenNameCOMMENT_JAVADOC	 Compile to true to debug element children. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
DEBUG_ELEMENT_CHILDREN	TokenNameIdentifier	 DEBUG  ELEMENT  CHILDREN
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Data 	TokenNameCOMMENT_LINE	Data 
// 	TokenNameCOMMENT_LINE	 
// updated during reset 	TokenNameCOMMENT_LINE	updated during reset 
protected	TokenNameprotected	
ValidationManager	TokenNameIdentifier	 Validation Manager
fValidationManager	TokenNameIdentifier	 f Validation Manager
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// validation state 	TokenNameCOMMENT_LINE	validation state 
protected	TokenNameprotected	
final	TokenNamefinal	
ValidationState	TokenNameIdentifier	 Validation State
fValidationState	TokenNameIdentifier	 f Validation State
=	TokenNameEQUAL	
new	TokenNamenew	
ValidationState	TokenNameIdentifier	 Validation State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// features 	TokenNameCOMMENT_LINE	features 
/** Namespaces. */	TokenNameCOMMENT_JAVADOC	 Namespaces. 
protected	TokenNameprotected	
boolean	TokenNameboolean	
fNamespaces	TokenNameIdentifier	 f Namespaces
;	TokenNameSEMICOLON	
/** Validation. */	TokenNameCOMMENT_JAVADOC	 Validation. 
protected	TokenNameprotected	
boolean	TokenNameboolean	
fValidation	TokenNameIdentifier	 f Validation
;	TokenNameSEMICOLON	
/** Validation against only DTD */	TokenNameCOMMENT_JAVADOC	 Validation against only DTD 
protected	TokenNameprotected	
boolean	TokenNameboolean	
fDTDValidation	TokenNameIdentifier	 f DTD Validation
;	TokenNameSEMICOLON	
/** * Dynamic validation. This state of this feature is only useful when * the validation feature is set to <code>true</code>. */	TokenNameCOMMENT_JAVADOC	 Dynamic validation. This state of this feature is only useful when the validation feature is set to <code>true</code>. 
protected	TokenNameprotected	
boolean	TokenNameboolean	
fDynamicValidation	TokenNameIdentifier	 f Dynamic Validation
;	TokenNameSEMICOLON	
/** Controls whether the DTD grammar produces balanced syntax trees. */	TokenNameCOMMENT_JAVADOC	 Controls whether the DTD grammar produces balanced syntax trees. 
protected	TokenNameprotected	
boolean	TokenNameboolean	
fBalanceSyntaxTrees	TokenNameIdentifier	 f Balance Syntax Trees
;	TokenNameSEMICOLON	
/** warn on duplicate attribute definition, this feature works only when validation is true */	TokenNameCOMMENT_JAVADOC	 warn on duplicate attribute definition, this feature works only when validation is true 
protected	TokenNameprotected	
boolean	TokenNameboolean	
fWarnDuplicateAttdef	TokenNameIdentifier	 f Warn Duplicate Attdef
;	TokenNameSEMICOLON	
// properties 	TokenNameCOMMENT_LINE	properties 
/** Symbol table. */	TokenNameCOMMENT_JAVADOC	 Symbol table. 
protected	TokenNameprotected	
SymbolTable	TokenNameIdentifier	 Symbol Table
fSymbolTable	TokenNameIdentifier	 f Symbol Table
;	TokenNameSEMICOLON	
/** Error reporter. */	TokenNameCOMMENT_JAVADOC	 Error reporter. 
protected	TokenNameprotected	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
fErrorReporter	TokenNameIdentifier	 f Error Reporter
;	TokenNameSEMICOLON	
// the grammar pool 	TokenNameCOMMENT_LINE	the grammar pool 
protected	TokenNameprotected	
XMLGrammarPool	TokenNameIdentifier	 XML Grammar Pool
fGrammarPool	TokenNameIdentifier	 f Grammar Pool
;	TokenNameSEMICOLON	
/** Grammar bucket. */	TokenNameCOMMENT_JAVADOC	 Grammar bucket. 
protected	TokenNameprotected	
DTDGrammarBucket	TokenNameIdentifier	 DTD Grammar Bucket
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
;	TokenNameSEMICOLON	
/* location of the document as passed in from startDocument call */	TokenNameCOMMENT_BLOCK	 location of the document as passed in from startDocument call 
protected	TokenNameprotected	
XMLLocator	TokenNameIdentifier	 XML Locator
fDocLocation	TokenNameIdentifier	 f Doc Location
;	TokenNameSEMICOLON	
/** Namespace support. */	TokenNameCOMMENT_JAVADOC	 Namespace support. 
protected	TokenNameprotected	
NamespaceContext	TokenNameIdentifier	 Namespace Context
fNamespaceContext	TokenNameIdentifier	 f Namespace Context
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** Datatype validator factory. */	TokenNameCOMMENT_JAVADOC	 Datatype validator factory. 
protected	TokenNameprotected	
DTDDVFactory	TokenNameIdentifier	 DTDDV Factory
fDatatypeValidatorFactory	TokenNameIdentifier	 f Datatype Validator Factory
;	TokenNameSEMICOLON	
// handlers 	TokenNameCOMMENT_LINE	handlers 
/** Document handler. */	TokenNameCOMMENT_JAVADOC	 Document handler. 
protected	TokenNameprotected	
XMLDocumentHandler	TokenNameIdentifier	 XML Document Handler
fDocumentHandler	TokenNameIdentifier	 f Document Handler
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
XMLDocumentSource	TokenNameIdentifier	 XML Document Source
fDocumentSource	TokenNameIdentifier	 f Document Source
;	TokenNameSEMICOLON	
// grammars 	TokenNameCOMMENT_LINE	grammars 
/** DTD Grammar. */	TokenNameCOMMENT_JAVADOC	 DTD Grammar. 
protected	TokenNameprotected	
DTDGrammar	TokenNameIdentifier	 DTD Grammar
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
;	TokenNameSEMICOLON	
// state 	TokenNameCOMMENT_LINE	state 
/** True if seen DOCTYPE declaration. */	TokenNameCOMMENT_JAVADOC	 True if seen DOCTYPE declaration. 
protected	TokenNameprotected	
boolean	TokenNameboolean	
fSeenDoctypeDecl	TokenNameIdentifier	 f Seen Doctype Decl
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** Perform validation. */	TokenNameCOMMENT_JAVADOC	 Perform validation. 
private	TokenNameprivate	
boolean	TokenNameboolean	
fPerformValidation	TokenNameIdentifier	 f Perform Validation
;	TokenNameSEMICOLON	
/** Schema type: None, DTD, Schema */	TokenNameCOMMENT_JAVADOC	 Schema type: None, DTD, Schema 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
fSchemaType	TokenNameIdentifier	 f Schema Type
;	TokenNameSEMICOLON	
// information regarding the current element 	TokenNameCOMMENT_LINE	information regarding the current element 
/** Current element name. */	TokenNameCOMMENT_JAVADOC	 Current element name. 
private	TokenNameprivate	
final	TokenNamefinal	
QName	TokenNameIdentifier	 Q Name
fCurrentElement	TokenNameIdentifier	 f Current Element
=	TokenNameEQUAL	
new	TokenNamenew	
QName	TokenNameIdentifier	 Q Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Current element index. */	TokenNameCOMMENT_JAVADOC	 Current element index. 
private	TokenNameprivate	
int	TokenNameint	
fCurrentElementIndex	TokenNameIdentifier	 f Current Element Index
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** Current content spec type. */	TokenNameCOMMENT_JAVADOC	 Current content spec type. 
private	TokenNameprivate	
int	TokenNameint	
fCurrentContentSpecType	TokenNameIdentifier	 f Current Content Spec Type
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** The root element name. */	TokenNameCOMMENT_JAVADOC	 The root element name. 
private	TokenNameprivate	
final	TokenNamefinal	
QName	TokenNameIdentifier	 Q Name
fRootElement	TokenNameIdentifier	 f Root Element
=	TokenNameEQUAL	
new	TokenNamenew	
QName	TokenNameIdentifier	 Q Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
fInCDATASection	TokenNameIdentifier	 f In CDATA Section
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// element stack 	TokenNameCOMMENT_LINE	element stack 
/** Element index stack. */	TokenNameCOMMENT_JAVADOC	 Element index stack. 
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fElementIndexStack	TokenNameIdentifier	 f Element Index Stack
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
8	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/** Content spec type stack. */	TokenNameCOMMENT_JAVADOC	 Content spec type stack. 
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fContentSpecTypeStack	TokenNameIdentifier	 f Content Spec Type Stack
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
8	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/** Element name stack. */	TokenNameCOMMENT_JAVADOC	 Element name stack. 
private	TokenNameprivate	
QName	TokenNameIdentifier	 Q Name
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fElementQNamePartsStack	TokenNameIdentifier	 f Element Q Name Parts Stack
=	TokenNameEQUAL	
new	TokenNamenew	
QName	TokenNameIdentifier	 Q Name
[	TokenNameLBRACKET	
8	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// children list and offset stack 	TokenNameCOMMENT_LINE	children list and offset stack 
/** * Element children. This data structure is a growing stack that * holds the children of elements from the root to the current * element depth. This structure never gets "deeper" than the * deepest element. Space is re-used once each element is closed. * <p> * <strong>Note:</strong> This is much more efficient use of memory * than creating new arrays for each element depth. * <p> * <strong>Note:</strong> The use of this data structure is for * validation "on the way out". If the validation model changes to * "on the way in", then this data structure is not needed. */	TokenNameCOMMENT_JAVADOC	 Element children. This data structure is a growing stack that holds the children of elements from the root to the current element depth. This structure never gets "deeper" than the deepest element. Space is re-used once each element is closed. <p> <strong>Note:</strong> This is much more efficient use of memory than creating new arrays for each element depth. <p> <strong>Note:</strong> The use of this data structure is for validation "on the way out". If the validation model changes to "on the way in", then this data structure is not needed. 
private	TokenNameprivate	
QName	TokenNameIdentifier	 Q Name
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fElementChildren	TokenNameIdentifier	 f Element Children
=	TokenNameEQUAL	
new	TokenNamenew	
QName	TokenNameIdentifier	 Q Name
[	TokenNameLBRACKET	
32	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/** Element children count. */	TokenNameCOMMENT_JAVADOC	 Element children count. 
private	TokenNameprivate	
int	TokenNameint	
fElementChildrenLength	TokenNameIdentifier	 f Element Children Length
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** * Element children offset stack. This stack refers to offsets * into the <code>fElementChildren</code> array. * @see #fElementChildren */	TokenNameCOMMENT_JAVADOC	 Element children offset stack. This stack refers to offsets into the <code>fElementChildren</code> array. @see #fElementChildren 
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fElementChildrenOffsetStack	TokenNameIdentifier	 f Element Children Offset Stack
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
32	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/** Element depth. */	TokenNameCOMMENT_JAVADOC	 Element depth. 
private	TokenNameprivate	
int	TokenNameint	
fElementDepth	TokenNameIdentifier	 f Element Depth
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// validation states 	TokenNameCOMMENT_LINE	validation states 
/** True if seen the root element. */	TokenNameCOMMENT_JAVADOC	 True if seen the root element. 
private	TokenNameprivate	
boolean	TokenNameboolean	
fSeenRootElement	TokenNameIdentifier	 f Seen Root Element
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** True if inside of element content. */	TokenNameCOMMENT_JAVADOC	 True if inside of element content. 
private	TokenNameprivate	
boolean	TokenNameboolean	
fInElementContent	TokenNameIdentifier	 f In Element Content
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// temporary variables 	TokenNameCOMMENT_LINE	temporary variables 
/** Temporary element declaration. */	TokenNameCOMMENT_JAVADOC	 Temporary element declaration. 
private	TokenNameprivate	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
fTempElementDecl	TokenNameIdentifier	 f Temp Element Decl
=	TokenNameEQUAL	
new	TokenNamenew	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Temporary atribute declaration. */	TokenNameCOMMENT_JAVADOC	 Temporary atribute declaration. 
private	TokenNameprivate	
final	TokenNamefinal	
XMLAttributeDecl	TokenNameIdentifier	 XML Attribute Decl
fTempAttDecl	TokenNameIdentifier	 f Temp Att Decl
=	TokenNameEQUAL	
new	TokenNamenew	
XMLAttributeDecl	TokenNameIdentifier	 XML Attribute Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Temporary entity declaration. */	TokenNameCOMMENT_JAVADOC	 Temporary entity declaration. 
private	TokenNameprivate	
final	TokenNamefinal	
XMLEntityDecl	TokenNameIdentifier	 XML Entity Decl
fEntityDecl	TokenNameIdentifier	 f Entity Decl
=	TokenNameEQUAL	
new	TokenNamenew	
XMLEntityDecl	TokenNameIdentifier	 XML Entity Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Temporary qualified name. */	TokenNameCOMMENT_JAVADOC	 Temporary qualified name. 
private	TokenNameprivate	
final	TokenNamefinal	
QName	TokenNameIdentifier	 Q Name
fTempQName	TokenNameIdentifier	 f Temp Q Name
=	TokenNameEQUAL	
new	TokenNamenew	
QName	TokenNameIdentifier	 Q Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Temporary string buffers. */	TokenNameCOMMENT_JAVADOC	 Temporary string buffers. 
private	TokenNameprivate	
final	TokenNamefinal	
StringBuffer	TokenNameIdentifier	 String Buffer
fBuffer	TokenNameIdentifier	 f Buffer
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// symbols: general 	TokenNameCOMMENT_LINE	symbols: general 
// attribute validators 	TokenNameCOMMENT_LINE	attribute validators 
/** Datatype validator: ID. */	TokenNameCOMMENT_JAVADOC	 Datatype validator: ID. 
protected	TokenNameprotected	
DatatypeValidator	TokenNameIdentifier	 Datatype Validator
fValID	TokenNameIdentifier	 f Val ID
;	TokenNameSEMICOLON	
/** Datatype validator: IDREF. */	TokenNameCOMMENT_JAVADOC	 Datatype validator: IDREF. 
protected	TokenNameprotected	
DatatypeValidator	TokenNameIdentifier	 Datatype Validator
fValIDRef	TokenNameIdentifier	 f Val ID Ref
;	TokenNameSEMICOLON	
/** Datatype validator: IDREFS. */	TokenNameCOMMENT_JAVADOC	 Datatype validator: IDREFS. 
protected	TokenNameprotected	
DatatypeValidator	TokenNameIdentifier	 Datatype Validator
fValIDRefs	TokenNameIdentifier	 f Val ID Refs
;	TokenNameSEMICOLON	
/** Datatype validator: ENTITY. */	TokenNameCOMMENT_JAVADOC	 Datatype validator: ENTITY. 
protected	TokenNameprotected	
DatatypeValidator	TokenNameIdentifier	 Datatype Validator
fValENTITY	TokenNameIdentifier	 f Val ENTITY
;	TokenNameSEMICOLON	
/** Datatype validator: ENTITIES. */	TokenNameCOMMENT_JAVADOC	 Datatype validator: ENTITIES. 
protected	TokenNameprotected	
DatatypeValidator	TokenNameIdentifier	 Datatype Validator
fValENTITIES	TokenNameIdentifier	 f Val ENTITIES
;	TokenNameSEMICOLON	
/** Datatype validator: NMTOKEN. */	TokenNameCOMMENT_JAVADOC	 Datatype validator: NMTOKEN. 
protected	TokenNameprotected	
DatatypeValidator	TokenNameIdentifier	 Datatype Validator
fValNMTOKEN	TokenNameIdentifier	 f Val NMTOKEN
;	TokenNameSEMICOLON	
/** Datatype validator: NMTOKENS. */	TokenNameCOMMENT_JAVADOC	 Datatype validator: NMTOKENS. 
protected	TokenNameprotected	
DatatypeValidator	TokenNameIdentifier	 Datatype Validator
fValNMTOKENS	TokenNameIdentifier	 f Val NMTOKENS
;	TokenNameSEMICOLON	
/** Datatype validator: NOTATION. */	TokenNameCOMMENT_JAVADOC	 Datatype validator: NOTATION. 
protected	TokenNameprotected	
DatatypeValidator	TokenNameIdentifier	 Datatype Validator
fValNOTATION	TokenNameIdentifier	 f Val NOTATION
;	TokenNameSEMICOLON	
// to check for duplicate ID or ANNOTATION attribute declare in 	TokenNameCOMMENT_LINE	to check for duplicate ID or ANNOTATION attribute declare in 
// ATTLIST, and misc VCs 	TokenNameCOMMENT_LINE	ATTLIST, and misc VCs 
// 	TokenNameCOMMENT_LINE	 
// Constructors 	TokenNameCOMMENT_LINE	Constructors 
// 	TokenNameCOMMENT_LINE	 
/** Default constructor. */	TokenNameCOMMENT_JAVADOC	 Default constructor. 
public	TokenNamepublic	
XMLDTDValidator	TokenNameIdentifier	 XMLDTD Validator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// initialize data 	TokenNameCOMMENT_LINE	initialize data 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fElementQNamePartsStack	TokenNameIdentifier	 f Element Q Name Parts Stack
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fElementQNamePartsStack	TokenNameIdentifier	 f Element Q Name Parts Stack
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
QName	TokenNameIdentifier	 Q Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
=	TokenNameEQUAL	
new	TokenNamenew	
DTDGrammarBucket	TokenNameIdentifier	 DTD Grammar Bucket
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// <init>() 	TokenNameCOMMENT_LINE	<init>() 
DTDGrammarBucket	TokenNameIdentifier	 DTD Grammar Bucket
getGrammarBucket	TokenNameIdentifier	 get Grammar Bucket
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getGrammarBucket(): DTDGrammarBucket 	TokenNameCOMMENT_LINE	getGrammarBucket(): DTDGrammarBucket 
// 	TokenNameCOMMENT_LINE	 
// XMLComponent methods 	TokenNameCOMMENT_LINE	XMLComponent methods 
// 	TokenNameCOMMENT_LINE	 
/* * Resets the component. The component can query the component manager * about any features and properties that affect the operation of the * component. * * @param componentManager The component manager. * * @throws SAXException Thrown by component on finitialization error. * For example, if a feature or property is * required for the operation of the component, the * component manager may throw a * SAXNotRecognizedException or a * SAXNotSupportedException. */	TokenNameCOMMENT_BLOCK	 Resets the component. The component can query the component manager about any features and properties that affect the operation of the component. * @param componentManager The component manager. * @throws SAXException Thrown by component on finitialization error. For example, if a feature or property is required for the operation of the component, the component manager may throw a SAXNotRecognizedException or a SAXNotSupportedException. 
public	TokenNamepublic	
void	TokenNamevoid	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
XMLComponentManager	TokenNameIdentifier	 XML Component Manager
componentManager	TokenNameIdentifier	 component Manager
)	TokenNameRPAREN	
throws	TokenNamethrows	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
{	TokenNameLBRACE	
// clear grammars 	TokenNameCOMMENT_LINE	clear grammars 
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fSeenDoctypeDecl	TokenNameIdentifier	 f Seen Doctype Decl
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fInCDATASection	TokenNameIdentifier	 f In CDATA Section
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// initialize state 	TokenNameCOMMENT_LINE	initialize state 
fSeenRootElement	TokenNameIdentifier	 f Seen Root Element
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fInElementContent	TokenNameIdentifier	 f In Element Content
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fCurrentElementIndex	TokenNameIdentifier	 f Current Element Index
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fCurrentContentSpecType	TokenNameIdentifier	 f Current Content Spec Type
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fRootElement	TokenNameIdentifier	 f Root Element
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fValidationState	TokenNameIdentifier	 f Validation State
.	TokenNameDOT	
resetIDTables	TokenNameIdentifier	 reset ID Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fElementDepth	TokenNameIdentifier	 f Element Depth
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fElementChildrenLength	TokenNameIdentifier	 f Element Children Length
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
parser_settings	TokenNameIdentifier	 parser settings
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
parser_settings	TokenNameIdentifier	 parser settings
=	TokenNameEQUAL	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
PARSER_SETTINGS	TokenNameIdentifier	 PARSER  SETTINGS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
parser_settings	TokenNameIdentifier	 parser settings
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
parser_settings	TokenNameIdentifier	 parser settings
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// parser settings have not been changed 	TokenNameCOMMENT_LINE	parser settings have not been changed 
fValidationManager	TokenNameIdentifier	 f Validation Manager
.	TokenNameDOT	
addValidationState	TokenNameIdentifier	 add Validation State
(	TokenNameLPAREN	
fValidationState	TokenNameIdentifier	 f Validation State
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// sax features 	TokenNameCOMMENT_LINE	sax features 
try	TokenNametry	
{	TokenNameLBRACE	
fNamespaces	TokenNameIdentifier	 f Namespaces
=	TokenNameEQUAL	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
NAMESPACES	TokenNameIdentifier	 NAMESPACES
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fNamespaces	TokenNameIdentifier	 f Namespaces
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fValidation	TokenNameIdentifier	 f Validation
=	TokenNameEQUAL	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
VALIDATION	TokenNameIdentifier	 VALIDATION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fValidation	TokenNameIdentifier	 f Validation
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fDTDValidation	TokenNameIdentifier	 f DTD Validation
=	TokenNameEQUAL	
!	TokenNameNOT	
(	TokenNameLPAREN	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SCHEMA_VALIDATION_FEATURE	TokenNameIdentifier	 SCHEMA  VALIDATION  FEATURE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// must be in a schema-less configuration! 	TokenNameCOMMENT_LINE	must be in a schema-less configuration! 
fDTDValidation	TokenNameIdentifier	 f DTD Validation
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Xerces features 	TokenNameCOMMENT_LINE	Xerces features 
try	TokenNametry	
{	TokenNameLBRACE	
fDynamicValidation	TokenNameIdentifier	 f Dynamic Validation
=	TokenNameEQUAL	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
DYNAMIC_VALIDATION	TokenNameIdentifier	 DYNAMIC  VALIDATION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDynamicValidation	TokenNameIdentifier	 f Dynamic Validation
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fBalanceSyntaxTrees	TokenNameIdentifier	 f Balance Syntax Trees
=	TokenNameEQUAL	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
BALANCE_SYNTAX_TREES	TokenNameIdentifier	 BALANCE  SYNTAX  TREES
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fBalanceSyntaxTrees	TokenNameIdentifier	 f Balance Syntax Trees
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fWarnDuplicateAttdef	TokenNameIdentifier	 f Warn Duplicate Attdef
=	TokenNameEQUAL	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
WARN_ON_DUPLICATE_ATTDEF	TokenNameIdentifier	 WARN  ON  DUPLICATE  ATTDEF
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fWarnDuplicateAttdef	TokenNameIdentifier	 f Warn Duplicate Attdef
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fSchemaType	TokenNameIdentifier	 f Schema Type
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
JAXP_PROPERTY_PREFIX	TokenNameIdentifier	 JAXP  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SCHEMA_LANGUAGE	TokenNameIdentifier	 SCHEMA  LANGUAGE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSchemaType	TokenNameIdentifier	 f Schema Type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fValidationManager	TokenNameIdentifier	 f Validation Manager
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ValidationManager	TokenNameIdentifier	 Validation Manager
)	TokenNameRPAREN	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
VALIDATION_MANAGER	TokenNameIdentifier	 VALIDATION  MANAGER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fValidationManager	TokenNameIdentifier	 f Validation Manager
.	TokenNameDOT	
addValidationState	TokenNameIdentifier	 add Validation State
(	TokenNameLPAREN	
fValidationState	TokenNameIdentifier	 f Validation State
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fValidationState	TokenNameIdentifier	 f Validation State
.	TokenNameDOT	
setUsingNamespaces	TokenNameIdentifier	 set Using Namespaces
(	TokenNameLPAREN	
fNamespaces	TokenNameIdentifier	 f Namespaces
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// get needed components 	TokenNameCOMMENT_LINE	get needed components 
fErrorReporter	TokenNameIdentifier	 f Error Reporter
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
)	TokenNameRPAREN	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ERROR_REPORTER_PROPERTY	TokenNameIdentifier	 ERROR  REPORTER  PROPERTY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
=	TokenNameEQUAL	
(	TokenNameLPAREN	
SymbolTable	TokenNameIdentifier	 Symbol Table
)	TokenNameRPAREN	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SYMBOL_TABLE_PROPERTY	TokenNameIdentifier	 SYMBOL  TABLE  PROPERTY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
fGrammarPool	TokenNameIdentifier	 f Grammar Pool
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XMLGrammarPool	TokenNameIdentifier	 XML Grammar Pool
)	TokenNameRPAREN	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
GRAMMAR_POOL	TokenNameIdentifier	 GRAMMAR  POOL
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fGrammarPool	TokenNameIdentifier	 f Grammar Pool
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fDatatypeValidatorFactory	TokenNameIdentifier	 f Datatype Validator Factory
=	TokenNameEQUAL	
(	TokenNameLPAREN	
DTDDVFactory	TokenNameIdentifier	 DTDDV Factory
)	TokenNameRPAREN	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
DATATYPE_VALIDATOR_FACTORY_PROPERTY	TokenNameIdentifier	 DATATYPE  VALIDATOR  FACTORY  PROPERTY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
init	TokenNameIdentifier	 init
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// reset(XMLComponentManager) 	TokenNameCOMMENT_LINE	reset(XMLComponentManager) 
/** * Returns a list of feature identifiers that are recognized by * this component. This method may return null if no features * are recognized by this component. */	TokenNameCOMMENT_JAVADOC	 Returns a list of feature identifiers that are recognized by this component. This method may return null if no features are recognized by this component. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getRecognizedFeatures	TokenNameIdentifier	 get Recognized Features
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
RECOGNIZED_FEATURES	TokenNameIdentifier	 RECOGNIZED  FEATURES
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getRecognizedFeatures():String[] 	TokenNameCOMMENT_LINE	getRecognizedFeatures():String[] 
/** * Sets the state of a feature. This method is called by the component * manager any time after reset when a feature changes state. * <p> * <strong>Note:</strong> Components should silently ignore features * that do not affect the operation of the component. * * @param featureId The feature identifier. * @param state The state of the feature. * * @throws SAXNotRecognizedException The component should not throw * this exception. * @throws SAXNotSupportedException The component should not throw * this exception. */	TokenNameCOMMENT_JAVADOC	 Sets the state of a feature. This method is called by the component manager any time after reset when a feature changes state. <p> <strong>Note:</strong> Components should silently ignore features that do not affect the operation of the component. * @param featureId The feature identifier. @param state The state of the feature. * @throws SAXNotRecognizedException The component should not throw this exception. @throws SAXNotSupportedException The component should not throw this exception. 
public	TokenNamepublic	
void	TokenNamevoid	
setFeature	TokenNameIdentifier	 set Feature
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
featureId	TokenNameIdentifier	 feature Id
,	TokenNameCOMMA	
boolean	TokenNameboolean	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
throws	TokenNamethrows	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
{	TokenNameLBRACE	
}	TokenNameRBRACE	
// setFeature(String,boolean) 	TokenNameCOMMENT_LINE	setFeature(String,boolean) 
/** * Returns a list of property identifiers that are recognized by * this component. This method may return null if no properties * are recognized by this component. */	TokenNameCOMMENT_JAVADOC	 Returns a list of property identifiers that are recognized by this component. This method may return null if no properties are recognized by this component. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getRecognizedProperties	TokenNameIdentifier	 get Recognized Properties
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
RECOGNIZED_PROPERTIES	TokenNameIdentifier	 RECOGNIZED  PROPERTIES
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getRecognizedProperties():String[] 	TokenNameCOMMENT_LINE	getRecognizedProperties():String[] 
/** * Sets the value of a property. This method is called by the component * manager any time after reset when a property changes value. * <p> * <strong>Note:</strong> Components should silently ignore properties * that do not affect the operation of the component. * * @param propertyId The property identifier. * @param value The value of the property. * * @throws SAXNotRecognizedException The component should not throw * this exception. * @throws SAXNotSupportedException The component should not throw * this exception. */	TokenNameCOMMENT_JAVADOC	 Sets the value of a property. This method is called by the component manager any time after reset when a property changes value. <p> <strong>Note:</strong> Components should silently ignore properties that do not affect the operation of the component. * @param propertyId The property identifier. @param value The value of the property. * @throws SAXNotRecognizedException The component should not throw this exception. @throws SAXNotSupportedException The component should not throw this exception. 
public	TokenNamepublic	
void	TokenNamevoid	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
propertyId	TokenNameIdentifier	 property Id
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
throws	TokenNamethrows	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
{	TokenNameLBRACE	
}	TokenNameRBRACE	
// setProperty(String,Object) 	TokenNameCOMMENT_LINE	setProperty(String,Object) 
/** * Returns the default state for a feature, or null if this * component does not want to report a default value for this * feature. * * @param featureId The feature identifier. * * @since Xerces 2.2.0 */	TokenNameCOMMENT_JAVADOC	 Returns the default state for a feature, or null if this component does not want to report a default value for this feature. * @param featureId The feature identifier. * @since Xerces 2.2.0 
public	TokenNamepublic	
Boolean	TokenNameIdentifier	 Boolean
getFeatureDefault	TokenNameIdentifier	 get Feature Default
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
featureId	TokenNameIdentifier	 feature Id
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
RECOGNIZED_FEATURES	TokenNameIdentifier	 RECOGNIZED  FEATURES
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
RECOGNIZED_FEATURES	TokenNameIdentifier	 RECOGNIZED  FEATURES
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
featureId	TokenNameIdentifier	 feature Id
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
FEATURE_DEFAULTS	TokenNameIdentifier	 FEATURE  DEFAULTS
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getFeatureDefault(String):Boolean 	TokenNameCOMMENT_LINE	getFeatureDefault(String):Boolean 
/** * Returns the default state for a property, or null if this * component does not want to report a default value for this * property. * * @param propertyId The property identifier. * * @since Xerces 2.2.0 */	TokenNameCOMMENT_JAVADOC	 Returns the default state for a property, or null if this component does not want to report a default value for this property. * @param propertyId The property identifier. * @since Xerces 2.2.0 
public	TokenNamepublic	
Object	TokenNameIdentifier	 Object
getPropertyDefault	TokenNameIdentifier	 get Property Default
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
propertyId	TokenNameIdentifier	 property Id
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
RECOGNIZED_PROPERTIES	TokenNameIdentifier	 RECOGNIZED  PROPERTIES
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
RECOGNIZED_PROPERTIES	TokenNameIdentifier	 RECOGNIZED  PROPERTIES
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
propertyId	TokenNameIdentifier	 property Id
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
PROPERTY_DEFAULTS	TokenNameIdentifier	 PROPERTY  DEFAULTS
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getPropertyDefault(String):Object 	TokenNameCOMMENT_LINE	getPropertyDefault(String):Object 
// 	TokenNameCOMMENT_LINE	 
// XMLDocumentSource methods 	TokenNameCOMMENT_LINE	XMLDocumentSource methods 
// 	TokenNameCOMMENT_LINE	 
/** Sets the document handler to receive information about the document. */	TokenNameCOMMENT_JAVADOC	 Sets the document handler to receive information about the document. 
public	TokenNamepublic	
void	TokenNamevoid	
setDocumentHandler	TokenNameIdentifier	 set Document Handler
(	TokenNameLPAREN	
XMLDocumentHandler	TokenNameIdentifier	 XML Document Handler
documentHandler	TokenNameIdentifier	 document Handler
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
=	TokenNameEQUAL	
documentHandler	TokenNameIdentifier	 document Handler
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// setDocumentHandler(XMLDocumentHandler) 	TokenNameCOMMENT_LINE	setDocumentHandler(XMLDocumentHandler) 
/** Returns the document handler */	TokenNameCOMMENT_JAVADOC	 Returns the document handler 
public	TokenNamepublic	
XMLDocumentHandler	TokenNameIdentifier	 XML Document Handler
getDocumentHandler	TokenNameIdentifier	 get Document Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getDocumentHandler(): XMLDocumentHandler 	TokenNameCOMMENT_LINE	getDocumentHandler(): XMLDocumentHandler 
// 	TokenNameCOMMENT_LINE	 
// XMLDocumentHandler methods 	TokenNameCOMMENT_LINE	XMLDocumentHandler methods 
// 	TokenNameCOMMENT_LINE	 
/** Sets the document source */	TokenNameCOMMENT_JAVADOC	 Sets the document source 
public	TokenNamepublic	
void	TokenNamevoid	
setDocumentSource	TokenNameIdentifier	 set Document Source
(	TokenNameLPAREN	
XMLDocumentSource	TokenNameIdentifier	 XML Document Source
source	TokenNameIdentifier	 source
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentSource	TokenNameIdentifier	 f Document Source
=	TokenNameEQUAL	
source	TokenNameIdentifier	 source
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// setDocumentSource 	TokenNameCOMMENT_LINE	setDocumentSource 
/** Returns the document source */	TokenNameCOMMENT_JAVADOC	 Returns the document source 
public	TokenNamepublic	
XMLDocumentSource	TokenNameIdentifier	 XML Document Source
getDocumentSource	TokenNameIdentifier	 get Document Source
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fDocumentSource	TokenNameIdentifier	 f Document Source
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getDocumentSource 	TokenNameCOMMENT_LINE	getDocumentSource 
/** * The start of the document. * * @param locator The system identifier of the entity if the entity * is external, null otherwise. * @param encoding The auto-detected IANA encoding name of the entity * stream. This value will be null in those situations * where the entity encoding is not auto-detected (e.g. * internal entities or a document entity that is * parsed from a java.io.Reader). * @param namespaceContext * The namespace context in effect at the * start of this document. * This object represents the current context. * Implementors of this class are responsible * for copying the namespace bindings from the * the current context (and its parent contexts) * if that information is important. * @param augs Additional information that may include infoset augmentations * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 The start of the document. * @param locator The system identifier of the entity if the entity is external, null otherwise. @param encoding The auto-detected IANA encoding name of the entity stream. This value will be null in those situations where the entity encoding is not auto-detected (e.g. internal entities or a document entity that is parsed from a java.io.Reader). @param namespaceContext The namespace context in effect at the start of this document. This object represents the current context. Implementors of this class are responsible for copying the namespace bindings from the the current context (and its parent contexts) if that information is important. @param augs Additional information that may include infoset augmentations * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
startDocument	TokenNameIdentifier	 start Document
(	TokenNameLPAREN	
XMLLocator	TokenNameIdentifier	 XML Locator
locator	TokenNameIdentifier	 locator
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
NamespaceContext	TokenNameIdentifier	 Namespace Context
namespaceContext	TokenNameIdentifier	 namespace Context
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
// call handlers 	TokenNameCOMMENT_LINE	call handlers 
// get initial grammars 	TokenNameCOMMENT_LINE	get initial grammars 
if	TokenNameif	
(	TokenNameLPAREN	
fGrammarPool	TokenNameIdentifier	 f Grammar Pool
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Grammar	TokenNameIdentifier	 Grammar
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
grammars	TokenNameIdentifier	 grammars
=	TokenNameEQUAL	
fGrammarPool	TokenNameIdentifier	 f Grammar Pool
.	TokenNameDOT	
retrieveInitialGrammarSet	TokenNameIdentifier	 retrieve Initial Grammar Set
(	TokenNameLPAREN	
XMLGrammarDescription	TokenNameIdentifier	 XML Grammar Description
.	TokenNameDOT	
XML_DTD	TokenNameIdentifier	 XML  DTD
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
(	TokenNameLPAREN	
grammars	TokenNameIdentifier	 grammars
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
grammars	TokenNameIdentifier	 grammars
.	TokenNameDOT	
length	TokenNameIdentifier	 length
:	TokenNameCOLON	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
putGrammar	TokenNameIdentifier	 put Grammar
(	TokenNameLPAREN	
(	TokenNameLPAREN	
DTDGrammar	TokenNameIdentifier	 DTD Grammar
)	TokenNameRPAREN	
grammars	TokenNameIdentifier	 grammars
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
fDocLocation	TokenNameIdentifier	 f Doc Location
=	TokenNameEQUAL	
locator	TokenNameIdentifier	 locator
;	TokenNameSEMICOLON	
fNamespaceContext	TokenNameIdentifier	 f Namespace Context
=	TokenNameEQUAL	
namespaceContext	TokenNameIdentifier	 namespace Context
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
startDocument	TokenNameIdentifier	 start Document
(	TokenNameLPAREN	
locator	TokenNameIdentifier	 locator
,	TokenNameCOMMA	
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
namespaceContext	TokenNameIdentifier	 namespace Context
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// startDocument(XMLLocator,String) 	TokenNameCOMMENT_LINE	startDocument(XMLLocator,String) 
/** * Notifies of the presence of an XMLDecl line in the document. If * present, this method will be called immediately following the * startDocument call. * * @param version The XML version. * @param encoding The IANA encoding name of the document, or null if * not specified. * @param standalone The standalone value, or null if not specified. * @param augs Additional information that may include infoset augmentations * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 Notifies of the presence of an XMLDecl line in the document. If present, this method will be called immediately following the startDocument call. * @param version The XML version. @param encoding The IANA encoding name of the document, or null if not specified. @param standalone The standalone value, or null if not specified. @param augs Additional information that may include infoset augmentations * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
xmlDecl	TokenNameIdentifier	 xml Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
version	TokenNameIdentifier	 version
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
standalone	TokenNameIdentifier	 standalone
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
// save standalone state 	TokenNameCOMMENT_LINE	save standalone state 
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
setStandalone	TokenNameIdentifier	 set Standalone
(	TokenNameLPAREN	
standalone	TokenNameIdentifier	 standalone
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
standalone	TokenNameIdentifier	 standalone
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"yes"	TokenNameStringLiteral	yes
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// call handlers 	TokenNameCOMMENT_LINE	call handlers 
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
xmlDecl	TokenNameIdentifier	 xml Decl
(	TokenNameLPAREN	
version	TokenNameIdentifier	 version
,	TokenNameCOMMA	
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
standalone	TokenNameIdentifier	 standalone
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// xmlDecl(String,String,String) 	TokenNameCOMMENT_LINE	xmlDecl(String,String,String) 
/** * Notifies of the presence of the DOCTYPE line in the document. * * @param rootElement The name of the root element. * @param publicId The public identifier if an external DTD or null * if the external DTD is specified using SYSTEM. * @param systemId The system identifier if an external DTD, null * otherwise. * @param augs Additional information that may include infoset augmentations * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 Notifies of the presence of the DOCTYPE line in the document. * @param rootElement The name of the root element. @param publicId The public identifier if an external DTD or null if the external DTD is specified using SYSTEM. @param systemId The system identifier if an external DTD, null otherwise. @param augs Additional information that may include infoset augmentations * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
doctypeDecl	TokenNameIdentifier	 doctype Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
rootElement	TokenNameIdentifier	 root Element
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
publicId	TokenNameIdentifier	 public Id
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
systemId	TokenNameIdentifier	 system Id
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
// save root element state 	TokenNameCOMMENT_LINE	save root element state 
fSeenDoctypeDecl	TokenNameIdentifier	 f Seen Doctype Decl
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
fRootElement	TokenNameIdentifier	 f Root Element
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
rootElement	TokenNameIdentifier	 root Element
,	TokenNameCOMMA	
rootElement	TokenNameIdentifier	 root Element
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// find or create grammar: 	TokenNameCOMMENT_LINE	find or create grammar: 
String	TokenNameIdentifier	 String
eid	TokenNameIdentifier	 eid
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
eid	TokenNameIdentifier	 eid
=	TokenNameEQUAL	
XMLEntityManager	TokenNameIdentifier	 XML Entity Manager
.	TokenNameDOT	
expandSystemId	TokenNameIdentifier	 expand System Id
(	TokenNameLPAREN	
systemId	TokenNameIdentifier	 system Id
,	TokenNameCOMMA	
fDocLocation	TokenNameIdentifier	 f Doc Location
.	TokenNameDOT	
getExpandedSystemId	TokenNameIdentifier	 get Expanded System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
XMLDTDDescription	TokenNameIdentifier	 XMLDTD Description
grammarDesc	TokenNameIdentifier	 grammar Desc
=	TokenNameEQUAL	
new	TokenNamenew	
XMLDTDDescription	TokenNameIdentifier	 XMLDTD Description
(	TokenNameLPAREN	
publicId	TokenNameIdentifier	 public Id
,	TokenNameCOMMA	
systemId	TokenNameIdentifier	 system Id
,	TokenNameCOMMA	
fDocLocation	TokenNameIdentifier	 f Doc Location
.	TokenNameDOT	
getExpandedSystemId	TokenNameIdentifier	 get Expanded System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
eid	TokenNameIdentifier	 eid
,	TokenNameCOMMA	
rootElement	TokenNameIdentifier	 root Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
=	TokenNameEQUAL	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getGrammar	TokenNameIdentifier	 get Grammar
(	TokenNameLPAREN	
grammarDesc	TokenNameIdentifier	 grammar Desc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// give grammar pool a chance... 	TokenNameCOMMENT_LINE	give grammar pool a chance... 
// 	TokenNameCOMMENT_LINE	 
// Do not bother checking the pool if no public or system identifier was provided. 	TokenNameCOMMENT_LINE	Do not bother checking the pool if no public or system identifier was provided. 
// Since so many different DTDs have roots in common, using only a root name as the 	TokenNameCOMMENT_LINE	Since so many different DTDs have roots in common, using only a root name as the 
// key may cause an unexpected grammar to be retrieved from the grammar pool. This scenario 	TokenNameCOMMENT_LINE	key may cause an unexpected grammar to be retrieved from the grammar pool. This scenario 
// would occur when an ExternalSubsetResolver has been queried and the 	TokenNameCOMMENT_LINE	would occur when an ExternalSubsetResolver has been queried and the 
// XMLInputSource returned contains an input stream but no external identifier. 	TokenNameCOMMENT_LINE	XMLInputSource returned contains an input stream but no external identifier. 
// This can never happen when the instance document specified a DOCTYPE. -- mrglavas 	TokenNameCOMMENT_LINE	This can never happen when the instance document specified a DOCTYPE. -- mrglavas 
if	TokenNameif	
(	TokenNameLPAREN	
fGrammarPool	TokenNameIdentifier	 f Grammar Pool
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
systemId	TokenNameIdentifier	 system Id
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
publicId	TokenNameIdentifier	 public Id
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
=	TokenNameEQUAL	
(	TokenNameLPAREN	
DTDGrammar	TokenNameIdentifier	 DTD Grammar
)	TokenNameRPAREN	
fGrammarPool	TokenNameIdentifier	 f Grammar Pool
.	TokenNameDOT	
retrieveGrammar	TokenNameIdentifier	 retrieve Grammar
(	TokenNameLPAREN	
grammarDesc	TokenNameIdentifier	 grammar Desc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// we'll have to create it... 	TokenNameCOMMENT_LINE	we'll have to create it... 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fBalanceSyntaxTrees	TokenNameIdentifier	 f Balance Syntax Trees
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
=	TokenNameEQUAL	
new	TokenNamenew	
DTDGrammar	TokenNameIdentifier	 DTD Grammar
(	TokenNameLPAREN	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
,	TokenNameCOMMA	
grammarDesc	TokenNameIdentifier	 grammar Desc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
=	TokenNameEQUAL	
new	TokenNamenew	
BalancedDTDGrammar	TokenNameIdentifier	 Balanced DTD Grammar
(	TokenNameLPAREN	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
,	TokenNameCOMMA	
grammarDesc	TokenNameIdentifier	 grammar Desc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// we've found a cached one;so let's make sure not to read 	TokenNameCOMMENT_LINE	we've found a cached one;so let's make sure not to read 
// any external subset! 	TokenNameCOMMENT_LINE	any external subset! 
fValidationManager	TokenNameIdentifier	 f Validation Manager
.	TokenNameDOT	
setCachedDTD	TokenNameIdentifier	 set Cached DTD
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
setActiveGrammar	TokenNameIdentifier	 set Active Grammar
(	TokenNameLPAREN	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// call handlers 	TokenNameCOMMENT_LINE	call handlers 
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
doctypeDecl	TokenNameIdentifier	 doctype Decl
(	TokenNameLPAREN	
rootElement	TokenNameIdentifier	 root Element
,	TokenNameCOMMA	
publicId	TokenNameIdentifier	 public Id
,	TokenNameCOMMA	
systemId	TokenNameIdentifier	 system Id
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// doctypeDecl(String,String,String, Augmentations) 	TokenNameCOMMENT_LINE	doctypeDecl(String,String,String, Augmentations) 
/** * The start of an element. * * @param element The name of the element. * @param attributes The element attributes. * @param augs Additional information that may include infoset augmentations * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 The start of an element. * @param element The name of the element. @param attributes The element attributes. @param augs Additional information that may include infoset augmentations * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
startElement	TokenNameIdentifier	 start Element
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
XMLAttributes	TokenNameIdentifier	 XML Attributes
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
handleStartElement	TokenNameIdentifier	 handle Start Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// call handlers 	TokenNameCOMMENT_LINE	call handlers 
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
startElement	TokenNameIdentifier	 start Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// startElement(QName,XMLAttributes) 	TokenNameCOMMENT_LINE	startElement(QName,XMLAttributes) 
/** * An empty element. * * @param element The name of the element. * @param attributes The element attributes. * @param augs Additional information that may include infoset augmentations * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 An empty element. * @param element The name of the element. @param attributes The element attributes. @param augs Additional information that may include infoset augmentations * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
emptyElement	TokenNameIdentifier	 empty Element
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
XMLAttributes	TokenNameIdentifier	 XML Attributes
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
boolean	TokenNameboolean	
removed	TokenNameIdentifier	 removed
=	TokenNameEQUAL	
handleStartElement	TokenNameIdentifier	 handle Start Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
emptyElement	TokenNameIdentifier	 empty Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
removed	TokenNameIdentifier	 removed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
handleEndElement	TokenNameIdentifier	 handle End Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// emptyElement(QName,XMLAttributes) 	TokenNameCOMMENT_LINE	emptyElement(QName,XMLAttributes) 
/** * Character content. * * @param text The content. * * @param augs Additional information that may include infoset augmentations * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 Character content. * @param text The content. * @param augs Additional information that may include infoset augmentations * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
characters	TokenNameIdentifier	 characters
(	TokenNameLPAREN	
XMLString	TokenNameIdentifier	 XML String
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
boolean	TokenNameboolean	
callNextCharacters	TokenNameIdentifier	 call Next Characters
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// REVISIT: [Q] Is there a more efficient way of doing this? 	TokenNameCOMMENT_LINE	REVISIT: [Q] Is there a more efficient way of doing this? 
// Perhaps if the scanner told us so we don't have to 	TokenNameCOMMENT_LINE	Perhaps if the scanner told us so we don't have to 
// look at the characters again. -Ac 	TokenNameCOMMENT_LINE	look at the characters again. -Ac 
boolean	TokenNameboolean	
allWhiteSpace	TokenNameIdentifier	 all White Space
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
+	TokenNamePLUS	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isSpace	TokenNameIdentifier	 is Space
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
allWhiteSpace	TokenNameIdentifier	 all White Space
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// call the ignoreableWhiteSpace callback 	TokenNameCOMMENT_LINE	call the ignoreableWhiteSpace callback 
// never call ignorableWhitespace if we are in cdata section 	TokenNameCOMMENT_LINE	never call ignorableWhitespace if we are in cdata section 
if	TokenNameif	
(	TokenNameLPAREN	
fInElementContent	TokenNameIdentifier	 f In Element Content
&&	TokenNameAND_AND	
allWhiteSpace	TokenNameIdentifier	 all White Space
&&	TokenNameAND_AND	
!	TokenNameNOT	
fInCDATASection	TokenNameIdentifier	 f In CDATA Section
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
ignorableWhitespace	TokenNameIdentifier	 ignorable Whitespace
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
callNextCharacters	TokenNameIdentifier	 call Next Characters
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// validate 	TokenNameCOMMENT_LINE	validate 
if	TokenNameif	
(	TokenNameLPAREN	
fPerformValidation	TokenNameIdentifier	 f Perform Validation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fInElementContent	TokenNameIdentifier	 f In Element Content
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getStandalone	TokenNameIdentifier	 get Standalone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
.	TokenNameDOT	
getElementDeclIsExternal	TokenNameIdentifier	 get Element Decl Is External
(	TokenNameLPAREN	
fCurrentElementIndex	TokenNameIdentifier	 f Current Element Index
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
allWhiteSpace	TokenNameIdentifier	 all White Space
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
"MSG_WHITE_SPACE_IN_ELEMENT_CONTENT_WHEN_STANDALONE"	TokenNameStringLiteral	MSG_WHITE_SPACE_IN_ELEMENT_CONTENT_WHEN_STANDALONE
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
allWhiteSpace	TokenNameIdentifier	 all White Space
)	TokenNameRPAREN	
{	TokenNameLBRACE	
charDataInContent	TokenNameIdentifier	 char Data In Content
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// For E15.2 	TokenNameCOMMENT_LINE	For E15.2 
if	TokenNameif	
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
augs	TokenNameIdentifier	 augs
.	TokenNameDOT	
getItem	TokenNameIdentifier	 get Item
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
CHAR_REF_PROBABLE_WS	TokenNameIdentifier	 CHAR  REF  PROBABLE  WS
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
TRUE	TokenNameIdentifier	 TRUE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
"MSG_CONTENT_INVALID_SPECIFIED"	TokenNameStringLiteral	MSG_CONTENT_INVALID_SPECIFIED
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fCurrentElement	TokenNameIdentifier	 f Current Element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
.	TokenNameDOT	
getContentSpecAsString	TokenNameIdentifier	 get Content Spec As String
(	TokenNameLPAREN	
fElementDepth	TokenNameIdentifier	 f Element Depth
)	TokenNameRPAREN	
,	TokenNameCOMMA	
"character reference"	TokenNameStringLiteral	character reference
}	TokenNameRBRACE	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentContentSpecType	TokenNameIdentifier	 f Current Content Spec Type
==	TokenNameEQUAL_EQUAL	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
.	TokenNameDOT	
TYPE_EMPTY	TokenNameIdentifier	 TYPE  EMPTY
)	TokenNameRPAREN	
{	TokenNameLBRACE	
charDataInContent	TokenNameIdentifier	 char Data In Content
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// call handlers 	TokenNameCOMMENT_LINE	call handlers 
if	TokenNameif	
(	TokenNameLPAREN	
callNextCharacters	TokenNameIdentifier	 call Next Characters
&&	TokenNameAND_AND	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
characters	TokenNameIdentifier	 characters
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// characters(XMLString) 	TokenNameCOMMENT_LINE	characters(XMLString) 
/** * Ignorable whitespace. For this method to be called, the document * source must have some way of determining that the text containing * only whitespace characters should be considered ignorable. For * example, the validator can determine if a length of whitespace * characters in the document are ignorable based on the element * content model. * * @param text The ignorable whitespace. * @param augs Additional information that may include infoset augmentations * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 Ignorable whitespace. For this method to be called, the document source must have some way of determining that the text containing only whitespace characters should be considered ignorable. For example, the validator can determine if a length of whitespace characters in the document are ignorable based on the element content model. * @param text The ignorable whitespace. @param augs Additional information that may include infoset augmentations * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
ignorableWhitespace	TokenNameIdentifier	 ignorable Whitespace
(	TokenNameLPAREN	
XMLString	TokenNameIdentifier	 XML String
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
// call handlers 	TokenNameCOMMENT_LINE	call handlers 
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
ignorableWhitespace	TokenNameIdentifier	 ignorable Whitespace
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// ignorableWhitespace(XMLString) 	TokenNameCOMMENT_LINE	ignorableWhitespace(XMLString) 
/** * The end of an element. * * @param element The name of the element. * @param augs Additional information that may include infoset augmentations * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 The end of an element. * @param element The name of the element. @param augs Additional information that may include infoset augmentations * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
endElement	TokenNameIdentifier	 end Element
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
handleEndElement	TokenNameIdentifier	 handle End Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// endElement(QName) 	TokenNameCOMMENT_LINE	endElement(QName) 
/** * The start of a CDATA section. * @param augs Additional information that may include infoset augmentations * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 The start of a CDATA section. @param augs Additional information that may include infoset augmentations * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
startCDATA	TokenNameIdentifier	 start CDATA
(	TokenNameLPAREN	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fPerformValidation	TokenNameIdentifier	 f Perform Validation
&&	TokenNameAND_AND	
fInElementContent	TokenNameIdentifier	 f In Element Content
)	TokenNameRPAREN	
{	TokenNameLBRACE	
charDataInContent	TokenNameIdentifier	 char Data In Content
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fInCDATASection	TokenNameIdentifier	 f In CDATA Section
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// call handlers 	TokenNameCOMMENT_LINE	call handlers 
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
startCDATA	TokenNameIdentifier	 start CDATA
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// startCDATA() 	TokenNameCOMMENT_LINE	startCDATA() 
/** * The end of a CDATA section. * @param augs Additional information that may include infoset augmentations * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 The end of a CDATA section. @param augs Additional information that may include infoset augmentations * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
endCDATA	TokenNameIdentifier	 end CDATA
(	TokenNameLPAREN	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
fInCDATASection	TokenNameIdentifier	 f In CDATA Section
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// call handlers 	TokenNameCOMMENT_LINE	call handlers 
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
endCDATA	TokenNameIdentifier	 end CDATA
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// endCDATA() 	TokenNameCOMMENT_LINE	endCDATA() 
/** * The end of the document. * @param augs Additional information that may include infoset augmentations * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 The end of the document. @param augs Additional information that may include infoset augmentations * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
endDocument	TokenNameIdentifier	 end Document
(	TokenNameLPAREN	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
// call handlers 	TokenNameCOMMENT_LINE	call handlers 
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
endDocument	TokenNameIdentifier	 end Document
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// endDocument() 	TokenNameCOMMENT_LINE	endDocument() 
/** * A comment. * * @param text The text in the comment. * @param augs Additional information that may include infoset augmentations * * @throws XNIException Thrown by application to signal an error. */	TokenNameCOMMENT_JAVADOC	 A comment. * @param text The text in the comment. @param augs Additional information that may include infoset augmentations * @throws XNIException Thrown by application to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
comment	TokenNameIdentifier	 comment
(	TokenNameLPAREN	
XMLString	TokenNameIdentifier	 XML String
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
// fixes E15.1 	TokenNameCOMMENT_LINE	fixes E15.1 
if	TokenNameif	
(	TokenNameLPAREN	
fPerformValidation	TokenNameIdentifier	 f Perform Validation
&&	TokenNameAND_AND	
fElementDepth	TokenNameIdentifier	 f Element Depth
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
.	TokenNameDOT	
getElementDecl	TokenNameIdentifier	 get Element Decl
(	TokenNameLPAREN	
fCurrentElementIndex	TokenNameIdentifier	 f Current Element Index
,	TokenNameCOMMA	
fTempElementDecl	TokenNameIdentifier	 f Temp Element Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fTempElementDecl	TokenNameIdentifier	 f Temp Element Decl
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
.	TokenNameDOT	
TYPE_EMPTY	TokenNameIdentifier	 TYPE  EMPTY
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
"MSG_CONTENT_INVALID_SPECIFIED"	TokenNameStringLiteral	MSG_CONTENT_INVALID_SPECIFIED
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fCurrentElement	TokenNameIdentifier	 f Current Element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
"EMPTY"	TokenNameStringLiteral	EMPTY
,	TokenNameCOMMA	
"comment"	TokenNameStringLiteral	comment
}	TokenNameRBRACE	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// call handlers 	TokenNameCOMMENT_LINE	call handlers 
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
comment	TokenNameIdentifier	 comment
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// comment(XMLString) 	TokenNameCOMMENT_LINE	comment(XMLString) 
/** * A processing instruction. Processing instructions consist of a * target name and, optionally, text data. The data is only meaningful * to the application. * <p> * Typically, a processing instruction's data will contain a series * of pseudo-attributes. These pseudo-attributes follow the form of * element attributes but are <strong>not</strong> parsed or presented * to the application as anything other than text. The application is * responsible for parsing the data. * * @param target The target. * @param data The data or null if none specified. * @param augs Additional information that may include infoset augmentations * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 A processing instruction. Processing instructions consist of a target name and, optionally, text data. The data is only meaningful to the application. <p> Typically, a processing instruction's data will contain a series of pseudo-attributes. These pseudo-attributes follow the form of element attributes but are <strong>not</strong> parsed or presented to the application as anything other than text. The application is responsible for parsing the data. * @param target The target. @param data The data or null if none specified. @param augs Additional information that may include infoset augmentations * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
processingInstruction	TokenNameIdentifier	 processing Instruction
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
target	TokenNameIdentifier	 target
,	TokenNameCOMMA	
XMLString	TokenNameIdentifier	 XML String
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
// fixes E15.1 	TokenNameCOMMENT_LINE	fixes E15.1 
if	TokenNameif	
(	TokenNameLPAREN	
fPerformValidation	TokenNameIdentifier	 f Perform Validation
&&	TokenNameAND_AND	
fElementDepth	TokenNameIdentifier	 f Element Depth
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
.	TokenNameDOT	
getElementDecl	TokenNameIdentifier	 get Element Decl
(	TokenNameLPAREN	
fCurrentElementIndex	TokenNameIdentifier	 f Current Element Index
,	TokenNameCOMMA	
fTempElementDecl	TokenNameIdentifier	 f Temp Element Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fTempElementDecl	TokenNameIdentifier	 f Temp Element Decl
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
.	TokenNameDOT	
TYPE_EMPTY	TokenNameIdentifier	 TYPE  EMPTY
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
"MSG_CONTENT_INVALID_SPECIFIED"	TokenNameStringLiteral	MSG_CONTENT_INVALID_SPECIFIED
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fCurrentElement	TokenNameIdentifier	 f Current Element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
"EMPTY"	TokenNameStringLiteral	EMPTY
,	TokenNameCOMMA	
"processing instruction"	TokenNameStringLiteral	processing instruction
}	TokenNameRBRACE	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// call handlers 	TokenNameCOMMENT_LINE	call handlers 
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
processingInstruction	TokenNameIdentifier	 processing Instruction
(	TokenNameLPAREN	
target	TokenNameIdentifier	 target
,	TokenNameCOMMA	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// processingInstruction(String,XMLString) 	TokenNameCOMMENT_LINE	processingInstruction(String,XMLString) 
/** * This method notifies the start of a general entity. * <p> * <strong>Note:</strong> This method is not called for entity references * appearing as part of attribute values. * * @param name The name of the general entity. * @param identifier The resource identifier. * @param encoding The auto-detected IANA encoding name of the entity * stream. This value will be null in those situations * where the entity encoding is not auto-detected (e.g. * internal entities or a document entity that is * parsed from a java.io.Reader). * @param augs Additional information that may include infoset augmentations * * @exception XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 This method notifies the start of a general entity. <p> <strong>Note:</strong> This method is not called for entity references appearing as part of attribute values. * @param name The name of the general entity. @param identifier The resource identifier. @param encoding The auto-detected IANA encoding name of the entity stream. This value will be null in those situations where the entity encoding is not auto-detected (e.g. internal entities or a document entity that is parsed from a java.io.Reader). @param augs Additional information that may include infoset augmentations * @exception XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
startGeneralEntity	TokenNameIdentifier	 start General Entity
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
XMLResourceIdentifier	TokenNameIdentifier	 XML Resource Identifier
identifier	TokenNameIdentifier	 identifier
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fPerformValidation	TokenNameIdentifier	 f Perform Validation
&&	TokenNameAND_AND	
fElementDepth	TokenNameIdentifier	 f Element Depth
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
.	TokenNameDOT	
getElementDecl	TokenNameIdentifier	 get Element Decl
(	TokenNameLPAREN	
fCurrentElementIndex	TokenNameIdentifier	 f Current Element Index
,	TokenNameCOMMA	
fTempElementDecl	TokenNameIdentifier	 f Temp Element Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// fixes E15.1 	TokenNameCOMMENT_LINE	fixes E15.1 
if	TokenNameif	
(	TokenNameLPAREN	
fTempElementDecl	TokenNameIdentifier	 f Temp Element Decl
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
.	TokenNameDOT	
TYPE_EMPTY	TokenNameIdentifier	 TYPE  EMPTY
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
"MSG_CONTENT_INVALID_SPECIFIED"	TokenNameStringLiteral	MSG_CONTENT_INVALID_SPECIFIED
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fCurrentElement	TokenNameIdentifier	 f Current Element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
"EMPTY"	TokenNameStringLiteral	EMPTY
,	TokenNameCOMMA	
"ENTITY"	TokenNameStringLiteral	ENTITY
}	TokenNameRBRACE	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getStandalone	TokenNameIdentifier	 get Standalone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XMLDTDLoader	TokenNameIdentifier	 XMLDTD Loader
.	TokenNameDOT	
checkStandaloneEntityRef	TokenNameIdentifier	 check Standalone Entity Ref
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
,	TokenNameCOMMA	
fEntityDecl	TokenNameIdentifier	 f Entity Decl
,	TokenNameCOMMA	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
startGeneralEntity	TokenNameIdentifier	 start General Entity
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
identifier	TokenNameIdentifier	 identifier
,	TokenNameCOMMA	
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * This method notifies the end of a general entity. * <p> * <strong>Note:</strong> This method is not called for entity references * appearing as part of attribute values. * * @param name The name of the entity. * @param augs Additional information that may include infoset augmentations * * @exception XNIException * Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 This method notifies the end of a general entity. <p> <strong>Note:</strong> This method is not called for entity references appearing as part of attribute values. * @param name The name of the entity. @param augs Additional information that may include infoset augmentations * @exception XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
endGeneralEntity	TokenNameIdentifier	 end General Entity
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
// call handlers 	TokenNameCOMMENT_LINE	call handlers 
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
endGeneralEntity	TokenNameIdentifier	 end General Entity
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// endEntity(String) 	TokenNameCOMMENT_LINE	endEntity(String) 
/** * Notifies of the presence of a TextDecl line in an entity. If present, * this method will be called immediately following the startParameterEntity call. * <p> * <strong>Note:</strong> This method is only called for external * parameter entities referenced in the DTD. * * @param version The XML version, or null if not specified. * @param encoding The IANA encoding name of the entity. * @param augs Additional information that may include infoset * augmentations. * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 Notifies of the presence of a TextDecl line in an entity. If present, this method will be called immediately following the startParameterEntity call. <p> <strong>Note:</strong> This method is only called for external parameter entities referenced in the DTD. * @param version The XML version, or null if not specified. @param encoding The IANA encoding name of the entity. @param augs Additional information that may include infoset augmentations. * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
textDecl	TokenNameIdentifier	 text Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
version	TokenNameIdentifier	 version
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
// call handlers 	TokenNameCOMMENT_LINE	call handlers 
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
textDecl	TokenNameIdentifier	 text Decl
(	TokenNameLPAREN	
version	TokenNameIdentifier	 version
,	TokenNameCOMMA	
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
final	TokenNamefinal	
boolean	TokenNameboolean	
hasGrammar	TokenNameIdentifier	 has Grammar
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
final	TokenNamefinal	
boolean	TokenNameboolean	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Do validation if all of the following are true: 	TokenNameCOMMENT_LINE	Do validation if all of the following are true: 
// 1. The JAXP Schema Language property is not XML Schema 	TokenNameCOMMENT_LINE	1. The JAXP Schema Language property is not XML Schema 
// REVISIT: since only DTD and Schema are supported at this time, 	TokenNameCOMMENT_LINE	REVISIT: since only DTD and Schema are supported at this time, 
// such checking is sufficient. but if more schema types 	TokenNameCOMMENT_LINE	such checking is sufficient. but if more schema types 
// are introduced in the future, we'll need to change it 	TokenNameCOMMENT_LINE	are introduced in the future, we'll need to change it 
// to something like 	TokenNameCOMMENT_LINE	to something like 
// (fSchemaType == null || fSchemaType == NS_XML_DTD) 	TokenNameCOMMENT_LINE	(fSchemaType == null || fSchemaType == NS_XML_DTD) 
// 2. One of the following is true (validation features) 	TokenNameCOMMENT_LINE	2. One of the following is true (validation features) 
// 2.1 Dynamic validation is off, and validation is on 	TokenNameCOMMENT_LINE	2.1 Dynamic validation is off, and validation is on 
// 2.2 Dynamic validation is on, and DOCTYPE was seen 	TokenNameCOMMENT_LINE	2.2 Dynamic validation is on, and DOCTYPE was seen 
// 3 Xerces schema validation feature is off, or DOCTYPE was seen. 	TokenNameCOMMENT_LINE	3 Xerces schema validation feature is off, or DOCTYPE was seen. 
return	TokenNamereturn	
(	TokenNameLPAREN	
fSchemaType	TokenNameIdentifier	 f Schema Type
!=	TokenNameNOT_EQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
NS_XMLSCHEMA	TokenNameIdentifier	 NS  XMLSCHEMA
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
!	TokenNameNOT	
fDynamicValidation	TokenNameIdentifier	 f Dynamic Validation
&&	TokenNameAND_AND	
fValidation	TokenNameIdentifier	 f Validation
||	TokenNameOR_OR	
fDynamicValidation	TokenNameIdentifier	 f Dynamic Validation
&&	TokenNameAND_AND	
fSeenDoctypeDecl	TokenNameIdentifier	 f Seen Doctype Decl
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
fDTDValidation	TokenNameIdentifier	 f DTD Validation
||	TokenNameOR_OR	
fSeenDoctypeDecl	TokenNameIdentifier	 f Seen Doctype Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//REVISIT:we can convert into functions.. adding default attribute values.. and one validating. 	TokenNameCOMMENT_LINE	REVISIT:we can convert into functions.. adding default attribute values.. and one validating. 
/** Add default attributes and validate. */	TokenNameCOMMENT_JAVADOC	 Add default attributes and validate. 
protected	TokenNameprotected	
void	TokenNamevoid	
addDTDDefaultAttrsAndValidate	TokenNameIdentifier	 add DTD Default Attrs And Validate
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
elementName	TokenNameIdentifier	 element Name
,	TokenNameCOMMA	
int	TokenNameint	
elementIndex	TokenNameIdentifier	 element Index
,	TokenNameCOMMA	
XMLAttributes	TokenNameIdentifier	 XML Attributes
attributes	TokenNameIdentifier	 attributes
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
// is there anything to do? 	TokenNameCOMMENT_LINE	is there anything to do? 
if	TokenNameif	
(	TokenNameLPAREN	
elementIndex	TokenNameIdentifier	 element Index
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// Check after all specified attrs are scanned 	TokenNameCOMMENT_LINE	Check after all specified attrs are scanned 
// (1) report error for REQUIRED attrs that are missing (V_TAGc) 	TokenNameCOMMENT_LINE	(1) report error for REQUIRED attrs that are missing (V_TAGc) 
// (2) add default attrs (FIXED and NOT_FIXED) 	TokenNameCOMMENT_LINE	(2) add default attrs (FIXED and NOT_FIXED) 
// 	TokenNameCOMMENT_LINE	 
int	TokenNameint	
attlistIndex	TokenNameIdentifier	 attlist Index
=	TokenNameEQUAL	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
.	TokenNameDOT	
getFirstAttributeDeclIndex	TokenNameIdentifier	 get First Attribute Decl Index
(	TokenNameLPAREN	
elementIndex	TokenNameIdentifier	 element Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
attlistIndex	TokenNameIdentifier	 attlist Index
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
.	TokenNameDOT	
getAttributeDecl	TokenNameIdentifier	 get Attribute Decl
(	TokenNameLPAREN	
attlistIndex	TokenNameIdentifier	 attlist Index
,	TokenNameCOMMA	
fTempAttDecl	TokenNameIdentifier	 f Temp Att Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG_ATTRIBUTES	TokenNameIdentifier	 DEBUG  ATTRIBUTES
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fTempAttDecl	TokenNameIdentifier	 f Temp Att Decl
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
elementDecl	TokenNameIdentifier	 element Decl
=	TokenNameEQUAL	
new	TokenNamenew	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
.	TokenNameDOT	
getElementDecl	TokenNameIdentifier	 get Element Decl
(	TokenNameLPAREN	
elementIndex	TokenNameIdentifier	 element Index
,	TokenNameCOMMA	
elementDecl	TokenNameIdentifier	 element Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"element: "	TokenNameStringLiteral	element: 
+	TokenNamePLUS	
(	TokenNameLPAREN	
elementDecl	TokenNameIdentifier	 element Decl
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"attlistIndex "	TokenNameStringLiteral	attlistIndex 
+	TokenNamePLUS	
attlistIndex	TokenNameIdentifier	 attlist Index
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
"attName : '"	TokenNameStringLiteral	attName : '
+	TokenNamePLUS	
(	TokenNameLPAREN	
fTempAttDecl	TokenNameIdentifier	 f Temp Att Decl
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
)	TokenNameRPAREN	
+	TokenNamePLUS	
"' "	TokenNameStringLiteral	' 
+	TokenNamePLUS	
"attType : "	TokenNameStringLiteral	attType : 
+	TokenNamePLUS	
fTempAttDecl	TokenNameIdentifier	 f Temp Att Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
type	TokenNameIdentifier	 type
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
"attDefaultType : "	TokenNameStringLiteral	attDefaultType : 
+	TokenNamePLUS	
fTempAttDecl	TokenNameIdentifier	 f Temp Att Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
defaultType	TokenNameIdentifier	 default Type
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
"attDefaultValue : '"	TokenNameStringLiteral	attDefaultValue : '
+	TokenNamePLUS	
fTempAttDecl	TokenNameIdentifier	 f Temp Att Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
defaultValue	TokenNameIdentifier	 default Value
+	TokenNamePLUS	
"' "	TokenNameStringLiteral	' 
+	TokenNamePLUS	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
attPrefix	TokenNameIdentifier	 att Prefix
=	TokenNameEQUAL	
fTempAttDecl	TokenNameIdentifier	 f Temp Att Decl
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
prefix	TokenNameIdentifier	 prefix
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
attLocalpart	TokenNameIdentifier	 att Localpart
=	TokenNameEQUAL	
fTempAttDecl	TokenNameIdentifier	 f Temp Att Decl
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
attRawName	TokenNameIdentifier	 att Raw Name
=	TokenNameEQUAL	
fTempAttDecl	TokenNameIdentifier	 f Temp Att Decl
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
attType	TokenNameIdentifier	 att Type
=	TokenNameEQUAL	
getAttributeTypeName	TokenNameIdentifier	 get Attribute Type Name
(	TokenNameLPAREN	
fTempAttDecl	TokenNameIdentifier	 f Temp Att Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
attDefaultType	TokenNameIdentifier	 att Default Type
=	TokenNameEQUAL	
fTempAttDecl	TokenNameIdentifier	 f Temp Att Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
defaultType	TokenNameIdentifier	 default Type
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
attValue	TokenNameIdentifier	 att Value
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fTempAttDecl	TokenNameIdentifier	 f Temp Att Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
defaultValue	TokenNameIdentifier	 default Value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
attValue	TokenNameIdentifier	 att Value
=	TokenNameEQUAL	
fTempAttDecl	TokenNameIdentifier	 f Temp Att Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
defaultValue	TokenNameIdentifier	 default Value
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
boolean	TokenNameboolean	
specified	TokenNameIdentifier	 specified
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
required	TokenNameIdentifier	 required
=	TokenNameEQUAL	
attDefaultType	TokenNameIdentifier	 att Default Type
==	TokenNameEQUAL_EQUAL	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
DEFAULT_TYPE_REQUIRED	TokenNameIdentifier	 DEFAULT  TYPE  REQUIRED
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
cdata	TokenNameIdentifier	 cdata
=	TokenNameEQUAL	
attType	TokenNameIdentifier	 att Type
==	TokenNameEQUAL_EQUAL	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
fCDATASymbol	TokenNameIdentifier	 f CDATA Symbol
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
cdata	TokenNameIdentifier	 cdata
||	TokenNameOR_OR	
required	TokenNameIdentifier	 required
||	TokenNameOR_OR	
attValue	TokenNameIdentifier	 att Value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
attrCount	TokenNameIdentifier	 attr Count
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
attrCount	TokenNameIdentifier	 attr Count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getQName	TokenNameIdentifier	 get Q Name
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
attRawName	TokenNameIdentifier	 att Raw Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
specified	TokenNameIdentifier	 specified
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
specified	TokenNameIdentifier	 specified
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
required	TokenNameIdentifier	 required
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fPerformValidation	TokenNameIdentifier	 f Perform Validation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
args	TokenNameIdentifier	 args
=	TokenNameEQUAL	
{	TokenNameLBRACE	
elementName	TokenNameIdentifier	 element Name
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
,	TokenNameCOMMA	
attRawName	TokenNameIdentifier	 att Raw Name
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
"MSG_REQUIRED_ATTRIBUTE_NOT_SPECIFIED"	TokenNameStringLiteral	MSG_REQUIRED_ATTRIBUTE_NOT_SPECIFIED
,	TokenNameCOMMA	
args	TokenNameIdentifier	 args
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
attValue	TokenNameIdentifier	 att Value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fPerformValidation	TokenNameIdentifier	 f Perform Validation
&&	TokenNameAND_AND	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getStandalone	TokenNameIdentifier	 get Standalone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
.	TokenNameDOT	
getAttributeDeclIsExternal	TokenNameIdentifier	 get Attribute Decl Is External
(	TokenNameLPAREN	
attlistIndex	TokenNameIdentifier	 attlist Index
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
args	TokenNameIdentifier	 args
=	TokenNameEQUAL	
{	TokenNameLBRACE	
elementName	TokenNameIdentifier	 element Name
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
,	TokenNameCOMMA	
attRawName	TokenNameIdentifier	 att Raw Name
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
"MSG_DEFAULTED_ATTRIBUTE_NOT_SPECIFIED"	TokenNameStringLiteral	MSG_DEFAULTED_ATTRIBUTE_NOT_SPECIFIED
,	TokenNameCOMMA	
args	TokenNameIdentifier	 args
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// add namespace information 	TokenNameCOMMENT_LINE	add namespace information 
if	TokenNameif	
(	TokenNameLPAREN	
fNamespaces	TokenNameIdentifier	 f Namespaces
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
attRawName	TokenNameIdentifier	 att Raw Name
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
':'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
attPrefix	TokenNameIdentifier	 att Prefix
=	TokenNameEQUAL	
attRawName	TokenNameIdentifier	 att Raw Name
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
attPrefix	TokenNameIdentifier	 att Prefix
=	TokenNameEQUAL	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
.	TokenNameDOT	
addSymbol	TokenNameIdentifier	 add Symbol
(	TokenNameLPAREN	
attPrefix	TokenNameIdentifier	 att Prefix
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
attLocalpart	TokenNameIdentifier	 att Localpart
=	TokenNameEQUAL	
attRawName	TokenNameIdentifier	 att Raw Name
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
attLocalpart	TokenNameIdentifier	 att Localpart
=	TokenNameEQUAL	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
.	TokenNameDOT	
addSymbol	TokenNameIdentifier	 add Symbol
(	TokenNameLPAREN	
attLocalpart	TokenNameIdentifier	 att Localpart
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// add attribute 	TokenNameCOMMENT_LINE	add attribute 
fTempQName	TokenNameIdentifier	 f Temp Q Name
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
attPrefix	TokenNameIdentifier	 att Prefix
,	TokenNameCOMMA	
attLocalpart	TokenNameIdentifier	 att Localpart
,	TokenNameCOMMA	
attRawName	TokenNameIdentifier	 att Raw Name
,	TokenNameCOMMA	
fTempAttDecl	TokenNameIdentifier	 f Temp Att Decl
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
newAttr	TokenNameIdentifier	 new Attr
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
fTempQName	TokenNameIdentifier	 f Temp Q Name
,	TokenNameCOMMA	
attType	TokenNameIdentifier	 att Type
,	TokenNameCOMMA	
attValue	TokenNameIdentifier	 att Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// get next att decl in the Grammar for this element 	TokenNameCOMMENT_LINE	get next att decl in the Grammar for this element 
attlistIndex	TokenNameIdentifier	 attlist Index
=	TokenNameEQUAL	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
.	TokenNameDOT	
getNextAttributeDeclIndex	TokenNameIdentifier	 get Next Attribute Decl Index
(	TokenNameLPAREN	
attlistIndex	TokenNameIdentifier	 attlist Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// now iterate through the expanded attributes for 	TokenNameCOMMENT_LINE	now iterate through the expanded attributes for 
// 1. if every attribute seen is declared in the DTD 	TokenNameCOMMENT_LINE	1. if every attribute seen is declared in the DTD 
// 2. check if the VC: default_fixed holds 	TokenNameCOMMENT_LINE	2. check if the VC: default_fixed holds 
// 3. validate every attribute. 	TokenNameCOMMENT_LINE	3. validate every attribute. 
int	TokenNameint	
attrCount	TokenNameIdentifier	 attr Count
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
attrCount	TokenNameIdentifier	 attr Count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
attrRawName	TokenNameIdentifier	 attr Raw Name
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getQName	TokenNameIdentifier	 get Q Name
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
declared	TokenNameIdentifier	 declared
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fPerformValidation	TokenNameIdentifier	 f Perform Validation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getStandalone	TokenNameIdentifier	 get Standalone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// check VC: Standalone Document Declaration, entities 	TokenNameCOMMENT_LINE	check VC: Standalone Document Declaration, entities 
// references appear in the document. 	TokenNameCOMMENT_LINE	references appear in the document. 
// REVISIT: this can be combined to a single check in 	TokenNameCOMMENT_LINE	REVISIT: this can be combined to a single check in 
// startEntity if we add one more argument in 	TokenNameCOMMENT_LINE	startEntity if we add one more argument in 
// startEnity, inAttrValue 	TokenNameCOMMENT_LINE	startEnity, inAttrValue 
String	TokenNameIdentifier	 String
nonNormalizedValue	TokenNameIdentifier	 non Normalized Value
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getNonNormalizedValue	TokenNameIdentifier	 get Non Normalized Value
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nonNormalizedValue	TokenNameIdentifier	 non Normalized Value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
entityName	TokenNameIdentifier	 entity Name
=	TokenNameEQUAL	
getExternalEntityRefInAttrValue	TokenNameIdentifier	 get External Entity Ref In Attr Value
(	TokenNameLPAREN	
nonNormalizedValue	TokenNameIdentifier	 non Normalized Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
entityName	TokenNameIdentifier	 entity Name
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
"MSG_REFERENCE_TO_EXTERNALLY_DECLARED_ENTITY_WHEN_STANDALONE"	TokenNameStringLiteral	MSG_REFERENCE_TO_EXTERNALLY_DECLARED_ENTITY_WHEN_STANDALONE
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
entityName	TokenNameIdentifier	 entity Name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
int	TokenNameint	
attDefIndex	TokenNameIdentifier	 att Def Index
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
position	TokenNameIdentifier	 position
=	TokenNameEQUAL	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
.	TokenNameDOT	
getFirstAttributeDeclIndex	TokenNameIdentifier	 get First Attribute Decl Index
(	TokenNameLPAREN	
elementIndex	TokenNameIdentifier	 element Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
position	TokenNameIdentifier	 position
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
.	TokenNameDOT	
getAttributeDecl	TokenNameIdentifier	 get Attribute Decl
(	TokenNameLPAREN	
position	TokenNameIdentifier	 position
,	TokenNameCOMMA	
fTempAttDecl	TokenNameIdentifier	 f Temp Att Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fTempAttDecl	TokenNameIdentifier	 f Temp Att Decl
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
==	TokenNameEQUAL_EQUAL	
attrRawName	TokenNameIdentifier	 attr Raw Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// found the match att decl, 	TokenNameCOMMENT_LINE	found the match att decl, 
attDefIndex	TokenNameIdentifier	 att Def Index
=	TokenNameEQUAL	
position	TokenNameIdentifier	 position
;	TokenNameSEMICOLON	
declared	TokenNameIdentifier	 declared
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
position	TokenNameIdentifier	 position
=	TokenNameEQUAL	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
.	TokenNameDOT	
getNextAttributeDeclIndex	TokenNameIdentifier	 get Next Attribute Decl Index
(	TokenNameLPAREN	
position	TokenNameIdentifier	 position
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
declared	TokenNameIdentifier	 declared
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fPerformValidation	TokenNameIdentifier	 f Perform Validation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// REVISIT - cache the elem/attr tuple so that we only 	TokenNameCOMMENT_LINE	REVISIT - cache the elem/attr tuple so that we only 
// give this error once for each unique occurrence 	TokenNameCOMMENT_LINE	give this error once for each unique occurrence 
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
args	TokenNameIdentifier	 args
=	TokenNameEQUAL	
{	TokenNameLBRACE	
elementName	TokenNameIdentifier	 element Name
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
attrRawName	TokenNameIdentifier	 attr Raw Name
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
"MSG_ATTRIBUTE_NOT_DECLARED"	TokenNameStringLiteral	MSG_ATTRIBUTE_NOT_DECLARED
,	TokenNameCOMMA	
args	TokenNameIdentifier	 args
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// attribute is declared 	TokenNameCOMMENT_LINE	attribute is declared 
// fTempAttDecl should have the right value set now, so 	TokenNameCOMMENT_LINE	fTempAttDecl should have the right value set now, so 
// the following is not needed 	TokenNameCOMMENT_LINE	the following is not needed 
// fGrammar.getAttributeDecl(attDefIndex,fTempAttDecl); 	TokenNameCOMMENT_LINE	fGrammar.getAttributeDecl(attDefIndex,fTempAttDecl); 
String	TokenNameIdentifier	 String
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
getAttributeTypeName	TokenNameIdentifier	 get Attribute Type Name
(	TokenNameLPAREN	
fTempAttDecl	TokenNameIdentifier	 f Temp Att Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
setType	TokenNameIdentifier	 set Type
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getAugmentations	TokenNameIdentifier	 get Augmentations
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
.	TokenNameDOT	
putItem	TokenNameIdentifier	 put Item
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ATTRIBUTE_DECLARED	TokenNameIdentifier	 ATTRIBUTE  DECLARED
,	TokenNameCOMMA	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
TRUE	TokenNameIdentifier	 TRUE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
changedByNormalization	TokenNameIdentifier	 changed By Normalization
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
oldValue	TokenNameIdentifier	 old Value
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
attrValue	TokenNameIdentifier	 attr Value
=	TokenNameEQUAL	
oldValue	TokenNameIdentifier	 old Value
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
isSpecified	TokenNameIdentifier	 is Specified
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
fCDATASymbol	TokenNameIdentifier	 f CDATA Symbol
)	TokenNameRPAREN	
{	TokenNameLBRACE	
changedByNormalization	TokenNameIdentifier	 changed By Normalization
=	TokenNameEQUAL	
normalizeAttrValue	TokenNameIdentifier	 normalize Attr Value
(	TokenNameLPAREN	
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
attrValue	TokenNameIdentifier	 attr Value
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fPerformValidation	TokenNameIdentifier	 f Perform Validation
&&	TokenNameAND_AND	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getStandalone	TokenNameIdentifier	 get Standalone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
changedByNormalization	TokenNameIdentifier	 changed By Normalization
&&	TokenNameAND_AND	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
.	TokenNameDOT	
getAttributeDeclIsExternal	TokenNameIdentifier	 get Attribute Decl Is External
(	TokenNameLPAREN	
position	TokenNameIdentifier	 position
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// check VC: Standalone Document Declaration 	TokenNameCOMMENT_LINE	check VC: Standalone Document Declaration 
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
"MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE"	TokenNameStringLiteral	MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
attrRawName	TokenNameIdentifier	 attr Raw Name
,	TokenNameCOMMA	
oldValue	TokenNameIdentifier	 old Value
,	TokenNameCOMMA	
attrValue	TokenNameIdentifier	 attr Value
}	TokenNameRBRACE	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fPerformValidation	TokenNameIdentifier	 f Perform Validation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fTempAttDecl	TokenNameIdentifier	 f Temp Att Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
defaultType	TokenNameIdentifier	 default Type
==	TokenNameEQUAL_EQUAL	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
DEFAULT_TYPE_FIXED	TokenNameIdentifier	 DEFAULT  TYPE  FIXED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
defaultValue	TokenNameIdentifier	 default Value
=	TokenNameEQUAL	
fTempAttDecl	TokenNameIdentifier	 f Temp Att Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
defaultValue	TokenNameIdentifier	 default Value
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
attrValue	TokenNameIdentifier	 attr Value
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
defaultValue	TokenNameIdentifier	 default Value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
args	TokenNameIdentifier	 args
=	TokenNameEQUAL	
{	TokenNameLBRACE	
elementName	TokenNameIdentifier	 element Name
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
,	TokenNameCOMMA	
attrRawName	TokenNameIdentifier	 attr Raw Name
,	TokenNameCOMMA	
attrValue	TokenNameIdentifier	 attr Value
,	TokenNameCOMMA	
defaultValue	TokenNameIdentifier	 default Value
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
"MSG_FIXED_ATTVALUE_INVALID"	TokenNameStringLiteral	MSG_FIXED_ATTVALUE_INVALID
,	TokenNameCOMMA	
args	TokenNameIdentifier	 args
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fTempAttDecl	TokenNameIdentifier	 f Temp Att Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
TYPE_ENTITY	TokenNameIdentifier	 TYPE  ENTITY
||	TokenNameOR_OR	
fTempAttDecl	TokenNameIdentifier	 f Temp Att Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
TYPE_ENUMERATION	TokenNameIdentifier	 TYPE  ENUMERATION
||	TokenNameOR_OR	
fTempAttDecl	TokenNameIdentifier	 f Temp Att Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
TYPE_ID	TokenNameIdentifier	 TYPE  ID
||	TokenNameOR_OR	
fTempAttDecl	TokenNameIdentifier	 f Temp Att Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
TYPE_IDREF	TokenNameIdentifier	 TYPE  IDREF
||	TokenNameOR_OR	
fTempAttDecl	TokenNameIdentifier	 f Temp Att Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
TYPE_NMTOKEN	TokenNameIdentifier	 TYPE  NMTOKEN
||	TokenNameOR_OR	
fTempAttDecl	TokenNameIdentifier	 f Temp Att Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
TYPE_NOTATION	TokenNameIdentifier	 TYPE  NOTATION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
validateDTDattribute	TokenNameIdentifier	 validate DT Dattribute
(	TokenNameLPAREN	
elementName	TokenNameIdentifier	 element Name
,	TokenNameCOMMA	
attrValue	TokenNameIdentifier	 attr Value
,	TokenNameCOMMA	
fTempAttDecl	TokenNameIdentifier	 f Temp Att Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// for all attributes 	TokenNameCOMMENT_LINE	for all attributes 
}	TokenNameRBRACE	
// addDTDDefaultAttrsAndValidate(int,XMLAttrList) 	TokenNameCOMMENT_LINE	addDTDDefaultAttrsAndValidate(int,XMLAttrList) 
/** Checks entities in attribute values for standalone VC. */	TokenNameCOMMENT_JAVADOC	 Checks entities in attribute values for standalone VC. 
protected	TokenNameprotected	
String	TokenNameIdentifier	 String
getExternalEntityRefInAttrValue	TokenNameIdentifier	 get External Entity Ref In Attr Value
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
nonNormalizedValue	TokenNameIdentifier	 non Normalized Value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
valLength	TokenNameIdentifier	 val Length
=	TokenNameEQUAL	
nonNormalizedValue	TokenNameIdentifier	 non Normalized Value
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
ampIndex	TokenNameIdentifier	 amp Index
=	TokenNameEQUAL	
nonNormalizedValue	TokenNameIdentifier	 non Normalized Value
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
'&'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
ampIndex	TokenNameIdentifier	 amp Index
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ampIndex	TokenNameIdentifier	 amp Index
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
<	TokenNameLESS	
valLength	TokenNameIdentifier	 val Length
&&	TokenNameAND_AND	
nonNormalizedValue	TokenNameIdentifier	 non Normalized Value
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
ampIndex	TokenNameIdentifier	 amp Index
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
'#'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
semicolonIndex	TokenNameIdentifier	 semicolon Index
=	TokenNameEQUAL	
nonNormalizedValue	TokenNameIdentifier	 non Normalized Value
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
';'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
ampIndex	TokenNameIdentifier	 amp Index
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
entityName	TokenNameIdentifier	 entity Name
=	TokenNameEQUAL	
nonNormalizedValue	TokenNameIdentifier	 non Normalized Value
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
ampIndex	TokenNameIdentifier	 amp Index
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
semicolonIndex	TokenNameIdentifier	 semicolon Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
entityName	TokenNameIdentifier	 entity Name
=	TokenNameEQUAL	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
.	TokenNameDOT	
addSymbol	TokenNameIdentifier	 add Symbol
(	TokenNameLPAREN	
entityName	TokenNameIdentifier	 entity Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
entIndex	TokenNameIdentifier	 ent Index
=	TokenNameEQUAL	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
.	TokenNameDOT	
getEntityDeclIndex	TokenNameIdentifier	 get Entity Decl Index
(	TokenNameLPAREN	
entityName	TokenNameIdentifier	 entity Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
entIndex	TokenNameIdentifier	 ent Index
>	TokenNameGREATER	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
.	TokenNameDOT	
getEntityDecl	TokenNameIdentifier	 get Entity Decl
(	TokenNameLPAREN	
entIndex	TokenNameIdentifier	 ent Index
,	TokenNameCOMMA	
fEntityDecl	TokenNameIdentifier	 f Entity Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityDecl	TokenNameIdentifier	 f Entity Decl
.	TokenNameDOT	
inExternal	TokenNameIdentifier	 in External
||	TokenNameOR_OR	
(	TokenNameLPAREN	
entityName	TokenNameIdentifier	 entity Name
=	TokenNameEQUAL	
getExternalEntityRefInAttrValue	TokenNameIdentifier	 get External Entity Ref In Attr Value
(	TokenNameLPAREN	
fEntityDecl	TokenNameIdentifier	 f Entity Decl
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
entityName	TokenNameIdentifier	 entity Name
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
ampIndex	TokenNameIdentifier	 amp Index
=	TokenNameEQUAL	
nonNormalizedValue	TokenNameIdentifier	 non Normalized Value
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
'&'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
ampIndex	TokenNameIdentifier	 amp Index
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// isExternalEntityRefInAttrValue(String):String 	TokenNameCOMMENT_LINE	isExternalEntityRefInAttrValue(String):String 
/** * Validate attributes in DTD fashion. */	TokenNameCOMMENT_JAVADOC	 Validate attributes in DTD fashion. 
protected	TokenNameprotected	
void	TokenNamevoid	
validateDTDattribute	TokenNameIdentifier	 validate DT Dattribute
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
attValue	TokenNameIdentifier	 att Value
,	TokenNameCOMMA	
XMLAttributeDecl	TokenNameIdentifier	 XML Attribute Decl
attributeDecl	TokenNameIdentifier	 attribute Decl
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
attributeDecl	TokenNameIdentifier	 attribute Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
TYPE_ENTITY	TokenNameIdentifier	 TYPE  ENTITY
:	TokenNameCOLON	
{	TokenNameLBRACE	
// NOTE: Save this information because invalidStandaloneAttDef 	TokenNameCOMMENT_LINE	NOTE: Save this information because invalidStandaloneAttDef 
boolean	TokenNameboolean	
isAlistAttribute	TokenNameIdentifier	 is Alist Attribute
=	TokenNameEQUAL	
attributeDecl	TokenNameIdentifier	 attribute Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
list	TokenNameIdentifier	 list
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isAlistAttribute	TokenNameIdentifier	 is Alist Attribute
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fValENTITIES	TokenNameIdentifier	 f Val ENTITIES
.	TokenNameDOT	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
attValue	TokenNameIdentifier	 att Value
,	TokenNameCOMMA	
fValidationState	TokenNameIdentifier	 f Validation State
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fValENTITY	TokenNameIdentifier	 f Val ENTITY
.	TokenNameDOT	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
attValue	TokenNameIdentifier	 att Value
,	TokenNameCOMMA	
fValidationState	TokenNameIdentifier	 f Validation State
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
ex	TokenNameIdentifier	 ex
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ex	TokenNameIdentifier	 ex
.	TokenNameDOT	
getArgs	TokenNameIdentifier	 get Args
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
TYPE_NOTATION	TokenNameIdentifier	 TYPE  NOTATION
:	TokenNameCOLON	
case	TokenNamecase	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
TYPE_ENUMERATION	TokenNameIdentifier	 TYPE  ENUMERATION
:	TokenNameCOLON	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
found	TokenNameIdentifier	 found
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
enumVals	TokenNameIdentifier	 enum Vals
=	TokenNameEQUAL	
attributeDecl	TokenNameIdentifier	 attribute Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
enumeration	TokenNameIdentifier	 enumeration
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
enumVals	TokenNameIdentifier	 enum Vals
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
found	TokenNameIdentifier	 found
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
enumVals	TokenNameIdentifier	 enum Vals
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
attValue	TokenNameIdentifier	 att Value
==	TokenNameEQUAL_EQUAL	
enumVals	TokenNameIdentifier	 enum Vals
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
||	TokenNameOR_OR	
attValue	TokenNameIdentifier	 att Value
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
enumVals	TokenNameIdentifier	 enum Vals
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
found	TokenNameIdentifier	 found
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
found	TokenNameIdentifier	 found
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StringBuffer	TokenNameIdentifier	 String Buffer
enumValueString	TokenNameIdentifier	 enum Value String
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
enumVals	TokenNameIdentifier	 enum Vals
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
enumVals	TokenNameIdentifier	 enum Vals
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
enumValueString	TokenNameIdentifier	 enum Value String
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
enumVals	TokenNameIdentifier	 enum Vals
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
"MSG_ATTRIBUTE_VALUE_NOT_IN_LIST"	TokenNameStringLiteral	MSG_ATTRIBUTE_VALUE_NOT_IN_LIST
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
attributeDecl	TokenNameIdentifier	 attribute Decl
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
attValue	TokenNameIdentifier	 att Value
,	TokenNameCOMMA	
enumValueString	TokenNameIdentifier	 enum Value String
}	TokenNameRBRACE	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
TYPE_ID	TokenNameIdentifier	 TYPE  ID
:	TokenNameCOLON	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fValID	TokenNameIdentifier	 f Val ID
.	TokenNameDOT	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
attValue	TokenNameIdentifier	 att Value
,	TokenNameCOMMA	
fValidationState	TokenNameIdentifier	 f Validation State
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
ex	TokenNameIdentifier	 ex
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ex	TokenNameIdentifier	 ex
.	TokenNameDOT	
getArgs	TokenNameIdentifier	 get Args
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
TYPE_IDREF	TokenNameIdentifier	 TYPE  IDREF
:	TokenNameCOLON	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
isAlistAttribute	TokenNameIdentifier	 is Alist Attribute
=	TokenNameEQUAL	
attributeDecl	TokenNameIdentifier	 attribute Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
list	TokenNameIdentifier	 list
;	TokenNameSEMICOLON	
//Caveat - Save this information because invalidStandaloneAttDef 	TokenNameCOMMENT_LINE	Caveat - Save this information because invalidStandaloneAttDef 
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isAlistAttribute	TokenNameIdentifier	 is Alist Attribute
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fValIDRefs	TokenNameIdentifier	 f Val ID Refs
.	TokenNameDOT	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
attValue	TokenNameIdentifier	 att Value
,	TokenNameCOMMA	
fValidationState	TokenNameIdentifier	 f Validation State
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fValIDRef	TokenNameIdentifier	 f Val ID Ref
.	TokenNameDOT	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
attValue	TokenNameIdentifier	 att Value
,	TokenNameCOMMA	
fValidationState	TokenNameIdentifier	 f Validation State
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isAlistAttribute	TokenNameIdentifier	 is Alist Attribute
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
"IDREFSInvalid"	TokenNameStringLiteral	IDREFSInvalid
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
attValue	TokenNameIdentifier	 att Value
}	TokenNameRBRACE	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
ex	TokenNameIdentifier	 ex
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ex	TokenNameIdentifier	 ex
.	TokenNameDOT	
getArgs	TokenNameIdentifier	 get Args
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
TYPE_NMTOKEN	TokenNameIdentifier	 TYPE  NMTOKEN
:	TokenNameCOLON	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
isAlistAttribute	TokenNameIdentifier	 is Alist Attribute
=	TokenNameEQUAL	
attributeDecl	TokenNameIdentifier	 attribute Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
list	TokenNameIdentifier	 list
;	TokenNameSEMICOLON	
//Caveat - Save this information because invalidStandaloneAttDef 	TokenNameCOMMENT_LINE	Caveat - Save this information because invalidStandaloneAttDef 
//changes fTempAttDef 	TokenNameCOMMENT_LINE	changes fTempAttDef 
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isAlistAttribute	TokenNameIdentifier	 is Alist Attribute
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fValNMTOKENS	TokenNameIdentifier	 f Val NMTOKENS
.	TokenNameDOT	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
attValue	TokenNameIdentifier	 att Value
,	TokenNameCOMMA	
fValidationState	TokenNameIdentifier	 f Validation State
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fValNMTOKEN	TokenNameIdentifier	 f Val NMTOKEN
.	TokenNameDOT	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
attValue	TokenNameIdentifier	 att Value
,	TokenNameCOMMA	
fValidationState	TokenNameIdentifier	 f Validation State
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isAlistAttribute	TokenNameIdentifier	 is Alist Attribute
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
"NMTOKENSInvalid"	TokenNameStringLiteral	NMTOKENSInvalid
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
attValue	TokenNameIdentifier	 att Value
}	TokenNameRBRACE	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
"NMTOKENInvalid"	TokenNameStringLiteral	NMTOKENInvalid
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
attValue	TokenNameIdentifier	 att Value
}	TokenNameRBRACE	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// switch 	TokenNameCOMMENT_LINE	switch 
}	TokenNameRBRACE	
// validateDTDattribute(QName,String,XMLAttributeDecl) 	TokenNameCOMMENT_LINE	validateDTDattribute(QName,String,XMLAttributeDecl) 
/** Returns true if invalid standalone attribute definition. */	TokenNameCOMMENT_JAVADOC	 Returns true if invalid standalone attribute definition. 
protected	TokenNameprotected	
boolean	TokenNameboolean	
invalidStandaloneAttDef	TokenNameIdentifier	 invalid Standalone Att Def
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
QName	TokenNameIdentifier	 Q Name
attribute	TokenNameIdentifier	 attribute
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// REVISIT: This obviously needs to be fixed! -Ac 	TokenNameCOMMENT_LINE	REVISIT: This obviously needs to be fixed! -Ac 
boolean	TokenNameboolean	
state	TokenNameIdentifier	 state
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
/* if (fStandaloneReader == -1) { return false; } // we are normalizing a default att value... this ok? if (element.rawname == -1) { return false; } return getAttDefIsExternal(element, attribute); */	TokenNameCOMMENT_BLOCK	 if (fStandaloneReader == -1) { return false; } // we are normalizing a default att value... this ok? if (element.rawname == -1) { return false; } return getAttDefIsExternal(element, attribute); 
return	TokenNamereturn	
state	TokenNameIdentifier	 state
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// Private methods 	TokenNameCOMMENT_LINE	Private methods 
// 	TokenNameCOMMENT_LINE	 
/** * Normalize the attribute value of a non CDATA attributes collapsing * sequences of space characters (x20) * * @param attributes The list of attributes * @param index The index of the attribute to normalize */	TokenNameCOMMENT_JAVADOC	 Normalize the attribute value of a non CDATA attributes collapsing sequences of space characters (x20) * @param attributes The list of attributes @param index The index of the attribute to normalize 
private	TokenNameprivate	
boolean	TokenNameboolean	
normalizeAttrValue	TokenNameIdentifier	 normalize Attr Value
(	TokenNameLPAREN	
XMLAttributes	TokenNameIdentifier	 XML Attributes
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
int	TokenNameint	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// vars 	TokenNameCOMMENT_LINE	vars 
boolean	TokenNameboolean	
leadingSpace	TokenNameIdentifier	 leading Space
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
spaceStart	TokenNameIdentifier	 space Start
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
readingNonSpace	TokenNameIdentifier	 reading Non Space
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
eaten	TokenNameIdentifier	 eaten
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
attrValue	TokenNameIdentifier	 attr Value
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
attValue	TokenNameIdentifier	 att Value
=	TokenNameEQUAL	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
attrValue	TokenNameIdentifier	 attr Value
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fBuffer	TokenNameIdentifier	 f Buffer
.	TokenNameDOT	
setLength	TokenNameIdentifier	 set Length
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
attrValue	TokenNameIdentifier	 attr Value
.	TokenNameDOT	
getChars	TokenNameIdentifier	 get Chars
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
attrValue	TokenNameIdentifier	 attr Value
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
attValue	TokenNameIdentifier	 att Value
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
attValue	TokenNameIdentifier	 att Value
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
attValue	TokenNameIdentifier	 att Value
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
' '	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// now the tricky part 	TokenNameCOMMENT_LINE	now the tricky part 
if	TokenNameif	
(	TokenNameLPAREN	
readingNonSpace	TokenNameIdentifier	 reading Non Space
)	TokenNameRPAREN	
{	TokenNameLBRACE	
spaceStart	TokenNameIdentifier	 space Start
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
readingNonSpace	TokenNameIdentifier	 reading Non Space
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
spaceStart	TokenNameIdentifier	 space Start
&&	TokenNameAND_AND	
!	TokenNameNOT	
leadingSpace	TokenNameIdentifier	 leading Space
)	TokenNameRPAREN	
{	TokenNameLBRACE	
spaceStart	TokenNameIdentifier	 space Start
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fBuffer	TokenNameIdentifier	 f Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
attValue	TokenNameIdentifier	 att Value
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
leadingSpace	TokenNameIdentifier	 leading Space
||	TokenNameOR_OR	
!	TokenNameNOT	
spaceStart	TokenNameIdentifier	 space Start
)	TokenNameRPAREN	
{	TokenNameLBRACE	
eaten	TokenNameIdentifier	 eaten
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
/*** BUG #3512 *** int entityCount = attributes.getEntityCount(index); for (int j = 0; j < entityCount; j++) { int offset = attributes.getEntityOffset(index, j); int length = attributes.getEntityLength(index, j); if (offset <= i-eaten+1) { if (offset+length >= i-eaten+1) { if (length > 0) length--; } } else { if (offset > 0) offset--; } attributes.setEntityOffset(index, j, offset); attributes.setEntityLength(index, j, length); } /***/	TokenNameCOMMENT_JAVADOC	* BUG #3512 *** int entityCount = attributes.getEntityCount(index); for (int j = 0; j < entityCount; j++) { int offset = attributes.getEntityOffset(index, j); int length = attributes.getEntityLength(index, j); if (offset <= i-eaten+1) { if (offset+length >= i-eaten+1) { if (length > 0) length--; } } else { if (offset > 0) offset--; } attributes.setEntityOffset(index, j, offset); attributes.setEntityLength(index, j, length); } /**
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
readingNonSpace	TokenNameIdentifier	 reading Non Space
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
spaceStart	TokenNameIdentifier	 space Start
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
leadingSpace	TokenNameIdentifier	 leading Space
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fBuffer	TokenNameIdentifier	 f Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
attValue	TokenNameIdentifier	 att Value
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// check if the last appended character is a space. 	TokenNameCOMMENT_LINE	check if the last appended character is a space. 
if	TokenNameif	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
fBuffer	TokenNameIdentifier	 f Buffer
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
' '	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fBuffer	TokenNameIdentifier	 f Buffer
.	TokenNameDOT	
setLength	TokenNameIdentifier	 set Length
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/*** BUG #3512 *** int entityCount = attributes.getEntityCount(index); for (int j=0; j < entityCount; j++) { int offset = attributes.getEntityOffset(index, j); int length = attributes.getEntityLength(index, j); if (offset < count-1) { if (offset+length == count) { length--; } } else { offset--; } attributes.setEntityOffset(index, j, offset); attributes.setEntityLength(index, j, length); } /***/	TokenNameCOMMENT_JAVADOC	* BUG #3512 *** int entityCount = attributes.getEntityCount(index); for (int j=0; j < entityCount; j++) { int offset = attributes.getEntityOffset(index, j); int length = attributes.getEntityLength(index, j); if (offset < count-1) { if (offset+length == count) { length--; } } else { offset--; } attributes.setEntityOffset(index, j, offset); attributes.setEntityLength(index, j, length); } /**
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
newValue	TokenNameIdentifier	 new Value
=	TokenNameEQUAL	
fBuffer	TokenNameIdentifier	 f Buffer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
setValue	TokenNameIdentifier	 set Value
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
,	TokenNameCOMMA	
newValue	TokenNameIdentifier	 new Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
!	TokenNameNOT	
attrValue	TokenNameIdentifier	 attr Value
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
newValue	TokenNameIdentifier	 new Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Root element specified. */	TokenNameCOMMENT_JAVADOC	 Root element specified. 
private	TokenNameprivate	
final	TokenNamefinal	
void	TokenNamevoid	
rootElementSpecified	TokenNameIdentifier	 root Element Specified
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
rootElement	TokenNameIdentifier	 root Element
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fPerformValidation	TokenNameIdentifier	 f Perform Validation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
root1	TokenNameIdentifier	 root1
=	TokenNameEQUAL	
fRootElement	TokenNameIdentifier	 f Root Element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
root2	TokenNameIdentifier	 root2
=	TokenNameEQUAL	
rootElement	TokenNameIdentifier	 root Element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
root1	TokenNameIdentifier	 root1
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
!	TokenNameNOT	
root1	TokenNameIdentifier	 root1
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
root2	TokenNameIdentifier	 root2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
"RootElementTypeMustMatchDoctypedecl"	TokenNameStringLiteral	RootElementTypeMustMatchDoctypedecl
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
root1	TokenNameIdentifier	 root1
,	TokenNameCOMMA	
root2	TokenNameIdentifier	 root2
}	TokenNameRBRACE	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// rootElementSpecified(QName) 	TokenNameCOMMENT_LINE	rootElementSpecified(QName) 
/** * Check that the content of an element is valid. * <p> * This is the method of primary concern to the validator. This method is called * upon the scanner reaching the end tag of an element. At that time, the * element's children must be structurally validated, so it calls this method. * The index of the element being checked (in the decl pool), is provided as * well as an array of element name indexes of the children. The validator must * confirm that this element can have these children in this order. * <p> * This can also be called to do 'what if' testing of content models just to see * if they would be valid. * <p> * Note that the element index is an index into the element decl pool, whereas * the children indexes are name indexes, i.e. into the string pool. * <p> * A value of -1 in the children array indicates a PCDATA node. All other * indexes will be positive and represent child elements. The count can be * zero, since some elements have the EMPTY content model and that must be * confirmed. * * @param elementIndex The index within the <code>ElementDeclPool</code> of this * element. * @param childCount The number of entries in the <code>children</code> array. * @param children The children of this element. * * @return The value -1 if fully valid, else the 0 based index of the child * that first failed. If the value returned is equal to the number * of children, then additional content is required to reach a valid * ending state. * * @exception Exception Thrown on error. */	TokenNameCOMMENT_JAVADOC	 Check that the content of an element is valid. <p> This is the method of primary concern to the validator. This method is called upon the scanner reaching the end tag of an element. At that time, the element's children must be structurally validated, so it calls this method. The index of the element being checked (in the decl pool), is provided as well as an array of element name indexes of the children. The validator must confirm that this element can have these children in this order. <p> This can also be called to do 'what if' testing of content models just to see if they would be valid. <p> Note that the element index is an index into the element decl pool, whereas the children indexes are name indexes, i.e. into the string pool. <p> A value of -1 in the children array indicates a PCDATA node. All other indexes will be positive and represent child elements. The count can be zero, since some elements have the EMPTY content model and that must be confirmed. * @param elementIndex The index within the <code>ElementDeclPool</code> of this element. @param childCount The number of entries in the <code>children</code> array. @param children The children of this element. * @return The value -1 if fully valid, else the 0 based index of the child that first failed. If the value returned is equal to the number of children, then additional content is required to reach a valid ending state. * @exception Exception Thrown on error. 
private	TokenNameprivate	
int	TokenNameint	
checkContent	TokenNameIdentifier	 check Content
(	TokenNameLPAREN	
int	TokenNameint	
elementIndex	TokenNameIdentifier	 element Index
,	TokenNameCOMMA	
QName	TokenNameIdentifier	 Q Name
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
children	TokenNameIdentifier	 children
,	TokenNameCOMMA	
int	TokenNameint	
childOffset	TokenNameIdentifier	 child Offset
,	TokenNameCOMMA	
int	TokenNameint	
childCount	TokenNameIdentifier	 child Count
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
.	TokenNameDOT	
getElementDecl	TokenNameIdentifier	 get Element Decl
(	TokenNameLPAREN	
elementIndex	TokenNameIdentifier	 element Index
,	TokenNameCOMMA	
fTempElementDecl	TokenNameIdentifier	 f Temp Element Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Get the element name index from the element 	TokenNameCOMMENT_LINE	Get the element name index from the element 
final	TokenNamefinal	
String	TokenNameIdentifier	 String
elementType	TokenNameIdentifier	 element Type
=	TokenNameEQUAL	
fCurrentElement	TokenNameIdentifier	 f Current Element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
;	TokenNameSEMICOLON	
// Get out the content spec for this element 	TokenNameCOMMENT_LINE	Get out the content spec for this element 
final	TokenNamefinal	
int	TokenNameint	
contentType	TokenNameIdentifier	 content Type
=	TokenNameEQUAL	
fCurrentContentSpecType	TokenNameIdentifier	 f Current Content Spec Type
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Deal with the possible types of content. We try to optimized here 	TokenNameCOMMENT_LINE	Deal with the possible types of content. We try to optimized here 
// by dealing specially with content models that don't require the 	TokenNameCOMMENT_LINE	by dealing specially with content models that don't require the 
// full DFA treatment. 	TokenNameCOMMENT_LINE	full DFA treatment. 
// 	TokenNameCOMMENT_LINE	 
if	TokenNameif	
(	TokenNameLPAREN	
contentType	TokenNameIdentifier	 content Type
==	TokenNameEQUAL_EQUAL	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
.	TokenNameDOT	
TYPE_EMPTY	TokenNameIdentifier	 TYPE  EMPTY
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// If the child count is greater than zero, then this is 	TokenNameCOMMENT_LINE	If the child count is greater than zero, then this is 
// an error right off the bat at index 0. 	TokenNameCOMMENT_LINE	an error right off the bat at index 0. 
// 	TokenNameCOMMENT_LINE	 
if	TokenNameif	
(	TokenNameLPAREN	
childCount	TokenNameIdentifier	 child Count
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
contentType	TokenNameIdentifier	 content Type
==	TokenNameEQUAL_EQUAL	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
.	TokenNameDOT	
TYPE_ANY	TokenNameIdentifier	 TYPE  ANY
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// This one is open game so we don't pass any judgement on it 	TokenNameCOMMENT_LINE	This one is open game so we don't pass any judgement on it 
// at all. Its assumed to fine since it can hold anything. 	TokenNameCOMMENT_LINE	at all. Its assumed to fine since it can hold anything. 
// 	TokenNameCOMMENT_LINE	 
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
contentType	TokenNameIdentifier	 content Type
==	TokenNameEQUAL_EQUAL	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
.	TokenNameDOT	
TYPE_MIXED	TokenNameIdentifier	 TYPE  MIXED
||	TokenNameOR_OR	
contentType	TokenNameIdentifier	 content Type
==	TokenNameEQUAL_EQUAL	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
.	TokenNameDOT	
TYPE_CHILDREN	TokenNameIdentifier	 TYPE  CHILDREN
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Get the content model for this element, faulting it in if needed 	TokenNameCOMMENT_LINE	Get the content model for this element, faulting it in if needed 
ContentModelValidator	TokenNameIdentifier	 Content Model Validator
cmElem	TokenNameIdentifier	 cm Elem
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
cmElem	TokenNameIdentifier	 cm Elem
=	TokenNameEQUAL	
fTempElementDecl	TokenNameIdentifier	 f Temp Element Decl
.	TokenNameDOT	
contentModelValidator	TokenNameIdentifier	 content Model Validator
;	TokenNameSEMICOLON	
int	TokenNameint	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
cmElem	TokenNameIdentifier	 cm Elem
.	TokenNameDOT	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
children	TokenNameIdentifier	 children
,	TokenNameCOMMA	
childOffset	TokenNameIdentifier	 child Offset
,	TokenNameCOMMA	
childCount	TokenNameIdentifier	 child Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
result	TokenNameIdentifier	 result
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
contentType	TokenNameIdentifier	 content Type
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//REVISIT 	TokenNameCOMMENT_LINE	REVISIT 
/**** reportRecoverableXMLError(XMLMessages.MSG_ELEMENT_NOT_DECLARED, XMLMessages.VC_ELEMENT_VALID, elementType); /****/	TokenNameCOMMENT_JAVADOC	** reportRecoverableXMLError(XMLMessages.MSG_ELEMENT_NOT_DECLARED, XMLMessages.VC_ELEMENT_VALID, elementType); /***
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
contentType	TokenNameIdentifier	 content Type
==	TokenNameEQUAL_EQUAL	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
.	TokenNameDOT	
TYPE_SIMPLE	TokenNameIdentifier	 TYPE  SIMPLE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//REVISIT 	TokenNameCOMMENT_LINE	REVISIT 
// this should never be reached in the case of DTD validation. 	TokenNameCOMMENT_LINE	this should never be reached in the case of DTD validation. 
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
//REVISIT 	TokenNameCOMMENT_LINE	REVISIT 
/**** fErrorReporter.reportError(fErrorReporter.getLocator(), ImplementationMessages.XERCES_IMPLEMENTATION_DOMAIN, ImplementationMessages.VAL_CST, 0, null, XMLErrorReporter.ERRORTYPE_FATAL_ERROR); /****/	TokenNameCOMMENT_JAVADOC	** fErrorReporter.reportError(fErrorReporter.getLocator(), ImplementationMessages.XERCES_IMPLEMENTATION_DOMAIN, ImplementationMessages.VAL_CST, 0, null, XMLErrorReporter.ERRORTYPE_FATAL_ERROR); /***
}	TokenNameRBRACE	
// We succeeded 	TokenNameCOMMENT_LINE	We succeeded 
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// checkContent(int,int,QName[]):int 	TokenNameCOMMENT_LINE	checkContent(int,int,QName[]):int 
/** Returns the content spec type for an element index. */	TokenNameCOMMENT_JAVADOC	 Returns the content spec type for an element index. 
private	TokenNameprivate	
int	TokenNameint	
getContentSpecType	TokenNameIdentifier	 get Content Spec Type
(	TokenNameLPAREN	
int	TokenNameint	
elementIndex	TokenNameIdentifier	 element Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
contentSpecType	TokenNameIdentifier	 content Spec Type
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
elementIndex	TokenNameIdentifier	 element Index
>	TokenNameGREATER	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
.	TokenNameDOT	
getElementDecl	TokenNameIdentifier	 get Element Decl
(	TokenNameLPAREN	
elementIndex	TokenNameIdentifier	 element Index
,	TokenNameCOMMA	
fTempElementDecl	TokenNameIdentifier	 f Temp Element Decl
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
contentSpecType	TokenNameIdentifier	 content Spec Type
=	TokenNameEQUAL	
fTempElementDecl	TokenNameIdentifier	 f Temp Element Decl
.	TokenNameDOT	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
contentSpecType	TokenNameIdentifier	 content Spec Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Character data in content. */	TokenNameCOMMENT_JAVADOC	 Character data in content. 
private	TokenNameprivate	
void	TokenNamevoid	
charDataInContent	TokenNameIdentifier	 char Data In Content
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG_ELEMENT_CHILDREN	TokenNameIdentifier	 DEBUG  ELEMENT  CHILDREN
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"charDataInContent()"	TokenNameStringLiteral	charDataInContent()
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fElementChildren	TokenNameIdentifier	 f Element Children
.	TokenNameDOT	
length	TokenNameIdentifier	 length
<=	TokenNameLESS_EQUAL	
fElementChildrenLength	TokenNameIdentifier	 f Element Children Length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
QName	TokenNameIdentifier	 Q Name
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newarray	TokenNameIdentifier	 newarray
=	TokenNameEQUAL	
new	TokenNamenew	
QName	TokenNameIdentifier	 Q Name
[	TokenNameLBRACKET	
fElementChildren	TokenNameIdentifier	 f Element Children
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fElementChildren	TokenNameIdentifier	 f Element Children
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newarray	TokenNameIdentifier	 newarray
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fElementChildren	TokenNameIdentifier	 f Element Children
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fElementChildren	TokenNameIdentifier	 f Element Children
=	TokenNameEQUAL	
newarray	TokenNameIdentifier	 newarray
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
QName	TokenNameIdentifier	 Q Name
qname	TokenNameIdentifier	 qname
=	TokenNameEQUAL	
fElementChildren	TokenNameIdentifier	 f Element Children
[	TokenNameLBRACKET	
fElementChildrenLength	TokenNameIdentifier	 f Element Children Length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
qname	TokenNameIdentifier	 qname
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
fElementChildrenLength	TokenNameIdentifier	 f Element Children Length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fElementChildren	TokenNameIdentifier	 f Element Children
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fElementChildren	TokenNameIdentifier	 f Element Children
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
QName	TokenNameIdentifier	 Q Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
qname	TokenNameIdentifier	 qname
=	TokenNameEQUAL	
fElementChildren	TokenNameIdentifier	 f Element Children
[	TokenNameLBRACKET	
fElementChildrenLength	TokenNameIdentifier	 f Element Children Length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
qname	TokenNameIdentifier	 qname
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fElementChildrenLength	TokenNameIdentifier	 f Element Children Length
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// charDataInCount() 	TokenNameCOMMENT_LINE	charDataInCount() 
/** convert attribute type from ints to strings */	TokenNameCOMMENT_JAVADOC	 convert attribute type from ints to strings 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
getAttributeTypeName	TokenNameIdentifier	 get Attribute Type Name
(	TokenNameLPAREN	
XMLAttributeDecl	TokenNameIdentifier	 XML Attribute Decl
attrDecl	TokenNameIdentifier	 attr Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
attrDecl	TokenNameIdentifier	 attr Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
TYPE_ENTITY	TokenNameIdentifier	 TYPE  ENTITY
:	TokenNameCOLON	
{	TokenNameLBRACE	
return	TokenNamereturn	
attrDecl	TokenNameIdentifier	 attr Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
list	TokenNameIdentifier	 list
?	TokenNameQUESTION	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
fENTITIESSymbol	TokenNameIdentifier	 f ENTITIES Symbol
:	TokenNameCOLON	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
fENTITYSymbol	TokenNameIdentifier	 f ENTITY Symbol
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
TYPE_ENUMERATION	TokenNameIdentifier	 TYPE  ENUMERATION
:	TokenNameCOLON	
{	TokenNameLBRACE	
StringBuffer	TokenNameIdentifier	 String Buffer
buffer	TokenNameIdentifier	 buffer
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'('	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
attrDecl	TokenNameIdentifier	 attr Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
enumeration	TokenNameIdentifier	 enumeration
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'|'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
attrDecl	TokenNameIdentifier	 attr Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
enumeration	TokenNameIdentifier	 enumeration
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
')'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
.	TokenNameDOT	
addSymbol	TokenNameIdentifier	 add Symbol
(	TokenNameLPAREN	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
TYPE_ID	TokenNameIdentifier	 TYPE  ID
:	TokenNameCOLON	
{	TokenNameLBRACE	
return	TokenNamereturn	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
fIDSymbol	TokenNameIdentifier	 f ID Symbol
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
TYPE_IDREF	TokenNameIdentifier	 TYPE  IDREF
:	TokenNameCOLON	
{	TokenNameLBRACE	
return	TokenNamereturn	
attrDecl	TokenNameIdentifier	 attr Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
list	TokenNameIdentifier	 list
?	TokenNameQUESTION	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
fIDREFSSymbol	TokenNameIdentifier	 f IDREFS Symbol
:	TokenNameCOLON	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
fIDREFSymbol	TokenNameIdentifier	 f IDREF Symbol
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
TYPE_NMTOKEN	TokenNameIdentifier	 TYPE  NMTOKEN
:	TokenNameCOLON	
{	TokenNameLBRACE	
return	TokenNamereturn	
attrDecl	TokenNameIdentifier	 attr Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
list	TokenNameIdentifier	 list
?	TokenNameQUESTION	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
fNMTOKENSSymbol	TokenNameIdentifier	 f NMTOKENS Symbol
:	TokenNameCOLON	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
fNMTOKENSymbol	TokenNameIdentifier	 f NMTOKEN Symbol
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
TYPE_NOTATION	TokenNameIdentifier	 TYPE  NOTATION
:	TokenNameCOLON	
{	TokenNameLBRACE	
return	TokenNamereturn	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
fNOTATIONSymbol	TokenNameIdentifier	 f NOTATION Symbol
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
fCDATASymbol	TokenNameIdentifier	 f CDATA Symbol
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getAttributeTypeName(XMLAttributeDecl):String 	TokenNameCOMMENT_LINE	getAttributeTypeName(XMLAttributeDecl):String 
/** initialization */	TokenNameCOMMENT_JAVADOC	 initialization 
protected	TokenNameprotected	
void	TokenNamevoid	
init	TokenNameIdentifier	 init
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// datatype validators 	TokenNameCOMMENT_LINE	datatype validators 
if	TokenNameif	
(	TokenNameLPAREN	
fValidation	TokenNameIdentifier	 f Validation
||	TokenNameOR_OR	
fDynamicValidation	TokenNameIdentifier	 f Dynamic Validation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
//REVISIT: datatypeRegistry + initialization of datatype 	TokenNameCOMMENT_LINE	REVISIT: datatypeRegistry + initialization of datatype 
// why do we cast to ListDatatypeValidator? 	TokenNameCOMMENT_LINE	why do we cast to ListDatatypeValidator? 
fValID	TokenNameIdentifier	 f Val ID
=	TokenNameEQUAL	
fDatatypeValidatorFactory	TokenNameIdentifier	 f Datatype Validator Factory
.	TokenNameDOT	
getBuiltInDV	TokenNameIdentifier	 get Built In DV
(	TokenNameLPAREN	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
fIDSymbol	TokenNameIdentifier	 f ID Symbol
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fValIDRef	TokenNameIdentifier	 f Val ID Ref
=	TokenNameEQUAL	
fDatatypeValidatorFactory	TokenNameIdentifier	 f Datatype Validator Factory
.	TokenNameDOT	
getBuiltInDV	TokenNameIdentifier	 get Built In DV
(	TokenNameLPAREN	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
fIDREFSymbol	TokenNameIdentifier	 f IDREF Symbol
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fValIDRefs	TokenNameIdentifier	 f Val ID Refs
=	TokenNameEQUAL	
fDatatypeValidatorFactory	TokenNameIdentifier	 f Datatype Validator Factory
.	TokenNameDOT	
getBuiltInDV	TokenNameIdentifier	 get Built In DV
(	TokenNameLPAREN	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
fIDREFSSymbol	TokenNameIdentifier	 f IDREFS Symbol
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fValENTITY	TokenNameIdentifier	 f Val ENTITY
=	TokenNameEQUAL	
fDatatypeValidatorFactory	TokenNameIdentifier	 f Datatype Validator Factory
.	TokenNameDOT	
getBuiltInDV	TokenNameIdentifier	 get Built In DV
(	TokenNameLPAREN	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
fENTITYSymbol	TokenNameIdentifier	 f ENTITY Symbol
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fValENTITIES	TokenNameIdentifier	 f Val ENTITIES
=	TokenNameEQUAL	
fDatatypeValidatorFactory	TokenNameIdentifier	 f Datatype Validator Factory
.	TokenNameDOT	
getBuiltInDV	TokenNameIdentifier	 get Built In DV
(	TokenNameLPAREN	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
fENTITIESSymbol	TokenNameIdentifier	 f ENTITIES Symbol
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fValNMTOKEN	TokenNameIdentifier	 f Val NMTOKEN
=	TokenNameEQUAL	
fDatatypeValidatorFactory	TokenNameIdentifier	 f Datatype Validator Factory
.	TokenNameDOT	
getBuiltInDV	TokenNameIdentifier	 get Built In DV
(	TokenNameLPAREN	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
fNMTOKENSymbol	TokenNameIdentifier	 f NMTOKEN Symbol
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fValNMTOKENS	TokenNameIdentifier	 f Val NMTOKENS
=	TokenNameEQUAL	
fDatatypeValidatorFactory	TokenNameIdentifier	 f Datatype Validator Factory
.	TokenNameDOT	
getBuiltInDV	TokenNameIdentifier	 get Built In DV
(	TokenNameLPAREN	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
fNMTOKENSSymbol	TokenNameIdentifier	 f NMTOKENS Symbol
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fValNOTATION	TokenNameIdentifier	 f Val NOTATION
=	TokenNameEQUAL	
fDatatypeValidatorFactory	TokenNameIdentifier	 f Datatype Validator Factory
.	TokenNameDOT	
getBuiltInDV	TokenNameIdentifier	 get Built In DV
(	TokenNameLPAREN	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
fNOTATIONSymbol	TokenNameIdentifier	 f NOTATION Symbol
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// should never happen 	TokenNameCOMMENT_LINE	should never happen 
e	TokenNameIdentifier	 e
.	TokenNameDOT	
printStackTrace	TokenNameIdentifier	 print Stack Trace
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// init() 	TokenNameCOMMENT_LINE	init() 
/** ensure element stack capacity */	TokenNameCOMMENT_JAVADOC	 ensure element stack capacity 
private	TokenNameprivate	
void	TokenNamevoid	
ensureStackCapacity	TokenNameIdentifier	 ensure Stack Capacity
(	TokenNameLPAREN	
int	TokenNameint	
newElementDepth	TokenNameIdentifier	 new Element Depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
newElementDepth	TokenNameIdentifier	 new Element Depth
==	TokenNameEQUAL_EQUAL	
fElementQNamePartsStack	TokenNameIdentifier	 f Element Q Name Parts Stack
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
QName	TokenNameIdentifier	 Q Name
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newStackOfQueue	TokenNameIdentifier	 new Stack Of Queue
=	TokenNameEQUAL	
new	TokenNamenew	
QName	TokenNameIdentifier	 Q Name
[	TokenNameLBRACKET	
newElementDepth	TokenNameIdentifier	 new Element Depth
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
fElementQNamePartsStack	TokenNameIdentifier	 f Element Q Name Parts Stack
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newStackOfQueue	TokenNameIdentifier	 new Stack Of Queue
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newElementDepth	TokenNameIdentifier	 new Element Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fElementQNamePartsStack	TokenNameIdentifier	 f Element Q Name Parts Stack
=	TokenNameEQUAL	
newStackOfQueue	TokenNameIdentifier	 new Stack Of Queue
;	TokenNameSEMICOLON	
QName	TokenNameIdentifier	 Q Name
qname	TokenNameIdentifier	 qname
=	TokenNameEQUAL	
fElementQNamePartsStack	TokenNameIdentifier	 f Element Q Name Parts Stack
[	TokenNameLBRACKET	
newElementDepth	TokenNameIdentifier	 new Element Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
qname	TokenNameIdentifier	 qname
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
newElementDepth	TokenNameIdentifier	 new Element Depth
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fElementQNamePartsStack	TokenNameIdentifier	 f Element Q Name Parts Stack
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fElementQNamePartsStack	TokenNameIdentifier	 f Element Q Name Parts Stack
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
QName	TokenNameIdentifier	 Q Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newStack	TokenNameIdentifier	 new Stack
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
newElementDepth	TokenNameIdentifier	 new Element Depth
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fElementIndexStack	TokenNameIdentifier	 f Element Index Stack
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newStack	TokenNameIdentifier	 new Stack
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newElementDepth	TokenNameIdentifier	 new Element Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fElementIndexStack	TokenNameIdentifier	 f Element Index Stack
=	TokenNameEQUAL	
newStack	TokenNameIdentifier	 new Stack
;	TokenNameSEMICOLON	
newStack	TokenNameIdentifier	 new Stack
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
newElementDepth	TokenNameIdentifier	 new Element Depth
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fContentSpecTypeStack	TokenNameIdentifier	 f Content Spec Type Stack
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newStack	TokenNameIdentifier	 new Stack
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newElementDepth	TokenNameIdentifier	 new Element Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fContentSpecTypeStack	TokenNameIdentifier	 f Content Spec Type Stack
=	TokenNameEQUAL	
newStack	TokenNameIdentifier	 new Stack
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// ensureStackCapacity 	TokenNameCOMMENT_LINE	ensureStackCapacity 
// 	TokenNameCOMMENT_LINE	 
// Protected methods 	TokenNameCOMMENT_LINE	Protected methods 
// 	TokenNameCOMMENT_LINE	 
/** Handle element * @return true if validator is removed from the pipeline */	TokenNameCOMMENT_JAVADOC	 Handle element @return true if validator is removed from the pipeline 
protected	TokenNameprotected	
boolean	TokenNameboolean	
handleStartElement	TokenNameIdentifier	 handle Start Element
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
XMLAttributes	TokenNameIdentifier	 XML Attributes
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
// VC: Root Element Type 	TokenNameCOMMENT_LINE	VC: Root Element Type 
// see if the root element's name matches the one in DoctypeDecl 	TokenNameCOMMENT_LINE	see if the root element's name matches the one in DoctypeDecl 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fSeenRootElement	TokenNameIdentifier	 f Seen Root Element
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// REVISIT: Here are current assumptions about validation features 	TokenNameCOMMENT_LINE	REVISIT: Here are current assumptions about validation features 
// given that XMLSchema validator is in the pipeline 	TokenNameCOMMENT_LINE	given that XMLSchema validator is in the pipeline 
// 	TokenNameCOMMENT_LINE	 
// http://xml.org/sax/features/validation = true 	TokenNameCOMMENT_LINE	http://xml.org/sax/features/validation = true 
// http://apache.org/xml/features/validation/schema = true 	TokenNameCOMMENT_LINE	http://apache.org/xml/features/validation/schema = true 
// 	TokenNameCOMMENT_LINE	 
// [1] XML instance document only has reference to a DTD 	TokenNameCOMMENT_LINE	[1] XML instance document only has reference to a DTD 
// Outcome: report validation errors only against dtd. 	TokenNameCOMMENT_LINE	Outcome: report validation errors only against dtd. 
// 	TokenNameCOMMENT_LINE	 
// [2] XML instance document has only XML Schema grammars: 	TokenNameCOMMENT_LINE	[2] XML instance document has only XML Schema grammars: 
// Outcome: report validation errors only against schemas (no errors produced from DTD validator) 	TokenNameCOMMENT_LINE	Outcome: report validation errors only against schemas (no errors produced from DTD validator) 
// 	TokenNameCOMMENT_LINE	 
// [3] XML instance document has DTD and XML schemas: 	TokenNameCOMMENT_LINE	[3] XML instance document has DTD and XML schemas: 
// [a] if schema language is not set outcome - validation errors reported against both grammars: DTD and schemas. 	TokenNameCOMMENT_LINE	[a] if schema language is not set outcome - validation errors reported against both grammars: DTD and schemas. 
// [b] if schema language is set to XML Schema - do not report validation errors 	TokenNameCOMMENT_LINE	[b] if schema language is set to XML Schema - do not report validation errors 
// 	TokenNameCOMMENT_LINE	 
// if dynamic validation is on 	TokenNameCOMMENT_LINE	if dynamic validation is on 
// validate only against grammar we've found (depending on settings 	TokenNameCOMMENT_LINE	validate only against grammar we've found (depending on settings 
// for schema feature) 	TokenNameCOMMENT_LINE	for schema feature) 
// 	TokenNameCOMMENT_LINE	 
// 	TokenNameCOMMENT_LINE	 
fPerformValidation	TokenNameIdentifier	 f Perform Validation
=	TokenNameEQUAL	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fSeenRootElement	TokenNameIdentifier	 f Seen Root Element
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
fValidationManager	TokenNameIdentifier	 f Validation Manager
.	TokenNameDOT	
setEntityState	TokenNameIdentifier	 set Entity State
(	TokenNameLPAREN	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fValidationManager	TokenNameIdentifier	 f Validation Manager
.	TokenNameDOT	
setGrammarFound	TokenNameIdentifier	 set Grammar Found
(	TokenNameLPAREN	
fSeenDoctypeDecl	TokenNameIdentifier	 f Seen Doctype Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rootElementSpecified	TokenNameIdentifier	 root Element Specified
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fPerformValidation	TokenNameIdentifier	 f Perform Validation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fCurrentElementIndex	TokenNameIdentifier	 f Current Element Index
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fCurrentContentSpecType	TokenNameIdentifier	 f Current Content Spec Type
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fInElementContent	TokenNameIdentifier	 f In Element Content
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fPerformValidation	TokenNameIdentifier	 f Perform Validation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
"MSG_GRAMMAR_NOT_FOUND"	TokenNameStringLiteral	MSG_GRAMMAR_NOT_FOUND
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
}	TokenNameRBRACE	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// modify pipeline 	TokenNameCOMMENT_LINE	modify pipeline 
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentSource	TokenNameIdentifier	 f Document Source
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentSource	TokenNameIdentifier	 f Document Source
.	TokenNameDOT	
setDocumentHandler	TokenNameIdentifier	 set Document Handler
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
setDocumentSource	TokenNameIdentifier	 set Document Source
(	TokenNameLPAREN	
fDocumentSource	TokenNameIdentifier	 f Document Source
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// resolve the element 	TokenNameCOMMENT_LINE	resolve the element 
fCurrentElementIndex	TokenNameIdentifier	 f Current Element Index
=	TokenNameEQUAL	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
.	TokenNameDOT	
getElementDeclIndex	TokenNameIdentifier	 get Element Decl Index
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//changed here.. new function for getContentSpecType 	TokenNameCOMMENT_LINE	changed here.. new function for getContentSpecType 
fCurrentContentSpecType	TokenNameIdentifier	 f Current Content Spec Type
=	TokenNameEQUAL	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
.	TokenNameDOT	
getContentSpecType	TokenNameIdentifier	 get Content Spec Type
(	TokenNameLPAREN	
fCurrentElementIndex	TokenNameIdentifier	 f Current Element Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentContentSpecType	TokenNameIdentifier	 f Current Content Spec Type
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
fPerformValidation	TokenNameIdentifier	 f Perform Validation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
"MSG_ELEMENT_NOT_DECLARED"	TokenNameStringLiteral	MSG_ELEMENT_NOT_DECLARED
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
}	TokenNameRBRACE	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 0. insert default attributes 	TokenNameCOMMENT_LINE	0. insert default attributes 
// 1. normalize the attributes 	TokenNameCOMMENT_LINE	1. normalize the attributes 
// 2. validate the attrivute list. 	TokenNameCOMMENT_LINE	2. validate the attrivute list. 
// TO DO: 	TokenNameCOMMENT_LINE	TO DO: 
//changed here.. also pass element name, 	TokenNameCOMMENT_LINE	changed here.. also pass element name, 
addDTDDefaultAttrsAndValidate	TokenNameIdentifier	 add DTD Default Attrs And Validate
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
fCurrentElementIndex	TokenNameIdentifier	 f Current Element Index
,	TokenNameCOMMA	
attributes	TokenNameIdentifier	 attributes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// set element content state 	TokenNameCOMMENT_LINE	set element content state 
fInElementContent	TokenNameIdentifier	 f In Element Content
=	TokenNameEQUAL	
fCurrentContentSpecType	TokenNameIdentifier	 f Current Content Spec Type
==	TokenNameEQUAL_EQUAL	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
.	TokenNameDOT	
TYPE_CHILDREN	TokenNameIdentifier	 TYPE  CHILDREN
;	TokenNameSEMICOLON	
// increment the element depth, add this element's 	TokenNameCOMMENT_LINE	increment the element depth, add this element's 
// QName to its enclosing element 's children list 	TokenNameCOMMENT_LINE	QName to its enclosing element 's children list 
fElementDepth	TokenNameIdentifier	 f Element Depth
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fPerformValidation	TokenNameIdentifier	 f Perform Validation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// push current length onto stack 	TokenNameCOMMENT_LINE	push current length onto stack 
if	TokenNameif	
(	TokenNameLPAREN	
fElementChildrenOffsetStack	TokenNameIdentifier	 f Element Children Offset Stack
.	TokenNameDOT	
length	TokenNameIdentifier	 length
<=	TokenNameLESS_EQUAL	
fElementDepth	TokenNameIdentifier	 f Element Depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
newarray	TokenNameIdentifier	 newarray
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
fElementChildrenOffsetStack	TokenNameIdentifier	 f Element Children Offset Stack
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fElementChildrenOffsetStack	TokenNameIdentifier	 f Element Children Offset Stack
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newarray	TokenNameIdentifier	 newarray
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fElementChildrenOffsetStack	TokenNameIdentifier	 f Element Children Offset Stack
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fElementChildrenOffsetStack	TokenNameIdentifier	 f Element Children Offset Stack
=	TokenNameEQUAL	
newarray	TokenNameIdentifier	 newarray
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fElementChildrenOffsetStack	TokenNameIdentifier	 f Element Children Offset Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fElementChildrenLength	TokenNameIdentifier	 f Element Children Length
;	TokenNameSEMICOLON	
// add this element to children 	TokenNameCOMMENT_LINE	add this element to children 
if	TokenNameif	
(	TokenNameLPAREN	
fElementChildren	TokenNameIdentifier	 f Element Children
.	TokenNameDOT	
length	TokenNameIdentifier	 length
<=	TokenNameLESS_EQUAL	
fElementChildrenLength	TokenNameIdentifier	 f Element Children Length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
QName	TokenNameIdentifier	 Q Name
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newarray	TokenNameIdentifier	 newarray
=	TokenNameEQUAL	
new	TokenNamenew	
QName	TokenNameIdentifier	 Q Name
[	TokenNameLBRACKET	
fElementChildrenLength	TokenNameIdentifier	 f Element Children Length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fElementChildren	TokenNameIdentifier	 f Element Children
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newarray	TokenNameIdentifier	 newarray
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fElementChildren	TokenNameIdentifier	 f Element Children
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fElementChildren	TokenNameIdentifier	 f Element Children
=	TokenNameEQUAL	
newarray	TokenNameIdentifier	 newarray
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
QName	TokenNameIdentifier	 Q Name
qname	TokenNameIdentifier	 qname
=	TokenNameEQUAL	
fElementChildren	TokenNameIdentifier	 f Element Children
[	TokenNameLBRACKET	
fElementChildrenLength	TokenNameIdentifier	 f Element Children Length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
qname	TokenNameIdentifier	 qname
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
fElementChildrenLength	TokenNameIdentifier	 f Element Children Length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fElementChildren	TokenNameIdentifier	 f Element Children
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fElementChildren	TokenNameIdentifier	 f Element Children
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
QName	TokenNameIdentifier	 Q Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
qname	TokenNameIdentifier	 qname
=	TokenNameEQUAL	
fElementChildren	TokenNameIdentifier	 f Element Children
[	TokenNameLBRACKET	
fElementChildrenLength	TokenNameIdentifier	 f Element Children Length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
qname	TokenNameIdentifier	 qname
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fElementChildrenLength	TokenNameIdentifier	 f Element Children Length
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// save current element information 	TokenNameCOMMENT_LINE	save current element information 
fCurrentElement	TokenNameIdentifier	 f Current Element
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ensureStackCapacity	TokenNameIdentifier	 ensure Stack Capacity
(	TokenNameLPAREN	
fElementDepth	TokenNameIdentifier	 f Element Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fElementQNamePartsStack	TokenNameIdentifier	 f Element Q Name Parts Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
fCurrentElement	TokenNameIdentifier	 f Current Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fElementIndexStack	TokenNameIdentifier	 f Element Index Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fCurrentElementIndex	TokenNameIdentifier	 f Current Element Index
;	TokenNameSEMICOLON	
fContentSpecTypeStack	TokenNameIdentifier	 f Content Spec Type Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fCurrentContentSpecType	TokenNameIdentifier	 f Current Content Spec Type
;	TokenNameSEMICOLON	
startNamespaceScope	TokenNameIdentifier	 start Namespace Scope
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// handleStartElement(QName,XMLAttributes) 	TokenNameCOMMENT_LINE	handleStartElement(QName,XMLAttributes) 
protected	TokenNameprotected	
void	TokenNamevoid	
startNamespaceScope	TokenNameIdentifier	 start Namespace Scope
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
XMLAttributes	TokenNameIdentifier	 XML Attributes
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
/** Handle end element. */	TokenNameCOMMENT_JAVADOC	 Handle end element. 
protected	TokenNameprotected	
void	TokenNamevoid	
handleEndElement	TokenNameIdentifier	 handle End Element
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isEmpty	TokenNameIdentifier	 is Empty
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
// decrease element depth 	TokenNameCOMMENT_LINE	decrease element depth 
fElementDepth	TokenNameIdentifier	 f Element Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
// validate 	TokenNameCOMMENT_LINE	validate 
if	TokenNameif	
(	TokenNameLPAREN	
fPerformValidation	TokenNameIdentifier	 f Perform Validation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
elementIndex	TokenNameIdentifier	 element Index
=	TokenNameEQUAL	
fCurrentElementIndex	TokenNameIdentifier	 f Current Element Index
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
elementIndex	TokenNameIdentifier	 element Index
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
fCurrentContentSpecType	TokenNameIdentifier	 f Current Content Spec Type
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
QName	TokenNameIdentifier	 Q Name
children	TokenNameIdentifier	 children
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fElementChildren	TokenNameIdentifier	 f Element Children
;	TokenNameSEMICOLON	
int	TokenNameint	
childrenOffset	TokenNameIdentifier	 children Offset
=	TokenNameEQUAL	
fElementChildrenOffsetStack	TokenNameIdentifier	 f Element Children Offset Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
childrenLength	TokenNameIdentifier	 children Length
=	TokenNameEQUAL	
fElementChildrenLength	TokenNameIdentifier	 f Element Children Length
-	TokenNameMINUS	
childrenOffset	TokenNameIdentifier	 children Offset
;	TokenNameSEMICOLON	
int	TokenNameint	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
checkContent	TokenNameIdentifier	 check Content
(	TokenNameLPAREN	
elementIndex	TokenNameIdentifier	 element Index
,	TokenNameCOMMA	
children	TokenNameIdentifier	 children
,	TokenNameCOMMA	
childrenOffset	TokenNameIdentifier	 children Offset
,	TokenNameCOMMA	
childrenLength	TokenNameIdentifier	 children Length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
.	TokenNameDOT	
getElementDecl	TokenNameIdentifier	 get Element Decl
(	TokenNameLPAREN	
elementIndex	TokenNameIdentifier	 element Index
,	TokenNameCOMMA	
fTempElementDecl	TokenNameIdentifier	 f Temp Element Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fTempElementDecl	TokenNameIdentifier	 f Temp Element Decl
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
.	TokenNameDOT	
TYPE_EMPTY	TokenNameIdentifier	 TYPE  EMPTY
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
"MSG_CONTENT_INVALID"	TokenNameStringLiteral	MSG_CONTENT_INVALID
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
"EMPTY"	TokenNameStringLiteral	EMPTY
}	TokenNameRBRACE	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
messageKey	TokenNameIdentifier	 message Key
=	TokenNameEQUAL	
result	TokenNameIdentifier	 result
!=	TokenNameNOT_EQUAL	
childrenLength	TokenNameIdentifier	 children Length
?	TokenNameQUESTION	
"MSG_CONTENT_INVALID"	TokenNameStringLiteral	MSG_CONTENT_INVALID
:	TokenNameCOLON	
"MSG_CONTENT_INCOMPLETE"	TokenNameStringLiteral	MSG_CONTENT_INCOMPLETE
;	TokenNameSEMICOLON	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
messageKey	TokenNameIdentifier	 message Key
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
fDTDGrammar	TokenNameIdentifier	 f DTD Grammar
.	TokenNameDOT	
getContentSpecAsString	TokenNameIdentifier	 get Content Spec As String
(	TokenNameLPAREN	
elementIndex	TokenNameIdentifier	 element Index
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
fElementChildrenLength	TokenNameIdentifier	 f Element Children Length
=	TokenNameEQUAL	
fElementChildrenOffsetStack	TokenNameIdentifier	 f Element Children Offset Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
endNamespaceScope	TokenNameIdentifier	 end Namespace Scope
(	TokenNameLPAREN	
fCurrentElement	TokenNameIdentifier	 f Current Element
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
,	TokenNameCOMMA	
isEmpty	TokenNameIdentifier	 is Empty
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// now pop this element off the top of the element stack 	TokenNameCOMMENT_LINE	now pop this element off the top of the element stack 
if	TokenNameif	
(	TokenNameLPAREN	
fElementDepth	TokenNameIdentifier	 f Element Depth
<	TokenNameLESS	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"FWK008 Element stack underflow"	TokenNameStringLiteral	FWK008 Element stack underflow
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fElementDepth	TokenNameIdentifier	 f Element Depth
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fCurrentElement	TokenNameIdentifier	 f Current Element
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fCurrentElementIndex	TokenNameIdentifier	 f Current Element Index
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fCurrentContentSpecType	TokenNameIdentifier	 f Current Content Spec Type
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fInElementContent	TokenNameIdentifier	 f In Element Content
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// TO DO : fix this 	TokenNameCOMMENT_LINE	TO DO : fix this 
// 	TokenNameCOMMENT_LINE	 
// Check after document is fully parsed 	TokenNameCOMMENT_LINE	Check after document is fully parsed 
// (1) check that there was an element with a matching id for every 	TokenNameCOMMENT_LINE	(1) check that there was an element with a matching id for every 
// IDREF and IDREFS attr (V_IDREF0) 	TokenNameCOMMENT_LINE	IDREF and IDREFS attr (V_IDREF0) 
// 	TokenNameCOMMENT_LINE	 
if	TokenNameif	
(	TokenNameLPAREN	
fPerformValidation	TokenNameIdentifier	 f Perform Validation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
fValidationState	TokenNameIdentifier	 f Validation State
.	TokenNameDOT	
checkIDRefID	TokenNameIdentifier	 check ID Ref ID
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
"MSG_ELEMENT_WITH_ID_REQUIRED"	TokenNameStringLiteral	MSG_ELEMENT_WITH_ID_REQUIRED
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
value	TokenNameIdentifier	 value
}	TokenNameRBRACE	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// If Namespace enable then localName != rawName 	TokenNameCOMMENT_LINE	If Namespace enable then localName != rawName 
fCurrentElement	TokenNameIdentifier	 f Current Element
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
fElementQNamePartsStack	TokenNameIdentifier	 f Element Q Name Parts Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fCurrentElementIndex	TokenNameIdentifier	 f Current Element Index
=	TokenNameEQUAL	
fElementIndexStack	TokenNameIdentifier	 f Element Index Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fCurrentContentSpecType	TokenNameIdentifier	 f Current Content Spec Type
=	TokenNameEQUAL	
fContentSpecTypeStack	TokenNameIdentifier	 f Content Spec Type Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fInElementContent	TokenNameIdentifier	 f In Element Content
=	TokenNameEQUAL	
(	TokenNameLPAREN	
fCurrentContentSpecType	TokenNameIdentifier	 f Current Content Spec Type
==	TokenNameEQUAL_EQUAL	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
.	TokenNameDOT	
TYPE_CHILDREN	TokenNameIdentifier	 TYPE  CHILDREN
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// handleEndElement(QName,boolean) 	TokenNameCOMMENT_LINE	handleEndElement(QName,boolean) 
protected	TokenNameprotected	
void	TokenNamevoid	
endNamespaceScope	TokenNameIdentifier	 end Namespace Scope
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isEmpty	TokenNameIdentifier	 is Empty
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// call handlers 	TokenNameCOMMENT_LINE	call handlers 
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
isEmpty	TokenNameIdentifier	 is Empty
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// NOTE: The binding of the element doesn't actually happen 	TokenNameCOMMENT_LINE	NOTE: The binding of the element doesn't actually happen 
// yet because the namespace binder does that. However, 	TokenNameCOMMENT_LINE	yet because the namespace binder does that. However, 
// if it does it before this point, then the endPrefix- 	TokenNameCOMMENT_LINE	if it does it before this point, then the endPrefix- 
// Mapping calls get made too soon! As long as the 	TokenNameCOMMENT_LINE	Mapping calls get made too soon! As long as the 
// rawnames match, we know it'll have a good binding, 	TokenNameCOMMENT_LINE	rawnames match, we know it'll have a good binding, 
// so we can just use the current element. -Ac 	TokenNameCOMMENT_LINE	so we can just use the current element. -Ac 
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
endElement	TokenNameIdentifier	 end Element
(	TokenNameLPAREN	
fCurrentElement	TokenNameIdentifier	 f Current Element
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// returns whether a character is space according to the 	TokenNameCOMMENT_LINE	returns whether a character is space according to the 
// version of XML this validator supports. 	TokenNameCOMMENT_LINE	version of XML this validator supports. 
protected	TokenNameprotected	
boolean	TokenNameboolean	
isSpace	TokenNameIdentifier	 is Space
(	TokenNameLPAREN	
int	TokenNameint	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
XMLChar	TokenNameIdentifier	 XML Char
.	TokenNameDOT	
isSpace	TokenNameIdentifier	 is Space
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// isSpace(int): boolean 	TokenNameCOMMENT_LINE	isSpace(int): boolean 
public	TokenNamepublic	
boolean	TokenNameboolean	
characterData	TokenNameIdentifier	 character Data
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
characters	TokenNameIdentifier	 characters
(	TokenNameLPAREN	
new	TokenNamenew	
XMLString	TokenNameIdentifier	 XML String
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
toCharArray	TokenNameIdentifier	 to Char Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// class XMLDTDValidator 	TokenNameCOMMENT_LINE	class XMLDTDValidator 
