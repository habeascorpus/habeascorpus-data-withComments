package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
vectorhighlight	TokenNameIdentifier	 vectorhighlight
;	TokenNameSEMICOLON	
/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_JAVADOC	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Collection	TokenNameIdentifier	 Collection
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
HashMap	TokenNameIdentifier	 Hash Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
HashSet	TokenNameIdentifier	 Hash Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Iterator	TokenNameIdentifier	 Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
LinkedHashSet	TokenNameIdentifier	 Linked Hash Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
List	TokenNameIdentifier	 List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Map	TokenNameIdentifier	 Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Set	TokenNameIdentifier	 Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
IndexReader	TokenNameIdentifier	 Index Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
Term	TokenNameIdentifier	 Term
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
BooleanClause	TokenNameIdentifier	 Boolean Clause
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
BooleanQuery	TokenNameIdentifier	 Boolean Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
DisjunctionMaxQuery	TokenNameIdentifier	 Disjunction Max Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
FuzzyQuery	TokenNameIdentifier	 Fuzzy Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
MultiTermQuery	TokenNameIdentifier	 Multi Term Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
PhraseQuery	TokenNameIdentifier	 Phrase Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
PrefixQuery	TokenNameIdentifier	 Prefix Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
Query	TokenNameIdentifier	 Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
TermQuery	TokenNameIdentifier	 Term Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
TermRangeQuery	TokenNameIdentifier	 Term Range Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
WildcardQuery	TokenNameIdentifier	 Wildcard Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
regex	TokenNameIdentifier	 regex
.	TokenNameDOT	
RegexQuery	TokenNameIdentifier	 Regex Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
vectorhighlight	TokenNameIdentifier	 vectorhighlight
.	TokenNameDOT	
FieldTermStack	TokenNameIdentifier	 Field Term Stack
.	TokenNameDOT	
TermInfo	TokenNameIdentifier	 Term Info
;	TokenNameSEMICOLON	
/** * FieldQuery breaks down query object into terms/phrases and keep * them in QueryPhraseMap structure. */	TokenNameCOMMENT_JAVADOC	 FieldQuery breaks down query object into terms/phrases and keep them in QueryPhraseMap structure. 
public	TokenNamepublic	
class	TokenNameclass	
FieldQuery	TokenNameIdentifier	 Field Query
{	TokenNameLBRACE	
final	TokenNamefinal	
boolean	TokenNameboolean	
fieldMatch	TokenNameIdentifier	 field Match
;	TokenNameSEMICOLON	
// fieldMatch==true, Map<fieldName,QueryPhraseMap> 	TokenNameCOMMENT_LINE	fieldMatch==true, Map<fieldName,QueryPhraseMap> 
// fieldMatch==false, Map<null,QueryPhraseMap> 	TokenNameCOMMENT_LINE	fieldMatch==false, Map<null,QueryPhraseMap> 
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
QueryPhraseMap	TokenNameIdentifier	 Query Phrase Map
>	TokenNameGREATER	
rootMaps	TokenNameIdentifier	 root Maps
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
QueryPhraseMap	TokenNameIdentifier	 Query Phrase Map
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// fieldMatch==true, Map<fieldName,setOfTermsInQueries> 	TokenNameCOMMENT_LINE	fieldMatch==true, Map<fieldName,setOfTermsInQueries> 
// fieldMatch==false, Map<null,setOfTermsInQueries> 	TokenNameCOMMENT_LINE	fieldMatch==false, Map<null,setOfTermsInQueries> 
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>>	TokenNameRIGHT_SHIFT	
termSetMap	TokenNameIdentifier	 term Set Map
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
termOrPhraseNumber	TokenNameIdentifier	 term Or Phrase Number
;	TokenNameSEMICOLON	
// used for colored tag support 	TokenNameCOMMENT_LINE	used for colored tag support 
// The maximum number of different matching terms accumulated from any one MultiTermQuery 	TokenNameCOMMENT_LINE	The maximum number of different matching terms accumulated from any one MultiTermQuery 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
MAX_MTQ_TERMS	TokenNameIdentifier	 MAX  MTQ  TERMS
=	TokenNameEQUAL	
1024	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
FieldQuery	TokenNameIdentifier	 Field Query
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
IndexReader	TokenNameIdentifier	 Index Reader
reader	TokenNameIdentifier	 reader
,	TokenNameCOMMA	
boolean	TokenNameboolean	
phraseHighlight	TokenNameIdentifier	 phrase Highlight
,	TokenNameCOMMA	
boolean	TokenNameboolean	
fieldMatch	TokenNameIdentifier	 field Match
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fieldMatch	TokenNameIdentifier	 field Match
=	TokenNameEQUAL	
fieldMatch	TokenNameIdentifier	 field Match
;	TokenNameSEMICOLON	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Query	TokenNameIdentifier	 Query
>	TokenNameGREATER	
flatQueries	TokenNameIdentifier	 flat Queries
=	TokenNameEQUAL	
new	TokenNamenew	
LinkedHashSet	TokenNameIdentifier	 Linked Hash Set
<	TokenNameLESS	
Query	TokenNameIdentifier	 Query
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
flatten	TokenNameIdentifier	 flatten
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
reader	TokenNameIdentifier	 reader
,	TokenNameCOMMA	
flatQueries	TokenNameIdentifier	 flat Queries
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
saveTerms	TokenNameIdentifier	 save Terms
(	TokenNameLPAREN	
flatQueries	TokenNameIdentifier	 flat Queries
,	TokenNameCOMMA	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Query	TokenNameIdentifier	 Query
>	TokenNameGREATER	
expandQueries	TokenNameIdentifier	 expand Queries
=	TokenNameEQUAL	
expand	TokenNameIdentifier	 expand
(	TokenNameLPAREN	
flatQueries	TokenNameIdentifier	 flat Queries
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
flatQuery	TokenNameIdentifier	 flat Query
:	TokenNameCOLON	
expandQueries	TokenNameIdentifier	 expand Queries
)	TokenNameRPAREN	
{	TokenNameLBRACE	
QueryPhraseMap	TokenNameIdentifier	 Query Phrase Map
rootMap	TokenNameIdentifier	 root Map
=	TokenNameEQUAL	
getRootMap	TokenNameIdentifier	 get Root Map
(	TokenNameLPAREN	
flatQuery	TokenNameIdentifier	 flat Query
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rootMap	TokenNameIdentifier	 root Map
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
flatQuery	TokenNameIdentifier	 flat Query
,	TokenNameCOMMA	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
phraseHighlight	TokenNameIdentifier	 phrase Highlight
&&	TokenNameAND_AND	
flatQuery	TokenNameIdentifier	 flat Query
instanceof	TokenNameinstanceof	
PhraseQuery	TokenNameIdentifier	 Phrase Query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
PhraseQuery	TokenNameIdentifier	 Phrase Query
pq	TokenNameIdentifier	 pq
=	TokenNameEQUAL	
(	TokenNameLPAREN	
PhraseQuery	TokenNameIdentifier	 Phrase Query
)	TokenNameRPAREN	
flatQuery	TokenNameIdentifier	 flat Query
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
pq	TokenNameIdentifier	 pq
.	TokenNameDOT	
getTerms	TokenNameIdentifier	 get Terms
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Term	TokenNameIdentifier	 Term
term	TokenNameIdentifier	 term
:	TokenNameCOLON	
pq	TokenNameIdentifier	 pq
.	TokenNameDOT	
getTerms	TokenNameIdentifier	 get Terms
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
rootMap	TokenNameIdentifier	 root Map
.	TokenNameDOT	
addTerm	TokenNameIdentifier	 add Term
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
,	TokenNameCOMMA	
flatQuery	TokenNameIdentifier	 flat Query
.	TokenNameDOT	
getBoost	TokenNameIdentifier	 get Boost
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** For backwards compatibility you can initialize FieldQuery without * an IndexReader, which is only required to support MultiTermQuery */	TokenNameCOMMENT_JAVADOC	 For backwards compatibility you can initialize FieldQuery without an IndexReader, which is only required to support MultiTermQuery 
FieldQuery	TokenNameIdentifier	 Field Query
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
boolean	TokenNameboolean	
phraseHighlight	TokenNameIdentifier	 phrase Highlight
,	TokenNameCOMMA	
boolean	TokenNameboolean	
fieldMatch	TokenNameIdentifier	 field Match
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
this	TokenNamethis	
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
phraseHighlight	TokenNameIdentifier	 phrase Highlight
,	TokenNameCOMMA	
fieldMatch	TokenNameIdentifier	 field Match
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
void	TokenNamevoid	
flatten	TokenNameIdentifier	 flatten
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
sourceQuery	TokenNameIdentifier	 source Query
,	TokenNameCOMMA	
IndexReader	TokenNameIdentifier	 Index Reader
reader	TokenNameIdentifier	 reader
,	TokenNameCOMMA	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Query	TokenNameIdentifier	 Query
>	TokenNameGREATER	
flatQueries	TokenNameIdentifier	 flat Queries
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
sourceQuery	TokenNameIdentifier	 source Query
instanceof	TokenNameinstanceof	
BooleanQuery	TokenNameIdentifier	 Boolean Query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
BooleanQuery	TokenNameIdentifier	 Boolean Query
bq	TokenNameIdentifier	 bq
=	TokenNameEQUAL	
(	TokenNameLPAREN	
BooleanQuery	TokenNameIdentifier	 Boolean Query
)	TokenNameRPAREN	
sourceQuery	TokenNameIdentifier	 source Query
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
BooleanClause	TokenNameIdentifier	 Boolean Clause
clause	TokenNameIdentifier	 clause
:	TokenNameCOLON	
bq	TokenNameIdentifier	 bq
.	TokenNameDOT	
getClauses	TokenNameIdentifier	 get Clauses
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
clause	TokenNameIdentifier	 clause
.	TokenNameDOT	
isProhibited	TokenNameIdentifier	 is Prohibited
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
flatten	TokenNameIdentifier	 flatten
(	TokenNameLPAREN	
clause	TokenNameIdentifier	 clause
.	TokenNameDOT	
getQuery	TokenNameIdentifier	 get Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
reader	TokenNameIdentifier	 reader
,	TokenNameCOMMA	
flatQueries	TokenNameIdentifier	 flat Queries
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
sourceQuery	TokenNameIdentifier	 source Query
instanceof	TokenNameinstanceof	
DisjunctionMaxQuery	TokenNameIdentifier	 Disjunction Max Query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DisjunctionMaxQuery	TokenNameIdentifier	 Disjunction Max Query
dmq	TokenNameIdentifier	 dmq
=	TokenNameEQUAL	
(	TokenNameLPAREN	
DisjunctionMaxQuery	TokenNameIdentifier	 Disjunction Max Query
)	TokenNameRPAREN	
sourceQuery	TokenNameIdentifier	 source Query
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
query	TokenNameIdentifier	 query
:	TokenNameCOLON	
dmq	TokenNameIdentifier	 dmq
)	TokenNameRPAREN	
{	TokenNameLBRACE	
flatten	TokenNameIdentifier	 flatten
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
reader	TokenNameIdentifier	 reader
,	TokenNameCOMMA	
flatQueries	TokenNameIdentifier	 flat Queries
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
sourceQuery	TokenNameIdentifier	 source Query
instanceof	TokenNameinstanceof	
TermQuery	TokenNameIdentifier	 Term Query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
flatQueries	TokenNameIdentifier	 flat Queries
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
sourceQuery	TokenNameIdentifier	 source Query
)	TokenNameRPAREN	
)	TokenNameRPAREN	
flatQueries	TokenNameIdentifier	 flat Queries
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
sourceQuery	TokenNameIdentifier	 source Query
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
sourceQuery	TokenNameIdentifier	 source Query
instanceof	TokenNameinstanceof	
MultiTermQuery	TokenNameIdentifier	 Multi Term Query
&&	TokenNameAND_AND	
reader	TokenNameIdentifier	 reader
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
MultiTermQuery	TokenNameIdentifier	 Multi Term Query
copy	TokenNameIdentifier	 copy
=	TokenNameEQUAL	
(	TokenNameLPAREN	
MultiTermQuery	TokenNameIdentifier	 Multi Term Query
)	TokenNameRPAREN	
sourceQuery	TokenNameIdentifier	 source Query
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
copy	TokenNameIdentifier	 copy
.	TokenNameDOT	
setRewriteMethod	TokenNameIdentifier	 set Rewrite Method
(	TokenNameLPAREN	
new	TokenNamenew	
MultiTermQuery	TokenNameIdentifier	 Multi Term Query
.	TokenNameDOT	
TopTermsScoringBooleanQueryRewrite	TokenNameIdentifier	 Top Terms Scoring Boolean Query Rewrite
(	TokenNameLPAREN	
MAX_MTQ_TERMS	TokenNameIdentifier	 MAX  MTQ  TERMS
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
BooleanQuery	TokenNameIdentifier	 Boolean Query
mtqTerms	TokenNameIdentifier	 mtq Terms
=	TokenNameEQUAL	
(	TokenNameLPAREN	
BooleanQuery	TokenNameIdentifier	 Boolean Query
)	TokenNameRPAREN	
copy	TokenNameIdentifier	 copy
.	TokenNameDOT	
rewrite	TokenNameIdentifier	 rewrite
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
flatten	TokenNameIdentifier	 flatten
(	TokenNameLPAREN	
mtqTerms	TokenNameIdentifier	 mtq Terms
,	TokenNameCOMMA	
reader	TokenNameIdentifier	 reader
,	TokenNameCOMMA	
flatQueries	TokenNameIdentifier	 flat Queries
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
sourceQuery	TokenNameIdentifier	 source Query
instanceof	TokenNameinstanceof	
PhraseQuery	TokenNameIdentifier	 Phrase Query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
flatQueries	TokenNameIdentifier	 flat Queries
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
sourceQuery	TokenNameIdentifier	 source Query
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
PhraseQuery	TokenNameIdentifier	 Phrase Query
pq	TokenNameIdentifier	 pq
=	TokenNameEQUAL	
(	TokenNameLPAREN	
PhraseQuery	TokenNameIdentifier	 Phrase Query
)	TokenNameRPAREN	
sourceQuery	TokenNameIdentifier	 source Query
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
pq	TokenNameIdentifier	 pq
.	TokenNameDOT	
getTerms	TokenNameIdentifier	 get Terms
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
flatQueries	TokenNameIdentifier	 flat Queries
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
pq	TokenNameIdentifier	 pq
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
pq	TokenNameIdentifier	 pq
.	TokenNameDOT	
getTerms	TokenNameIdentifier	 get Terms
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
flatQueries	TokenNameIdentifier	 flat Queries
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
TermQuery	TokenNameIdentifier	 Term Query
(	TokenNameLPAREN	
pq	TokenNameIdentifier	 pq
.	TokenNameDOT	
getTerms	TokenNameIdentifier	 get Terms
(	TokenNameLPAREN	
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// else discard queries 	TokenNameCOMMENT_LINE	else discard queries 
}	TokenNameRBRACE	
/* * Create expandQueries from flatQueries. * * expandQueries := flatQueries + overlapped phrase queries * * ex1) flatQueries={a,b,c} * => expandQueries={a,b,c} * ex2) flatQueries={a,"b c","c d"} * => expandQueries={a,"b c","c d","b c d"} */	TokenNameCOMMENT_BLOCK	 Create expandQueries from flatQueries. * expandQueries := flatQueries + overlapped phrase queries * ex1) flatQueries={a,b,c} => expandQueries={a,b,c} ex2) flatQueries={a,"b c","c d"} => expandQueries={a,"b c","c d","b c d"} 
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Query	TokenNameIdentifier	 Query
>	TokenNameGREATER	
expand	TokenNameIdentifier	 expand
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Query	TokenNameIdentifier	 Query
>	TokenNameGREATER	
flatQueries	TokenNameIdentifier	 flat Queries
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Query	TokenNameIdentifier	 Query
>	TokenNameGREATER	
expandQueries	TokenNameIdentifier	 expand Queries
=	TokenNameEQUAL	
new	TokenNamenew	
LinkedHashSet	TokenNameIdentifier	 Linked Hash Set
<	TokenNameLESS	
Query	TokenNameIdentifier	 Query
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
Query	TokenNameIdentifier	 Query
>	TokenNameGREATER	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
flatQueries	TokenNameIdentifier	 flat Queries
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Query	TokenNameIdentifier	 Query
query	TokenNameIdentifier	 query
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
expandQueries	TokenNameIdentifier	 expand Queries
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
instanceof	TokenNameinstanceof	
PhraseQuery	TokenNameIdentifier	 Phrase Query
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
Query	TokenNameIdentifier	 Query
>	TokenNameGREATER	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
flatQueries	TokenNameIdentifier	 flat Queries
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Query	TokenNameIdentifier	 Query
qj	TokenNameIdentifier	 qj
=	TokenNameEQUAL	
j	TokenNameIdentifier	 j
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
qj	TokenNameIdentifier	 qj
instanceof	TokenNameinstanceof	
PhraseQuery	TokenNameIdentifier	 Phrase Query
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
checkOverlap	TokenNameIdentifier	 check Overlap
(	TokenNameLPAREN	
expandQueries	TokenNameIdentifier	 expand Queries
,	TokenNameCOMMA	
(	TokenNameLPAREN	
PhraseQuery	TokenNameIdentifier	 Phrase Query
)	TokenNameRPAREN	
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
(	TokenNameLPAREN	
PhraseQuery	TokenNameIdentifier	 Phrase Query
)	TokenNameRPAREN	
qj	TokenNameIdentifier	 qj
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
expandQueries	TokenNameIdentifier	 expand Queries
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* * Check if PhraseQuery A and B have overlapped part. * * ex1) A="a b", B="b c" => overlap; expandQueries={"a b c"} * ex2) A="b c", B="a b" => overlap; expandQueries={"a b c"} * ex3) A="a b", B="c d" => no overlap; expandQueries={} */	TokenNameCOMMENT_BLOCK	 Check if PhraseQuery A and B have overlapped part. * ex1) A="a b", B="b c" => overlap; expandQueries={"a b c"} ex2) A="b c", B="a b" => overlap; expandQueries={"a b c"} ex3) A="a b", B="c d" => no overlap; expandQueries={} 
private	TokenNameprivate	
void	TokenNamevoid	
checkOverlap	TokenNameIdentifier	 check Overlap
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Query	TokenNameIdentifier	 Query
>	TokenNameGREATER	
expandQueries	TokenNameIdentifier	 expand Queries
,	TokenNameCOMMA	
PhraseQuery	TokenNameIdentifier	 Phrase Query
a	TokenNameIdentifier	 a
,	TokenNameCOMMA	
PhraseQuery	TokenNameIdentifier	 Phrase Query
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
a	TokenNameIdentifier	 a
.	TokenNameDOT	
getSlop	TokenNameIdentifier	 get Slop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
getSlop	TokenNameIdentifier	 get Slop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
Term	TokenNameIdentifier	 Term
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
ats	TokenNameIdentifier	 ats
=	TokenNameEQUAL	
a	TokenNameIdentifier	 a
.	TokenNameDOT	
getTerms	TokenNameIdentifier	 get Terms
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Term	TokenNameIdentifier	 Term
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bts	TokenNameIdentifier	 bts
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
getTerms	TokenNameIdentifier	 get Terms
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fieldMatch	TokenNameIdentifier	 field Match
&&	TokenNameAND_AND	
!	TokenNameNOT	
ats	TokenNameIdentifier	 ats
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
field	TokenNameIdentifier	 field
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
bts	TokenNameIdentifier	 bts
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
field	TokenNameIdentifier	 field
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
checkOverlap	TokenNameIdentifier	 check Overlap
(	TokenNameLPAREN	
expandQueries	TokenNameIdentifier	 expand Queries
,	TokenNameCOMMA	
ats	TokenNameIdentifier	 ats
,	TokenNameCOMMA	
bts	TokenNameIdentifier	 bts
,	TokenNameCOMMA	
a	TokenNameIdentifier	 a
.	TokenNameDOT	
getSlop	TokenNameIdentifier	 get Slop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
a	TokenNameIdentifier	 a
.	TokenNameDOT	
getBoost	TokenNameIdentifier	 get Boost
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
checkOverlap	TokenNameIdentifier	 check Overlap
(	TokenNameLPAREN	
expandQueries	TokenNameIdentifier	 expand Queries
,	TokenNameCOMMA	
bts	TokenNameIdentifier	 bts
,	TokenNameCOMMA	
ats	TokenNameIdentifier	 ats
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
getSlop	TokenNameIdentifier	 get Slop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
getBoost	TokenNameIdentifier	 get Boost
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* * Check if src and dest have overlapped part and if it is, create PhraseQueries and add expandQueries. * * ex1) src="a b", dest="c d" => no overlap * ex2) src="a b", dest="a b c" => no overlap * ex3) src="a b", dest="b c" => overlap; expandQueries={"a b c"} * ex4) src="a b c", dest="b c d" => overlap; expandQueries={"a b c d"} * ex5) src="a b c", dest="b c" => no overlap * ex6) src="a b c", dest="b" => no overlap * ex7) src="a a a a", dest="a a a" => overlap; * expandQueries={"a a a a a","a a a a a a"} * ex8) src="a b c d", dest="b c" => no overlap */	TokenNameCOMMENT_BLOCK	 Check if src and dest have overlapped part and if it is, create PhraseQueries and add expandQueries. * ex1) src="a b", dest="c d" => no overlap ex2) src="a b", dest="a b c" => no overlap ex3) src="a b", dest="b c" => overlap; expandQueries={"a b c"} ex4) src="a b c", dest="b c d" => overlap; expandQueries={"a b c d"} ex5) src="a b c", dest="b c" => no overlap ex6) src="a b c", dest="b" => no overlap ex7) src="a a a a", dest="a a a" => overlap; expandQueries={"a a a a a","a a a a a a"} ex8) src="a b c d", dest="b c" => no overlap 
private	TokenNameprivate	
void	TokenNamevoid	
checkOverlap	TokenNameIdentifier	 check Overlap
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Query	TokenNameIdentifier	 Query
>	TokenNameGREATER	
expandQueries	TokenNameIdentifier	 expand Queries
,	TokenNameCOMMA	
Term	TokenNameIdentifier	 Term
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
src	TokenNameIdentifier	 src
,	TokenNameCOMMA	
Term	TokenNameIdentifier	 Term
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
dest	TokenNameIdentifier	 dest
,	TokenNameCOMMA	
int	TokenNameint	
slop	TokenNameIdentifier	 slop
,	TokenNameCOMMA	
float	TokenNamefloat	
boost	TokenNameIdentifier	 boost
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// beginning from 1 (not 0) is safe because that the PhraseQuery has multiple terms 	TokenNameCOMMENT_LINE	beginning from 1 (not 0) is safe because that the PhraseQuery has multiple terms 
// is guaranteed in flatten() method (if PhraseQuery has only one term, flatten() 	TokenNameCOMMENT_LINE	is guaranteed in flatten() method (if PhraseQuery has only one term, flatten() 
// converts PhraseQuery to TermQuery) 	TokenNameCOMMENT_LINE	converts PhraseQuery to TermQuery) 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
overlap	TokenNameIdentifier	 overlap
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
-	TokenNameMINUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
<	TokenNameLESS	
dest	TokenNameIdentifier	 dest
.	TokenNameDOT	
length	TokenNameIdentifier	 length
&&	TokenNameAND_AND	
!	TokenNameNOT	
src	TokenNameIdentifier	 src
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
.	TokenNameDOT	
text	TokenNameIdentifier	 text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
dest	TokenNameIdentifier	 dest
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
-	TokenNameMINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
text	TokenNameIdentifier	 text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
overlap	TokenNameIdentifier	 overlap
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
overlap	TokenNameIdentifier	 overlap
&&	TokenNameAND_AND	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
dest	TokenNameIdentifier	 dest
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
PhraseQuery	TokenNameIdentifier	 Phrase Query
pq	TokenNameIdentifier	 pq
=	TokenNameEQUAL	
new	TokenNamenew	
PhraseQuery	TokenNameIdentifier	 Phrase Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Term	TokenNameIdentifier	 Term
srcTerm	TokenNameIdentifier	 src Term
:	TokenNameCOLON	
src	TokenNameIdentifier	 src
)	TokenNameRPAREN	
pq	TokenNameIdentifier	 pq
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
srcTerm	TokenNameIdentifier	 src Term
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
k	TokenNameIdentifier	 k
=	TokenNameEQUAL	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
<	TokenNameLESS	
dest	TokenNameIdentifier	 dest
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pq	TokenNameIdentifier	 pq
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
Term	TokenNameIdentifier	 Term
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
field	TokenNameIdentifier	 field
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
dest	TokenNameIdentifier	 dest
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
.	TokenNameDOT	
text	TokenNameIdentifier	 text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
pq	TokenNameIdentifier	 pq
.	TokenNameDOT	
setSlop	TokenNameIdentifier	 set Slop
(	TokenNameLPAREN	
slop	TokenNameIdentifier	 slop
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pq	TokenNameIdentifier	 pq
.	TokenNameDOT	
setBoost	TokenNameIdentifier	 set Boost
(	TokenNameLPAREN	
boost	TokenNameIdentifier	 boost
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
expandQueries	TokenNameIdentifier	 expand Queries
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
pq	TokenNameIdentifier	 pq
)	TokenNameRPAREN	
)	TokenNameRPAREN	
expandQueries	TokenNameIdentifier	 expand Queries
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
pq	TokenNameIdentifier	 pq
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
QueryPhraseMap	TokenNameIdentifier	 Query Phrase Map
getRootMap	TokenNameIdentifier	 get Root Map
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
QueryPhraseMap	TokenNameIdentifier	 Query Phrase Map
map	TokenNameIdentifier	 map
=	TokenNameEQUAL	
rootMaps	TokenNameIdentifier	 root Maps
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
map	TokenNameIdentifier	 map
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
map	TokenNameIdentifier	 map
=	TokenNameEQUAL	
new	TokenNamenew	
QueryPhraseMap	TokenNameIdentifier	 Query Phrase Map
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rootMaps	TokenNameIdentifier	 root Maps
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
map	TokenNameIdentifier	 map
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
map	TokenNameIdentifier	 map
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* * Return 'key' string. 'key' is the field name of the Query. * If not fieldMatch, 'key' will be null. */	TokenNameCOMMENT_BLOCK	 Return 'key' string. 'key' is the field name of the Query. If not fieldMatch, 'key' will be null. 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fieldMatch	TokenNameIdentifier	 field Match
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
instanceof	TokenNameinstanceof	
TermQuery	TokenNameIdentifier	 Term Query
)	TokenNameRPAREN	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
TermQuery	TokenNameIdentifier	 Term Query
)	TokenNameRPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
.	TokenNameDOT	
getTerm	TokenNameIdentifier	 get Term
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
field	TokenNameIdentifier	 field
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
instanceof	TokenNameinstanceof	
PhraseQuery	TokenNameIdentifier	 Phrase Query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
PhraseQuery	TokenNameIdentifier	 Phrase Query
pq	TokenNameIdentifier	 pq
=	TokenNameEQUAL	
(	TokenNameLPAREN	
PhraseQuery	TokenNameIdentifier	 Phrase Query
)	TokenNameRPAREN	
query	TokenNameIdentifier	 query
;	TokenNameSEMICOLON	
Term	TokenNameIdentifier	 Term
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
terms	TokenNameIdentifier	 terms
=	TokenNameEQUAL	
pq	TokenNameIdentifier	 pq
.	TokenNameDOT	
getTerms	TokenNameIdentifier	 get Terms
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
terms	TokenNameIdentifier	 terms
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
field	TokenNameIdentifier	 field
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
instanceof	TokenNameinstanceof	
FuzzyQuery	TokenNameIdentifier	 Fuzzy Query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
FuzzyQuery	TokenNameIdentifier	 Fuzzy Query
)	TokenNameRPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
.	TokenNameDOT	
getTerm	TokenNameIdentifier	 get Term
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
field	TokenNameIdentifier	 field
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
instanceof	TokenNameinstanceof	
PrefixQuery	TokenNameIdentifier	 Prefix Query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
PrefixQuery	TokenNameIdentifier	 Prefix Query
)	TokenNameRPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
.	TokenNameDOT	
getPrefix	TokenNameIdentifier	 get Prefix
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
field	TokenNameIdentifier	 field
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
instanceof	TokenNameinstanceof	
RegexQuery	TokenNameIdentifier	 Regex Query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
RegexQuery	TokenNameIdentifier	 Regex Query
)	TokenNameRPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
.	TokenNameDOT	
getTerm	TokenNameIdentifier	 get Term
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
field	TokenNameIdentifier	 field
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
instanceof	TokenNameinstanceof	
TermRangeQuery	TokenNameIdentifier	 Term Range Query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
TermRangeQuery	TokenNameIdentifier	 Term Range Query
)	TokenNameRPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
.	TokenNameDOT	
getField	TokenNameIdentifier	 get Field
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
instanceof	TokenNameinstanceof	
WildcardQuery	TokenNameIdentifier	 Wildcard Query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
WildcardQuery	TokenNameIdentifier	 Wildcard Query
)	TokenNameRPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
.	TokenNameDOT	
getTerm	TokenNameIdentifier	 get Term
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
field	TokenNameIdentifier	 field
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"query ""	TokenNameStringLiteral	query "
+	TokenNamePLUS	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"" must be flatten first."	TokenNameStringLiteral	" must be flatten first.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* * Save the set of terms in the queries to termSetMap. * * ex1) q=name:john * - fieldMatch==true * termSetMap=Map<"name",Set<"john">> * - fieldMatch==false * termSetMap=Map<null,Set<"john">> * * ex2) q=name:john title:manager * - fieldMatch==true * termSetMap=Map<"name",Set<"john">, * "title",Set<"manager">> * - fieldMatch==false * termSetMap=Map<null,Set<"john","manager">> * * ex3) q=name:"john lennon" * - fieldMatch==true * termSetMap=Map<"name",Set<"john","lennon">> * - fieldMatch==false * termSetMap=Map<null,Set<"john","lennon">> */	TokenNameCOMMENT_BLOCK	 Save the set of terms in the queries to termSetMap. * ex1) q=name:john - fieldMatch==true termSetMap=Map<"name",Set<"john">> - fieldMatch==false termSetMap=Map<null,Set<"john">> * ex2) q=name:john title:manager - fieldMatch==true termSetMap=Map<"name",Set<"john">, "title",Set<"manager">> - fieldMatch==false termSetMap=Map<null,Set<"john","manager">> * ex3) q=name:"john lennon" - fieldMatch==true termSetMap=Map<"name",Set<"john","lennon">> - fieldMatch==false termSetMap=Map<null,Set<"john","lennon">> 
void	TokenNamevoid	
saveTerms	TokenNameIdentifier	 save Terms
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Query	TokenNameIdentifier	 Query
>	TokenNameGREATER	
flatQueries	TokenNameIdentifier	 flat Queries
,	TokenNameCOMMA	
IndexReader	TokenNameIdentifier	 Index Reader
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
query	TokenNameIdentifier	 query
:	TokenNameCOLON	
flatQueries	TokenNameIdentifier	 flat Queries
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
termSet	TokenNameIdentifier	 term Set
=	TokenNameEQUAL	
getTermSet	TokenNameIdentifier	 get Term Set
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
instanceof	TokenNameinstanceof	
TermQuery	TokenNameIdentifier	 Term Query
)	TokenNameRPAREN	
termSet	TokenNameIdentifier	 term Set
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
TermQuery	TokenNameIdentifier	 Term Query
)	TokenNameRPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
.	TokenNameDOT	
getTerm	TokenNameIdentifier	 get Term
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
text	TokenNameIdentifier	 text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
instanceof	TokenNameinstanceof	
PhraseQuery	TokenNameIdentifier	 Phrase Query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Term	TokenNameIdentifier	 Term
term	TokenNameIdentifier	 term
:	TokenNameCOLON	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
PhraseQuery	TokenNameIdentifier	 Phrase Query
)	TokenNameRPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
.	TokenNameDOT	
getTerms	TokenNameIdentifier	 get Terms
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
termSet	TokenNameIdentifier	 term Set
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
text	TokenNameIdentifier	 text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
instanceof	TokenNameinstanceof	
MultiTermQuery	TokenNameIdentifier	 Multi Term Query
&&	TokenNameAND_AND	
reader	TokenNameIdentifier	 reader
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
BooleanQuery	TokenNameIdentifier	 Boolean Query
mtqTerms	TokenNameIdentifier	 mtq Terms
=	TokenNameEQUAL	
(	TokenNameLPAREN	
BooleanQuery	TokenNameIdentifier	 Boolean Query
)	TokenNameRPAREN	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
rewrite	TokenNameIdentifier	 rewrite
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
BooleanClause	TokenNameIdentifier	 Boolean Clause
clause	TokenNameIdentifier	 clause
:	TokenNameCOLON	
mtqTerms	TokenNameIdentifier	 mtq Terms
.	TokenNameDOT	
getClauses	TokenNameIdentifier	 get Clauses
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
termSet	TokenNameIdentifier	 term Set
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
TermQuery	TokenNameIdentifier	 Term Query
)	TokenNameRPAREN	
clause	TokenNameIdentifier	 clause
.	TokenNameDOT	
getQuery	TokenNameIdentifier	 get Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getTerm	TokenNameIdentifier	 get Term
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
text	TokenNameIdentifier	 text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"query ""	TokenNameStringLiteral	query "
+	TokenNamePLUS	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"" must be flatten first."	TokenNameStringLiteral	" must be flatten first.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
getTermSet	TokenNameIdentifier	 get Term Set
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
set	TokenNameIdentifier	 set
=	TokenNameEQUAL	
termSetMap	TokenNameIdentifier	 term Set Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
set	TokenNameIdentifier	 set
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
set	TokenNameIdentifier	 set
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
termSetMap	TokenNameIdentifier	 term Set Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
set	TokenNameIdentifier	 set
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
set	TokenNameIdentifier	 set
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
getTermSet	TokenNameIdentifier	 get Term Set
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
termSetMap	TokenNameIdentifier	 term Set Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
fieldMatch	TokenNameIdentifier	 field Match
?	TokenNameQUESTION	
field	TokenNameIdentifier	 field
:	TokenNameCOLON	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * * @param fieldName * @param term * @return QueryPhraseMap */	TokenNameCOMMENT_JAVADOC	 * @param fieldName @param term @return QueryPhraseMap 
public	TokenNamepublic	
QueryPhraseMap	TokenNameIdentifier	 Query Phrase Map
getFieldTermMap	TokenNameIdentifier	 get Field Term Map
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
fieldName	TokenNameIdentifier	 field Name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
{	TokenNameLBRACE	
QueryPhraseMap	TokenNameIdentifier	 Query Phrase Map
rootMap	TokenNameIdentifier	 root Map
=	TokenNameEQUAL	
getRootMap	TokenNameIdentifier	 get Root Map
(	TokenNameLPAREN	
fieldName	TokenNameIdentifier	 field Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
rootMap	TokenNameIdentifier	 root Map
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
rootMap	TokenNameIdentifier	 root Map
.	TokenNameDOT	
subMap	TokenNameIdentifier	 sub Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * * @param fieldName * @param phraseCandidate * @return QueryPhraseMap */	TokenNameCOMMENT_JAVADOC	 * @param fieldName @param phraseCandidate @return QueryPhraseMap 
public	TokenNamepublic	
QueryPhraseMap	TokenNameIdentifier	 Query Phrase Map
searchPhrase	TokenNameIdentifier	 search Phrase
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
fieldName	TokenNameIdentifier	 field Name
,	TokenNameCOMMA	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
TermInfo	TokenNameIdentifier	 Term Info
>	TokenNameGREATER	
phraseCandidate	TokenNameIdentifier	 phrase Candidate
)	TokenNameRPAREN	
{	TokenNameLBRACE	
QueryPhraseMap	TokenNameIdentifier	 Query Phrase Map
root	TokenNameIdentifier	 root
=	TokenNameEQUAL	
getRootMap	TokenNameIdentifier	 get Root Map
(	TokenNameLPAREN	
fieldName	TokenNameIdentifier	 field Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
root	TokenNameIdentifier	 root
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
root	TokenNameIdentifier	 root
.	TokenNameDOT	
searchPhrase	TokenNameIdentifier	 search Phrase
(	TokenNameLPAREN	
phraseCandidate	TokenNameIdentifier	 phrase Candidate
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
QueryPhraseMap	TokenNameIdentifier	 Query Phrase Map
getRootMap	TokenNameIdentifier	 get Root Map
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
fieldName	TokenNameIdentifier	 field Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
rootMaps	TokenNameIdentifier	 root Maps
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
fieldMatch	TokenNameIdentifier	 field Match
?	TokenNameQUESTION	
fieldName	TokenNameIdentifier	 field Name
:	TokenNameCOLON	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
nextTermOrPhraseNumber	TokenNameIdentifier	 next Term Or Phrase Number
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
termOrPhraseNumber	TokenNameIdentifier	 term Or Phrase Number
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
class	TokenNameclass	
QueryPhraseMap	TokenNameIdentifier	 Query Phrase Map
{	TokenNameLBRACE	
boolean	TokenNameboolean	
terminal	TokenNameIdentifier	 terminal
;	TokenNameSEMICOLON	
int	TokenNameint	
slop	TokenNameIdentifier	 slop
;	TokenNameSEMICOLON	
// valid if terminal == true and phraseHighlight == true 	TokenNameCOMMENT_LINE	valid if terminal == true and phraseHighlight == true 
float	TokenNamefloat	
boost	TokenNameIdentifier	 boost
;	TokenNameSEMICOLON	
// valid if terminal == true 	TokenNameCOMMENT_LINE	valid if terminal == true 
int	TokenNameint	
termOrPhraseNumber	TokenNameIdentifier	 term Or Phrase Number
;	TokenNameSEMICOLON	
// valid if terminal == true 	TokenNameCOMMENT_LINE	valid if terminal == true 
FieldQuery	TokenNameIdentifier	 Field Query
fieldQuery	TokenNameIdentifier	 field Query
;	TokenNameSEMICOLON	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
QueryPhraseMap	TokenNameIdentifier	 Query Phrase Map
>	TokenNameGREATER	
subMap	TokenNameIdentifier	 sub Map
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
QueryPhraseMap	TokenNameIdentifier	 Query Phrase Map
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
QueryPhraseMap	TokenNameIdentifier	 Query Phrase Map
(	TokenNameLPAREN	
FieldQuery	TokenNameIdentifier	 Field Query
fieldQuery	TokenNameIdentifier	 field Query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fieldQuery	TokenNameIdentifier	 field Query
=	TokenNameEQUAL	
fieldQuery	TokenNameIdentifier	 field Query
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
void	TokenNamevoid	
addTerm	TokenNameIdentifier	 add Term
(	TokenNameLPAREN	
Term	TokenNameIdentifier	 Term
term	TokenNameIdentifier	 term
,	TokenNameCOMMA	
float	TokenNamefloat	
boost	TokenNameIdentifier	 boost
)	TokenNameRPAREN	
{	TokenNameLBRACE	
QueryPhraseMap	TokenNameIdentifier	 Query Phrase Map
map	TokenNameIdentifier	 map
=	TokenNameEQUAL	
getOrNewMap	TokenNameIdentifier	 get Or New Map
(	TokenNameLPAREN	
subMap	TokenNameIdentifier	 sub Map
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
text	TokenNameIdentifier	 text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
map	TokenNameIdentifier	 map
.	TokenNameDOT	
markTerminal	TokenNameIdentifier	 mark Terminal
(	TokenNameLPAREN	
boost	TokenNameIdentifier	 boost
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
QueryPhraseMap	TokenNameIdentifier	 Query Phrase Map
getOrNewMap	TokenNameIdentifier	 get Or New Map
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
QueryPhraseMap	TokenNameIdentifier	 Query Phrase Map
>	TokenNameGREATER	
subMap	TokenNameIdentifier	 sub Map
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
{	TokenNameLBRACE	
QueryPhraseMap	TokenNameIdentifier	 Query Phrase Map
map	TokenNameIdentifier	 map
=	TokenNameEQUAL	
subMap	TokenNameIdentifier	 sub Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
map	TokenNameIdentifier	 map
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
map	TokenNameIdentifier	 map
=	TokenNameEQUAL	
new	TokenNamenew	
QueryPhraseMap	TokenNameIdentifier	 Query Phrase Map
(	TokenNameLPAREN	
fieldQuery	TokenNameIdentifier	 field Query
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
subMap	TokenNameIdentifier	 sub Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
,	TokenNameCOMMA	
map	TokenNameIdentifier	 map
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
map	TokenNameIdentifier	 map
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
void	TokenNamevoid	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
IndexReader	TokenNameIdentifier	 Index Reader
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
instanceof	TokenNameinstanceof	
TermQuery	TokenNameIdentifier	 Term Query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addTerm	TokenNameIdentifier	 add Term
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
TermQuery	TokenNameIdentifier	 Term Query
)	TokenNameRPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
.	TokenNameDOT	
getTerm	TokenNameIdentifier	 get Term
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
getBoost	TokenNameIdentifier	 get Boost
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
instanceof	TokenNameinstanceof	
PhraseQuery	TokenNameIdentifier	 Phrase Query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
PhraseQuery	TokenNameIdentifier	 Phrase Query
pq	TokenNameIdentifier	 pq
=	TokenNameEQUAL	
(	TokenNameLPAREN	
PhraseQuery	TokenNameIdentifier	 Phrase Query
)	TokenNameRPAREN	
query	TokenNameIdentifier	 query
;	TokenNameSEMICOLON	
Term	TokenNameIdentifier	 Term
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
terms	TokenNameIdentifier	 terms
=	TokenNameEQUAL	
pq	TokenNameIdentifier	 pq
.	TokenNameDOT	
getTerms	TokenNameIdentifier	 get Terms
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
QueryPhraseMap	TokenNameIdentifier	 Query Phrase Map
>	TokenNameGREATER	
map	TokenNameIdentifier	 map
=	TokenNameEQUAL	
subMap	TokenNameIdentifier	 sub Map
;	TokenNameSEMICOLON	
QueryPhraseMap	TokenNameIdentifier	 Query Phrase Map
qpm	TokenNameIdentifier	 qpm
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Term	TokenNameIdentifier	 Term
term	TokenNameIdentifier	 term
:	TokenNameCOLON	
terms	TokenNameIdentifier	 terms
)	TokenNameRPAREN	
{	TokenNameLBRACE	
qpm	TokenNameIdentifier	 qpm
=	TokenNameEQUAL	
getOrNewMap	TokenNameIdentifier	 get Or New Map
(	TokenNameLPAREN	
map	TokenNameIdentifier	 map
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
text	TokenNameIdentifier	 text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
map	TokenNameIdentifier	 map
=	TokenNameEQUAL	
qpm	TokenNameIdentifier	 qpm
.	TokenNameDOT	
subMap	TokenNameIdentifier	 sub Map
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
qpm	TokenNameIdentifier	 qpm
.	TokenNameDOT	
markTerminal	TokenNameIdentifier	 mark Terminal
(	TokenNameLPAREN	
pq	TokenNameIdentifier	 pq
.	TokenNameDOT	
getSlop	TokenNameIdentifier	 get Slop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
pq	TokenNameIdentifier	 pq
.	TokenNameDOT	
getBoost	TokenNameIdentifier	 get Boost
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"query ""	TokenNameStringLiteral	query "
+	TokenNamePLUS	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"" must be flatten first."	TokenNameStringLiteral	" must be flatten first.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
QueryPhraseMap	TokenNameIdentifier	 Query Phrase Map
getTermMap	TokenNameIdentifier	 get Term Map
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
subMap	TokenNameIdentifier	 sub Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
markTerminal	TokenNameIdentifier	 mark Terminal
(	TokenNameLPAREN	
float	TokenNamefloat	
boost	TokenNameIdentifier	 boost
)	TokenNameRPAREN	
{	TokenNameLBRACE	
markTerminal	TokenNameIdentifier	 mark Terminal
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
boost	TokenNameIdentifier	 boost
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
markTerminal	TokenNameIdentifier	 mark Terminal
(	TokenNameLPAREN	
int	TokenNameint	
slop	TokenNameIdentifier	 slop
,	TokenNameCOMMA	
float	TokenNamefloat	
boost	TokenNameIdentifier	 boost
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
terminal	TokenNameIdentifier	 terminal
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
slop	TokenNameIdentifier	 slop
=	TokenNameEQUAL	
slop	TokenNameIdentifier	 slop
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
boost	TokenNameIdentifier	 boost
=	TokenNameEQUAL	
boost	TokenNameIdentifier	 boost
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
termOrPhraseNumber	TokenNameIdentifier	 term Or Phrase Number
=	TokenNameEQUAL	
fieldQuery	TokenNameIdentifier	 field Query
.	TokenNameDOT	
nextTermOrPhraseNumber	TokenNameIdentifier	 next Term Or Phrase Number
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isTerminal	TokenNameIdentifier	 is Terminal
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
terminal	TokenNameIdentifier	 terminal
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getSlop	TokenNameIdentifier	 get Slop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
slop	TokenNameIdentifier	 slop
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
float	TokenNamefloat	
getBoost	TokenNameIdentifier	 get Boost
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
boost	TokenNameIdentifier	 boost
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getTermOrPhraseNumber	TokenNameIdentifier	 get Term Or Phrase Number
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
termOrPhraseNumber	TokenNameIdentifier	 term Or Phrase Number
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
QueryPhraseMap	TokenNameIdentifier	 Query Phrase Map
searchPhrase	TokenNameIdentifier	 search Phrase
(	TokenNameLPAREN	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
TermInfo	TokenNameIdentifier	 Term Info
>	TokenNameGREATER	
phraseCandidate	TokenNameIdentifier	 phrase Candidate
)	TokenNameRPAREN	
{	TokenNameLBRACE	
QueryPhraseMap	TokenNameIdentifier	 Query Phrase Map
currMap	TokenNameIdentifier	 curr Map
=	TokenNameEQUAL	
this	TokenNamethis	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
TermInfo	TokenNameIdentifier	 Term Info
ti	TokenNameIdentifier	 ti
:	TokenNameCOLON	
phraseCandidate	TokenNameIdentifier	 phrase Candidate
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currMap	TokenNameIdentifier	 curr Map
=	TokenNameEQUAL	
currMap	TokenNameIdentifier	 curr Map
.	TokenNameDOT	
subMap	TokenNameIdentifier	 sub Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
ti	TokenNameIdentifier	 ti
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
currMap	TokenNameIdentifier	 curr Map
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
currMap	TokenNameIdentifier	 curr Map
.	TokenNameDOT	
isValidTermOrPhrase	TokenNameIdentifier	 is Valid Term Or Phrase
(	TokenNameLPAREN	
phraseCandidate	TokenNameIdentifier	 phrase Candidate
)	TokenNameRPAREN	
?	TokenNameQUESTION	
currMap	TokenNameIdentifier	 curr Map
:	TokenNameCOLON	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isValidTermOrPhrase	TokenNameIdentifier	 is Valid Term Or Phrase
(	TokenNameLPAREN	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
TermInfo	TokenNameIdentifier	 Term Info
>	TokenNameGREATER	
phraseCandidate	TokenNameIdentifier	 phrase Candidate
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// check terminal 	TokenNameCOMMENT_LINE	check terminal 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
terminal	TokenNameIdentifier	 terminal
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// if the candidate is a term, it is valid 	TokenNameCOMMENT_LINE	if the candidate is a term, it is valid 
if	TokenNameif	
(	TokenNameLPAREN	
phraseCandidate	TokenNameIdentifier	 phrase Candidate
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// else check whether the candidate is valid phrase 	TokenNameCOMMENT_LINE	else check whether the candidate is valid phrase 
// compare position-gaps between terms to slop 	TokenNameCOMMENT_LINE	compare position-gaps between terms to slop 
int	TokenNameint	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
phraseCandidate	TokenNameIdentifier	 phrase Candidate
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getPosition	TokenNameIdentifier	 get Position
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
phraseCandidate	TokenNameIdentifier	 phrase Candidate
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
nextPos	TokenNameIdentifier	 next Pos
=	TokenNameEQUAL	
phraseCandidate	TokenNameIdentifier	 phrase Candidate
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
.	TokenNameDOT	
getPosition	TokenNameIdentifier	 get Position
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
abs	TokenNameIdentifier	 abs
(	TokenNameLPAREN	
nextPos	TokenNameIdentifier	 next Pos
-	TokenNameMINUS	
pos	TokenNameIdentifier	 pos
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>	TokenNameGREATER	
slop	TokenNameIdentifier	 slop
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
nextPos	TokenNameIdentifier	 next Pos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
