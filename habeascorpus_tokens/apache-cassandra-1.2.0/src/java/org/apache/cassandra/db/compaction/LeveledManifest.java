/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
compaction	TokenNameIdentifier	 compaction
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
File	TokenNameIdentifier	 File
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
annotations	TokenNameIdentifier	 annotations
.	TokenNameDOT	
VisibleForTesting	TokenNameIdentifier	 Visible For Testing
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
base	TokenNameIdentifier	 base
.	TokenNameDOT	
Predicate	TokenNameIdentifier	 Predicate
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
base	TokenNameIdentifier	 base
.	TokenNameDOT	
Predicates	TokenNameIdentifier	 Predicates
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
collect	TokenNameIdentifier	 collect
.	TokenNameDOT	
ImmutableSortedSet	TokenNameIdentifier	 Immutable Sorted Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
collect	TokenNameIdentifier	 collect
.	TokenNameDOT	
Iterables	TokenNameIdentifier	 Iterables
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
collect	TokenNameIdentifier	 collect
.	TokenNameDOT	
Sets	TokenNameIdentifier	 Sets
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
primitives	TokenNameIdentifier	 primitives
.	TokenNameDOT	
Ints	TokenNameIdentifier	 Ints
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
codehaus	TokenNameIdentifier	 codehaus
.	TokenNameDOT	
jackson	TokenNameIdentifier	 jackson
.	TokenNameDOT	
JsonEncoding	TokenNameIdentifier	 Json Encoding
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
codehaus	TokenNameIdentifier	 codehaus
.	TokenNameDOT	
jackson	TokenNameIdentifier	 jackson
.	TokenNameDOT	
JsonFactory	TokenNameIdentifier	 Json Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
codehaus	TokenNameIdentifier	 codehaus
.	TokenNameDOT	
jackson	TokenNameIdentifier	 jackson
.	TokenNameDOT	
JsonGenerator	TokenNameIdentifier	 Json Generator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
codehaus	TokenNameIdentifier	 codehaus
.	TokenNameDOT	
jackson	TokenNameIdentifier	 jackson
.	TokenNameDOT	
JsonNode	TokenNameIdentifier	 Json Node
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
codehaus	TokenNameIdentifier	 codehaus
.	TokenNameDOT	
jackson	TokenNameIdentifier	 jackson
.	TokenNameDOT	
map	TokenNameIdentifier	 map
.	TokenNameDOT	
ObjectMapper	TokenNameIdentifier	 Object Mapper
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
slf4j	TokenNameIdentifier	 slf4j
.	TokenNameDOT	
Logger	TokenNameIdentifier	 Logger
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
slf4j	TokenNameIdentifier	 slf4j
.	TokenNameDOT	
LoggerFactory	TokenNameIdentifier	 Logger Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
RowPosition	TokenNameIdentifier	 Row Position
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
dht	TokenNameIdentifier	 dht
.	TokenNameDOT	
Bounds	TokenNameIdentifier	 Bounds
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
dht	TokenNameIdentifier	 dht
.	TokenNameDOT	
Token	TokenNameIdentifier	 Token
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
FSWriteError	TokenNameIdentifier	 FS Write Error
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
SSTable	TokenNameIdentifier	 SS Table
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
SSTableReader	TokenNameIdentifier	 SS Table Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
FileUtils	TokenNameIdentifier	 File Utils
;	TokenNameSEMICOLON	
public	TokenNamepublic	
class	TokenNameclass	
LeveledManifest	TokenNameIdentifier	 Leveled Manifest
{	TokenNameLBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Logger	TokenNameIdentifier	 Logger
logger	TokenNameIdentifier	 logger
=	TokenNameEQUAL	
LoggerFactory	TokenNameIdentifier	 Logger Factory
.	TokenNameDOT	
getLogger	TokenNameIdentifier	 get Logger
(	TokenNameLPAREN	
LeveledManifest	TokenNameIdentifier	 Leveled Manifest
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
EXTENSION	TokenNameIdentifier	 EXTENSION
=	TokenNameEQUAL	
".json"	TokenNameStringLiteral	.json
;	TokenNameSEMICOLON	
/** * limit the number of L0 sstables we do at once, because compaction bloom filter creation * uses a pessimistic estimate of how many keys overlap (none), so we risk wasting memory * or even OOMing when compacting highly overlapping sstables */	TokenNameCOMMENT_JAVADOC	 limit the number of L0 sstables we do at once, because compaction bloom filter creation uses a pessimistic estimate of how many keys overlap (none), so we risk wasting memory or even OOMing when compacting highly overlapping sstables 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
MAX_COMPACTING_L0	TokenNameIdentifier	 MAX  COMPACTING  L0
=	TokenNameEQUAL	
32	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
generations	TokenNameIdentifier	 generations
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
sstableGenerations	TokenNameIdentifier	 sstable Generations
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
RowPosition	TokenNameIdentifier	 Row Position
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
lastCompactedKeys	TokenNameIdentifier	 last Compacted Keys
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
maxSSTableSizeInBytes	TokenNameIdentifier	 max SS Table Size In Bytes
;	TokenNameSEMICOLON	
private	TokenNameprivate	
LeveledManifest	TokenNameIdentifier	 Leveled Manifest
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
int	TokenNameint	
maxSSTableSizeInMB	TokenNameIdentifier	 max SS Table Size In MB
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
cfs	TokenNameIdentifier	 cfs
=	TokenNameEQUAL	
cfs	TokenNameIdentifier	 cfs
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
maxSSTableSizeInBytes	TokenNameIdentifier	 max SS Table Size In Bytes
=	TokenNameEQUAL	
maxSSTableSizeInMB	TokenNameIdentifier	 max SS Table Size In MB
*	TokenNameMULTIPLY	
1024	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
1024	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// allocate enough generations for a PB of data 	TokenNameCOMMENT_LINE	allocate enough generations for a PB of data 
int	TokenNameint	
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
log10	TokenNameIdentifier	 log10
(	TokenNameLPAREN	
1000	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
1000	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
1000	TokenNameIntegerLiteral	
/	TokenNameDIVIDE	
maxSSTableSizeInMB	TokenNameIdentifier	 max SS Table Size In MB
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
generations	TokenNameIdentifier	 generations
=	TokenNameEQUAL	
new	TokenNamenew	
List	TokenNameIdentifier	 List
[	TokenNameLBRACKET	
n	TokenNameIdentifier	 n
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
lastCompactedKeys	TokenNameIdentifier	 last Compacted Keys
=	TokenNameEQUAL	
new	TokenNamenew	
RowPosition	TokenNameIdentifier	 Row Position
[	TokenNameLBRACKET	
n	TokenNameIdentifier	 n
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
generations	TokenNameIdentifier	 generations
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
generations	TokenNameIdentifier	 generations
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
lastCompactedKeys	TokenNameIdentifier	 last Compacted Keys
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
partitioner	TokenNameIdentifier	 partitioner
.	TokenNameDOT	
getMinimumToken	TokenNameIdentifier	 get Minimum Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
minKeyBound	TokenNameIdentifier	 min Key Bound
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
sstableGenerations	TokenNameIdentifier	 sstable Generations
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
static	TokenNamestatic	
LeveledManifest	TokenNameIdentifier	 Leveled Manifest
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
int	TokenNameint	
maxSSTableSize	TokenNameIdentifier	 max SS Table Size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
maxSSTableSize	TokenNameIdentifier	 max SS Table Size
,	TokenNameCOMMA	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
getSSTables	TokenNameIdentifier	 get SS Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
LeveledManifest	TokenNameIdentifier	 Leveled Manifest
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
int	TokenNameint	
maxSSTableSize	TokenNameIdentifier	 max SS Table Size
,	TokenNameCOMMA	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
LeveledManifest	TokenNameIdentifier	 Leveled Manifest
manifest	TokenNameIdentifier	 manifest
=	TokenNameEQUAL	
new	TokenNamenew	
LeveledManifest	TokenNameIdentifier	 Leveled Manifest
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
maxSSTableSize	TokenNameIdentifier	 max SS Table Size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
load	TokenNameIdentifier	 load
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
manifest	TokenNameIdentifier	 manifest
,	TokenNameCOMMA	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// ensure all SSTables are in the manifest 	TokenNameCOMMENT_LINE	ensure all SSTables are in the manifest 
for	TokenNamefor	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
ssTableReader	TokenNameIdentifier	 ss Table Reader
:	TokenNameCOLON	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
manifest	TokenNameIdentifier	 manifest
.	TokenNameDOT	
levelOf	TokenNameIdentifier	 level Of
(	TokenNameLPAREN	
ssTableReader	TokenNameIdentifier	 ss Table Reader
)	TokenNameRPAREN	
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
manifest	TokenNameIdentifier	 manifest
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
ssTableReader	TokenNameIdentifier	 ss Table Reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
manifest	TokenNameIdentifier	 manifest
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
load	TokenNameIdentifier	 load
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
LeveledManifest	TokenNameIdentifier	 Leveled Manifest
manifest	TokenNameIdentifier	 manifest
,	TokenNameCOMMA	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
manifestFile	TokenNameIdentifier	 manifest File
=	TokenNameEQUAL	
tryGetManifest	TokenNameIdentifier	 try Get Manifest
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
manifestFile	TokenNameIdentifier	 manifest File
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
ObjectMapper	TokenNameIdentifier	 Object Mapper
m	TokenNameIdentifier	 m
=	TokenNameEQUAL	
new	TokenNamenew	
ObjectMapper	TokenNameIdentifier	 Object Mapper
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
JsonNode	TokenNameIdentifier	 Json Node
rootNode	TokenNameIdentifier	 root Node
=	TokenNameEQUAL	
m	TokenNameIdentifier	 m
.	TokenNameDOT	
readValue	TokenNameIdentifier	 read Value
(	TokenNameLPAREN	
manifestFile	TokenNameIdentifier	 manifest File
,	TokenNameCOMMA	
JsonNode	TokenNameIdentifier	 Json Node
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
JsonNode	TokenNameIdentifier	 Json Node
generations	TokenNameIdentifier	 generations
=	TokenNameEQUAL	
rootNode	TokenNameIdentifier	 root Node
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
"generations"	TokenNameStringLiteral	generations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
generations	TokenNameIdentifier	 generations
.	TokenNameDOT	
isArray	TokenNameIdentifier	 is Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
JsonNode	TokenNameIdentifier	 Json Node
generation	TokenNameIdentifier	 generation
:	TokenNameCOLON	
generations	TokenNameIdentifier	 generations
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
level	TokenNameIdentifier	 level
=	TokenNameEQUAL	
generation	TokenNameIdentifier	 generation
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
"generation"	TokenNameStringLiteral	generation
)	TokenNameRPAREN	
.	TokenNameDOT	
getIntValue	TokenNameIdentifier	 get Int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
JsonNode	TokenNameIdentifier	 Json Node
generationValues	TokenNameIdentifier	 generation Values
=	TokenNameEQUAL	
generation	TokenNameIdentifier	 generation
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
"members"	TokenNameStringLiteral	members
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
JsonNode	TokenNameIdentifier	 Json Node
generationValue	TokenNameIdentifier	 generation Value
:	TokenNameCOLON	
generationValues	TokenNameIdentifier	 generation Values
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
ssTableReader	TokenNameIdentifier	 ss Table Reader
:	TokenNameCOLON	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ssTableReader	TokenNameIdentifier	 ss Table Reader
.	TokenNameDOT	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
generation	TokenNameIdentifier	 generation
==	TokenNameEQUAL_EQUAL	
generationValue	TokenNameIdentifier	 generation Value
.	TokenNameDOT	
getIntValue	TokenNameIdentifier	 get Int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Loading {} at L{}"	TokenNameStringLiteral	Loading {} at L{}
,	TokenNameCOMMA	
ssTableReader	TokenNameIdentifier	 ss Table Reader
,	TokenNameCOMMA	
level	TokenNameIdentifier	 level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
manifest	TokenNameIdentifier	 manifest
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
ssTableReader	TokenNameIdentifier	 ss Table Reader
,	TokenNameCOMMA	
level	TokenNameIdentifier	 level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// TODO try to recover -old first 	TokenNameCOMMENT_LINE	TODO try to recover -old first 
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
error	TokenNameIdentifier	 error
(	TokenNameLPAREN	
"Manifest present but corrupt. Cassandra will compact levels from scratch"	TokenNameStringLiteral	Manifest present but corrupt. Cassandra will compact levels from scratch
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logDistribution	TokenNameIdentifier	 log Distribution
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Adding {} to L0"	TokenNameStringLiteral	Adding {} to L0
,	TokenNameCOMMA	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
serialize	TokenNameIdentifier	 serialize
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * if the number of SSTables in the current compacted set *by itself* exceeds the target level's * (regardless of the level's current contents), find an empty level instead */	TokenNameCOMMENT_JAVADOC	 if the number of SSTables in the current compacted set *by itself* exceeds the target level's (regardless of the level's current contents), find an empty level instead 
private	TokenNameprivate	
int	TokenNameint	
skipLevels	TokenNameIdentifier	 skip Levels
(	TokenNameLPAREN	
int	TokenNameint	
newLevel	TokenNameIdentifier	 new Level
,	TokenNameCOMMA	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
added	TokenNameIdentifier	 added
)	TokenNameRPAREN	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
maxBytesForLevel	TokenNameIdentifier	 max Bytes For Level
(	TokenNameLPAREN	
newLevel	TokenNameIdentifier	 new Level
)	TokenNameRPAREN	
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
.	TokenNameDOT	
getTotalBytes	TokenNameIdentifier	 get Total Bytes
(	TokenNameLPAREN	
added	TokenNameIdentifier	 added
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
generations	TokenNameIdentifier	 generations
[	TokenNameLBRACKET	
(	TokenNameLPAREN	
newLevel	TokenNameIdentifier	 new Level
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
newLevel	TokenNameIdentifier	 new Level
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
newLevel	TokenNameIdentifier	 new Level
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
promote	TokenNameIdentifier	 promote
(	TokenNameLPAREN	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
removed	TokenNameIdentifier	 removed
,	TokenNameCOMMA	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
added	TokenNameIdentifier	 added
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
!	TokenNameNOT	
Iterables	TokenNameIdentifier	 Iterables
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
removed	TokenNameIdentifier	 removed
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// use add() instead of promote when adding new sstables 	TokenNameCOMMENT_LINE	use add() instead of promote when adding new sstables 
logDistribution	TokenNameIdentifier	 log Distribution
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Replacing ["	TokenNameStringLiteral	Replacing [
+	TokenNamePLUS	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
removed	TokenNameIdentifier	 removed
)	TokenNameRPAREN	
+	TokenNamePLUS	
"]"	TokenNameStringLiteral	]
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// the level for the added sstables is the max of the removed ones, 	TokenNameCOMMENT_LINE	the level for the added sstables is the max of the removed ones, 
// plus one if the removed were all on the same level 	TokenNameCOMMENT_LINE	plus one if the removed were all on the same level 
int	TokenNameint	
minimumLevel	TokenNameIdentifier	 minimum Level
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
;	TokenNameSEMICOLON	
int	TokenNameint	
maximumLevel	TokenNameIdentifier	 maximum Level
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
:	TokenNameCOLON	
removed	TokenNameIdentifier	 removed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
thisLevel	TokenNameIdentifier	 this Level
=	TokenNameEQUAL	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
thisLevel	TokenNameIdentifier	 this Level
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
maximumLevel	TokenNameIdentifier	 maximum Level
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
max	TokenNameIdentifier	 max
(	TokenNameLPAREN	
maximumLevel	TokenNameIdentifier	 maximum Level
,	TokenNameCOMMA	
thisLevel	TokenNameIdentifier	 this Level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
minimumLevel	TokenNameIdentifier	 minimum Level
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
min	TokenNameIdentifier	 min
(	TokenNameLPAREN	
minimumLevel	TokenNameIdentifier	 minimum Level
,	TokenNameCOMMA	
thisLevel	TokenNameIdentifier	 this Level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// it's valid to do a remove w/o an add (e.g. on truncate) 	TokenNameCOMMENT_LINE	it's valid to do a remove w/o an add (e.g. on truncate) 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
added	TokenNameIdentifier	 added
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
int	TokenNameint	
newLevel	TokenNameIdentifier	 new Level
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
minimumLevel	TokenNameIdentifier	 minimum Level
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
maximumLevel	TokenNameIdentifier	 maximum Level
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
SSTable	TokenNameIdentifier	 SS Table
.	TokenNameDOT	
getTotalBytes	TokenNameIdentifier	 get Total Bytes
(	TokenNameLPAREN	
removed	TokenNameIdentifier	 removed
)	TokenNameRPAREN	
<=	TokenNameLESS_EQUAL	
maxSSTableSizeInBytes	TokenNameIdentifier	 max SS Table Size In Bytes
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// special case for tiny L0 sstables; see CASSANDRA-4341 	TokenNameCOMMENT_LINE	special case for tiny L0 sstables; see CASSANDRA-4341 
newLevel	TokenNameIdentifier	 new Level
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
newLevel	TokenNameIdentifier	 new Level
=	TokenNameEQUAL	
minimumLevel	TokenNameIdentifier	 minimum Level
==	TokenNameEQUAL_EQUAL	
maximumLevel	TokenNameIdentifier	 maximum Level
?	TokenNameQUESTION	
maximumLevel	TokenNameIdentifier	 maximum Level
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
maximumLevel	TokenNameIdentifier	 maximum Level
;	TokenNameSEMICOLON	
newLevel	TokenNameIdentifier	 new Level
=	TokenNameEQUAL	
skipLevels	TokenNameIdentifier	 skip Levels
(	TokenNameLPAREN	
newLevel	TokenNameIdentifier	 new Level
,	TokenNameCOMMA	
added	TokenNameIdentifier	 added
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
newLevel	TokenNameIdentifier	 new Level
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Adding [{}] at L{}"	TokenNameStringLiteral	Adding [{}] at L{}
,	TokenNameCOMMA	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
added	TokenNameIdentifier	 added
)	TokenNameRPAREN	
,	TokenNameCOMMA	
newLevel	TokenNameIdentifier	 new Level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
lastCompactedKeys	TokenNameIdentifier	 last Compacted Keys
[	TokenNameLBRACKET	
minimumLevel	TokenNameIdentifier	 minimum Level
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
SSTable	TokenNameIdentifier	 SS Table
.	TokenNameDOT	
sstableOrdering	TokenNameIdentifier	 sstable Ordering
.	TokenNameDOT	
max	TokenNameIdentifier	 max
(	TokenNameLPAREN	
added	TokenNameIdentifier	 added
)	TokenNameRPAREN	
.	TokenNameDOT	
last	TokenNameIdentifier	 last
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
ssTableReader	TokenNameIdentifier	 ss Table Reader
:	TokenNameCOLON	
added	TokenNameIdentifier	 added
)	TokenNameRPAREN	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
ssTableReader	TokenNameIdentifier	 ss Table Reader
,	TokenNameCOMMA	
newLevel	TokenNameIdentifier	 new Level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Fix overlapping sstables from CASSANDRA-4321/4411 	TokenNameCOMMENT_LINE	Fix overlapping sstables from CASSANDRA-4321/4411 
if	TokenNameif	
(	TokenNameLPAREN	
newLevel	TokenNameIdentifier	 new Level
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
repairOverlappingSSTables	TokenNameIdentifier	 repair Overlapping SS Tables
(	TokenNameLPAREN	
newLevel	TokenNameIdentifier	 new Level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
serialize	TokenNameIdentifier	 serialize
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
repairOverlappingSSTables	TokenNameIdentifier	 repair Overlapping SS Tables
(	TokenNameLPAREN	
int	TokenNameint	
level	TokenNameIdentifier	 level
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SSTableReader	TokenNameIdentifier	 SS Table Reader
previous	TokenNameIdentifier	 previous
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
generations	TokenNameIdentifier	 generations
[	TokenNameLBRACKET	
level	TokenNameIdentifier	 level
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
SSTable	TokenNameIdentifier	 SS Table
.	TokenNameDOT	
sstableComparator	TokenNameIdentifier	 sstable Comparator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
outOfOrderSSTables	TokenNameIdentifier	 out Of Order SS Tables
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
current	TokenNameIdentifier	 current
:	TokenNameCOLON	
generations	TokenNameIdentifier	 generations
[	TokenNameLBRACKET	
level	TokenNameIdentifier	 level
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
previous	TokenNameIdentifier	 previous
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
current	TokenNameIdentifier	 current
.	TokenNameDOT	
first	TokenNameIdentifier	 first
.	TokenNameDOT	
compareTo	TokenNameIdentifier	 compare To
(	TokenNameLPAREN	
previous	TokenNameIdentifier	 previous
.	TokenNameDOT	
last	TokenNameIdentifier	 last
)	TokenNameRPAREN	
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
error	TokenNameIdentifier	 error
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"At level %d, %s [%s, %s] overlaps %s [%s, %s]. This is caused by a bug in Cassandra 1.1.0 .. 1.1.3. Sending back to L0. If you have not yet run scrub, you should do so since you may also have rows out-of-order within an sstable"	TokenNameStringLiteral	At level %d, %s [%s, %s] overlaps %s [%s, %s]. This is caused by a bug in Cassandra 1.1.0 .. 1.1.3. Sending back to L0. If you have not yet run scrub, you should do so since you may also have rows out-of-order within an sstable
,	TokenNameCOMMA	
level	TokenNameIdentifier	 level
,	TokenNameCOMMA	
previous	TokenNameIdentifier	 previous
,	TokenNameCOMMA	
previous	TokenNameIdentifier	 previous
.	TokenNameDOT	
first	TokenNameIdentifier	 first
,	TokenNameCOMMA	
previous	TokenNameIdentifier	 previous
.	TokenNameDOT	
last	TokenNameIdentifier	 last
,	TokenNameCOMMA	
current	TokenNameIdentifier	 current
,	TokenNameCOMMA	
current	TokenNameIdentifier	 current
.	TokenNameDOT	
first	TokenNameIdentifier	 first
,	TokenNameCOMMA	
current	TokenNameIdentifier	 current
.	TokenNameDOT	
last	TokenNameIdentifier	 last
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
outOfOrderSSTables	TokenNameIdentifier	 out Of Order SS Tables
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
current	TokenNameIdentifier	 current
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
previous	TokenNameIdentifier	 previous
=	TokenNameEQUAL	
current	TokenNameIdentifier	 current
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
outOfOrderSSTables	TokenNameIdentifier	 out Of Order SS Tables
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
:	TokenNameCOLON	
outOfOrderSSTables	TokenNameIdentifier	 out Of Order SS Tables
)	TokenNameRPAREN	
sendBackToL0	TokenNameIdentifier	 send Back To L0
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
serialize	TokenNameIdentifier	 serialize
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
removed	TokenNameIdentifier	 removed
,	TokenNameCOMMA	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
added	TokenNameIdentifier	 added
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// replace is for compaction operation that operate on exactly one sstable, with no merging. 	TokenNameCOMMENT_LINE	replace is for compaction operation that operate on exactly one sstable, with no merging. 
// Thus, removed will be exactly one sstable, and added will be 0 or 1. 	TokenNameCOMMENT_LINE	Thus, removed will be exactly one sstable, and added will be 0 or 1. 
assert	TokenNameassert	
Iterables	TokenNameIdentifier	 Iterables
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
removed	TokenNameIdentifier	 removed
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
Iterables	TokenNameIdentifier	 Iterables
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
removed	TokenNameIdentifier	 removed
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
Iterables	TokenNameIdentifier	 Iterables
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
added	TokenNameIdentifier	 added
)	TokenNameRPAREN	
<=	TokenNameLESS_EQUAL	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
Iterables	TokenNameIdentifier	 Iterables
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
added	TokenNameIdentifier	 added
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logDistribution	TokenNameIdentifier	 log Distribution
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Replacing {} with {}"	TokenNameStringLiteral	Replacing {} with {}
,	TokenNameCOMMA	
removed	TokenNameIdentifier	 removed
,	TokenNameCOMMA	
added	TokenNameIdentifier	 added
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
level	TokenNameIdentifier	 level
=	TokenNameEQUAL	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
removed	TokenNameIdentifier	 removed
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
Iterables	TokenNameIdentifier	 Iterables
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
added	TokenNameIdentifier	 added
)	TokenNameRPAREN	
)	TokenNameRPAREN	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
added	TokenNameIdentifier	 added
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
level	TokenNameIdentifier	 level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
serialize	TokenNameIdentifier	 serialize
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
sendBackToL0	TokenNameIdentifier	 send Back To L0
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
{	TokenNameLBRACE	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StringBuilder	TokenNameIdentifier	 String Builder
builder	TokenNameIdentifier	 builder
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuilder	TokenNameIdentifier	 String Builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
:	TokenNameCOLON	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
cfname	TokenNameIdentifier	 cfname
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'-'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
generation	TokenNameIdentifier	 generation
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"(L"	TokenNameStringLiteral	(L
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
levelOf	TokenNameIdentifier	 level Of
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"), "	TokenNameStringLiteral	), 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
VisibleForTesting	TokenNameIdentifier	 Visible For Testing
long	TokenNamelong	
maxBytesForLevel	TokenNameIdentifier	 max Bytes For Level
(	TokenNameLPAREN	
int	TokenNameint	
level	TokenNameIdentifier	 level
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
level	TokenNameIdentifier	 level
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
4L	TokenNameLongLiteral	
*	TokenNameMULTIPLY	
maxSSTableSizeInBytes	TokenNameIdentifier	 max SS Table Size In Bytes
;	TokenNameSEMICOLON	
double	TokenNamedouble	
bytes	TokenNameIdentifier	 bytes
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
pow	TokenNameIdentifier	 pow
(	TokenNameLPAREN	
10	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
level	TokenNameIdentifier	 level
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
maxSSTableSizeInBytes	TokenNameIdentifier	 max SS Table Size In Bytes
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
bytes	TokenNameIdentifier	 bytes
>	TokenNameGREATER	
Long	TokenNameIdentifier	 Long
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"At most "	TokenNameStringLiteral	At most 
+	TokenNamePLUS	
Long	TokenNameIdentifier	 Long
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
+	TokenNamePLUS	
" bytes may be in a compaction level; your maxSSTableSize must be absurdly high to compute "	TokenNameStringLiteral	 bytes may be in a compaction level; your maxSSTableSize must be absurdly high to compute 
+	TokenNamePLUS	
bytes	TokenNameIdentifier	 bytes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
long	TokenNamelong	
)	TokenNameRPAREN	
bytes	TokenNameIdentifier	 bytes
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @return highest-priority sstables to compact * If no compactions are necessary, will return an empty list. Never returns null. */	TokenNameCOMMENT_JAVADOC	 @return highest-priority sstables to compact If no compactions are necessary, will return an empty list. Never returns null. 
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
getCompactionCandidates	TokenNameIdentifier	 get Compaction Candidates
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// LevelDB gives each level a score of how much data it contains vs its ideal amount, and 	TokenNameCOMMENT_LINE	LevelDB gives each level a score of how much data it contains vs its ideal amount, and 
// compacts the level with the highest score. But this falls apart spectacularly once you 	TokenNameCOMMENT_LINE	compacts the level with the highest score. But this falls apart spectacularly once you 
// get behind. Consider this set of levels: 	TokenNameCOMMENT_LINE	get behind. Consider this set of levels: 
// L0: 988 [ideal: 4] 	TokenNameCOMMENT_LINE	L0: 988 [ideal: 4] 
// L1: 117 [ideal: 10] 	TokenNameCOMMENT_LINE	L1: 117 [ideal: 10] 
// L2: 12 [ideal: 100] 	TokenNameCOMMENT_LINE	L2: 12 [ideal: 100] 
// 	TokenNameCOMMENT_LINE	 
// The problem is that L0 has a much higher score (almost 250) than L1 (11), so what we'll 	TokenNameCOMMENT_LINE	The problem is that L0 has a much higher score (almost 250) than L1 (11), so what we'll 
// do is compact a batch of MAX_COMPACTING_L0 sstables with all 117 L1 sstables, and put the 	TokenNameCOMMENT_LINE	do is compact a batch of MAX_COMPACTING_L0 sstables with all 117 L1 sstables, and put the 
// result (say, 120 sstables) in L1. Then we'll compact the next batch of MAX_COMPACTING_L0, 	TokenNameCOMMENT_LINE	result (say, 120 sstables) in L1. Then we'll compact the next batch of MAX_COMPACTING_L0, 
// and so forth. So we spend most of our i/o rewriting the L1 data with each batch. 	TokenNameCOMMENT_LINE	and so forth. So we spend most of our i/o rewriting the L1 data with each batch. 
// 	TokenNameCOMMENT_LINE	 
// If we could just do *all* L0 a single time with L1, that would be ideal. But we can't 	TokenNameCOMMENT_LINE	If we could just do *all* L0 a single time with L1, that would be ideal. But we can't 
// -- see the javadoc for MAX_COMPACTING_L0. 	TokenNameCOMMENT_LINE	-- see the javadoc for MAX_COMPACTING_L0. 
// 	TokenNameCOMMENT_LINE	 
// LevelDB's way around this is to simply block writes if L0 compaction falls behind. 	TokenNameCOMMENT_LINE	LevelDB's way around this is to simply block writes if L0 compaction falls behind. 
// We don't have that luxury. 	TokenNameCOMMENT_LINE	We don't have that luxury. 
// 	TokenNameCOMMENT_LINE	 
// So instead, we force compacting higher levels first. This may not minimize the number 	TokenNameCOMMENT_LINE	So instead, we force compacting higher levels first. This may not minimize the number 
// of reads done as quickly in the short term, but it minimizes the i/o needed to compact 	TokenNameCOMMENT_LINE	of reads done as quickly in the short term, but it minimizes the i/o needed to compact 
// optimially which gives us a long term win. 	TokenNameCOMMENT_LINE	optimially which gives us a long term win. 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
generations	TokenNameIdentifier	 generations
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
=	TokenNameEQUAL	
generations	TokenNameIdentifier	 generations
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sstables	TokenNameIdentifier	 sstables
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
// mostly this just avoids polluting the debug log with zero scores 	TokenNameCOMMENT_LINE	mostly this just avoids polluting the debug log with zero scores 
// we want to calculate score excluding compacting ones 	TokenNameCOMMENT_LINE	we want to calculate score excluding compacting ones 
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstablesInLevel	TokenNameIdentifier	 sstables In Level
=	TokenNameEQUAL	
Sets	TokenNameIdentifier	 Sets
.	TokenNameDOT	
newHashSet	TokenNameIdentifier	 new Hash Set
(	TokenNameLPAREN	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
remaining	TokenNameIdentifier	 remaining
=	TokenNameEQUAL	
Sets	TokenNameIdentifier	 Sets
.	TokenNameDOT	
difference	TokenNameIdentifier	 difference
(	TokenNameLPAREN	
sstablesInLevel	TokenNameIdentifier	 sstables In Level
,	TokenNameCOMMA	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
getDataTracker	TokenNameIdentifier	 get Data Tracker
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getCompacting	TokenNameIdentifier	 get Compacting
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
score	TokenNameIdentifier	 score
=	TokenNameEQUAL	
(	TokenNameLPAREN	
double	TokenNamedouble	
)	TokenNameRPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
.	TokenNameDOT	
getTotalBytes	TokenNameIdentifier	 get Total Bytes
(	TokenNameLPAREN	
remaining	TokenNameIdentifier	 remaining
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
(	TokenNameLPAREN	
double	TokenNamedouble	
)	TokenNameRPAREN	
maxBytesForLevel	TokenNameIdentifier	 max Bytes For Level
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Compaction score for level {} is {}"	TokenNameStringLiteral	Compaction score for level {} is {}
,	TokenNameCOMMA	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
score	TokenNameIdentifier	 score
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// L0 gets a special case that if we don't have anything more important to do, 	TokenNameCOMMENT_LINE	L0 gets a special case that if we don't have anything more important to do, 
// we'll go ahead and compact if we have more than one sstable 	TokenNameCOMMENT_LINE	we'll go ahead and compact if we have more than one sstable 
if	TokenNameif	
(	TokenNameLPAREN	
score	TokenNameIdentifier	 score
>	TokenNameGREATER	
1.001	TokenNameDoubleLiteral	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
sstables	TokenNameIdentifier	 sstables
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
candidates	TokenNameIdentifier	 candidates
=	TokenNameEQUAL	
getCandidatesFor	TokenNameIdentifier	 get Candidates For
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Compaction candidates for L{} are {}"	TokenNameStringLiteral	Compaction candidates for L{} are {}
,	TokenNameCOMMA	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
candidates	TokenNameIdentifier	 candidates
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
candidates	TokenNameIdentifier	 candidates
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
candidates	TokenNameIdentifier	 candidates
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
emptyList	TokenNameIdentifier	 empty List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getLevelSize	TokenNameIdentifier	 get Level Size
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
generations	TokenNameIdentifier	 generations
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
i	TokenNameIdentifier	 i
?	TokenNameQUESTION	
generations	TokenNameIdentifier	 generations
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getAllLevelSize	TokenNameIdentifier	 get All Level Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
counts	TokenNameIdentifier	 counts
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
generations	TokenNameIdentifier	 generations
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
counts	TokenNameIdentifier	 counts
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
counts	TokenNameIdentifier	 counts
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
generations	TokenNameIdentifier	 generations
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
counts	TokenNameIdentifier	 counts
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
logDistribution	TokenNameIdentifier	 log Distribution
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
generations	TokenNameIdentifier	 generations
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
generations	TokenNameIdentifier	 generations
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"L{} contains {} SSTables ({} bytes) in {}"	TokenNameStringLiteral	L{} contains {} SSTables ({} bytes) in {}
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
generations	TokenNameIdentifier	 generations
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
SSTableReader	TokenNameIdentifier	 SS Table Reader
.	TokenNameDOT	
getTotalBytes	TokenNameIdentifier	 get Total Bytes
(	TokenNameLPAREN	
generations	TokenNameIdentifier	 generations
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
this	TokenNamethis	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
int	TokenNameint	
levelOf	TokenNameIdentifier	 level Of
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
level	TokenNameIdentifier	 level
=	TokenNameEQUAL	
sstableGenerations	TokenNameIdentifier	 sstable Generations
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
level	TokenNameIdentifier	 level
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
level	TokenNameIdentifier	 level
.	TokenNameDOT	
intValue	TokenNameIdentifier	 int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
level	TokenNameIdentifier	 level
=	TokenNameEQUAL	
levelOf	TokenNameIdentifier	 level Of
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
level	TokenNameIdentifier	 level
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
reader	TokenNameIdentifier	 reader
+	TokenNamePLUS	
" not present in manifest"	TokenNameStringLiteral	 not present in manifest
;	TokenNameSEMICOLON	
generations	TokenNameIdentifier	 generations
[	TokenNameLBRACKET	
level	TokenNameIdentifier	 level
]	TokenNameRBRACKET	
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sstableGenerations	TokenNameIdentifier	 sstable Generations
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
level	TokenNameIdentifier	 level
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
,	TokenNameCOMMA	
int	TokenNameint	
level	TokenNameIdentifier	 level
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
level	TokenNameIdentifier	 level
<	TokenNameLESS	
generations	TokenNameIdentifier	 generations
.	TokenNameDOT	
length	TokenNameIdentifier	 length
:	TokenNameCOLON	
"Invalid level "	TokenNameStringLiteral	Invalid level 
+	TokenNamePLUS	
level	TokenNameIdentifier	 level
+	TokenNamePLUS	
" out of "	TokenNameStringLiteral	 out of 
+	TokenNamePLUS	
(	TokenNameLPAREN	
generations	TokenNameIdentifier	 generations
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
generations	TokenNameIdentifier	 generations
[	TokenNameLBRACKET	
level	TokenNameIdentifier	 level
]	TokenNameRBRACKET	
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sstableGenerations	TokenNameIdentifier	 sstable Generations
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
level	TokenNameIdentifier	 level
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
overlapping	TokenNameIdentifier	 overlapping
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
candidates	TokenNameIdentifier	 candidates
,	TokenNameCOMMA	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
others	TokenNameIdentifier	 others
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
!	TokenNameNOT	
candidates	TokenNameIdentifier	 candidates
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* * Picking each sstable from others that overlap one of the sstable of candidates is not enough * because you could have the following situation: * candidates = [ s1(a, c), s2(m, z) ] * others = [ s3(e, g) ] * In that case, s2 overlaps none of s1 or s2, but if we compact s1 with s2, the resulting sstable will * overlap s3, so we must return s3. * * Thus, the correct approach is to pick sstables overlapping anything between the first key in all * the candidate sstables, and the last. */	TokenNameCOMMENT_BLOCK	 Picking each sstable from others that overlap one of the sstable of candidates is not enough because you could have the following situation: candidates = [ s1(a, c), s2(m, z) ] others = [ s3(e, g) ] In that case, s2 overlaps none of s1 or s2, but if we compact s1 with s2, the resulting sstable will overlap s3, so we must return s3. * Thus, the correct approach is to pick sstables overlapping anything between the first key in all the candidate sstables, and the last. 
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
candidates	TokenNameIdentifier	 candidates
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
=	TokenNameEQUAL	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Token	TokenNameIdentifier	 Token
first	TokenNameIdentifier	 first
=	TokenNameEQUAL	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
first	TokenNameIdentifier	 first
.	TokenNameDOT	
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
Token	TokenNameIdentifier	 Token
last	TokenNameIdentifier	 last
=	TokenNameEQUAL	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
last	TokenNameIdentifier	 last
.	TokenNameDOT	
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sstable	TokenNameIdentifier	 sstable
=	TokenNameEQUAL	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
first	TokenNameIdentifier	 first
=	TokenNameEQUAL	
first	TokenNameIdentifier	 first
.	TokenNameDOT	
compareTo	TokenNameIdentifier	 compare To
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
first	TokenNameIdentifier	 first
.	TokenNameDOT	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
first	TokenNameIdentifier	 first
:	TokenNameCOLON	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
first	TokenNameIdentifier	 first
.	TokenNameDOT	
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
last	TokenNameIdentifier	 last
=	TokenNameEQUAL	
last	TokenNameIdentifier	 last
.	TokenNameDOT	
compareTo	TokenNameIdentifier	 compare To
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
last	TokenNameIdentifier	 last
.	TokenNameDOT	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
last	TokenNameIdentifier	 last
:	TokenNameCOLON	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
last	TokenNameIdentifier	 last
.	TokenNameDOT	
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
overlapping	TokenNameIdentifier	 overlapping
(	TokenNameLPAREN	
first	TokenNameIdentifier	 first
,	TokenNameCOMMA	
last	TokenNameIdentifier	 last
,	TokenNameCOMMA	
others	TokenNameIdentifier	 others
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
VisibleForTesting	TokenNameIdentifier	 Visible For Testing
static	TokenNamestatic	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
overlapping	TokenNameIdentifier	 overlapping
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
,	TokenNameCOMMA	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
others	TokenNameIdentifier	 others
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
overlapping	TokenNameIdentifier	 overlapping
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
first	TokenNameIdentifier	 first
.	TokenNameDOT	
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
last	TokenNameIdentifier	 last
.	TokenNameDOT	
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
others	TokenNameIdentifier	 others
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @return sstables from @param sstables that contain keys between @param start and @param end, inclusive. */	TokenNameCOMMENT_JAVADOC	 @return sstables from @param sstables that contain keys between @param start and @param end, inclusive. 
private	TokenNameprivate	
static	TokenNamestatic	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
overlapping	TokenNameIdentifier	 overlapping
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
start	TokenNameIdentifier	 start
,	TokenNameCOMMA	
Token	TokenNameIdentifier	 Token
end	TokenNameIdentifier	 end
,	TokenNameCOMMA	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
start	TokenNameIdentifier	 start
.	TokenNameDOT	
compareTo	TokenNameIdentifier	 compare To
(	TokenNameLPAREN	
end	TokenNameIdentifier	 end
)	TokenNameRPAREN	
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
overlapped	TokenNameIdentifier	 overlapped
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Bounds	TokenNameIdentifier	 Bounds
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
promotedBounds	TokenNameIdentifier	 promoted Bounds
=	TokenNameEQUAL	
new	TokenNamenew	
Bounds	TokenNameIdentifier	 Bounds
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
(	TokenNameLPAREN	
start	TokenNameIdentifier	 start
,	TokenNameCOMMA	
end	TokenNameIdentifier	 end
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
candidate	TokenNameIdentifier	 candidate
:	TokenNameCOLON	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Bounds	TokenNameIdentifier	 Bounds
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
candidateBounds	TokenNameIdentifier	 candidate Bounds
=	TokenNameEQUAL	
new	TokenNamenew	
Bounds	TokenNameIdentifier	 Bounds
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
(	TokenNameLPAREN	
candidate	TokenNameIdentifier	 candidate
.	TokenNameDOT	
first	TokenNameIdentifier	 first
.	TokenNameDOT	
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
candidate	TokenNameIdentifier	 candidate
.	TokenNameDOT	
last	TokenNameIdentifier	 last
.	TokenNameDOT	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
candidateBounds	TokenNameIdentifier	 candidate Bounds
.	TokenNameDOT	
intersects	TokenNameIdentifier	 intersects
(	TokenNameLPAREN	
promotedBounds	TokenNameIdentifier	 promoted Bounds
)	TokenNameRPAREN	
)	TokenNameRPAREN	
overlapped	TokenNameIdentifier	 overlapped
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
candidate	TokenNameIdentifier	 candidate
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
overlapped	TokenNameIdentifier	 overlapped
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Predicate	TokenNameIdentifier	 Predicate
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
suspectP	TokenNameIdentifier	 suspect P
=	TokenNameEQUAL	
new	TokenNamenew	
Predicate	TokenNameIdentifier	 Predicate
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
apply	TokenNameIdentifier	 apply
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
candidate	TokenNameIdentifier	 candidate
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
candidate	TokenNameIdentifier	 candidate
.	TokenNameDOT	
isMarkedSuspect	TokenNameIdentifier	 is Marked Suspect
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** * @return highest-priority sstables to compact for the given level. * If no compactions are possible (because of concurrent compactions or because some sstables are blacklisted * for prior failure), will return an empty list. Never returns null. */	TokenNameCOMMENT_JAVADOC	 @return highest-priority sstables to compact for the given level. If no compactions are possible (because of concurrent compactions or because some sstables are blacklisted for prior failure), will return an empty list. Never returns null. 
private	TokenNameprivate	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
getCandidatesFor	TokenNameIdentifier	 get Candidates For
(	TokenNameLPAREN	
int	TokenNameint	
level	TokenNameIdentifier	 level
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
!	TokenNameNOT	
generations	TokenNameIdentifier	 generations
[	TokenNameLBRACKET	
level	TokenNameIdentifier	 level
]	TokenNameRBRACKET	
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Choosing candidates for L{}"	TokenNameStringLiteral	Choosing candidates for L{}
,	TokenNameCOMMA	
level	TokenNameIdentifier	 level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
compacting	TokenNameIdentifier	 compacting
=	TokenNameEQUAL	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
getDataTracker	TokenNameIdentifier	 get Data Tracker
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getCompacting	TokenNameIdentifier	 get Compacting
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
level	TokenNameIdentifier	 level
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// L0 is the dumping ground for new sstables which thus may overlap each other. 	TokenNameCOMMENT_LINE	L0 is the dumping ground for new sstables which thus may overlap each other. 
// 	TokenNameCOMMENT_LINE	 
// We treat L0 compactions specially: 	TokenNameCOMMENT_LINE	We treat L0 compactions specially: 
// 1a. add sstables to the candidate set until we have at least maxSSTableSizeInMB 	TokenNameCOMMENT_LINE	1a. add sstables to the candidate set until we have at least maxSSTableSizeInMB 
// 1b. prefer choosing older sstables as candidates, to newer ones 	TokenNameCOMMENT_LINE	1b. prefer choosing older sstables as candidates, to newer ones 
// 1c. any L0 sstables that overlap a candidate, will also become candidates 	TokenNameCOMMENT_LINE	1c. any L0 sstables that overlap a candidate, will also become candidates 
// 2. At most MAX_COMPACTING_L0 sstables from L0 will be compacted at once 	TokenNameCOMMENT_LINE	2. At most MAX_COMPACTING_L0 sstables from L0 will be compacted at once 
// 3. If total candidate size is less than maxSSTableSizeInMB, we won't bother compacting with L1, 	TokenNameCOMMENT_LINE	3. If total candidate size is less than maxSSTableSizeInMB, we won't bother compacting with L1, 
// and the result of the compaction will stay in L0 instead of being promoted (see promote()) 	TokenNameCOMMENT_LINE	and the result of the compaction will stay in L0 instead of being promoted (see promote()) 
// 	TokenNameCOMMENT_LINE	 
// Note that we ignore suspect-ness of L1 sstables here, since if an L1 sstable is suspect we're 	TokenNameCOMMENT_LINE	Note that we ignore suspect-ness of L1 sstables here, since if an L1 sstable is suspect we're 
// basically screwed, since we expect all or most L0 sstables to overlap with each L1 sstable. 	TokenNameCOMMENT_LINE	basically screwed, since we expect all or most L0 sstables to overlap with each L1 sstable. 
// So if an L1 sstable is suspect we can't do much besides try anyway and hope for the best. 	TokenNameCOMMENT_LINE	So if an L1 sstable is suspect we can't do much besides try anyway and hope for the best. 
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
candidates	TokenNameIdentifier	 candidates
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
remaining	TokenNameIdentifier	 remaining
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Iterables	TokenNameIdentifier	 Iterables
.	TokenNameDOT	
addAll	TokenNameIdentifier	 add All
(	TokenNameLPAREN	
remaining	TokenNameIdentifier	 remaining
,	TokenNameCOMMA	
Iterables	TokenNameIdentifier	 Iterables
.	TokenNameDOT	
filter	TokenNameIdentifier	 filter
(	TokenNameLPAREN	
generations	TokenNameIdentifier	 generations
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
Predicates	TokenNameIdentifier	 Predicates
.	TokenNameDOT	
not	TokenNameIdentifier	 not
(	TokenNameLPAREN	
suspectP	TokenNameIdentifier	 suspect P
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
:	TokenNameCOLON	
ageSortedSSTables	TokenNameIdentifier	 age Sorted SS Tables
(	TokenNameLPAREN	
remaining	TokenNameIdentifier	 remaining
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
candidates	TokenNameIdentifier	 candidates
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
newCandidate	TokenNameIdentifier	 new Candidate
:	TokenNameCOLON	
Sets	TokenNameIdentifier	 Sets
.	TokenNameDOT	
union	TokenNameIdentifier	 union
(	TokenNameLPAREN	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
singleton	TokenNameIdentifier	 singleton
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
,	TokenNameCOMMA	
overlapping	TokenNameIdentifier	 overlapping
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
,	TokenNameCOMMA	
remaining	TokenNameIdentifier	 remaining
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
compacting	TokenNameIdentifier	 compacting
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
newCandidate	TokenNameIdentifier	 new Candidate
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
candidates	TokenNameIdentifier	 candidates
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
newCandidate	TokenNameIdentifier	 new Candidate
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
remaining	TokenNameIdentifier	 remaining
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
newCandidate	TokenNameIdentifier	 new Candidate
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
candidates	TokenNameIdentifier	 candidates
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
MAX_COMPACTING_L0	TokenNameIdentifier	 MAX  COMPACTING  L0
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// limit to only the MAX_COMPACTING_L0 oldest candidates 	TokenNameCOMMENT_LINE	limit to only the MAX_COMPACTING_L0 oldest candidates 
candidates	TokenNameIdentifier	 candidates
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
(	TokenNameLPAREN	
ageSortedSSTables	TokenNameIdentifier	 age Sorted SS Tables
(	TokenNameLPAREN	
candidates	TokenNameIdentifier	 candidates
)	TokenNameRPAREN	
.	TokenNameDOT	
subList	TokenNameIdentifier	 sub List
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
MAX_COMPACTING_L0	TokenNameIdentifier	 MAX  COMPACTING  L0
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// leave everything in L0 if we didn't end up with a full sstable's worth of data 	TokenNameCOMMENT_LINE	leave everything in L0 if we didn't end up with a full sstable's worth of data 
if	TokenNameif	
(	TokenNameLPAREN	
SSTable	TokenNameIdentifier	 SS Table
.	TokenNameDOT	
getTotalBytes	TokenNameIdentifier	 get Total Bytes
(	TokenNameLPAREN	
candidates	TokenNameIdentifier	 candidates
)	TokenNameRPAREN	
>	TokenNameGREATER	
maxSSTableSizeInBytes	TokenNameIdentifier	 max SS Table Size In Bytes
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// add sstables from L1 that overlap candidates 	TokenNameCOMMENT_LINE	add sstables from L1 that overlap candidates 
// if the overlapping ones are already busy in a compaction, leave it out. 	TokenNameCOMMENT_LINE	if the overlapping ones are already busy in a compaction, leave it out. 
// TODO try to find a set of L0 sstables that only overlaps with non-busy L1 sstables 	TokenNameCOMMENT_LINE	TODO try to find a set of L0 sstables that only overlaps with non-busy L1 sstables 
candidates	TokenNameIdentifier	 candidates
=	TokenNameEQUAL	
Sets	TokenNameIdentifier	 Sets
.	TokenNameDOT	
union	TokenNameIdentifier	 union
(	TokenNameLPAREN	
candidates	TokenNameIdentifier	 candidates
,	TokenNameCOMMA	
overlapping	TokenNameIdentifier	 overlapping
(	TokenNameLPAREN	
candidates	TokenNameIdentifier	 candidates
,	TokenNameCOMMA	
generations	TokenNameIdentifier	 generations
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// check overlap with L0 compacting sstables to make sure we are not generating overlap in L1. 	TokenNameCOMMENT_LINE	check overlap with L0 compacting sstables to make sure we are not generating overlap in L1. 
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
compactingL0	TokenNameIdentifier	 compacting L0
=	TokenNameEQUAL	
Iterables	TokenNameIdentifier	 Iterables
.	TokenNameDOT	
filter	TokenNameIdentifier	 filter
(	TokenNameLPAREN	
generations	TokenNameIdentifier	 generations
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
Predicates	TokenNameIdentifier	 Predicates
.	TokenNameDOT	
in	TokenNameIdentifier	 in
(	TokenNameLPAREN	
compacting	TokenNameIdentifier	 compacting
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
Sets	TokenNameIdentifier	 Sets
.	TokenNameDOT	
intersection	TokenNameIdentifier	 intersection
(	TokenNameLPAREN	
candidates	TokenNameIdentifier	 candidates
,	TokenNameCOMMA	
compacting	TokenNameIdentifier	 compacting
)	TokenNameRPAREN	
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
overlapping	TokenNameIdentifier	 overlapping
(	TokenNameLPAREN	
candidates	TokenNameIdentifier	 candidates
,	TokenNameCOMMA	
compactingL0	TokenNameIdentifier	 compacting L0
)	TokenNameRPAREN	
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
emptyList	TokenNameIdentifier	 empty List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
candidates	TokenNameIdentifier	 candidates
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
candidates	TokenNameIdentifier	 candidates
:	TokenNameCOLON	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
emptyList	TokenNameIdentifier	 empty List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// for non-L0 compactions, pick up where we left off last time 	TokenNameCOMMENT_LINE	for non-L0 compactions, pick up where we left off last time 
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
generations	TokenNameIdentifier	 generations
[	TokenNameLBRACKET	
level	TokenNameIdentifier	 level
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
SSTable	TokenNameIdentifier	 SS Table
.	TokenNameDOT	
sstableComparator	TokenNameIdentifier	 sstable Comparator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
start	TokenNameIdentifier	 start
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// handles case where the prior compaction touched the very last range 	TokenNameCOMMENT_LINE	handles case where the prior compaction touched the very last range 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
generations	TokenNameIdentifier	 generations
[	TokenNameLBRACKET	
level	TokenNameIdentifier	 level
]	TokenNameRBRACKET	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
=	TokenNameEQUAL	
generations	TokenNameIdentifier	 generations
[	TokenNameLBRACKET	
level	TokenNameIdentifier	 level
]	TokenNameRBRACKET	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
first	TokenNameIdentifier	 first
.	TokenNameDOT	
compareTo	TokenNameIdentifier	 compare To
(	TokenNameLPAREN	
lastCompactedKeys	TokenNameIdentifier	 last Compacted Keys
[	TokenNameLBRACKET	
level	TokenNameIdentifier	 level
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
start	TokenNameIdentifier	 start
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// look for a non-suspect table to compact with, starting with where we left off last time, 	TokenNameCOMMENT_LINE	look for a non-suspect table to compact with, starting with where we left off last time, 
// and wrapping back to the beginning of the generation if necessary 	TokenNameCOMMENT_LINE	and wrapping back to the beginning of the generation if necessary 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
generations	TokenNameIdentifier	 generations
[	TokenNameLBRACKET	
level	TokenNameIdentifier	 level
]	TokenNameRBRACKET	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
=	TokenNameEQUAL	
generations	TokenNameIdentifier	 generations
[	TokenNameLBRACKET	
level	TokenNameIdentifier	 level
]	TokenNameRBRACKET	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
(	TokenNameLPAREN	
start	TokenNameIdentifier	 start
+	TokenNamePLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
%	TokenNameREMAINDER	
generations	TokenNameIdentifier	 generations
[	TokenNameLBRACKET	
level	TokenNameIdentifier	 level
]	TokenNameRBRACKET	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
candidates	TokenNameIdentifier	 candidates
=	TokenNameEQUAL	
Sets	TokenNameIdentifier	 Sets
.	TokenNameDOT	
union	TokenNameIdentifier	 union
(	TokenNameLPAREN	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
singleton	TokenNameIdentifier	 singleton
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
,	TokenNameCOMMA	
overlapping	TokenNameIdentifier	 overlapping
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
,	TokenNameCOMMA	
generations	TokenNameIdentifier	 generations
[	TokenNameLBRACKET	
level	TokenNameIdentifier	 level
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
Iterables	TokenNameIdentifier	 Iterables
.	TokenNameDOT	
any	TokenNameIdentifier	 any
(	TokenNameLPAREN	
candidates	TokenNameIdentifier	 candidates
,	TokenNameCOMMA	
suspectP	TokenNameIdentifier	 suspect P
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
Sets	TokenNameIdentifier	 Sets
.	TokenNameDOT	
intersection	TokenNameIdentifier	 intersection
(	TokenNameLPAREN	
candidates	TokenNameIdentifier	 candidates
,	TokenNameCOMMA	
compacting	TokenNameIdentifier	 compacting
)	TokenNameRPAREN	
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
candidates	TokenNameIdentifier	 candidates
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// all the sstables were suspect or overlapped with something suspect 	TokenNameCOMMENT_LINE	all the sstables were suspect or overlapped with something suspect 
return	TokenNamereturn	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
emptyList	TokenNameIdentifier	 empty List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
ageSortedSSTables	TokenNameIdentifier	 age Sorted SS Tables
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
candidates	TokenNameIdentifier	 candidates
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
ageSortedCandidates	TokenNameIdentifier	 age Sorted Candidates
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
(	TokenNameLPAREN	
candidates	TokenNameIdentifier	 candidates
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
ageSortedCandidates	TokenNameIdentifier	 age Sorted Candidates
,	TokenNameCOMMA	
SSTable	TokenNameIdentifier	 SS Table
.	TokenNameDOT	
maxTimestampComparator	TokenNameIdentifier	 max Timestamp Comparator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
ageSortedCandidates	TokenNameIdentifier	 age Sorted Candidates
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
File	TokenNameIdentifier	 File
tryGetManifest	TokenNameIdentifier	 try Get Manifest
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
directories	TokenNameIdentifier	 directories
.	TokenNameDOT	
tryGetLeveledManifest	TokenNameIdentifier	 try Get Leveled Manifest
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
serialize	TokenNameIdentifier	 serialize
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
manifestFile	TokenNameIdentifier	 manifest File
=	TokenNameEQUAL	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
directories	TokenNameIdentifier	 directories
.	TokenNameDOT	
getOrCreateLeveledManifest	TokenNameIdentifier	 get Or Create Leveled Manifest
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
oldFile	TokenNameIdentifier	 old File
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
manifestFile	TokenNameIdentifier	 manifest File
.	TokenNameDOT	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
EXTENSION	TokenNameIdentifier	 EXTENSION
,	TokenNameCOMMA	
"-old.json"	TokenNameStringLiteral	-old.json
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
tmpFile	TokenNameIdentifier	 tmp File
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
manifestFile	TokenNameIdentifier	 manifest File
.	TokenNameDOT	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
EXTENSION	TokenNameIdentifier	 EXTENSION
,	TokenNameCOMMA	
"-tmp.json"	TokenNameStringLiteral	-tmp.json
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
JsonFactory	TokenNameIdentifier	 Json Factory
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
new	TokenNamenew	
JsonFactory	TokenNameIdentifier	 Json Factory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
JsonGenerator	TokenNameIdentifier	 Json Generator
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
f	TokenNameIdentifier	 f
.	TokenNameDOT	
createJsonGenerator	TokenNameIdentifier	 create Json Generator
(	TokenNameLPAREN	
tmpFile	TokenNameIdentifier	 tmp File
,	TokenNameCOMMA	
JsonEncoding	TokenNameIdentifier	 Json Encoding
.	TokenNameDOT	
UTF8	TokenNameIdentifier	 UT F8
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
g	TokenNameIdentifier	 g
.	TokenNameDOT	
useDefaultPrettyPrinter	TokenNameIdentifier	 use Default Pretty Printer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
g	TokenNameIdentifier	 g
.	TokenNameDOT	
writeStartObject	TokenNameIdentifier	 write Start Object
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
g	TokenNameIdentifier	 g
.	TokenNameDOT	
writeArrayFieldStart	TokenNameIdentifier	 write Array Field Start
(	TokenNameLPAREN	
"generations"	TokenNameStringLiteral	generations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
level	TokenNameIdentifier	 level
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
level	TokenNameIdentifier	 level
<	TokenNameLESS	
generations	TokenNameIdentifier	 generations
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
level	TokenNameIdentifier	 level
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
.	TokenNameDOT	
writeStartObject	TokenNameIdentifier	 write Start Object
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
g	TokenNameIdentifier	 g
.	TokenNameDOT	
writeNumberField	TokenNameIdentifier	 write Number Field
(	TokenNameLPAREN	
"generation"	TokenNameStringLiteral	generation
,	TokenNameCOMMA	
level	TokenNameIdentifier	 level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
g	TokenNameIdentifier	 g
.	TokenNameDOT	
writeArrayFieldStart	TokenNameIdentifier	 write Array Field Start
(	TokenNameLPAREN	
"members"	TokenNameStringLiteral	members
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
ssTableReader	TokenNameIdentifier	 ss Table Reader
:	TokenNameCOLON	
generations	TokenNameIdentifier	 generations
[	TokenNameLBRACKET	
level	TokenNameIdentifier	 level
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
g	TokenNameIdentifier	 g
.	TokenNameDOT	
writeNumber	TokenNameIdentifier	 write Number
(	TokenNameLPAREN	
ssTableReader	TokenNameIdentifier	 ss Table Reader
.	TokenNameDOT	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
generation	TokenNameIdentifier	 generation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
g	TokenNameIdentifier	 g
.	TokenNameDOT	
writeEndArray	TokenNameIdentifier	 write End Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// members 	TokenNameCOMMENT_LINE	members 
g	TokenNameIdentifier	 g
.	TokenNameDOT	
writeEndObject	TokenNameIdentifier	 write End Object
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// generation 	TokenNameCOMMENT_LINE	generation 
}	TokenNameRBRACE	
g	TokenNameIdentifier	 g
.	TokenNameDOT	
writeEndArray	TokenNameIdentifier	 write End Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// for field generations 	TokenNameCOMMENT_LINE	for field generations 
g	TokenNameIdentifier	 g
.	TokenNameDOT	
writeEndObject	TokenNameIdentifier	 write End Object
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// write global object 	TokenNameCOMMENT_LINE	write global object 
g	TokenNameIdentifier	 g
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
FSWriteError	TokenNameIdentifier	 FS Write Error
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
,	TokenNameCOMMA	
tmpFile	TokenNameIdentifier	 tmp File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
oldFile	TokenNameIdentifier	 old File
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
manifestFile	TokenNameIdentifier	 manifest File
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
deleteWithConfirm	TokenNameIdentifier	 delete With Confirm
(	TokenNameLPAREN	
oldFile	TokenNameIdentifier	 old File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
manifestFile	TokenNameIdentifier	 manifest File
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
renameWithConfirm	TokenNameIdentifier	 rename With Confirm
(	TokenNameLPAREN	
manifestFile	TokenNameIdentifier	 manifest File
,	TokenNameCOMMA	
oldFile	TokenNameIdentifier	 old File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
tmpFile	TokenNameIdentifier	 tmp File
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
renameWithConfirm	TokenNameIdentifier	 rename With Confirm
(	TokenNameLPAREN	
tmpFile	TokenNameIdentifier	 tmp File
,	TokenNameCOMMA	
manifestFile	TokenNameIdentifier	 manifest File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Saved manifest {}"	TokenNameStringLiteral	Saved manifest {}
,	TokenNameCOMMA	
manifestFile	TokenNameIdentifier	 manifest File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
String	TokenNameIdentifier	 String
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
"Manifest@"	TokenNameStringLiteral	Manifest@
+	TokenNamePLUS	
hashCode	TokenNameIdentifier	 hash Code
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getLevelCount	TokenNameIdentifier	 get Level Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
generations	TokenNameIdentifier	 generations
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
generations	TokenNameIdentifier	 generations
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
SortedSet	TokenNameIdentifier	 Sorted Set
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
getLevelSorted	TokenNameIdentifier	 get Level Sorted
(	TokenNameLPAREN	
int	TokenNameint	
level	TokenNameIdentifier	 level
,	TokenNameCOMMA	
Comparator	TokenNameIdentifier	 Comparator
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
comparator	TokenNameIdentifier	 comparator
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
ImmutableSortedSet	TokenNameIdentifier	 Immutable Sorted Set
.	TokenNameDOT	
copyOf	TokenNameIdentifier	 copy Of
(	TokenNameLPAREN	
comparator	TokenNameIdentifier	 comparator
,	TokenNameCOMMA	
generations	TokenNameIdentifier	 generations
[	TokenNameLBRACKET	
level	TokenNameIdentifier	 level
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
getLevel	TokenNameIdentifier	 get Level
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
generations	TokenNameIdentifier	 generations
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
int	TokenNameint	
getEstimatedTasks	TokenNameIdentifier	 get Estimated Tasks
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
tasks	TokenNameIdentifier	 tasks
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
estimated	TokenNameIdentifier	 estimated
=	TokenNameEQUAL	
new	TokenNamenew	
long	TokenNamelong	
[	TokenNameLBRACKET	
generations	TokenNameIdentifier	 generations
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
generations	TokenNameIdentifier	 generations
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
=	TokenNameEQUAL	
generations	TokenNameIdentifier	 generations
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
estimated	TokenNameIdentifier	 estimated
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
max	TokenNameIdentifier	 max
(	TokenNameLPAREN	
0L	TokenNameLongLiteral	
,	TokenNameCOMMA	
SSTableReader	TokenNameIdentifier	 SS Table Reader
.	TokenNameDOT	
getTotalBytes	TokenNameIdentifier	 get Total Bytes
(	TokenNameLPAREN	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
-	TokenNameMINUS	
maxBytesForLevel	TokenNameIdentifier	 max Bytes For Level
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
maxSSTableSizeInBytes	TokenNameIdentifier	 max SS Table Size In Bytes
;	TokenNameSEMICOLON	
tasks	TokenNameIdentifier	 tasks
+=	TokenNamePLUS_EQUAL	
estimated	TokenNameIdentifier	 estimated
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Estimating {} compactions to do for {}.{}"	TokenNameStringLiteral	Estimating {} compactions to do for {}.{}
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
estimated	TokenNameIdentifier	 estimated
)	TokenNameRPAREN	
,	TokenNameCOMMA	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
columnFamily	TokenNameIdentifier	 column Family
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
Ints	TokenNameIdentifier	 Ints
.	TokenNameDOT	
checkedCast	TokenNameIdentifier	 checked Cast
(	TokenNameLPAREN	
tasks	TokenNameIdentifier	 tasks
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
