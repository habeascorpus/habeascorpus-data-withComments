/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
util	TokenNameIdentifier	 util
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
File	TokenNameIdentifier	 File
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
FilenameFilter	TokenNameIdentifier	 Filename Filter
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
InputStream	TokenNameIdentifier	 Input Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
InputStreamReader	TokenNameIdentifier	 Input Stream Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
OutputStream	TokenNameIdentifier	 Output Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
Reader	TokenNameIdentifier	 Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
Writer	TokenNameIdentifier	 Writer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
net	TokenNameIdentifier	 net
.	TokenNameDOT	
MalformedURLException	TokenNameIdentifier	 Malformed URL Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
net	TokenNameIdentifier	 net
.	TokenNameDOT	
HttpURLConnection	TokenNameIdentifier	 Http URL Connection
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
net	TokenNameIdentifier	 net
.	TokenNameDOT	
JarURLConnection	TokenNameIdentifier	 Jar URL Connection
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
net	TokenNameIdentifier	 net
.	TokenNameDOT	
URL	TokenNameIdentifier	 URL
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
net	TokenNameIdentifier	 net
.	TokenNameDOT	
URLConnection	TokenNameIdentifier	 URL Connection
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
nio	TokenNameIdentifier	 nio
.	TokenNameDOT	
channels	TokenNameIdentifier	 channels
.	TokenNameDOT	
Channel	TokenNameIdentifier	 Channel
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
DecimalFormat	TokenNameIdentifier	 Decimal Format
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Arrays	TokenNameIdentifier	 Arrays
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Iterator	TokenNameIdentifier	 Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
List	TokenNameIdentifier	 List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Random	TokenNameIdentifier	 Random
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Stack	TokenNameIdentifier	 Stack
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
StringTokenizer	TokenNameIdentifier	 String Tokenizer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Vector	TokenNameIdentifier	 Vector
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
jar	TokenNameIdentifier	 jar
.	TokenNameDOT	
JarFile	TokenNameIdentifier	 Jar File
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
BuildException	TokenNameIdentifier	 Build Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
PathTokenizer	TokenNameIdentifier	 Path Tokenizer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
Project	TokenNameIdentifier	 Project
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
launch	TokenNameIdentifier	 launch
.	TokenNameDOT	
Locator	TokenNameIdentifier	 Locator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
taskdefs	TokenNameIdentifier	 taskdefs
.	TokenNameDOT	
condition	TokenNameIdentifier	 condition
.	TokenNameDOT	
Os	TokenNameIdentifier	 Os
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
FilterSetCollection	TokenNameIdentifier	 Filter Set Collection
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
FileResource	TokenNameIdentifier	 File Resource
;	TokenNameSEMICOLON	
/** * This class also encapsulates methods which allow Files to be * referred to using abstract path names which are translated to native * system file paths at runtime as well as copying files or setting * their last modification time. * */	TokenNameCOMMENT_JAVADOC	 This class also encapsulates methods which allow Files to be referred to using abstract path names which are translated to native system file paths at runtime as well as copying files or setting their last modification time. 
public	TokenNamepublic	
class	TokenNameclass	
FileUtils	TokenNameIdentifier	 File Utils
{	TokenNameLBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
DELETE_RETRY_SLEEP_MILLIS	TokenNameIdentifier	 DELETE  RETRY  SLEEP  MILLIS
=	TokenNameEQUAL	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
EXPAND_SPACE	TokenNameIdentifier	 EXPAND  SPACE
=	TokenNameEQUAL	
50	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
FileUtils	TokenNameIdentifier	 File Utils
PRIMARY_INSTANCE	TokenNameIdentifier	 PRIMARY  INSTANCE
=	TokenNameEQUAL	
new	TokenNamenew	
FileUtils	TokenNameIdentifier	 File Utils
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//get some non-crypto-grade randomness from various places. 	TokenNameCOMMENT_LINE	get some non-crypto-grade randomness from various places. 
private	TokenNameprivate	
static	TokenNamestatic	
Random	TokenNameIdentifier	 Random
rand	TokenNameIdentifier	 rand
=	TokenNameEQUAL	
new	TokenNamenew	
Random	TokenNameIdentifier	 Random
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
Runtime	TokenNameIdentifier	 Runtime
.	TokenNameDOT	
getRuntime	TokenNameIdentifier	 get Runtime
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
freeMemory	TokenNameIdentifier	 free Memory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
ON_NETWARE	TokenNameIdentifier	 ON  NETWARE
=	TokenNameEQUAL	
Os	TokenNameIdentifier	 Os
.	TokenNameDOT	
isFamily	TokenNameIdentifier	 is Family
(	TokenNameLPAREN	
"netware"	TokenNameStringLiteral	netware
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
ON_DOS	TokenNameIdentifier	 ON  DOS
=	TokenNameEQUAL	
Os	TokenNameIdentifier	 Os
.	TokenNameDOT	
isFamily	TokenNameIdentifier	 is Family
(	TokenNameLPAREN	
"dos"	TokenNameStringLiteral	dos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
ON_WIN9X	TokenNameIdentifier	 ON  WI N9 X
=	TokenNameEQUAL	
Os	TokenNameIdentifier	 Os
.	TokenNameDOT	
isFamily	TokenNameIdentifier	 is Family
(	TokenNameLPAREN	
"win9x"	TokenNameStringLiteral	win9x
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
ON_WINDOWS	TokenNameIdentifier	 ON  WINDOWS
=	TokenNameEQUAL	
Os	TokenNameIdentifier	 Os
.	TokenNameDOT	
isFamily	TokenNameIdentifier	 is Family
(	TokenNameLPAREN	
"windows"	TokenNameStringLiteral	windows
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
BUF_SIZE	TokenNameIdentifier	 BUF  SIZE
=	TokenNameEQUAL	
8192	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** * The granularity of timestamps under FAT. */	TokenNameCOMMENT_JAVADOC	 The granularity of timestamps under FAT. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
long	TokenNamelong	
FAT_FILE_TIMESTAMP_GRANULARITY	TokenNameIdentifier	 FAT  FILE  TIMESTAMP  GRANULARITY
=	TokenNameEQUAL	
2000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** * The granularity of timestamps under Unix. */	TokenNameCOMMENT_JAVADOC	 The granularity of timestamps under Unix. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
long	TokenNamelong	
UNIX_FILE_TIMESTAMP_GRANULARITY	TokenNameIdentifier	 UNIX  FILE  TIMESTAMP  GRANULARITY
=	TokenNameEQUAL	
1000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** * The granularity of timestamps under the NT File System. * NTFS has a granularity of 100 nanoseconds, which is less * than 1 millisecond, so we round this up to 1 millisecond. */	TokenNameCOMMENT_JAVADOC	 The granularity of timestamps under the NT File System. NTFS has a granularity of 100 nanoseconds, which is less than 1 millisecond, so we round this up to 1 millisecond. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
long	TokenNamelong	
NTFS_FILE_TIMESTAMP_GRANULARITY	TokenNameIdentifier	 NTFS  FILE  TIMESTAMP  GRANULARITY
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** * A one item cache for fromUri. * fromUri is called for each element when parseing ant build * files. It is a costly operation. This just caches the result * of the last call. */	TokenNameCOMMENT_JAVADOC	 A one item cache for fromUri. fromUri is called for each element when parseing ant build files. It is a costly operation. This just caches the result of the last call. 
private	TokenNameprivate	
Object	TokenNameIdentifier	 Object
cacheFromUriLock	TokenNameIdentifier	 cache From Uri Lock
=	TokenNameEQUAL	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
cacheFromUriRequest	TokenNameIdentifier	 cache From Uri Request
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
cacheFromUriResponse	TokenNameIdentifier	 cache From Uri Response
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** * Factory method. * * @return a new instance of FileUtils. * @deprecated since 1.7. * Use getFileUtils instead, * FileUtils do not have state. */	TokenNameCOMMENT_JAVADOC	 Factory method. * @return a new instance of FileUtils. @deprecated since 1.7. Use getFileUtils instead, FileUtils do not have state. 
public	TokenNamepublic	
static	TokenNamestatic	
FileUtils	TokenNameIdentifier	 File Utils
newFileUtils	TokenNameIdentifier	 new File Utils
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
FileUtils	TokenNameIdentifier	 File Utils
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Method to retrieve The FileUtils, which is shared by all users of this * method. * @return an instance of FileUtils. * @since Ant 1.6.3 */	TokenNameCOMMENT_JAVADOC	 Method to retrieve The FileUtils, which is shared by all users of this method. @return an instance of FileUtils. @since Ant 1.6.3 
public	TokenNamepublic	
static	TokenNamestatic	
FileUtils	TokenNameIdentifier	 File Utils
getFileUtils	TokenNameIdentifier	 get File Utils
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
PRIMARY_INSTANCE	TokenNameIdentifier	 PRIMARY  INSTANCE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Empty constructor. */	TokenNameCOMMENT_JAVADOC	 Empty constructor. 
protected	TokenNameprotected	
FileUtils	TokenNameIdentifier	 File Utils
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
/** * Get the URL for a file taking into account # characters. * * @param file the file whose URL representation is required. * @return The FileURL value. * @throws MalformedURLException if the URL representation cannot be * formed. */	TokenNameCOMMENT_JAVADOC	 Get the URL for a file taking into account # characters. * @param file the file whose URL representation is required. @return The FileURL value. @throws MalformedURLException if the URL representation cannot be formed. 
public	TokenNamepublic	
URL	TokenNameIdentifier	 URL
getFileURL	TokenNameIdentifier	 get File URL
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
throws	TokenNamethrows	
MalformedURLException	TokenNameIdentifier	 Malformed URL Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
URL	TokenNameIdentifier	 URL
(	TokenNameLPAREN	
toURI	TokenNameIdentifier	 to URI
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Convenience method to copy a file from a source to a destination. * No filtering is performed. * * @param sourceFile Name of file to copy from. * Must not be <code>null</code>. * @param destFile Name of file to copy to. * Must not be <code>null</code>. * * @throws IOException if the copying fails. */	TokenNameCOMMENT_JAVADOC	 Convenience method to copy a file from a source to a destination. No filtering is performed. * @param sourceFile Name of file to copy from. Must not be <code>null</code>. @param destFile Name of file to copy to. Must not be <code>null</code>. * @throws IOException if the copying fails. 
public	TokenNamepublic	
void	TokenNamevoid	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
sourceFile	TokenNameIdentifier	 source File
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
destFile	TokenNameIdentifier	 dest File
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
sourceFile	TokenNameIdentifier	 source File
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
destFile	TokenNameIdentifier	 dest File
)	TokenNameRPAREN	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Convenience method to copy a file from a source to a destination * specifying if token filtering must be used. * * @param sourceFile Name of file to copy from. * Must not be <code>null</code>. * @param destFile Name of file to copy to. * Must not be <code>null</code>. * @param filters the collection of filters to apply to this copy. * * @throws IOException if the copying fails. */	TokenNameCOMMENT_JAVADOC	 Convenience method to copy a file from a source to a destination specifying if token filtering must be used. * @param sourceFile Name of file to copy from. Must not be <code>null</code>. @param destFile Name of file to copy to. Must not be <code>null</code>. @param filters the collection of filters to apply to this copy. * @throws IOException if the copying fails. 
public	TokenNamepublic	
void	TokenNamevoid	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
sourceFile	TokenNameIdentifier	 source File
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
destFile	TokenNameIdentifier	 dest File
,	TokenNameCOMMA	
FilterSetCollection	TokenNameIdentifier	 Filter Set Collection
filters	TokenNameIdentifier	 filters
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
sourceFile	TokenNameIdentifier	 source File
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
destFile	TokenNameIdentifier	 dest File
)	TokenNameRPAREN	
,	TokenNameCOMMA	
filters	TokenNameIdentifier	 filters
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Convenience method to copy a file from a source to a destination specifying if token * filtering must be used and if source files may overwrite newer destination files. * * @param sourceFile Name of file to copy from. Must not be <code>null</code>. * @param destFile Name of file to copy to. Must not be <code>null</code>. * @param filters the collection of filters to apply to this copy. * @param overwrite Whether or not the destination file should be overwritten if it already * exists. * * @throws IOException if the copying fails. */	TokenNameCOMMENT_JAVADOC	 Convenience method to copy a file from a source to a destination specifying if token filtering must be used and if source files may overwrite newer destination files. * @param sourceFile Name of file to copy from. Must not be <code>null</code>. @param destFile Name of file to copy to. Must not be <code>null</code>. @param filters the collection of filters to apply to this copy. @param overwrite Whether or not the destination file should be overwritten if it already exists. * @throws IOException if the copying fails. 
public	TokenNamepublic	
void	TokenNamevoid	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
sourceFile	TokenNameIdentifier	 source File
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
destFile	TokenNameIdentifier	 dest File
,	TokenNameCOMMA	
FilterSetCollection	TokenNameIdentifier	 Filter Set Collection
filters	TokenNameIdentifier	 filters
,	TokenNameCOMMA	
boolean	TokenNameboolean	
overwrite	TokenNameIdentifier	 overwrite
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
sourceFile	TokenNameIdentifier	 source File
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
destFile	TokenNameIdentifier	 dest File
)	TokenNameRPAREN	
,	TokenNameCOMMA	
filters	TokenNameIdentifier	 filters
,	TokenNameCOMMA	
overwrite	TokenNameIdentifier	 overwrite
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Convenience method to copy a file from a source to a destination * specifying if token * filtering must be used, if source files may overwrite newer destination * files and the last * modified time of <code>destFile</code> file should be made equal to * the last modified time * of <code>sourceFile</code>. * * @param sourceFile Name of file to copy from. Must not be <code>null</code>. * @param destFile Name of file to copy to. Must not be <code>null</code>. * @param filters the collection of filters to apply to this copy. * @param overwrite Whether or not the destination file should be * overwritten if it already exists. * @param preserveLastModified Whether or not the last modified time of * the resulting file * should be set to that of the source file. * * @throws IOException if the copying fails. */	TokenNameCOMMENT_JAVADOC	 Convenience method to copy a file from a source to a destination specifying if token filtering must be used, if source files may overwrite newer destination files and the last modified time of <code>destFile</code> file should be made equal to the last modified time of <code>sourceFile</code>. * @param sourceFile Name of file to copy from. Must not be <code>null</code>. @param destFile Name of file to copy to. Must not be <code>null</code>. @param filters the collection of filters to apply to this copy. @param overwrite Whether or not the destination file should be overwritten if it already exists. @param preserveLastModified Whether or not the last modified time of the resulting file should be set to that of the source file. * @throws IOException if the copying fails. 
public	TokenNamepublic	
void	TokenNamevoid	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
sourceFile	TokenNameIdentifier	 source File
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
destFile	TokenNameIdentifier	 dest File
,	TokenNameCOMMA	
FilterSetCollection	TokenNameIdentifier	 Filter Set Collection
filters	TokenNameIdentifier	 filters
,	TokenNameCOMMA	
boolean	TokenNameboolean	
overwrite	TokenNameIdentifier	 overwrite
,	TokenNameCOMMA	
boolean	TokenNameboolean	
preserveLastModified	TokenNameIdentifier	 preserve Last Modified
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
sourceFile	TokenNameIdentifier	 source File
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
destFile	TokenNameIdentifier	 dest File
)	TokenNameRPAREN	
,	TokenNameCOMMA	
filters	TokenNameIdentifier	 filters
,	TokenNameCOMMA	
overwrite	TokenNameIdentifier	 overwrite
,	TokenNameCOMMA	
preserveLastModified	TokenNameIdentifier	 preserve Last Modified
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Convenience method to copy a file from a source to a destination specifying if token * filtering must be used, if source files may overwrite newer destination files and the last * modified time of <code>destFile</code> file should be made equal to the last modified time * of <code>sourceFile</code>. * * @param sourceFile Name of file to copy from. Must not be <code>null</code>. * @param destFile Name of file to copy to. Must not be <code>null</code>. * @param filters the collection of filters to apply to this copy. * @param overwrite Whether or not the destination file should be overwritten if it already * exists. * @param preserveLastModified Whether or not the last modified time of the resulting file * should be set to that of the source file. * @param encoding the encoding used to read and write the files. * * @throws IOException if the copying fails. * * @since Ant 1.5 */	TokenNameCOMMENT_JAVADOC	 Convenience method to copy a file from a source to a destination specifying if token filtering must be used, if source files may overwrite newer destination files and the last modified time of <code>destFile</code> file should be made equal to the last modified time of <code>sourceFile</code>. * @param sourceFile Name of file to copy from. Must not be <code>null</code>. @param destFile Name of file to copy to. Must not be <code>null</code>. @param filters the collection of filters to apply to this copy. @param overwrite Whether or not the destination file should be overwritten if it already exists. @param preserveLastModified Whether or not the last modified time of the resulting file should be set to that of the source file. @param encoding the encoding used to read and write the files. * @throws IOException if the copying fails. * @since Ant 1.5 
public	TokenNamepublic	
void	TokenNamevoid	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
sourceFile	TokenNameIdentifier	 source File
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
destFile	TokenNameIdentifier	 dest File
,	TokenNameCOMMA	
FilterSetCollection	TokenNameIdentifier	 Filter Set Collection
filters	TokenNameIdentifier	 filters
,	TokenNameCOMMA	
boolean	TokenNameboolean	
overwrite	TokenNameIdentifier	 overwrite
,	TokenNameCOMMA	
boolean	TokenNameboolean	
preserveLastModified	TokenNameIdentifier	 preserve Last Modified
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
sourceFile	TokenNameIdentifier	 source File
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
destFile	TokenNameIdentifier	 dest File
)	TokenNameRPAREN	
,	TokenNameCOMMA	
filters	TokenNameIdentifier	 filters
,	TokenNameCOMMA	
overwrite	TokenNameIdentifier	 overwrite
,	TokenNameCOMMA	
preserveLastModified	TokenNameIdentifier	 preserve Last Modified
,	TokenNameCOMMA	
encoding	TokenNameIdentifier	 encoding
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// CheckStyle:ParameterNumberCheck OFF - bc 	TokenNameCOMMENT_LINE	CheckStyle:ParameterNumberCheck OFF - bc 
/** * Convenience method to copy a file from a source to a * destination specifying if token filtering must be used, if * filter chains must be used, if source files may overwrite * newer destination files and the last modified time of * <code>destFile</code> file should be made equal * to the last modified time of <code>sourceFile</code>. * * @param sourceFile Name of file to copy from. * Must not be <code>null</code>. * @param destFile Name of file to copy to. * Must not be <code>null</code>. * @param filters the collection of filters to apply to this copy. * @param filterChains filterChains to apply during the copy. * @param overwrite Whether or not the destination file should be * overwritten if it already exists. * @param preserveLastModified Whether or not the last modified time of * the resulting file should be set to that * of the source file. * @param encoding the encoding used to read and write the files. * @param project the project instance. * * @throws IOException if the copying fails. * * @since Ant 1.5 */	TokenNameCOMMENT_JAVADOC	 Convenience method to copy a file from a source to a destination specifying if token filtering must be used, if filter chains must be used, if source files may overwrite newer destination files and the last modified time of <code>destFile</code> file should be made equal to the last modified time of <code>sourceFile</code>. * @param sourceFile Name of file to copy from. Must not be <code>null</code>. @param destFile Name of file to copy to. Must not be <code>null</code>. @param filters the collection of filters to apply to this copy. @param filterChains filterChains to apply during the copy. @param overwrite Whether or not the destination file should be overwritten if it already exists. @param preserveLastModified Whether or not the last modified time of the resulting file should be set to that of the source file. @param encoding the encoding used to read and write the files. @param project the project instance. * @throws IOException if the copying fails. * @since Ant 1.5 
public	TokenNamepublic	
void	TokenNamevoid	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
sourceFile	TokenNameIdentifier	 source File
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
destFile	TokenNameIdentifier	 dest File
,	TokenNameCOMMA	
FilterSetCollection	TokenNameIdentifier	 Filter Set Collection
filters	TokenNameIdentifier	 filters
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
filterChains	TokenNameIdentifier	 filter Chains
,	TokenNameCOMMA	
boolean	TokenNameboolean	
overwrite	TokenNameIdentifier	 overwrite
,	TokenNameCOMMA	
boolean	TokenNameboolean	
preserveLastModified	TokenNameIdentifier	 preserve Last Modified
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
project	TokenNameIdentifier	 project
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
sourceFile	TokenNameIdentifier	 source File
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
destFile	TokenNameIdentifier	 dest File
)	TokenNameRPAREN	
,	TokenNameCOMMA	
filters	TokenNameIdentifier	 filters
,	TokenNameCOMMA	
filterChains	TokenNameIdentifier	 filter Chains
,	TokenNameCOMMA	
overwrite	TokenNameIdentifier	 overwrite
,	TokenNameCOMMA	
preserveLastModified	TokenNameIdentifier	 preserve Last Modified
,	TokenNameCOMMA	
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
project	TokenNameIdentifier	 project
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Convenience method to copy a file from a source to a destination specifying if token * filtering must be used, if filter chains must be used, if source files may overwrite newer * destination files and the last modified time of <code>destFile</code> file should be made * equal to the last modified time of <code>sourceFile</code>. * * @param sourceFile Name of file to copy from. Must not be <code>null</code>. * @param destFile Name of file to copy to. Must not be <code>null</code>. * @param filters the collection of filters to apply to this copy. * @param filterChains filterChains to apply during the copy. * @param overwrite Whether or not the destination file should be overwritten if it already * exists. * @param preserveLastModified Whether or not the last modified time of the resulting file * should be set to that of the source file. * @param inputEncoding the encoding used to read the files. * @param outputEncoding the encoding used to write the files. * @param project the project instance. * * @throws IOException if the copying fails. * * @since Ant 1.6 */	TokenNameCOMMENT_JAVADOC	 Convenience method to copy a file from a source to a destination specifying if token filtering must be used, if filter chains must be used, if source files may overwrite newer destination files and the last modified time of <code>destFile</code> file should be made equal to the last modified time of <code>sourceFile</code>. * @param sourceFile Name of file to copy from. Must not be <code>null</code>. @param destFile Name of file to copy to. Must not be <code>null</code>. @param filters the collection of filters to apply to this copy. @param filterChains filterChains to apply during the copy. @param overwrite Whether or not the destination file should be overwritten if it already exists. @param preserveLastModified Whether or not the last modified time of the resulting file should be set to that of the source file. @param inputEncoding the encoding used to read the files. @param outputEncoding the encoding used to write the files. @param project the project instance. * @throws IOException if the copying fails. * @since Ant 1.6 
public	TokenNamepublic	
void	TokenNamevoid	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
sourceFile	TokenNameIdentifier	 source File
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
destFile	TokenNameIdentifier	 dest File
,	TokenNameCOMMA	
FilterSetCollection	TokenNameIdentifier	 Filter Set Collection
filters	TokenNameIdentifier	 filters
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
filterChains	TokenNameIdentifier	 filter Chains
,	TokenNameCOMMA	
boolean	TokenNameboolean	
overwrite	TokenNameIdentifier	 overwrite
,	TokenNameCOMMA	
boolean	TokenNameboolean	
preserveLastModified	TokenNameIdentifier	 preserve Last Modified
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
inputEncoding	TokenNameIdentifier	 input Encoding
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
outputEncoding	TokenNameIdentifier	 output Encoding
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
project	TokenNameIdentifier	 project
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
sourceFile	TokenNameIdentifier	 source File
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
destFile	TokenNameIdentifier	 dest File
)	TokenNameRPAREN	
,	TokenNameCOMMA	
filters	TokenNameIdentifier	 filters
,	TokenNameCOMMA	
filterChains	TokenNameIdentifier	 filter Chains
,	TokenNameCOMMA	
overwrite	TokenNameIdentifier	 overwrite
,	TokenNameCOMMA	
preserveLastModified	TokenNameIdentifier	 preserve Last Modified
,	TokenNameCOMMA	
inputEncoding	TokenNameIdentifier	 input Encoding
,	TokenNameCOMMA	
outputEncoding	TokenNameIdentifier	 output Encoding
,	TokenNameCOMMA	
project	TokenNameIdentifier	 project
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Convenience method to copy a file from a source to a destination. No filtering is performed. * * @param sourceFile the file to copy from. Must not be <code>null</code>. * @param destFile the file to copy to. Must not be <code>null</code>. * * @throws IOException if the copying fails. */	TokenNameCOMMENT_JAVADOC	 Convenience method to copy a file from a source to a destination. No filtering is performed. * @param sourceFile the file to copy from. Must not be <code>null</code>. @param destFile the file to copy to. Must not be <code>null</code>. * @throws IOException if the copying fails. 
public	TokenNamepublic	
void	TokenNamevoid	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
sourceFile	TokenNameIdentifier	 source File
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
destFile	TokenNameIdentifier	 dest File
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
sourceFile	TokenNameIdentifier	 source File
,	TokenNameCOMMA	
destFile	TokenNameIdentifier	 dest File
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Convenience method to copy a file from a source to a destination * specifying if token filtering must be used. * * @param sourceFile the file to copy from. * Must not be <code>null</code>. * @param destFile the file to copy to. * Must not be <code>null</code>. * @param filters the collection of filters to apply to this copy. * * @throws IOException if the copying fails. */	TokenNameCOMMENT_JAVADOC	 Convenience method to copy a file from a source to a destination specifying if token filtering must be used. * @param sourceFile the file to copy from. Must not be <code>null</code>. @param destFile the file to copy to. Must not be <code>null</code>. @param filters the collection of filters to apply to this copy. * @throws IOException if the copying fails. 
public	TokenNamepublic	
void	TokenNamevoid	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
sourceFile	TokenNameIdentifier	 source File
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
destFile	TokenNameIdentifier	 dest File
,	TokenNameCOMMA	
FilterSetCollection	TokenNameIdentifier	 Filter Set Collection
filters	TokenNameIdentifier	 filters
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
sourceFile	TokenNameIdentifier	 source File
,	TokenNameCOMMA	
destFile	TokenNameIdentifier	 dest File
,	TokenNameCOMMA	
filters	TokenNameIdentifier	 filters
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Convenience method to copy a file from a source to a * destination specifying if token filtering must be used and if * source files may overwrite newer destination files. * * @param sourceFile the file to copy from. * Must not be <code>null</code>. * @param destFile the file to copy to. * Must not be <code>null</code>. * @param filters the collection of filters to apply to this copy. * @param overwrite Whether or not the destination file should be * overwritten if it already exists. * * @throws IOException if the copying fails. */	TokenNameCOMMENT_JAVADOC	 Convenience method to copy a file from a source to a destination specifying if token filtering must be used and if source files may overwrite newer destination files. * @param sourceFile the file to copy from. Must not be <code>null</code>. @param destFile the file to copy to. Must not be <code>null</code>. @param filters the collection of filters to apply to this copy. @param overwrite Whether or not the destination file should be overwritten if it already exists. * @throws IOException if the copying fails. 
public	TokenNamepublic	
void	TokenNamevoid	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
sourceFile	TokenNameIdentifier	 source File
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
destFile	TokenNameIdentifier	 dest File
,	TokenNameCOMMA	
FilterSetCollection	TokenNameIdentifier	 Filter Set Collection
filters	TokenNameIdentifier	 filters
,	TokenNameCOMMA	
boolean	TokenNameboolean	
overwrite	TokenNameIdentifier	 overwrite
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
sourceFile	TokenNameIdentifier	 source File
,	TokenNameCOMMA	
destFile	TokenNameIdentifier	 dest File
,	TokenNameCOMMA	
filters	TokenNameIdentifier	 filters
,	TokenNameCOMMA	
overwrite	TokenNameIdentifier	 overwrite
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Convenience method to copy a file from a source to a * destination specifying if token filtering must be used, if * source files may overwrite newer destination files and the * last modified time of <code>destFile</code> file should be made equal * to the last modified time of <code>sourceFile</code>. * * @param sourceFile the file to copy from. * Must not be <code>null</code>. * @param destFile the file to copy to. * Must not be <code>null</code>. * @param filters the collection of filters to apply to this copy. * @param overwrite Whether or not the destination file should be * overwritten if it already exists. * @param preserveLastModified Whether or not the last modified time of * the resulting file should be set to that * of the source file. * * @throws IOException if the copying fails. */	TokenNameCOMMENT_JAVADOC	 Convenience method to copy a file from a source to a destination specifying if token filtering must be used, if source files may overwrite newer destination files and the last modified time of <code>destFile</code> file should be made equal to the last modified time of <code>sourceFile</code>. * @param sourceFile the file to copy from. Must not be <code>null</code>. @param destFile the file to copy to. Must not be <code>null</code>. @param filters the collection of filters to apply to this copy. @param overwrite Whether or not the destination file should be overwritten if it already exists. @param preserveLastModified Whether or not the last modified time of the resulting file should be set to that of the source file. * @throws IOException if the copying fails. 
public	TokenNamepublic	
void	TokenNamevoid	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
sourceFile	TokenNameIdentifier	 source File
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
destFile	TokenNameIdentifier	 dest File
,	TokenNameCOMMA	
FilterSetCollection	TokenNameIdentifier	 Filter Set Collection
filters	TokenNameIdentifier	 filters
,	TokenNameCOMMA	
boolean	TokenNameboolean	
overwrite	TokenNameIdentifier	 overwrite
,	TokenNameCOMMA	
boolean	TokenNameboolean	
preserveLastModified	TokenNameIdentifier	 preserve Last Modified
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
sourceFile	TokenNameIdentifier	 source File
,	TokenNameCOMMA	
destFile	TokenNameIdentifier	 dest File
,	TokenNameCOMMA	
filters	TokenNameIdentifier	 filters
,	TokenNameCOMMA	
overwrite	TokenNameIdentifier	 overwrite
,	TokenNameCOMMA	
preserveLastModified	TokenNameIdentifier	 preserve Last Modified
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Convenience method to copy a file from a source to a destination specifying if token * filtering must be used, if source files may overwrite newer destination files, the last * modified time of <code>destFile</code> file should be made equal to the last modified time * of <code>sourceFile</code> and which character encoding to assume. * * @param sourceFile the file to copy from. Must not be <code>null</code>. * @param destFile the file to copy to. Must not be <code>null</code>. * @param filters the collection of filters to apply to this copy. * @param overwrite Whether or not the destination file should be overwritten if it already * exists. * @param preserveLastModified Whether or not the last modified time of the resulting file * should be set to that of the source file. * @param encoding the encoding used to read and write the files. * * @throws IOException if the copying fails. * * @since Ant 1.5 */	TokenNameCOMMENT_JAVADOC	 Convenience method to copy a file from a source to a destination specifying if token filtering must be used, if source files may overwrite newer destination files, the last modified time of <code>destFile</code> file should be made equal to the last modified time of <code>sourceFile</code> and which character encoding to assume. * @param sourceFile the file to copy from. Must not be <code>null</code>. @param destFile the file to copy to. Must not be <code>null</code>. @param filters the collection of filters to apply to this copy. @param overwrite Whether or not the destination file should be overwritten if it already exists. @param preserveLastModified Whether or not the last modified time of the resulting file should be set to that of the source file. @param encoding the encoding used to read and write the files. * @throws IOException if the copying fails. * @since Ant 1.5 
public	TokenNamepublic	
void	TokenNamevoid	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
sourceFile	TokenNameIdentifier	 source File
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
destFile	TokenNameIdentifier	 dest File
,	TokenNameCOMMA	
FilterSetCollection	TokenNameIdentifier	 Filter Set Collection
filters	TokenNameIdentifier	 filters
,	TokenNameCOMMA	
boolean	TokenNameboolean	
overwrite	TokenNameIdentifier	 overwrite
,	TokenNameCOMMA	
boolean	TokenNameboolean	
preserveLastModified	TokenNameIdentifier	 preserve Last Modified
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
sourceFile	TokenNameIdentifier	 source File
,	TokenNameCOMMA	
destFile	TokenNameIdentifier	 dest File
,	TokenNameCOMMA	
filters	TokenNameIdentifier	 filters
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
overwrite	TokenNameIdentifier	 overwrite
,	TokenNameCOMMA	
preserveLastModified	TokenNameIdentifier	 preserve Last Modified
,	TokenNameCOMMA	
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Convenience method to copy a file from a source to a * destination specifying if token filtering must be used, if * filter chains must be used, if source files may overwrite * newer destination files and the last modified time of * <code>destFile</code> file should be made equal * to the last modified time of <code>sourceFile</code>. * * @param sourceFile the file to copy from. * Must not be <code>null</code>. * @param destFile the file to copy to. * Must not be <code>null</code>. * @param filters the collection of filters to apply to this copy. * @param filterChains filterChains to apply during the copy. * @param overwrite Whether or not the destination file should be * overwritten if it already exists. * @param preserveLastModified Whether or not the last modified time of * the resulting file should be set to that * of the source file. * @param encoding the encoding used to read and write the files. * @param project the project instance. * * @throws IOException if the copying fails. * * @since Ant 1.5 */	TokenNameCOMMENT_JAVADOC	 Convenience method to copy a file from a source to a destination specifying if token filtering must be used, if filter chains must be used, if source files may overwrite newer destination files and the last modified time of <code>destFile</code> file should be made equal to the last modified time of <code>sourceFile</code>. * @param sourceFile the file to copy from. Must not be <code>null</code>. @param destFile the file to copy to. Must not be <code>null</code>. @param filters the collection of filters to apply to this copy. @param filterChains filterChains to apply during the copy. @param overwrite Whether or not the destination file should be overwritten if it already exists. @param preserveLastModified Whether or not the last modified time of the resulting file should be set to that of the source file. @param encoding the encoding used to read and write the files. @param project the project instance. * @throws IOException if the copying fails. * @since Ant 1.5 
public	TokenNamepublic	
void	TokenNamevoid	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
sourceFile	TokenNameIdentifier	 source File
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
destFile	TokenNameIdentifier	 dest File
,	TokenNameCOMMA	
FilterSetCollection	TokenNameIdentifier	 Filter Set Collection
filters	TokenNameIdentifier	 filters
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
filterChains	TokenNameIdentifier	 filter Chains
,	TokenNameCOMMA	
boolean	TokenNameboolean	
overwrite	TokenNameIdentifier	 overwrite
,	TokenNameCOMMA	
boolean	TokenNameboolean	
preserveLastModified	TokenNameIdentifier	 preserve Last Modified
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
project	TokenNameIdentifier	 project
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
sourceFile	TokenNameIdentifier	 source File
,	TokenNameCOMMA	
destFile	TokenNameIdentifier	 dest File
,	TokenNameCOMMA	
filters	TokenNameIdentifier	 filters
,	TokenNameCOMMA	
filterChains	TokenNameIdentifier	 filter Chains
,	TokenNameCOMMA	
overwrite	TokenNameIdentifier	 overwrite
,	TokenNameCOMMA	
preserveLastModified	TokenNameIdentifier	 preserve Last Modified
,	TokenNameCOMMA	
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
project	TokenNameIdentifier	 project
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Convenience method to copy a file from a source to a * destination specifying if token filtering must be used, if * filter chains must be used, if source files may overwrite * newer destination files and the last modified time of * <code>destFile</code> file should be made equal * to the last modified time of <code>sourceFile</code>. * * @param sourceFile the file to copy from. * Must not be <code>null</code>. * @param destFile the file to copy to. * Must not be <code>null</code>. * @param filters the collection of filters to apply to this copy. * @param filterChains filterChains to apply during the copy. * @param overwrite Whether or not the destination file should be * overwritten if it already exists. * @param preserveLastModified Whether or not the last modified time of * the resulting file should be set to that * of the source file. * @param inputEncoding the encoding used to read the files. * @param outputEncoding the encoding used to write the files. * @param project the project instance. * * * @throws IOException if the copying fails. * * @since Ant 1.6 */	TokenNameCOMMENT_JAVADOC	 Convenience method to copy a file from a source to a destination specifying if token filtering must be used, if filter chains must be used, if source files may overwrite newer destination files and the last modified time of <code>destFile</code> file should be made equal to the last modified time of <code>sourceFile</code>. * @param sourceFile the file to copy from. Must not be <code>null</code>. @param destFile the file to copy to. Must not be <code>null</code>. @param filters the collection of filters to apply to this copy. @param filterChains filterChains to apply during the copy. @param overwrite Whether or not the destination file should be overwritten if it already exists. @param preserveLastModified Whether or not the last modified time of the resulting file should be set to that of the source file. @param inputEncoding the encoding used to read the files. @param outputEncoding the encoding used to write the files. @param project the project instance. * @throws IOException if the copying fails. * @since Ant 1.6 
public	TokenNamepublic	
void	TokenNamevoid	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
sourceFile	TokenNameIdentifier	 source File
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
destFile	TokenNameIdentifier	 dest File
,	TokenNameCOMMA	
FilterSetCollection	TokenNameIdentifier	 Filter Set Collection
filters	TokenNameIdentifier	 filters
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
filterChains	TokenNameIdentifier	 filter Chains
,	TokenNameCOMMA	
boolean	TokenNameboolean	
overwrite	TokenNameIdentifier	 overwrite
,	TokenNameCOMMA	
boolean	TokenNameboolean	
preserveLastModified	TokenNameIdentifier	 preserve Last Modified
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
inputEncoding	TokenNameIdentifier	 input Encoding
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
outputEncoding	TokenNameIdentifier	 output Encoding
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
project	TokenNameIdentifier	 project
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
sourceFile	TokenNameIdentifier	 source File
,	TokenNameCOMMA	
destFile	TokenNameIdentifier	 dest File
,	TokenNameCOMMA	
filters	TokenNameIdentifier	 filters
,	TokenNameCOMMA	
filterChains	TokenNameIdentifier	 filter Chains
,	TokenNameCOMMA	
overwrite	TokenNameIdentifier	 overwrite
,	TokenNameCOMMA	
preserveLastModified	TokenNameIdentifier	 preserve Last Modified
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
inputEncoding	TokenNameIdentifier	 input Encoding
,	TokenNameCOMMA	
outputEncoding	TokenNameIdentifier	 output Encoding
,	TokenNameCOMMA	
project	TokenNameIdentifier	 project
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Convenience method to copy a file from a source to a * destination specifying if token filtering must be used, if * filter chains must be used, if source files may overwrite * newer destination files and the last modified time of * <code>destFile</code> file should be made equal * to the last modified time of <code>sourceFile</code>. * * @param sourceFile the file to copy from. * Must not be <code>null</code>. * @param destFile the file to copy to. * Must not be <code>null</code>. * @param filters the collection of filters to apply to this copy. * @param filterChains filterChains to apply during the copy. * @param overwrite Whether or not the destination file should be * overwritten if it already exists. * @param preserveLastModified Whether or not the last modified time of * the resulting file should be set to that * of the source file. * @param append whether to append to the destination file. * @param inputEncoding the encoding used to read the files. * @param outputEncoding the encoding used to write the files. * @param project the project instance. * * * @throws IOException if the copying fails. * * @since Ant 1.8 */	TokenNameCOMMENT_JAVADOC	 Convenience method to copy a file from a source to a destination specifying if token filtering must be used, if filter chains must be used, if source files may overwrite newer destination files and the last modified time of <code>destFile</code> file should be made equal to the last modified time of <code>sourceFile</code>. * @param sourceFile the file to copy from. Must not be <code>null</code>. @param destFile the file to copy to. Must not be <code>null</code>. @param filters the collection of filters to apply to this copy. @param filterChains filterChains to apply during the copy. @param overwrite Whether or not the destination file should be overwritten if it already exists. @param preserveLastModified Whether or not the last modified time of the resulting file should be set to that of the source file. @param append whether to append to the destination file. @param inputEncoding the encoding used to read the files. @param outputEncoding the encoding used to write the files. @param project the project instance. * @throws IOException if the copying fails. * @since Ant 1.8 
public	TokenNamepublic	
void	TokenNamevoid	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
sourceFile	TokenNameIdentifier	 source File
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
destFile	TokenNameIdentifier	 dest File
,	TokenNameCOMMA	
FilterSetCollection	TokenNameIdentifier	 Filter Set Collection
filters	TokenNameIdentifier	 filters
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
filterChains	TokenNameIdentifier	 filter Chains
,	TokenNameCOMMA	
boolean	TokenNameboolean	
overwrite	TokenNameIdentifier	 overwrite
,	TokenNameCOMMA	
boolean	TokenNameboolean	
preserveLastModified	TokenNameIdentifier	 preserve Last Modified
,	TokenNameCOMMA	
boolean	TokenNameboolean	
append	TokenNameIdentifier	 append
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
inputEncoding	TokenNameIdentifier	 input Encoding
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
outputEncoding	TokenNameIdentifier	 output Encoding
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
project	TokenNameIdentifier	 project
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
sourceFile	TokenNameIdentifier	 source File
,	TokenNameCOMMA	
destFile	TokenNameIdentifier	 dest File
,	TokenNameCOMMA	
filters	TokenNameIdentifier	 filters
,	TokenNameCOMMA	
filterChains	TokenNameIdentifier	 filter Chains
,	TokenNameCOMMA	
overwrite	TokenNameIdentifier	 overwrite
,	TokenNameCOMMA	
preserveLastModified	TokenNameIdentifier	 preserve Last Modified
,	TokenNameCOMMA	
append	TokenNameIdentifier	 append
,	TokenNameCOMMA	
inputEncoding	TokenNameIdentifier	 input Encoding
,	TokenNameCOMMA	
outputEncoding	TokenNameIdentifier	 output Encoding
,	TokenNameCOMMA	
project	TokenNameIdentifier	 project
,	TokenNameCOMMA	
/* force: */	TokenNameCOMMENT_BLOCK	 force: 
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Convenience method to copy a file from a source to a * destination specifying if token filtering must be used, if * filter chains must be used, if source files may overwrite * newer destination files and the last modified time of * <code>destFile</code> file should be made equal * to the last modified time of <code>sourceFile</code>. * * @param sourceFile the file to copy from. * Must not be <code>null</code>. * @param destFile the file to copy to. * Must not be <code>null</code>. * @param filters the collection of filters to apply to this copy. * @param filterChains filterChains to apply during the copy. * @param overwrite Whether or not the destination file should be * overwritten if it already exists. * @param preserveLastModified Whether or not the last modified time of * the resulting file should be set to that * of the source file. * @param append whether to append to the destination file. * @param inputEncoding the encoding used to read the files. * @param outputEncoding the encoding used to write the files. * @param project the project instance. * @param force whether to overwrite read-only destination files. * * @throws IOException if the copying fails. * * @since Ant 1.8.2 */	TokenNameCOMMENT_JAVADOC	 Convenience method to copy a file from a source to a destination specifying if token filtering must be used, if filter chains must be used, if source files may overwrite newer destination files and the last modified time of <code>destFile</code> file should be made equal to the last modified time of <code>sourceFile</code>. * @param sourceFile the file to copy from. Must not be <code>null</code>. @param destFile the file to copy to. Must not be <code>null</code>. @param filters the collection of filters to apply to this copy. @param filterChains filterChains to apply during the copy. @param overwrite Whether or not the destination file should be overwritten if it already exists. @param preserveLastModified Whether or not the last modified time of the resulting file should be set to that of the source file. @param append whether to append to the destination file. @param inputEncoding the encoding used to read the files. @param outputEncoding the encoding used to write the files. @param project the project instance. @param force whether to overwrite read-only destination files. * @throws IOException if the copying fails. * @since Ant 1.8.2 
public	TokenNamepublic	
void	TokenNamevoid	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
sourceFile	TokenNameIdentifier	 source File
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
destFile	TokenNameIdentifier	 dest File
,	TokenNameCOMMA	
FilterSetCollection	TokenNameIdentifier	 Filter Set Collection
filters	TokenNameIdentifier	 filters
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
filterChains	TokenNameIdentifier	 filter Chains
,	TokenNameCOMMA	
boolean	TokenNameboolean	
overwrite	TokenNameIdentifier	 overwrite
,	TokenNameCOMMA	
boolean	TokenNameboolean	
preserveLastModified	TokenNameIdentifier	 preserve Last Modified
,	TokenNameCOMMA	
boolean	TokenNameboolean	
append	TokenNameIdentifier	 append
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
inputEncoding	TokenNameIdentifier	 input Encoding
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
outputEncoding	TokenNameIdentifier	 output Encoding
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
project	TokenNameIdentifier	 project
,	TokenNameCOMMA	
boolean	TokenNameboolean	
force	TokenNameIdentifier	 force
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
ResourceUtils	TokenNameIdentifier	 Resource Utils
.	TokenNameDOT	
copyResource	TokenNameIdentifier	 copy Resource
(	TokenNameLPAREN	
new	TokenNamenew	
FileResource	TokenNameIdentifier	 File Resource
(	TokenNameLPAREN	
sourceFile	TokenNameIdentifier	 source File
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
FileResource	TokenNameIdentifier	 File Resource
(	TokenNameLPAREN	
destFile	TokenNameIdentifier	 dest File
)	TokenNameRPAREN	
,	TokenNameCOMMA	
filters	TokenNameIdentifier	 filters
,	TokenNameCOMMA	
filterChains	TokenNameIdentifier	 filter Chains
,	TokenNameCOMMA	
overwrite	TokenNameIdentifier	 overwrite
,	TokenNameCOMMA	
preserveLastModified	TokenNameIdentifier	 preserve Last Modified
,	TokenNameCOMMA	
append	TokenNameIdentifier	 append
,	TokenNameCOMMA	
inputEncoding	TokenNameIdentifier	 input Encoding
,	TokenNameCOMMA	
outputEncoding	TokenNameIdentifier	 output Encoding
,	TokenNameCOMMA	
project	TokenNameIdentifier	 project
,	TokenNameCOMMA	
force	TokenNameIdentifier	 force
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// CheckStyle:ParameterNumberCheck ON 	TokenNameCOMMENT_LINE	CheckStyle:ParameterNumberCheck ON 
/** * Calls File.setLastModified(long time). Originally written to * to dynamically bind to that call on Java1.2+. * * @param file the file whose modified time is to be set * @param time the time to which the last modified time is to be set. * if this is -1, the current time is used. */	TokenNameCOMMENT_JAVADOC	 Calls File.setLastModified(long time). Originally written to to dynamically bind to that call on Java1.2+. * @param file the file whose modified time is to be set @param time the time to which the last modified time is to be set. if this is -1, the current time is used. 
public	TokenNamepublic	
void	TokenNamevoid	
setFileLastModified	TokenNameIdentifier	 set File Last Modified
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
long	TokenNamelong	
time	TokenNameIdentifier	 time
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ResourceUtils	TokenNameIdentifier	 Resource Utils
.	TokenNameDOT	
setLastModified	TokenNameIdentifier	 set Last Modified
(	TokenNameLPAREN	
new	TokenNamenew	
FileResource	TokenNameIdentifier	 File Resource
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
,	TokenNameCOMMA	
time	TokenNameIdentifier	 time
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Interpret the filename as a file relative to the given file * unless the filename already represents an absolute filename. * Differs from <code>new File(file, filename)</code> in that * the resulting File's path will always be a normalized, * absolute pathname. Also, if it is determined that * <code>filename</code> is context-relative, <code>file</code> * will be discarded and the reference will be resolved using * available context/state information about the filesystem. * * @param file the "reference" file for relative paths. This * instance must be an absolute file and must not contain * &quot;./&quot; or &quot;../&quot; sequences (same for \ instead * of /). If it is null, this call is equivalent to * <code>new java.io.File(filename).getAbsoluteFile()</code>. * * @param filename a file name. * * @return an absolute file. * @throws java.lang.NullPointerException if filename is null. */	TokenNameCOMMENT_JAVADOC	 Interpret the filename as a file relative to the given file unless the filename already represents an absolute filename. Differs from <code>new File(file, filename)</code> in that the resulting File's path will always be a normalized, absolute pathname. Also, if it is determined that <code>filename</code> is context-relative, <code>file</code> will be discarded and the reference will be resolved using available context/state information about the filesystem. * @param file the "reference" file for relative paths. This instance must be an absolute file and must not contain &quot;./&quot; or &quot;../&quot; sequences (same for \ instead of /). If it is null, this call is equivalent to <code>new java.io.File(filename).getAbsoluteFile()</code>. * @param filename a file name. * @return an absolute file. @throws java.lang.NullPointerException if filename is null. 
public	TokenNamepublic	
File	TokenNameIdentifier	 File
resolveFile	TokenNameIdentifier	 resolve File
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
filename	TokenNameIdentifier	 filename
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isAbsolutePath	TokenNameIdentifier	 is Absolute Path
(	TokenNameLPAREN	
filename	TokenNameIdentifier	 filename
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
char	TokenNamechar	
sep	TokenNameIdentifier	 sep
=	TokenNameEQUAL	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separatorChar	TokenNameIdentifier	 separator Char
;	TokenNameSEMICOLON	
filename	TokenNameIdentifier	 filename
=	TokenNameEQUAL	
filename	TokenNameIdentifier	 filename
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
'/'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
sep	TokenNameIdentifier	 sep
)	TokenNameRPAREN	
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
'\\'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
sep	TokenNameIdentifier	 sep
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isContextRelativePath	TokenNameIdentifier	 is Context Relative Path
(	TokenNameLPAREN	
filename	TokenNameIdentifier	 filename
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
file	TokenNameIdentifier	 file
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// on cygwin, our current directory can be a UNC; 	TokenNameCOMMENT_LINE	on cygwin, our current directory can be a UNC; 
// assume user.dir is absolute or all hell breaks loose... 	TokenNameCOMMENT_LINE	assume user.dir is absolute or all hell breaks loose... 
String	TokenNameIdentifier	 String
udir	TokenNameIdentifier	 udir
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"user.dir"	TokenNameStringLiteral	user.dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
filename	TokenNameIdentifier	 filename
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
sep	TokenNameIdentifier	 sep
&&	TokenNameAND_AND	
udir	TokenNameIdentifier	 udir
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
sep	TokenNameIdentifier	 sep
)	TokenNameRPAREN	
{	TokenNameLBRACE	
filename	TokenNameIdentifier	 filename
=	TokenNameEQUAL	
dissect	TokenNameIdentifier	 dissect
(	TokenNameLPAREN	
udir	TokenNameIdentifier	 udir
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
+	TokenNamePLUS	
filename	TokenNameIdentifier	 filename
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
filename	TokenNameIdentifier	 filename
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
filename	TokenNameIdentifier	 filename
)	TokenNameRPAREN	
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
normalize	TokenNameIdentifier	 normalize
(	TokenNameLPAREN	
filename	TokenNameIdentifier	 filename
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * On DOS and NetWare, the evaluation of certain file * specifications is context-dependent. These are filenames * beginning with a single separator (relative to current root directory) * and filenames with a drive specification and no intervening separator * (relative to current directory of the specified root). * @param filename the filename to evaluate. * @return true if the filename is relative to system context. * @throws java.lang.NullPointerException if filename is null. * @since Ant 1.7 */	TokenNameCOMMENT_JAVADOC	 On DOS and NetWare, the evaluation of certain file specifications is context-dependent. These are filenames beginning with a single separator (relative to current root directory) and filenames with a drive specification and no intervening separator (relative to current directory of the specified root). @param filename the filename to evaluate. @return true if the filename is relative to system context. @throws java.lang.NullPointerException if filename is null. @since Ant 1.7 
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
isContextRelativePath	TokenNameIdentifier	 is Context Relative Path
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
filename	TokenNameIdentifier	 filename
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
ON_DOS	TokenNameIdentifier	 ON  DOS
||	TokenNameOR_OR	
ON_NETWARE	TokenNameIdentifier	 ON  NETWARE
)	TokenNameRPAREN	
||	TokenNameOR_OR	
filename	TokenNameIdentifier	 filename
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
char	TokenNamechar	
sep	TokenNameIdentifier	 sep
=	TokenNameEQUAL	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separatorChar	TokenNameIdentifier	 separator Char
;	TokenNameSEMICOLON	
filename	TokenNameIdentifier	 filename
=	TokenNameEQUAL	
filename	TokenNameIdentifier	 filename
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
'/'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
sep	TokenNameIdentifier	 sep
)	TokenNameRPAREN	
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
'\\'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
sep	TokenNameIdentifier	 sep
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
char	TokenNamechar	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
filename	TokenNameIdentifier	 filename
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
filename	TokenNameIdentifier	 filename
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
sep	TokenNameIdentifier	 sep
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
len	TokenNameIdentifier	 len
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
filename	TokenNameIdentifier	 filename
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
sep	TokenNameIdentifier	 sep
)	TokenNameRPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
isLetter	TokenNameIdentifier	 is Letter
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
len	TokenNameIdentifier	 len
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
filename	TokenNameIdentifier	 filename
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
':'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
len	TokenNameIdentifier	 len
==	TokenNameEQUAL_EQUAL	
2	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
filename	TokenNameIdentifier	 filename
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
sep	TokenNameIdentifier	 sep
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Verifies that the specified filename represents an absolute path. * Differs from new java.io.File("filename").isAbsolute() in that a path * beginning with a double file separator--signifying a Windows UNC--must * at minimum match "\\a\b" to be considered an absolute path. * @param filename the filename to be checked. * @return true if the filename represents an absolute path. * @throws java.lang.NullPointerException if filename is null. * @since Ant 1.6.3 */	TokenNameCOMMENT_JAVADOC	 Verifies that the specified filename represents an absolute path. Differs from new java.io.File("filename").isAbsolute() in that a path beginning with a double file separator--signifying a Windows UNC--must at minimum match "\\a\b" to be considered an absolute path. @param filename the filename to be checked. @return true if the filename represents an absolute path. @throws java.lang.NullPointerException if filename is null. @since Ant 1.6.3 
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
isAbsolutePath	TokenNameIdentifier	 is Absolute Path
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
filename	TokenNameIdentifier	 filename
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
filename	TokenNameIdentifier	 filename
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
len	TokenNameIdentifier	 len
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
char	TokenNamechar	
sep	TokenNameIdentifier	 sep
=	TokenNameEQUAL	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separatorChar	TokenNameIdentifier	 separator Char
;	TokenNameSEMICOLON	
filename	TokenNameIdentifier	 filename
=	TokenNameEQUAL	
filename	TokenNameIdentifier	 filename
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
'/'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
sep	TokenNameIdentifier	 sep
)	TokenNameRPAREN	
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
'\\'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
sep	TokenNameIdentifier	 sep
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
char	TokenNamechar	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
filename	TokenNameIdentifier	 filename
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
ON_DOS	TokenNameIdentifier	 ON  DOS
||	TokenNameOR_OR	
ON_NETWARE	TokenNameIdentifier	 ON  NETWARE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
sep	TokenNameIdentifier	 sep
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
sep	TokenNameIdentifier	 sep
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// CheckStyle:MagicNumber OFF 	TokenNameCOMMENT_LINE	CheckStyle:MagicNumber OFF 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
ON_DOS	TokenNameIdentifier	 ON  DOS
&&	TokenNameAND_AND	
len	TokenNameIdentifier	 len
>	TokenNameGREATER	
4	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
filename	TokenNameIdentifier	 filename
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
sep	TokenNameIdentifier	 sep
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// CheckStyle:MagicNumber ON 	TokenNameCOMMENT_LINE	CheckStyle:MagicNumber ON 
int	TokenNameint	
nextsep	TokenNameIdentifier	 nextsep
=	TokenNameEQUAL	
filename	TokenNameIdentifier	 filename
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
sep	TokenNameIdentifier	 sep
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
nextsep	TokenNameIdentifier	 nextsep
>	TokenNameGREATER	
2	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
nextsep	TokenNameIdentifier	 nextsep
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
<	TokenNameLESS	
len	TokenNameIdentifier	 len
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
colon	TokenNameIdentifier	 colon
=	TokenNameEQUAL	
filename	TokenNameIdentifier	 filename
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
':'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
isLetter	TokenNameIdentifier	 is Letter
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
colon	TokenNameIdentifier	 colon
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
filename	TokenNameIdentifier	 filename
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
2	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
filename	TokenNameIdentifier	 filename
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
sep	TokenNameIdentifier	 sep
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
ON_NETWARE	TokenNameIdentifier	 ON  NETWARE
&&	TokenNameAND_AND	
colon	TokenNameIdentifier	 colon
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Translate a path into its native (platform specific) format. * <p> * This method uses PathTokenizer to separate the input path * into its components. This handles DOS style paths in a relatively * sensible way. The file separators are then converted to their platform * specific versions. * * @param toProcess The path to be translated. * May be <code>null</code>. * * @return the native version of the specified path or * an empty string if the path is <code>null</code> or empty. * * @since ant 1.7 * @see PathTokenizer */	TokenNameCOMMENT_JAVADOC	 Translate a path into its native (platform specific) format. <p> This method uses PathTokenizer to separate the input path into its components. This handles DOS style paths in a relatively sensible way. The file separators are then converted to their platform specific versions. * @param toProcess The path to be translated. May be <code>null</code>. * @return the native version of the specified path or an empty string if the path is <code>null</code> or empty. * @since ant 1.7 @see PathTokenizer 
public	TokenNamepublic	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
translatePath	TokenNameIdentifier	 translate Path
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
toProcess	TokenNameIdentifier	 to Process
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
toProcess	TokenNameIdentifier	 to Process
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
toProcess	TokenNameIdentifier	 to Process
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
StringBuffer	TokenNameIdentifier	 String Buffer
path	TokenNameIdentifier	 path
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
toProcess	TokenNameIdentifier	 to Process
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
EXPAND_SPACE	TokenNameIdentifier	 EXPAND  SPACE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
PathTokenizer	TokenNameIdentifier	 Path Tokenizer
tokenizer	TokenNameIdentifier	 tokenizer
=	TokenNameEQUAL	
new	TokenNamenew	
PathTokenizer	TokenNameIdentifier	 Path Tokenizer
(	TokenNameLPAREN	
toProcess	TokenNameIdentifier	 to Process
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
tokenizer	TokenNameIdentifier	 tokenizer
.	TokenNameDOT	
hasMoreTokens	TokenNameIdentifier	 has More Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
pathComponent	TokenNameIdentifier	 path Component
=	TokenNameEQUAL	
tokenizer	TokenNameIdentifier	 tokenizer
.	TokenNameDOT	
nextToken	TokenNameIdentifier	 next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pathComponent	TokenNameIdentifier	 path Component
=	TokenNameEQUAL	
pathComponent	TokenNameIdentifier	 path Component
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
'/'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separatorChar	TokenNameIdentifier	 separator Char
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pathComponent	TokenNameIdentifier	 path Component
=	TokenNameEQUAL	
pathComponent	TokenNameIdentifier	 path Component
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
'\\'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separatorChar	TokenNameIdentifier	 separator Char
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
pathSeparatorChar	TokenNameIdentifier	 path Separator Char
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
pathComponent	TokenNameIdentifier	 path Component
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * &quot;Normalize&quot; the given absolute path. * * <p>This includes: * <ul> * <li>Uppercase the drive letter if there is one.</li> * <li>Remove redundant slashes after the drive spec.</li> * <li>Resolve all ./, .\, ../ and ..\ sequences.</li> * <li>DOS style paths that start with a drive letter will have * \ as the separator.</li> * </ul> * Unlike {@link File#getCanonicalPath()} this method * specifically does not resolve symbolic links. * * @param path the path to be normalized. * @return the normalized version of the path. * * @throws java.lang.NullPointerException if path is null. */	TokenNameCOMMENT_JAVADOC	 &quot;Normalize&quot; the given absolute path. * <p>This includes: <ul> <li>Uppercase the drive letter if there is one.</li> <li>Remove redundant slashes after the drive spec.</li> <li>Resolve all ./, .\, ../ and ..\ sequences.</li> <li>DOS style paths that start with a drive letter will have \ as the separator.</li> </ul> Unlike {@link File#getCanonicalPath()} this method specifically does not resolve symbolic links. * @param path the path to be normalized. @return the normalized version of the path. * @throws java.lang.NullPointerException if path is null. 
public	TokenNamepublic	
File	TokenNameIdentifier	 File
normalize	TokenNameIdentifier	 normalize
(	TokenNameLPAREN	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
path	TokenNameIdentifier	 path
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Stack	TokenNameIdentifier	 Stack
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
new	TokenNamenew	
Stack	TokenNameIdentifier	 Stack
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
dissect	TokenNameIdentifier	 dissect
=	TokenNameEQUAL	
dissect	TokenNameIdentifier	 dissect
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
push	TokenNameIdentifier	 push
(	TokenNameLPAREN	
dissect	TokenNameIdentifier	 dissect
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
StringTokenizer	TokenNameIdentifier	 String Tokenizer
tok	TokenNameIdentifier	 tok
=	TokenNameEQUAL	
new	TokenNamenew	
StringTokenizer	TokenNameIdentifier	 String Tokenizer
(	TokenNameLPAREN	
dissect	TokenNameIdentifier	 dissect
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separator	TokenNameIdentifier	 separator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
tok	TokenNameIdentifier	 tok
.	TokenNameDOT	
hasMoreTokens	TokenNameIdentifier	 has More Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
thisToken	TokenNameIdentifier	 this Token
=	TokenNameEQUAL	
tok	TokenNameIdentifier	 tok
.	TokenNameDOT	
nextToken	TokenNameIdentifier	 next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
"."	TokenNameStringLiteral	.
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
thisToken	TokenNameIdentifier	 this Token
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
".."	TokenNameStringLiteral	..
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
thisToken	TokenNameIdentifier	 this Token
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<	TokenNameLESS	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Cannot resolve it, so skip it. 	TokenNameCOMMENT_LINE	Cannot resolve it, so skip it. 
return	TokenNamereturn	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
pop	TokenNameIdentifier	 pop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// plain component 	TokenNameCOMMENT_LINE	plain component 
s	TokenNameIdentifier	 s
.	TokenNameDOT	
push	TokenNameIdentifier	 push
(	TokenNameLPAREN	
thisToken	TokenNameIdentifier	 this Token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
StringBuffer	TokenNameIdentifier	 String Buffer
sb	TokenNameIdentifier	 sb
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// not before the filesystem root and not after it, since root 	TokenNameCOMMENT_LINE	not before the filesystem root and not after it, since root 
// already contains one 	TokenNameCOMMENT_LINE	already contains one 
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separatorChar	TokenNameIdentifier	 separator Char
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Dissect the specified absolute path. * @param path the path to dissect. * @return String[] {root, remaining path}. * @throws java.lang.NullPointerException if path is null. * @since Ant 1.7 */	TokenNameCOMMENT_JAVADOC	 Dissect the specified absolute path. @param path the path to dissect. @return String[] {root, remaining path}. @throws java.lang.NullPointerException if path is null. @since Ant 1.7 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
dissect	TokenNameIdentifier	 dissect
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
path	TokenNameIdentifier	 path
)	TokenNameRPAREN	
{	TokenNameLBRACE	
char	TokenNamechar	
sep	TokenNameIdentifier	 sep
=	TokenNameEQUAL	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separatorChar	TokenNameIdentifier	 separator Char
;	TokenNameSEMICOLON	
path	TokenNameIdentifier	 path
=	TokenNameEQUAL	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
'/'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
sep	TokenNameIdentifier	 sep
)	TokenNameRPAREN	
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
'\\'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
sep	TokenNameIdentifier	 sep
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// make sure we are dealing with an absolute path 	TokenNameCOMMENT_LINE	make sure we are dealing with an absolute path 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isAbsolutePath	TokenNameIdentifier	 is Absolute Path
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
+	TokenNamePLUS	
" is not an absolute path"	TokenNameStringLiteral	 is not an absolute path
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
root	TokenNameIdentifier	 root
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
colon	TokenNameIdentifier	 colon
=	TokenNameEQUAL	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
':'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
colon	TokenNameIdentifier	 colon
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
ON_DOS	TokenNameIdentifier	 ON  DOS
||	TokenNameOR_OR	
ON_NETWARE	TokenNameIdentifier	 ON  NETWARE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
colon	TokenNameIdentifier	 colon
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
root	TokenNameIdentifier	 root
=	TokenNameEQUAL	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
next	TokenNameIdentifier	 next
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
ca	TokenNameIdentifier	 ca
=	TokenNameEQUAL	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
toCharArray	TokenNameIdentifier	 to Char Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
root	TokenNameIdentifier	 root
+=	TokenNamePLUS_EQUAL	
sep	TokenNameIdentifier	 sep
;	TokenNameSEMICOLON	
//remove the initial separator; the root has it. 	TokenNameCOMMENT_LINE	remove the initial separator; the root has it. 
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ca	TokenNameIdentifier	 ca
[	TokenNameLBRACKET	
next	TokenNameIdentifier	 next
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
sep	TokenNameIdentifier	 sep
)	TokenNameRPAREN	
?	TokenNameQUESTION	
next	TokenNameIdentifier	 next
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
StringBuffer	TokenNameIdentifier	 String Buffer
sbPath	TokenNameIdentifier	 sb Path
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Eliminate consecutive slashes after the drive spec: 	TokenNameCOMMENT_LINE	Eliminate consecutive slashes after the drive spec: 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
ca	TokenNameIdentifier	 ca
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ca	TokenNameIdentifier	 ca
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
sep	TokenNameIdentifier	 sep
||	TokenNameOR_OR	
ca	TokenNameIdentifier	 ca
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
sep	TokenNameIdentifier	 sep
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sbPath	TokenNameIdentifier	 sb Path
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
ca	TokenNameIdentifier	 ca
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
path	TokenNameIdentifier	 path
=	TokenNameEQUAL	
sbPath	TokenNameIdentifier	 sb Path
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
sep	TokenNameIdentifier	 sep
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// UNC drive 	TokenNameCOMMENT_LINE	UNC drive 
int	TokenNameint	
nextsep	TokenNameIdentifier	 nextsep
=	TokenNameEQUAL	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
sep	TokenNameIdentifier	 sep
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
nextsep	TokenNameIdentifier	 nextsep
=	TokenNameEQUAL	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
sep	TokenNameIdentifier	 sep
,	TokenNameCOMMA	
nextsep	TokenNameIdentifier	 nextsep
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
root	TokenNameIdentifier	 root
=	TokenNameEQUAL	
(	TokenNameLPAREN	
nextsep	TokenNameIdentifier	 nextsep
>	TokenNameGREATER	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
nextsep	TokenNameIdentifier	 nextsep
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
:	TokenNameCOLON	
path	TokenNameIdentifier	 path
;	TokenNameSEMICOLON	
path	TokenNameIdentifier	 path
=	TokenNameEQUAL	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
root	TokenNameIdentifier	 root
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
root	TokenNameIdentifier	 root
=	TokenNameEQUAL	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separator	TokenNameIdentifier	 separator
;	TokenNameSEMICOLON	
path	TokenNameIdentifier	 path
=	TokenNameEQUAL	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
root	TokenNameIdentifier	 root
,	TokenNameCOMMA	
path	TokenNameIdentifier	 path
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns a VMS String representation of a <code>File</code> object. * This is useful since the JVM by default internally converts VMS paths * to Unix style. * The returned String is always an absolute path. * * @param f The <code>File</code> to get the VMS path for. * @return The absolute VMS path to <code>f</code>. */	TokenNameCOMMENT_JAVADOC	 Returns a VMS String representation of a <code>File</code> object. This is useful since the JVM by default internally converts VMS paths to Unix style. The returned String is always an absolute path. * @param f The <code>File</code> to get the VMS path for. @return The absolute VMS path to <code>f</code>. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
toVMSPath	TokenNameIdentifier	 to VMS Path
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
f	TokenNameIdentifier	 f
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// format: "DEVICE:[DIR.SUBDIR]FILE" 	TokenNameCOMMENT_LINE	format: "DEVICE:[DIR.SUBDIR]FILE" 
String	TokenNameIdentifier	 String
osPath	TokenNameIdentifier	 os Path
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
path	TokenNameIdentifier	 path
=	TokenNameEQUAL	
normalize	TokenNameIdentifier	 normalize
(	TokenNameLPAREN	
f	TokenNameIdentifier	 f
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
f	TokenNameIdentifier	 f
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
isAbsolute	TokenNameIdentifier	 is Absolute
=	TokenNameEQUAL	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separatorChar	TokenNameIdentifier	 separator Char
;	TokenNameSEMICOLON	
// treat directories specified using .DIR syntax as files 	TokenNameCOMMENT_LINE	treat directories specified using .DIR syntax as files 
// CheckStyle:MagicNumber OFF 	TokenNameCOMMENT_LINE	CheckStyle:MagicNumber OFF 
boolean	TokenNameboolean	
isDirectory	TokenNameIdentifier	 is Directory
=	TokenNameEQUAL	
f	TokenNameIdentifier	 f
.	TokenNameDOT	
isDirectory	TokenNameIdentifier	 is Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
regionMatches	TokenNameIdentifier	 region Matches
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
4	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
".DIR"	TokenNameStringLiteral	.DIR
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// CheckStyle:MagicNumber ON 	TokenNameCOMMENT_LINE	CheckStyle:MagicNumber ON 
String	TokenNameIdentifier	 String
device	TokenNameIdentifier	 device
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
StringBuffer	TokenNameIdentifier	 String Buffer
directory	TokenNameIdentifier	 directory
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
file	TokenNameIdentifier	 file
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isAbsolute	TokenNameIdentifier	 is Absolute
)	TokenNameRPAREN	
{	TokenNameLBRACE	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separatorChar	TokenNameIdentifier	 separator Char
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
+	TokenNamePLUS	
":[000000]"	TokenNameStringLiteral	:[000000]
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
device	TokenNameIdentifier	 device
=	TokenNameEQUAL	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
index	TokenNameIdentifier	 index
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isDirectory	TokenNameIdentifier	 is Directory
)	TokenNameRPAREN	
{	TokenNameLBRACE	
directory	TokenNameIdentifier	 directory
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separatorChar	TokenNameIdentifier	 separator Char
,	TokenNameCOMMA	
'.'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
dirEnd	TokenNameIdentifier	 dir End
=	TokenNameEQUAL	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
lastIndexOf	TokenNameIdentifier	 last Index Of
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separatorChar	TokenNameIdentifier	 separator Char
,	TokenNameCOMMA	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dirEnd	TokenNameIdentifier	 dir End
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
dirEnd	TokenNameIdentifier	 dir End
<	TokenNameLESS	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
file	TokenNameIdentifier	 file
=	TokenNameEQUAL	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
directory	TokenNameIdentifier	 directory
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
,	TokenNameCOMMA	
dirEnd	TokenNameIdentifier	 dir End
)	TokenNameRPAREN	
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separatorChar	TokenNameIdentifier	 separator Char
,	TokenNameCOMMA	
'.'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
dirEnd	TokenNameIdentifier	 dir End
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
file	TokenNameIdentifier	 file
=	TokenNameEQUAL	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isAbsolute	TokenNameIdentifier	 is Absolute
&&	TokenNameAND_AND	
directory	TokenNameIdentifier	 directory
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
directory	TokenNameIdentifier	 directory
.	TokenNameDOT	
insert	TokenNameIdentifier	 insert
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
'.'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
osPath	TokenNameIdentifier	 os Path
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
device	TokenNameIdentifier	 device
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
device	TokenNameIdentifier	 device
+	TokenNamePLUS	
":"	TokenNameStringLiteral	:
:	TokenNameCOLON	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
+	TokenNamePLUS	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
directory	TokenNameIdentifier	 directory
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
"["	TokenNameStringLiteral	[
+	TokenNamePLUS	
directory	TokenNameIdentifier	 directory
+	TokenNamePLUS	
"]"	TokenNameStringLiteral	]
:	TokenNameCOLON	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
+	TokenNamePLUS	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
file	TokenNameIdentifier	 file
:	TokenNameCOLON	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
osPath	TokenNameIdentifier	 os Path
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Create a File object for a temporary file in a given directory. Without * actually creating the file. * * <p> * The file denoted by the returned abstract pathname did not exist before * this method was invoked, any subsequent invocation of this method will * yield a different file name. * </p> * <p> * The filename is prefixNNNNNsuffix where NNNN is a random number. * </p> * * @param prefix * prefix before the random number. * @param suffix * file extension; include the '.'. * @param parentDir * Directory to create the temporary file in; java.io.tmpdir used * if not specified. * * @deprecated since ant 1.7.1 use createTempFile(String, String, File, * boolean, boolean) instead. * @return a File reference to the new, nonexistent temporary file. */	TokenNameCOMMENT_JAVADOC	 Create a File object for a temporary file in a given directory. Without actually creating the file. * <p> The file denoted by the returned abstract pathname did not exist before this method was invoked, any subsequent invocation of this method will yield a different file name. </p> <p> The filename is prefixNNNNNsuffix where NNNN is a random number. </p> * @param prefix prefix before the random number. @param suffix file extension; include the '.'. @param parentDir Directory to create the temporary file in; java.io.tmpdir used if not specified. * @deprecated since ant 1.7.1 use createTempFile(String, String, File, boolean, boolean) instead. @return a File reference to the new, nonexistent temporary file. 
public	TokenNamepublic	
File	TokenNameIdentifier	 File
createTempFile	TokenNameIdentifier	 create Temp File
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
prefix	TokenNameIdentifier	 prefix
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
suffix	TokenNameIdentifier	 suffix
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
parentDir	TokenNameIdentifier	 parent Dir
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
createTempFile	TokenNameIdentifier	 create Temp File
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
,	TokenNameCOMMA	
suffix	TokenNameIdentifier	 suffix
,	TokenNameCOMMA	
parentDir	TokenNameIdentifier	 parent Dir
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
NULL_PLACEHOLDER	TokenNameIdentifier	 NULL  PLACEHOLDER
=	TokenNameEQUAL	
"null"	TokenNameStringLiteral	null
;	TokenNameSEMICOLON	
/** * Create a temporary file in a given directory. * * <p>The file denoted by the returned abstract pathname did not * exist before this method was invoked, any subsequent invocation * of this method will yield a different file name.</p> * * @param prefix prefix before the random number. * @param suffix file extension; include the '.'. * @param parentDir Directory to create the temporary file in; * java.io.tmpdir used if not specified. * @param deleteOnExit whether to set the tempfile for deletion on * normal VM exit. * @param createFile true if the file must actually be created. If false * chances exist that a file with the same name is created in the time * between invoking this method and the moment the file is actually created. * If possible set to true. * * @return a File reference to the new temporary file. * @since Ant 1.7.1 */	TokenNameCOMMENT_JAVADOC	 Create a temporary file in a given directory. * <p>The file denoted by the returned abstract pathname did not exist before this method was invoked, any subsequent invocation of this method will yield a different file name.</p> * @param prefix prefix before the random number. @param suffix file extension; include the '.'. @param parentDir Directory to create the temporary file in; java.io.tmpdir used if not specified. @param deleteOnExit whether to set the tempfile for deletion on normal VM exit. @param createFile true if the file must actually be created. If false chances exist that a file with the same name is created in the time between invoking this method and the moment the file is actually created. If possible set to true. * @return a File reference to the new temporary file. @since Ant 1.7.1 
public	TokenNamepublic	
File	TokenNameIdentifier	 File
createTempFile	TokenNameIdentifier	 create Temp File
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
prefix	TokenNameIdentifier	 prefix
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
suffix	TokenNameIdentifier	 suffix
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
parentDir	TokenNameIdentifier	 parent Dir
,	TokenNameCOMMA	
boolean	TokenNameboolean	
deleteOnExit	TokenNameIdentifier	 delete On Exit
,	TokenNameCOMMA	
boolean	TokenNameboolean	
createFile	TokenNameIdentifier	 create File
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
parent	TokenNameIdentifier	 parent
=	TokenNameEQUAL	
(	TokenNameLPAREN	
parentDir	TokenNameIdentifier	 parent Dir
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"java.io.tmpdir"	TokenNameStringLiteral	java.io.tmpdir
)	TokenNameRPAREN	
:	TokenNameCOLON	
parentDir	TokenNameIdentifier	 parent Dir
.	TokenNameDOT	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
prefix	TokenNameIdentifier	 prefix
=	TokenNameEQUAL	
NULL_PLACEHOLDER	TokenNameIdentifier	 NULL  PLACEHOLDER
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
suffix	TokenNameIdentifier	 suffix
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
suffix	TokenNameIdentifier	 suffix
=	TokenNameEQUAL	
NULL_PLACEHOLDER	TokenNameIdentifier	 NULL  PLACEHOLDER
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
createFile	TokenNameIdentifier	 create File
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
createTempFile	TokenNameIdentifier	 create Temp File
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
,	TokenNameCOMMA	
suffix	TokenNameIdentifier	 suffix
,	TokenNameCOMMA	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
parent	TokenNameIdentifier	 parent
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Could not create tempfile in "	TokenNameStringLiteral	Could not create tempfile in 
+	TokenNamePLUS	
parent	TokenNameIdentifier	 parent
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
DecimalFormat	TokenNameIdentifier	 Decimal Format
fmt	TokenNameIdentifier	 fmt
=	TokenNameEQUAL	
new	TokenNamenew	
DecimalFormat	TokenNameIdentifier	 Decimal Format
(	TokenNameLPAREN	
"#####"	TokenNameStringLiteral	#####
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
rand	TokenNameIdentifier	 rand
)	TokenNameRPAREN	
{	TokenNameLBRACE	
do	TokenNamedo	
{	TokenNameLBRACE	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
parent	TokenNameIdentifier	 parent
,	TokenNameCOMMA	
prefix	TokenNameIdentifier	 prefix
+	TokenNamePLUS	
fmt	TokenNameIdentifier	 fmt
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
rand	TokenNameIdentifier	 rand
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
suffix	TokenNameIdentifier	 suffix
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
deleteOnExit	TokenNameIdentifier	 delete On Exit
)	TokenNameRPAREN	
{	TokenNameLBRACE	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
deleteOnExit	TokenNameIdentifier	 delete On Exit
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
result	TokenNameIdentifier	 result
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Create a File object for a temporary file in a given directory. Without * actually creating the file. * * <p> * The file denoted by the returned abstract pathname did not exist before * this method was invoked, any subsequent invocation of this method will * yield a different file name. * </p> * <p> * The filename is prefixNNNNNsuffix where NNNN is a random number. * </p> * * @param prefix * prefix before the random number. * @param suffix * file extension; include the '.'. * @param parentDir * Directory to create the temporary file in; java.io.tmpdir used * if not specified. * @param deleteOnExit * whether to set the tempfile for deletion on normal VM exit. * * @deprecated since ant 1.7.1 use createTempFile(String, String, File, * boolean, boolean) instead. * @return a File reference to the new, nonexistent temporary file. */	TokenNameCOMMENT_JAVADOC	 Create a File object for a temporary file in a given directory. Without actually creating the file. * <p> The file denoted by the returned abstract pathname did not exist before this method was invoked, any subsequent invocation of this method will yield a different file name. </p> <p> The filename is prefixNNNNNsuffix where NNNN is a random number. </p> * @param prefix prefix before the random number. @param suffix file extension; include the '.'. @param parentDir Directory to create the temporary file in; java.io.tmpdir used if not specified. @param deleteOnExit whether to set the tempfile for deletion on normal VM exit. * @deprecated since ant 1.7.1 use createTempFile(String, String, File, boolean, boolean) instead. @return a File reference to the new, nonexistent temporary file. 
public	TokenNamepublic	
File	TokenNameIdentifier	 File
createTempFile	TokenNameIdentifier	 create Temp File
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
prefix	TokenNameIdentifier	 prefix
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
suffix	TokenNameIdentifier	 suffix
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
parentDir	TokenNameIdentifier	 parent Dir
,	TokenNameCOMMA	
boolean	TokenNameboolean	
deleteOnExit	TokenNameIdentifier	 delete On Exit
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
createTempFile	TokenNameIdentifier	 create Temp File
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
,	TokenNameCOMMA	
suffix	TokenNameIdentifier	 suffix
,	TokenNameCOMMA	
parentDir	TokenNameIdentifier	 parent Dir
,	TokenNameCOMMA	
deleteOnExit	TokenNameIdentifier	 delete On Exit
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Compares the contents of two files. * * @param f1 the file whose content is to be compared. * @param f2 the other file whose content is to be compared. * * @return true if the content of the files is the same. * * @throws IOException if the files cannot be read. */	TokenNameCOMMENT_JAVADOC	 Compares the contents of two files. * @param f1 the file whose content is to be compared. @param f2 the other file whose content is to be compared. * @return true if the content of the files is the same. * @throws IOException if the files cannot be read. 
public	TokenNamepublic	
boolean	TokenNameboolean	
contentEquals	TokenNameIdentifier	 content Equals
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
f1	TokenNameIdentifier	 f1
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
f2	TokenNameIdentifier	 f2
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
contentEquals	TokenNameIdentifier	 content Equals
(	TokenNameLPAREN	
f1	TokenNameIdentifier	 f1
,	TokenNameCOMMA	
f2	TokenNameIdentifier	 f2
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Compares the contents of two files. * * @param f1 the file whose content is to be compared. * @param f2 the other file whose content is to be compared. * @param textfile true if the file is to be treated as a text file and * differences in kind of line break are to be ignored. * * @return true if the content of the files is the same. * * @throws IOException if the files cannot be read. * @since Ant 1.6.3 */	TokenNameCOMMENT_JAVADOC	 Compares the contents of two files. * @param f1 the file whose content is to be compared. @param f2 the other file whose content is to be compared. @param textfile true if the file is to be treated as a text file and differences in kind of line break are to be ignored. * @return true if the content of the files is the same. * @throws IOException if the files cannot be read. @since Ant 1.6.3 
public	TokenNamepublic	
boolean	TokenNameboolean	
contentEquals	TokenNameIdentifier	 content Equals
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
f1	TokenNameIdentifier	 f1
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
f2	TokenNameIdentifier	 f2
,	TokenNameCOMMA	
boolean	TokenNameboolean	
textfile	TokenNameIdentifier	 textfile
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
ResourceUtils	TokenNameIdentifier	 Resource Utils
.	TokenNameDOT	
contentEquals	TokenNameIdentifier	 content Equals
(	TokenNameLPAREN	
new	TokenNamenew	
FileResource	TokenNameIdentifier	 File Resource
(	TokenNameLPAREN	
f1	TokenNameIdentifier	 f1
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
FileResource	TokenNameIdentifier	 File Resource
(	TokenNameLPAREN	
f2	TokenNameIdentifier	 f2
)	TokenNameRPAREN	
,	TokenNameCOMMA	
textfile	TokenNameIdentifier	 textfile
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * This was originally an emulation of {@link File#getParentFile} for JDK 1.1, but it is now * implemented using that method (Ant 1.6.3 onwards). * * @param f the file whose parent is required. * @return the given file's parent, or null if the file does not have a parent. * @since 1.10 * @deprecated since 1.7. Just use {@link File#getParentFile} directly. */	TokenNameCOMMENT_JAVADOC	 This was originally an emulation of {@link File#getParentFile} for JDK 1.1, but it is now implemented using that method (Ant 1.6.3 onwards). * @param f the file whose parent is required. @return the given file's parent, or null if the file does not have a parent. @since 1.10 @deprecated since 1.7. Just use {@link File#getParentFile} directly. 
public	TokenNamepublic	
File	TokenNameIdentifier	 File
getParentFile	TokenNameIdentifier	 get Parent File
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
f	TokenNameIdentifier	 f
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
f	TokenNameIdentifier	 f
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
f	TokenNameIdentifier	 f
.	TokenNameDOT	
getParentFile	TokenNameIdentifier	 get Parent File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Read from reader till EOF. * @param rdr the reader from which to read. * @return the contents read out of the given reader. * * @throws IOException if the contents could not be read out from the * reader. */	TokenNameCOMMENT_JAVADOC	 Read from reader till EOF. @param rdr the reader from which to read. @return the contents read out of the given reader. * @throws IOException if the contents could not be read out from the reader. 
public	TokenNamepublic	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
Reader	TokenNameIdentifier	 Reader
rdr	TokenNameIdentifier	 rdr
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
rdr	TokenNameIdentifier	 rdr
,	TokenNameCOMMA	
BUF_SIZE	TokenNameIdentifier	 BUF  SIZE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Read from reader till EOF. * * @param rdr the reader from which to read. * @param bufferSize the buffer size to use when reading. * * @return the contents read out of the given reader. * * @throws IOException if the contents could not be read out from the * reader. */	TokenNameCOMMENT_JAVADOC	 Read from reader till EOF. * @param rdr the reader from which to read. @param bufferSize the buffer size to use when reading. * @return the contents read out of the given reader. * @throws IOException if the contents could not be read out from the reader. 
public	TokenNamepublic	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
Reader	TokenNameIdentifier	 Reader
rdr	TokenNameIdentifier	 rdr
,	TokenNameCOMMA	
int	TokenNameint	
bufferSize	TokenNameIdentifier	 buffer Size
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
bufferSize	TokenNameIdentifier	 buffer Size
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"Buffer size must be greater "	TokenNameStringLiteral	Buffer size must be greater 
+	TokenNamePLUS	
"than 0"	TokenNameStringLiteral	than 0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
buffer	TokenNameIdentifier	 buffer
=	TokenNameEQUAL	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
bufferSize	TokenNameIdentifier	 buffer Size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
bufferLength	TokenNameIdentifier	 buffer Length
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
StringBuffer	TokenNameIdentifier	 String Buffer
textBuffer	TokenNameIdentifier	 text Buffer
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
bufferLength	TokenNameIdentifier	 buffer Length
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bufferLength	TokenNameIdentifier	 buffer Length
=	TokenNameEQUAL	
rdr	TokenNameIdentifier	 rdr
.	TokenNameDOT	
read	TokenNameIdentifier	 read
(	TokenNameLPAREN	
buffer	TokenNameIdentifier	 buffer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
bufferLength	TokenNameIdentifier	 buffer Length
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
textBuffer	TokenNameIdentifier	 text Buffer
=	TokenNameEQUAL	
(	TokenNameLPAREN	
textBuffer	TokenNameIdentifier	 text Buffer
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
textBuffer	TokenNameIdentifier	 text Buffer
;	TokenNameSEMICOLON	
textBuffer	TokenNameIdentifier	 text Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
new	TokenNamenew	
String	TokenNameIdentifier	 String
(	TokenNameLPAREN	
buffer	TokenNameIdentifier	 buffer
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
bufferLength	TokenNameIdentifier	 buffer Length
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
textBuffer	TokenNameIdentifier	 text Buffer
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
textBuffer	TokenNameIdentifier	 text Buffer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Safe read fully - do not return a null for an empty reader. * @param reader the input to read from. * @return the string. * @throws IOException if unable to read from reader. * @since Ant 1.7.1 */	TokenNameCOMMENT_JAVADOC	 Safe read fully - do not return a null for an empty reader. @param reader the input to read from. @return the string. @throws IOException if unable to read from reader. @since Ant 1.7.1 
public	TokenNamepublic	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
safeReadFully	TokenNameIdentifier	 safe Read Fully
(	TokenNameLPAREN	
Reader	TokenNameIdentifier	 Reader
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
ret	TokenNameIdentifier	 ret
=	TokenNameEQUAL	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
ret	TokenNameIdentifier	 ret
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
""	TokenNameStringLiteral	 
:	TokenNameCOLON	
ret	TokenNameIdentifier	 ret
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * This was originally an emulation of File.createNewFile for JDK 1.1, * but it is now implemented using that method (Ant 1.6.3 onwards). * * <p>This method has historically <strong>not</strong> guaranteed that the * operation was atomic. In its current implementation it is. * * @param f the file to be created. * @return true if the file did not exist already. * @throws IOException on error. * @since Ant 1.5 */	TokenNameCOMMENT_JAVADOC	 This was originally an emulation of File.createNewFile for JDK 1.1, but it is now implemented using that method (Ant 1.6.3 onwards). * <p>This method has historically <strong>not</strong> guaranteed that the operation was atomic. In its current implementation it is. * @param f the file to be created. @return true if the file did not exist already. @throws IOException on error. @since Ant 1.5 
public	TokenNamepublic	
boolean	TokenNameboolean	
createNewFile	TokenNameIdentifier	 create New File
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
f	TokenNameIdentifier	 f
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
f	TokenNameIdentifier	 f
.	TokenNameDOT	
createNewFile	TokenNameIdentifier	 create New File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Create a new file, optionally creating parent directories. * * @param f the file to be created. * @param mkdirs <code>boolean</code> whether to create parent directories. * @return true if the file did not exist already. * @throws IOException on error. * @since Ant 1.6.3 */	TokenNameCOMMENT_JAVADOC	 Create a new file, optionally creating parent directories. * @param f the file to be created. @param mkdirs <code>boolean</code> whether to create parent directories. @return true if the file did not exist already. @throws IOException on error. @since Ant 1.6.3 
public	TokenNamepublic	
boolean	TokenNameboolean	
createNewFile	TokenNameIdentifier	 create New File
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
f	TokenNameIdentifier	 f
,	TokenNameCOMMA	
boolean	TokenNameboolean	
mkdirs	TokenNameIdentifier	 mkdirs
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
parent	TokenNameIdentifier	 parent
=	TokenNameEQUAL	
f	TokenNameIdentifier	 f
.	TokenNameDOT	
getParentFile	TokenNameIdentifier	 get Parent File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
mkdirs	TokenNameIdentifier	 mkdirs
&&	TokenNameAND_AND	
!	TokenNameNOT	
(	TokenNameLPAREN	
parent	TokenNameIdentifier	 parent
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
parent	TokenNameIdentifier	 parent
.	TokenNameDOT	
mkdirs	TokenNameIdentifier	 mkdirs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
f	TokenNameIdentifier	 f
.	TokenNameDOT	
createNewFile	TokenNameIdentifier	 create New File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Checks whether a given file is a symbolic link. * * <p>It doesn't really test for symbolic links but whether the * canonical and absolute paths of the file are identical--this * may lead to false positives on some platforms.</p> * * @param parent the parent directory of the file to test * @param name the name of the file to test. * * @return true if the file is a symbolic link. * @throws IOException on error. * @since Ant 1.5 * @deprecated use SymbolicLinkUtils instead */	TokenNameCOMMENT_JAVADOC	 Checks whether a given file is a symbolic link. * <p>It doesn't really test for symbolic links but whether the canonical and absolute paths of the file are identical--this may lead to false positives on some platforms.</p> * @param parent the parent directory of the file to test @param name the name of the file to test. * @return true if the file is a symbolic link. @throws IOException on error. @since Ant 1.5 @deprecated use SymbolicLinkUtils instead 
public	TokenNamepublic	
boolean	TokenNameboolean	
isSymbolicLink	TokenNameIdentifier	 is Symbolic Link
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
parent	TokenNameIdentifier	 parent
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
SymbolicLinkUtils	TokenNameIdentifier	 Symbolic Link Utils
u	TokenNameIdentifier	 u
=	TokenNameEQUAL	
SymbolicLinkUtils	TokenNameIdentifier	 Symbolic Link Utils
.	TokenNameDOT	
getSymbolicLinkUtils	TokenNameIdentifier	 get Symbolic Link Utils
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
parent	TokenNameIdentifier	 parent
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
u	TokenNameIdentifier	 u
.	TokenNameDOT	
isSymbolicLink	TokenNameIdentifier	 is Symbolic Link
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
u	TokenNameIdentifier	 u
.	TokenNameDOT	
isSymbolicLink	TokenNameIdentifier	 is Symbolic Link
(	TokenNameLPAREN	
parent	TokenNameIdentifier	 parent
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Removes a leading path from a second path. * * @param leading The leading path, must not be null, must be absolute. * @param path The path to remove from, must not be null, must be absolute. * * @return path's normalized absolute if it doesn't start with * leading; path's path with leading's path removed otherwise. * * @since Ant 1.5 */	TokenNameCOMMENT_JAVADOC	 Removes a leading path from a second path. * @param leading The leading path, must not be null, must be absolute. @param path The path to remove from, must not be null, must be absolute. * @return path's normalized absolute if it doesn't start with leading; path's path with leading's path removed otherwise. * @since Ant 1.5 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
removeLeadingPath	TokenNameIdentifier	 remove Leading Path
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
leading	TokenNameIdentifier	 leading
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
path	TokenNameIdentifier	 path
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
normalize	TokenNameIdentifier	 normalize
(	TokenNameLPAREN	
leading	TokenNameIdentifier	 leading
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
normalize	TokenNameIdentifier	 normalize
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
l	TokenNameIdentifier	 l
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// ensure that l ends with a / 	TokenNameCOMMENT_LINE	ensure that l ends with a / 
// so we never think /foo was a parent directory of /foobar 	TokenNameCOMMENT_LINE	so we never think /foo was a parent directory of /foobar 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
l	TokenNameIdentifier	 l
.	TokenNameDOT	
endsWith	TokenNameIdentifier	 ends With
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separator	TokenNameIdentifier	 separator
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
l	TokenNameIdentifier	 l
+=	TokenNamePLUS_EQUAL	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separator	TokenNameIdentifier	 separator
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
l	TokenNameIdentifier	 l
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
p	TokenNameIdentifier	 p
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Learn whether one path "leads" another. * @param leading The leading path, must not be null, must be absolute. * @param path The path to remove from, must not be null, must be absolute. * @return true if path starts with leading; false otherwise. * @since Ant 1.7 */	TokenNameCOMMENT_JAVADOC	 Learn whether one path "leads" another. @param leading The leading path, must not be null, must be absolute. @param path The path to remove from, must not be null, must be absolute. @return true if path starts with leading; false otherwise. @since Ant 1.7 
public	TokenNamepublic	
boolean	TokenNameboolean	
isLeadingPath	TokenNameIdentifier	 is Leading Path
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
leading	TokenNameIdentifier	 leading
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
path	TokenNameIdentifier	 path
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
normalize	TokenNameIdentifier	 normalize
(	TokenNameLPAREN	
leading	TokenNameIdentifier	 leading
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
normalize	TokenNameIdentifier	 normalize
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
l	TokenNameIdentifier	 l
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// ensure that l ends with a / 	TokenNameCOMMENT_LINE	ensure that l ends with a / 
// so we never think /foo was a parent directory of /foobar 	TokenNameCOMMENT_LINE	so we never think /foo was a parent directory of /foobar 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
l	TokenNameIdentifier	 l
.	TokenNameDOT	
endsWith	TokenNameIdentifier	 ends With
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separator	TokenNameIdentifier	 separator
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
l	TokenNameIdentifier	 l
+=	TokenNamePLUS_EQUAL	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separator	TokenNameIdentifier	 separator
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Constructs a <code>file:</code> URI that represents the * external form of the given pathname. * * <p>Will be an absolute URI if the given path is absolute.</p> * * <p>This code encodes non ASCII characters too.</p> * * <p>The coding of the output is the same as what File.toURI().toASCIIString() produces</p> * * See <a href="http://www.w3.org/TR/xml11/#dt-sysid">dt-sysid</a> * which makes some mention of how * characters not supported by URI Reference syntax should be escaped. * * @param path the path in the local file system. * @return the URI version of the local path. * @since Ant 1.6 */	TokenNameCOMMENT_JAVADOC	 Constructs a <code>file:</code> URI that represents the external form of the given pathname. * <p>Will be an absolute URI if the given path is absolute.</p> * <p>This code encodes non ASCII characters too.</p> * <p>The coding of the output is the same as what File.toURI().toASCIIString() produces</p> * See <a href="http://www.w3.org/TR/xml11/#dt-sysid">dt-sysid</a> which makes some mention of how characters not supported by URI Reference syntax should be escaped. * @param path the path in the local file system. @return the URI version of the local path. @since Ant 1.6 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
toURI	TokenNameIdentifier	 to URI
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
path	TokenNameIdentifier	 path
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
)	TokenNameRPAREN	
.	TokenNameDOT	
getAbsoluteFile	TokenNameIdentifier	 get Absolute File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toURI	TokenNameIdentifier	 to URI
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toASCIIString	TokenNameIdentifier	 to ASCII String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Constructs a file path from a <code>file:</code> URI. * * <p>Will be an absolute path if the given URI is absolute.</p> * * <p>Swallows '%' that are not followed by two characters, * doesn't deal with non-ASCII characters.</p> * * @param uri the URI designating a file in the local filesystem. * @return the local file system path for the file. * @since Ant 1.6 */	TokenNameCOMMENT_JAVADOC	 Constructs a file path from a <code>file:</code> URI. * <p>Will be an absolute path if the given URI is absolute.</p> * <p>Swallows '%' that are not followed by two characters, doesn't deal with non-ASCII characters.</p> * @param uri the URI designating a file in the local filesystem. @return the local file system path for the file. @since Ant 1.6 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
fromURI	TokenNameIdentifier	 from URI
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
uri	TokenNameIdentifier	 uri
)	TokenNameRPAREN	
{	TokenNameLBRACE	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
cacheFromUriLock	TokenNameIdentifier	 cache From Uri Lock
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
uri	TokenNameIdentifier	 uri
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
cacheFromUriRequest	TokenNameIdentifier	 cache From Uri Request
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
cacheFromUriResponse	TokenNameIdentifier	 cache From Uri Response
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
path	TokenNameIdentifier	 path
=	TokenNameEQUAL	
Locator	TokenNameIdentifier	 Locator
.	TokenNameDOT	
fromURI	TokenNameIdentifier	 from URI
(	TokenNameLPAREN	
uri	TokenNameIdentifier	 uri
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
ret	TokenNameIdentifier	 ret
=	TokenNameEQUAL	
isAbsolutePath	TokenNameIdentifier	 is Absolute Path
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
)	TokenNameRPAREN	
?	TokenNameQUESTION	
normalize	TokenNameIdentifier	 normalize
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
)	TokenNameRPAREN	
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
path	TokenNameIdentifier	 path
;	TokenNameSEMICOLON	
cacheFromUriRequest	TokenNameIdentifier	 cache From Uri Request
=	TokenNameEQUAL	
uri	TokenNameIdentifier	 uri
;	TokenNameSEMICOLON	
cacheFromUriResponse	TokenNameIdentifier	 cache From Uri Response
=	TokenNameEQUAL	
ret	TokenNameIdentifier	 ret
;	TokenNameSEMICOLON	
return	TokenNamereturn	
ret	TokenNameIdentifier	 ret
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Compares two filenames. * * <p>Unlike java.io.File#equals this method will try to compare * the absolute paths and &quot;normalize&quot; the filenames * before comparing them.</p> * * @param f1 the file whose name is to be compared. * @param f2 the other file whose name is to be compared. * * @return true if the file are for the same file. * * @since Ant 1.5.3 */	TokenNameCOMMENT_JAVADOC	 Compares two filenames. * <p>Unlike java.io.File#equals this method will try to compare the absolute paths and &quot;normalize&quot; the filenames before comparing them.</p> * @param f1 the file whose name is to be compared. @param f2 the other file whose name is to be compared. * @return true if the file are for the same file. * @since Ant 1.5.3 
public	TokenNamepublic	
boolean	TokenNameboolean	
fileNameEquals	TokenNameIdentifier	 file Name Equals
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
f1	TokenNameIdentifier	 f1
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
f2	TokenNameIdentifier	 f2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
normalize	TokenNameIdentifier	 normalize
(	TokenNameLPAREN	
f1	TokenNameIdentifier	 f1
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
normalize	TokenNameIdentifier	 normalize
(	TokenNameLPAREN	
f2	TokenNameIdentifier	 f2
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Are the two File instances pointing to the same object on the * file system? * @since Ant 1.8.2 */	TokenNameCOMMENT_JAVADOC	 Are the two File instances pointing to the same object on the file system? @since Ant 1.8.2 
public	TokenNamepublic	
boolean	TokenNameboolean	
areSame	TokenNameIdentifier	 are Same
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
f1	TokenNameIdentifier	 f1
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
f2	TokenNameIdentifier	 f2
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
f1	TokenNameIdentifier	 f1
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
f2	TokenNameIdentifier	 f2
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
f1	TokenNameIdentifier	 f1
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
f2	TokenNameIdentifier	 f2
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
File	TokenNameIdentifier	 File
f1Normalized	TokenNameIdentifier	 f1 Normalized
=	TokenNameEQUAL	
normalize	TokenNameIdentifier	 normalize
(	TokenNameLPAREN	
f1	TokenNameIdentifier	 f1
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
f2Normalized	TokenNameIdentifier	 f2 Normalized
=	TokenNameEQUAL	
normalize	TokenNameIdentifier	 normalize
(	TokenNameLPAREN	
f2	TokenNameIdentifier	 f2
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
f1Normalized	TokenNameIdentifier	 f1 Normalized
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
f2Normalized	TokenNameIdentifier	 f2 Normalized
)	TokenNameRPAREN	
||	TokenNameOR_OR	
f1Normalized	TokenNameIdentifier	 f1 Normalized
.	TokenNameDOT	
getCanonicalFile	TokenNameIdentifier	 get Canonical File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
f2Normalized	TokenNameIdentifier	 f2 Normalized
.	TokenNameDOT	
getCanonicalFile	TokenNameIdentifier	 get Canonical File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Renames a file, even if that involves crossing file system boundaries. * * <p>This will remove <code>to</code> (if it exists), ensure that * <code>to</code>'s parent directory exists and move * <code>from</code>, which involves deleting <code>from</code> as * well.</p> * * @param from the file to move. * @param to the new file name. * * @throws IOException if anything bad happens during this * process. Note that <code>to</code> may have been deleted * already when this happens. * * @since Ant 1.6 */	TokenNameCOMMENT_JAVADOC	 Renames a file, even if that involves crossing file system boundaries. * <p>This will remove <code>to</code> (if it exists), ensure that <code>to</code>'s parent directory exists and move <code>from</code>, which involves deleting <code>from</code> as well.</p> * @param from the file to move. @param to the new file name. * @throws IOException if anything bad happens during this process. Note that <code>to</code> may have been deleted already when this happens. * @since Ant 1.6 
public	TokenNamepublic	
void	TokenNamevoid	
rename	TokenNameIdentifier	 rename
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
from	TokenNameIdentifier	 from
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
to	TokenNameIdentifier	 to
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// identical logic lives in Move.renameFile(): 	TokenNameCOMMENT_LINE	identical logic lives in Move.renameFile(): 
from	TokenNameIdentifier	 from
=	TokenNameEQUAL	
normalize	TokenNameIdentifier	 normalize
(	TokenNameLPAREN	
from	TokenNameIdentifier	 from
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getCanonicalFile	TokenNameIdentifier	 get Canonical File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
to	TokenNameIdentifier	 to
=	TokenNameEQUAL	
normalize	TokenNameIdentifier	 normalize
(	TokenNameLPAREN	
to	TokenNameIdentifier	 to
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
from	TokenNameIdentifier	 from
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Cannot rename nonexistent file "	TokenNameStringLiteral	Cannot rename nonexistent file 
+	TokenNamePLUS	
from	TokenNameIdentifier	 from
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
from	TokenNameIdentifier	 from
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
to	TokenNameIdentifier	 to
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Rename of "	TokenNameStringLiteral	Rename of 
+	TokenNamePLUS	
from	TokenNameIdentifier	 from
+	TokenNamePLUS	
" to "	TokenNameStringLiteral	 to 
+	TokenNamePLUS	
to	TokenNameIdentifier	 to
+	TokenNamePLUS	
" is a no-op."	TokenNameStringLiteral	 is a no-op.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
to	TokenNameIdentifier	 to
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
(	TokenNameLPAREN	
areSame	TokenNameIdentifier	 are Same
(	TokenNameLPAREN	
from	TokenNameIdentifier	 from
,	TokenNameCOMMA	
to	TokenNameIdentifier	 to
)	TokenNameRPAREN	
||	TokenNameOR_OR	
tryHardToDelete	TokenNameIdentifier	 try Hard To Delete
(	TokenNameLPAREN	
to	TokenNameIdentifier	 to
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IOException	TokenNameIdentifier	 IO Exception
(	TokenNameLPAREN	
"Failed to delete "	TokenNameStringLiteral	Failed to delete 
+	TokenNamePLUS	
to	TokenNameIdentifier	 to
+	TokenNamePLUS	
" while trying to rename "	TokenNameStringLiteral	 while trying to rename 
+	TokenNamePLUS	
from	TokenNameIdentifier	 from
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
File	TokenNameIdentifier	 File
parent	TokenNameIdentifier	 parent
=	TokenNameEQUAL	
to	TokenNameIdentifier	 to
.	TokenNameDOT	
getParentFile	TokenNameIdentifier	 get Parent File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
parent	TokenNameIdentifier	 parent
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
parent	TokenNameIdentifier	 parent
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
parent	TokenNameIdentifier	 parent
.	TokenNameDOT	
mkdirs	TokenNameIdentifier	 mkdirs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IOException	TokenNameIdentifier	 IO Exception
(	TokenNameLPAREN	
"Failed to create directory "	TokenNameStringLiteral	Failed to create directory 
+	TokenNamePLUS	
parent	TokenNameIdentifier	 parent
+	TokenNamePLUS	
" while trying to rename "	TokenNameStringLiteral	 while trying to rename 
+	TokenNamePLUS	
from	TokenNameIdentifier	 from
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
from	TokenNameIdentifier	 from
.	TokenNameDOT	
renameTo	TokenNameIdentifier	 rename To
(	TokenNameLPAREN	
to	TokenNameIdentifier	 to
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
from	TokenNameIdentifier	 from
,	TokenNameCOMMA	
to	TokenNameIdentifier	 to
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
tryHardToDelete	TokenNameIdentifier	 try Hard To Delete
(	TokenNameLPAREN	
from	TokenNameIdentifier	 from
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IOException	TokenNameIdentifier	 IO Exception
(	TokenNameLPAREN	
"Failed to delete "	TokenNameStringLiteral	Failed to delete 
+	TokenNamePLUS	
from	TokenNameIdentifier	 from
+	TokenNamePLUS	
" while trying to rename it."	TokenNameStringLiteral	 while trying to rename it.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Get the granularity of file timestamps. The choice is made based on OS, which is * incorrect--it should really be by filesystem. We do not have an easy way to probe for file * systems, however, so this heuristic gives us a decent default. * * @return the difference, in milliseconds, which two file timestamps must have in order for the * two files to be considered to have different timestamps. */	TokenNameCOMMENT_JAVADOC	 Get the granularity of file timestamps. The choice is made based on OS, which is incorrect--it should really be by filesystem. We do not have an easy way to probe for file systems, however, so this heuristic gives us a decent default. * @return the difference, in milliseconds, which two file timestamps must have in order for the two files to be considered to have different timestamps. 
public	TokenNamepublic	
long	TokenNamelong	
getFileTimestampGranularity	TokenNameIdentifier	 get File Timestamp Granularity
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ON_WIN9X	TokenNameIdentifier	 ON  WI N9 X
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
FAT_FILE_TIMESTAMP_GRANULARITY	TokenNameIdentifier	 FAT  FILE  TIMESTAMP  GRANULARITY
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ON_WINDOWS	TokenNameIdentifier	 ON  WINDOWS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
NTFS_FILE_TIMESTAMP_GRANULARITY	TokenNameIdentifier	 NTFS  FILE  TIMESTAMP  GRANULARITY
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ON_DOS	TokenNameIdentifier	 ON  DOS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
FAT_FILE_TIMESTAMP_GRANULARITY	TokenNameIdentifier	 FAT  FILE  TIMESTAMP  GRANULARITY
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
UNIX_FILE_TIMESTAMP_GRANULARITY	TokenNameIdentifier	 UNIX  FILE  TIMESTAMP  GRANULARITY
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * test whether a file or directory exists, with an error in the * upper/lower case spelling of the name. * Using this method is only interesting on case insensitive file systems * (Windows).<br/> * It will return true only if 3 conditions are met : * <br/> * <ul> * <li>operating system is case insensitive</li> * <li>file exists</li> * <li>actual name from directory reading is different from the * supplied argument</li> * </ul> * <br/> * the purpose is to identify files or directories on case-insensitive * filesystems whose case is not what is expected.<br/> * Possibly to rename them afterwards to the desired upper/lowercase * combination. * <br/> * @param localFile file to test * @return true if the file exists and the case of the actual file * is not the case of the parameter * @since Ant 1.7.1 */	TokenNameCOMMENT_JAVADOC	 test whether a file or directory exists, with an error in the upper/lower case spelling of the name. Using this method is only interesting on case insensitive file systems (Windows).<br/> It will return true only if 3 conditions are met : <br/> <ul> <li>operating system is case insensitive</li> <li>file exists</li> <li>actual name from directory reading is different from the supplied argument</li> </ul> <br/> the purpose is to identify files or directories on case-insensitive filesystems whose case is not what is expected.<br/> Possibly to rename them afterwards to the desired upper/lowercase combination. <br/> @param localFile file to test @return true if the file exists and the case of the actual file is not the case of the parameter @since Ant 1.7.1 
public	TokenNamepublic	
boolean	TokenNameboolean	
hasErrorInCase	TokenNameIdentifier	 has Error In Case
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
localFile	TokenNameIdentifier	 local File
)	TokenNameRPAREN	
{	TokenNameLBRACE	
localFile	TokenNameIdentifier	 local File
=	TokenNameEQUAL	
normalize	TokenNameIdentifier	 normalize
(	TokenNameLPAREN	
localFile	TokenNameIdentifier	 local File
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
localFile	TokenNameIdentifier	 local File
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
localFileName	TokenNameIdentifier	 local File Name
=	TokenNameEQUAL	
localFile	TokenNameIdentifier	 local File
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
FilenameFilter	TokenNameIdentifier	 Filename Filter
ff	TokenNameIdentifier	 ff
=	TokenNameEQUAL	
new	TokenNamenew	
FilenameFilter	TokenNameIdentifier	 Filename Filter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
accept	TokenNameIdentifier	 accept
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
equalsIgnoreCase	TokenNameIdentifier	 equals Ignore Case
(	TokenNameLPAREN	
localFileName	TokenNameIdentifier	 local File Name
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
!	TokenNameNOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
localFileName	TokenNameIdentifier	 local File Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
names	TokenNameIdentifier	 names
=	TokenNameEQUAL	
localFile	TokenNameIdentifier	 local File
.	TokenNameDOT	
getParentFile	TokenNameIdentifier	 get Parent File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
list	TokenNameIdentifier	 list
(	TokenNameLPAREN	
ff	TokenNameIdentifier	 ff
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
names	TokenNameIdentifier	 names
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
names	TokenNameIdentifier	 names
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns true if the source is older than the dest. * If the dest file does not exist, then the test returns false; it is * implicitly not up do date. * @param source source file (should be the older). * @param dest dest file (should be the newer). * @param granularity an offset added to the source time. * @return true if the source is older than the dest after accounting * for granularity. * @since Ant 1.6.3 */	TokenNameCOMMENT_JAVADOC	 Returns true if the source is older than the dest. If the dest file does not exist, then the test returns false; it is implicitly not up do date. @param source source file (should be the older). @param dest dest file (should be the newer). @param granularity an offset added to the source time. @return true if the source is older than the dest after accounting for granularity. @since Ant 1.6.3 
public	TokenNamepublic	
boolean	TokenNameboolean	
isUpToDate	TokenNameIdentifier	 is Up To Date
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
source	TokenNameIdentifier	 source
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
dest	TokenNameIdentifier	 dest
,	TokenNameCOMMA	
long	TokenNamelong	
granularity	TokenNameIdentifier	 granularity
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//do a check for the destination file existing 	TokenNameCOMMENT_LINE	do a check for the destination file existing 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
dest	TokenNameIdentifier	 dest
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//if it does not, then the file is not up to date. 	TokenNameCOMMENT_LINE	if it does not, then the file is not up to date. 
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
long	TokenNamelong	
sourceTime	TokenNameIdentifier	 source Time
=	TokenNameEQUAL	
source	TokenNameIdentifier	 source
.	TokenNameDOT	
lastModified	TokenNameIdentifier	 last Modified
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
destTime	TokenNameIdentifier	 dest Time
=	TokenNameEQUAL	
dest	TokenNameIdentifier	 dest
.	TokenNameDOT	
lastModified	TokenNameIdentifier	 last Modified
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
isUpToDate	TokenNameIdentifier	 is Up To Date
(	TokenNameLPAREN	
sourceTime	TokenNameIdentifier	 source Time
,	TokenNameCOMMA	
destTime	TokenNameIdentifier	 dest Time
,	TokenNameCOMMA	
granularity	TokenNameIdentifier	 granularity
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns true if the source is older than the dest. * @param source source file (should be the older). * @param dest dest file (should be the newer). * @return true if the source is older than the dest, taking the granularity into account. * @since Ant 1.6.3 */	TokenNameCOMMENT_JAVADOC	 Returns true if the source is older than the dest. @param source source file (should be the older). @param dest dest file (should be the newer). @return true if the source is older than the dest, taking the granularity into account. @since Ant 1.6.3 
public	TokenNamepublic	
boolean	TokenNameboolean	
isUpToDate	TokenNameIdentifier	 is Up To Date
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
source	TokenNameIdentifier	 source
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
dest	TokenNameIdentifier	 dest
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
isUpToDate	TokenNameIdentifier	 is Up To Date
(	TokenNameLPAREN	
source	TokenNameIdentifier	 source
,	TokenNameCOMMA	
dest	TokenNameIdentifier	 dest
,	TokenNameCOMMA	
getFileTimestampGranularity	TokenNameIdentifier	 get File Timestamp Granularity
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Compare two timestamps for being up to date using * the specified granularity. * * @param sourceTime timestamp of source file. * @param destTime timestamp of dest file. * @param granularity os/filesys granularity. * @return true if the dest file is considered up to date. */	TokenNameCOMMENT_JAVADOC	 Compare two timestamps for being up to date using the specified granularity. * @param sourceTime timestamp of source file. @param destTime timestamp of dest file. @param granularity os/filesys granularity. @return true if the dest file is considered up to date. 
public	TokenNamepublic	
boolean	TokenNameboolean	
isUpToDate	TokenNameIdentifier	 is Up To Date
(	TokenNameLPAREN	
long	TokenNamelong	
sourceTime	TokenNameIdentifier	 source Time
,	TokenNameCOMMA	
long	TokenNamelong	
destTime	TokenNameIdentifier	 dest Time
,	TokenNameCOMMA	
long	TokenNamelong	
granularity	TokenNameIdentifier	 granularity
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
destTime	TokenNameIdentifier	 dest Time
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
destTime	TokenNameIdentifier	 dest Time
>=	TokenNameGREATER_EQUAL	
sourceTime	TokenNameIdentifier	 source Time
+	TokenNamePLUS	
granularity	TokenNameIdentifier	 granularity
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Compare two timestamps for being up to date using the * current granularity. * * @param sourceTime timestamp of source file. * @param destTime timestamp of dest file. * @return true if the dest file is considered up to date. */	TokenNameCOMMENT_JAVADOC	 Compare two timestamps for being up to date using the current granularity. * @param sourceTime timestamp of source file. @param destTime timestamp of dest file. @return true if the dest file is considered up to date. 
public	TokenNamepublic	
boolean	TokenNameboolean	
isUpToDate	TokenNameIdentifier	 is Up To Date
(	TokenNameLPAREN	
long	TokenNamelong	
sourceTime	TokenNameIdentifier	 source Time
,	TokenNameCOMMA	
long	TokenNamelong	
destTime	TokenNameIdentifier	 dest Time
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
isUpToDate	TokenNameIdentifier	 is Up To Date
(	TokenNameLPAREN	
sourceTime	TokenNameIdentifier	 source Time
,	TokenNameCOMMA	
destTime	TokenNameIdentifier	 dest Time
,	TokenNameCOMMA	
getFileTimestampGranularity	TokenNameIdentifier	 get File Timestamp Granularity
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Close a Writer without throwing any exception if something went wrong. * Do not attempt to close it if the argument is null. * @param device output writer, can be null. */	TokenNameCOMMENT_JAVADOC	 Close a Writer without throwing any exception if something went wrong. Do not attempt to close it if the argument is null. @param device output writer, can be null. 
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
Writer	TokenNameIdentifier	 Writer
device	TokenNameIdentifier	 device
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
device	TokenNameIdentifier	 device
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
device	TokenNameIdentifier	 device
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//ignore 	TokenNameCOMMENT_LINE	ignore 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Close a Reader without throwing any exception if something went wrong. * Do not attempt to close it if the argument is null. * * @param device Reader, can be null. */	TokenNameCOMMENT_JAVADOC	 Close a Reader without throwing any exception if something went wrong. Do not attempt to close it if the argument is null. * @param device Reader, can be null. 
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
Reader	TokenNameIdentifier	 Reader
device	TokenNameIdentifier	 device
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
device	TokenNameIdentifier	 device
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
device	TokenNameIdentifier	 device
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//ignore 	TokenNameCOMMENT_LINE	ignore 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Close a stream without throwing any exception if something went wrong. * Do not attempt to close it if the argument is null. * * @param device stream, can be null. */	TokenNameCOMMENT_JAVADOC	 Close a stream without throwing any exception if something went wrong. Do not attempt to close it if the argument is null. * @param device stream, can be null. 
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
OutputStream	TokenNameIdentifier	 Output Stream
device	TokenNameIdentifier	 device
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
device	TokenNameIdentifier	 device
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
device	TokenNameIdentifier	 device
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//ignore 	TokenNameCOMMENT_LINE	ignore 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Close a stream without throwing any exception if something went wrong. * Do not attempt to close it if the argument is null. * * @param device stream, can be null. */	TokenNameCOMMENT_JAVADOC	 Close a stream without throwing any exception if something went wrong. Do not attempt to close it if the argument is null. * @param device stream, can be null. 
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
InputStream	TokenNameIdentifier	 Input Stream
device	TokenNameIdentifier	 device
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
device	TokenNameIdentifier	 device
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
device	TokenNameIdentifier	 device
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//ignore 	TokenNameCOMMENT_LINE	ignore 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Close a Channel without throwing any exception if something went wrong. * Do not attempt to close it if the argument is null. * * @param device channel, can be null. * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Close a Channel without throwing any exception if something went wrong. Do not attempt to close it if the argument is null. * @param device channel, can be null. @since Ant 1.8.0 
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
Channel	TokenNameIdentifier	 Channel
device	TokenNameIdentifier	 device
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
device	TokenNameIdentifier	 device
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
device	TokenNameIdentifier	 device
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//ignore 	TokenNameCOMMENT_LINE	ignore 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Closes an URLConnection if its concrete implementation provides * a way to close it that Ant knows of. * * @param conn connection, can be null * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Closes an URLConnection if its concrete implementation provides a way to close it that Ant knows of. * @param conn connection, can be null @since Ant 1.8.0 
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
URLConnection	TokenNameIdentifier	 URL Connection
conn	TokenNameIdentifier	 conn
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
conn	TokenNameIdentifier	 conn
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
conn	TokenNameIdentifier	 conn
instanceof	TokenNameinstanceof	
JarURLConnection	TokenNameIdentifier	 Jar URL Connection
)	TokenNameRPAREN	
{	TokenNameLBRACE	
JarURLConnection	TokenNameIdentifier	 Jar URL Connection
juc	TokenNameIdentifier	 juc
=	TokenNameEQUAL	
(	TokenNameLPAREN	
JarURLConnection	TokenNameIdentifier	 Jar URL Connection
)	TokenNameRPAREN	
conn	TokenNameIdentifier	 conn
;	TokenNameSEMICOLON	
JarFile	TokenNameIdentifier	 Jar File
jf	TokenNameIdentifier	 jf
=	TokenNameEQUAL	
juc	TokenNameIdentifier	 juc
.	TokenNameDOT	
getJarFile	TokenNameIdentifier	 get Jar File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jf	TokenNameIdentifier	 jf
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jf	TokenNameIdentifier	 jf
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
conn	TokenNameIdentifier	 conn
instanceof	TokenNameinstanceof	
HttpURLConnection	TokenNameIdentifier	 Http URL Connection
)	TokenNameRPAREN	
{	TokenNameLBRACE	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
HttpURLConnection	TokenNameIdentifier	 Http URL Connection
)	TokenNameRPAREN	
conn	TokenNameIdentifier	 conn
)	TokenNameRPAREN	
.	TokenNameDOT	
disconnect	TokenNameIdentifier	 disconnect
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
exc	TokenNameIdentifier	 exc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//ignore 	TokenNameCOMMENT_LINE	ignore 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Delete the file with {@link File#delete()} if the argument is not null. * Do nothing on a null argument. * @param file file to delete. */	TokenNameCOMMENT_JAVADOC	 Delete the file with {@link File#delete()} if the argument is not null. Do nothing on a null argument. @param file file to delete. 
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
delete	TokenNameIdentifier	 delete
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
delete	TokenNameIdentifier	 delete
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Accommodate Windows bug encountered in both Sun and IBM JDKs. * Others possible. If the delete does not work, call System.gc(), * wait a little and try again. * * @return whether deletion was successful * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Accommodate Windows bug encountered in both Sun and IBM JDKs. Others possible. If the delete does not work, call System.gc(), wait a little and try again. * @return whether deletion was successful @since Ant 1.8.0 
public	TokenNamepublic	
boolean	TokenNameboolean	
tryHardToDelete	TokenNameIdentifier	 try Hard To Delete
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
f	TokenNameIdentifier	 f
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
tryHardToDelete	TokenNameIdentifier	 try Hard To Delete
(	TokenNameLPAREN	
f	TokenNameIdentifier	 f
,	TokenNameCOMMA	
ON_WINDOWS	TokenNameIdentifier	 ON  WINDOWS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * If delete does not work, call System.gc() if asked to, wait a * little and try again. * * @return whether deletion was successful * @since Ant 1.8.3 */	TokenNameCOMMENT_JAVADOC	 If delete does not work, call System.gc() if asked to, wait a little and try again. * @return whether deletion was successful @since Ant 1.8.3 
public	TokenNamepublic	
boolean	TokenNameboolean	
tryHardToDelete	TokenNameIdentifier	 try Hard To Delete
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
f	TokenNameIdentifier	 f
,	TokenNameCOMMA	
boolean	TokenNameboolean	
runGC	TokenNameIdentifier	 run GC
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
f	TokenNameIdentifier	 f
.	TokenNameDOT	
delete	TokenNameIdentifier	 delete
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
runGC	TokenNameIdentifier	 run GC
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
gc	TokenNameIdentifier	 gc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
sleep	TokenNameIdentifier	 sleep
(	TokenNameLPAREN	
DELETE_RETRY_SLEEP_MILLIS	TokenNameIdentifier	 DELETE  RETRY  SLEEP  MILLIS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Ignore Exception 	TokenNameCOMMENT_LINE	Ignore Exception 
}	TokenNameRBRACE	
return	TokenNamereturn	
f	TokenNameIdentifier	 f
.	TokenNameDOT	
delete	TokenNameIdentifier	 delete
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Calculates the relative path between two files. * <p> * Implementation note:<br/> This function may throw an IOException if an I/O error occurs * because its use of the canonical pathname may require filesystem queries. * </p> * * @param fromFile the <code>File</code> to calculate the path from * @param toFile the <code>File</code> to calculate the path to * @return the relative path between the files * @throws Exception for undocumented reasons * @see File#getCanonicalPath() * * @since Ant 1.7 */	TokenNameCOMMENT_JAVADOC	 Calculates the relative path between two files. <p> Implementation note:<br/> This function may throw an IOException if an I/O error occurs because its use of the canonical pathname may require filesystem queries. </p> * @param fromFile the <code>File</code> to calculate the path from @param toFile the <code>File</code> to calculate the path to @return the relative path between the files @throws Exception for undocumented reasons @see File#getCanonicalPath() * @since Ant 1.7 
public	TokenNamepublic	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
getRelativePath	TokenNameIdentifier	 get Relative Path
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
fromFile	TokenNameIdentifier	 from File
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
toFile	TokenNameIdentifier	 to File
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
fromPath	TokenNameIdentifier	 from Path
=	TokenNameEQUAL	
fromFile	TokenNameIdentifier	 from File
.	TokenNameDOT	
getCanonicalPath	TokenNameIdentifier	 get Canonical Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
toPath	TokenNameIdentifier	 to Path
=	TokenNameEQUAL	
toFile	TokenNameIdentifier	 to File
.	TokenNameDOT	
getCanonicalPath	TokenNameIdentifier	 get Canonical Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// build the path stack info to compare 	TokenNameCOMMENT_LINE	build the path stack info to compare 
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fromPathStack	TokenNameIdentifier	 from Path Stack
=	TokenNameEQUAL	
getPathStack	TokenNameIdentifier	 get Path Stack
(	TokenNameLPAREN	
fromPath	TokenNameIdentifier	 from Path
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
toPathStack	TokenNameIdentifier	 to Path Stack
=	TokenNameEQUAL	
getPathStack	TokenNameIdentifier	 get Path Stack
(	TokenNameLPAREN	
toPath	TokenNameIdentifier	 to Path
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
<	TokenNameLESS	
toPathStack	TokenNameIdentifier	 to Path Stack
.	TokenNameDOT	
length	TokenNameIdentifier	 length
&&	TokenNameAND_AND	
0	TokenNameIntegerLiteral	
<	TokenNameLESS	
fromPathStack	TokenNameIdentifier	 from Path Stack
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fromPathStack	TokenNameIdentifier	 from Path Stack
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
toPathStack	TokenNameIdentifier	 to Path Stack
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// not the same device (would be "" on Linux/Unix) 	TokenNameCOMMENT_LINE	not the same device (would be "" on Linux/Unix) 
return	TokenNamereturn	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
asList	TokenNameIdentifier	 as List
(	TokenNameLPAREN	
toPathStack	TokenNameIdentifier	 to Path Stack
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// no comparison possible 	TokenNameCOMMENT_LINE	no comparison possible 
return	TokenNamereturn	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
asList	TokenNameIdentifier	 as List
(	TokenNameLPAREN	
toPathStack	TokenNameIdentifier	 to Path Stack
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
minLength	TokenNameIdentifier	 min Length
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
min	TokenNameIdentifier	 min
(	TokenNameLPAREN	
fromPathStack	TokenNameIdentifier	 from Path Stack
.	TokenNameDOT	
length	TokenNameIdentifier	 length
,	TokenNameCOMMA	
toPathStack	TokenNameIdentifier	 to Path Stack
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
same	TokenNameIdentifier	 same
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Used outside the for loop 	TokenNameCOMMENT_LINE	Used outside the for loop 
// get index of parts which are equal 	TokenNameCOMMENT_LINE	get index of parts which are equal 
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
same	TokenNameIdentifier	 same
<	TokenNameLESS	
minLength	TokenNameIdentifier	 min Length
&&	TokenNameAND_AND	
fromPathStack	TokenNameIdentifier	 from Path Stack
[	TokenNameLBRACKET	
same	TokenNameIdentifier	 same
]	TokenNameRBRACKET	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
toPathStack	TokenNameIdentifier	 to Path Stack
[	TokenNameLBRACKET	
same	TokenNameIdentifier	 same
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
same	TokenNameIdentifier	 same
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Do nothing 	TokenNameCOMMENT_LINE	Do nothing 
}	TokenNameRBRACE	
List	TokenNameIdentifier	 List
relativePathStack	TokenNameIdentifier	 relative Path Stack
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// if "from" part is longer, fill it up with ".." 	TokenNameCOMMENT_LINE	if "from" part is longer, fill it up with ".." 
// to reach path which is equal to both paths 	TokenNameCOMMENT_LINE	to reach path which is equal to both paths 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
same	TokenNameIdentifier	 same
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fromPathStack	TokenNameIdentifier	 from Path Stack
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
relativePathStack	TokenNameIdentifier	 relative Path Stack
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
".."	TokenNameStringLiteral	..
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// fill it up path with parts which were not equal 	TokenNameCOMMENT_LINE	fill it up path with parts which were not equal 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
same	TokenNameIdentifier	 same
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
toPathStack	TokenNameIdentifier	 to Path Stack
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
relativePathStack	TokenNameIdentifier	 relative Path Stack
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
toPathStack	TokenNameIdentifier	 to Path Stack
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
relativePathStack	TokenNameIdentifier	 relative Path Stack
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Gets all names of the path as an array of <code>String</code>s. * * @param path to get names from * @return <code>String</code>s, never <code>null</code> * * @since Ant 1.7 */	TokenNameCOMMENT_JAVADOC	 Gets all names of the path as an array of <code>String</code>s. * @param path to get names from @return <code>String</code>s, never <code>null</code> * @since Ant 1.7 
public	TokenNamepublic	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getPathStack	TokenNameIdentifier	 get Path Stack
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
path	TokenNameIdentifier	 path
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
normalizedPath	TokenNameIdentifier	 normalized Path
=	TokenNameEQUAL	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separatorChar	TokenNameIdentifier	 separator Char
,	TokenNameCOMMA	
'/'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
normalizedPath	TokenNameIdentifier	 normalized Path
.	TokenNameDOT	
split	TokenNameIdentifier	 split
(	TokenNameLPAREN	
"/"	TokenNameStringLiteral	/
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Gets path from a <code>List</code> of <code>String</code>s. * * @param pathStack <code>List</code> of <code>String</code>s to be concatenated as a path. * @return <code>String</code>, never <code>null</code> * * @since Ant 1.7 */	TokenNameCOMMENT_JAVADOC	 Gets path from a <code>List</code> of <code>String</code>s. * @param pathStack <code>List</code> of <code>String</code>s to be concatenated as a path. @return <code>String</code>, never <code>null</code> * @since Ant 1.7 
public	TokenNamepublic	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
pathStack	TokenNameIdentifier	 path Stack
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// can safely use '/' because Windows understands '/' as separator 	TokenNameCOMMENT_LINE	can safely use '/' because Windows understands '/' as separator 
return	TokenNamereturn	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
pathStack	TokenNameIdentifier	 path Stack
,	TokenNameCOMMA	
'/'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Gets path from a <code>List</code> of <code>String</code>s. * * @param pathStack <code>List</code> of <code>String</code>s to be concated as a path. * @param separatorChar <code>char</code> to be used as separator between names in path * @return <code>String</code>, never <code>null</code> * * @since Ant 1.7 */	TokenNameCOMMENT_JAVADOC	 Gets path from a <code>List</code> of <code>String</code>s. * @param pathStack <code>List</code> of <code>String</code>s to be concated as a path. @param separatorChar <code>char</code> to be used as separator between names in path @return <code>String</code>, never <code>null</code> * @since Ant 1.7 
public	TokenNamepublic	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
pathStack	TokenNameIdentifier	 path Stack
,	TokenNameCOMMA	
final	TokenNamefinal	
char	TokenNamechar	
separatorChar	TokenNameIdentifier	 separator Char
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
StringBuffer	TokenNameIdentifier	 String Buffer
buffer	TokenNameIdentifier	 buffer
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Iterator	TokenNameIdentifier	 Iterator
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
pathStack	TokenNameIdentifier	 path Stack
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
separatorChar	TokenNameIdentifier	 separator Char
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the default encoding. * This is done by opening an InputStreamReader on * a dummy InputStream and getting the encoding. * Could use System.getProperty("file.encoding"), but cannot * see where this is documented. * @return the default file encoding. */	TokenNameCOMMENT_JAVADOC	 Get the default encoding. This is done by opening an InputStreamReader on a dummy InputStream and getting the encoding. Could use System.getProperty("file.encoding"), but cannot see where this is documented. @return the default file encoding. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getDefaultEncoding	TokenNameIdentifier	 get Default Encoding
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
InputStreamReader	TokenNameIdentifier	 Input Stream Reader
is	TokenNameIdentifier	 is
=	TokenNameEQUAL	
new	TokenNamenew	
InputStreamReader	TokenNameIdentifier	 Input Stream Reader
(	TokenNameLPAREN	
new	TokenNamenew	
InputStream	TokenNameIdentifier	 Input Stream
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
int	TokenNameint	
read	TokenNameIdentifier	 read
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
return	TokenNamereturn	
is	TokenNameIdentifier	 is
.	TokenNameDOT	
getEncoding	TokenNameIdentifier	 get Encoding
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
