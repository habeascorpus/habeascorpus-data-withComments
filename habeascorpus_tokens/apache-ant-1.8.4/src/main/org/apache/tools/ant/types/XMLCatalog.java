/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
reflect	TokenNameIdentifier	 reflect
.	TokenNameDOT	
Method	TokenNameIdentifier	 Method
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
File	TokenNameIdentifier	 File
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
FileInputStream	TokenNameIdentifier	 File Input Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
InputStream	TokenNameIdentifier	 Input Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
net	TokenNameIdentifier	 net
.	TokenNameDOT	
MalformedURLException	TokenNameIdentifier	 Malformed URL Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
net	TokenNameIdentifier	 net
.	TokenNameDOT	
URL	TokenNameIdentifier	 URL
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Enumeration	TokenNameIdentifier	 Enumeration
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Stack	TokenNameIdentifier	 Stack
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Vector	TokenNameIdentifier	 Vector
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
parsers	TokenNameIdentifier	 parsers
.	TokenNameDOT	
ParserConfigurationException	TokenNameIdentifier	 Parser Configuration Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
parsers	TokenNameIdentifier	 parsers
.	TokenNameDOT	
SAXParserFactory	TokenNameIdentifier	 SAX Parser Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
Source	TokenNameIdentifier	 Source
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
TransformerException	TokenNameIdentifier	 Transformer Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
URIResolver	TokenNameIdentifier	 URI Resolver
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
SAXSource	TokenNameIdentifier	 SAX Source
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
AntClassLoader	TokenNameIdentifier	 Ant Class Loader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
BuildException	TokenNameIdentifier	 Build Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
Project	TokenNameIdentifier	 Project
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
FileUtils	TokenNameIdentifier	 File Utils
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
JAXPUtils	TokenNameIdentifier	 JAXP Utils
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
EntityResolver	TokenNameIdentifier	 Entity Resolver
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
InputSource	TokenNameIdentifier	 Input Source
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
SAXException	TokenNameIdentifier	 SAX Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
XMLReader	TokenNameIdentifier	 XML Reader
;	TokenNameSEMICOLON	
/** * <p>This data type provides a catalog of resource locations (such as * DTDs and XML entities), based on the <a * href="http://oasis-open.org/committees/entity/spec-2001-08-06.html"> * OASIS "Open Catalog" standard</a>. The catalog entries are used * both for Entity resolution and URI resolution, in accordance with * the {@link org.xml.sax.EntityResolver EntityResolver} and {@link * javax.xml.transform.URIResolver URIResolver} interfaces as defined * in the <a href="http://java.sun.com/xml/jaxp">Java API for XML * Processing Specification</a>.</p> * * <p>Resource locations can be specified either in-line or in * external catalog file(s), or both. In order to use an external * catalog file, the xml-commons resolver library ("resolver.jar") * must be in your classpath. External catalog files may be either <a * href="http://oasis-open.org/committees/entity/background/9401.html"> * plain text format</a> or <a * href="http://www.oasis-open.org/committees/entity/spec-2001-08-06.html"> * XML format</a>. If the xml-commons resolver library is not found * in the classpath, external catalog files, specified in * <code>&lt;catalogpath&gt;</code> paths, will be ignored and a warning will * be logged. In this case, however, processing of inline entries will proceed * normally.</p> * * <p>Currently, only <code>&lt;dtd&gt;</code> and * <code>&lt;entity&gt;</code> elements may be specified inline; these * correspond to OASIS catalog entry types <code>PUBLIC</code> and * <code>URI</code> respectively.</p> * * <p>The following is a usage example:</p> * * <code> * &lt;xmlcatalog&gt;<br> * &nbsp;&nbsp;&lt;dtd publicId="" location="/path/to/file.jar" /&gt;<br> * &nbsp;&nbsp;&lt;dtd publicId="" location="/path/to/file2.jar" /&gt;<br> * &nbsp;&nbsp;&lt;entity publicId="" location="/path/to/file3.jar" /&gt;<br> * &nbsp;&nbsp;&lt;entity publicId="" location="/path/to/file4.jar" /&gt;<br> * &nbsp;&nbsp;&lt;catalogpath&gt;<br> * &nbsp;&nbsp;&nbsp;&nbsp;&lt;pathelement location="/etc/sgml/catalog"/&gt;<br> * &nbsp;&nbsp;&lt;/catalogpath&gt;<br> * &nbsp;&nbsp;&lt;catalogfiles dir="/opt/catalogs/" includes="**\catalog.xml" /&gt;<br> * &lt;/xmlcatalog&gt;<br> * </code> * <p> * Tasks wishing to use <code>&lt;xmlcatalog&gt;</code> must provide a method called * <code>createXMLCatalog</code> which returns an instance of * <code>XMLCatalog</code>. Nested DTD and entity definitions are handled by * the XMLCatalog object and must be labeled <code>dtd</code> and * <code>entity</code> respectively.</p> * * <p>The following is a description of the resolution algorithm: * entities/URIs/dtds are looked up in each of the following contexts, * stopping when a valid and readable resource is found: * <ol> * <li>In the local filesystem</li> * <li>In the classpath</li> * <li>Using the Apache xml-commons resolver (if it is available)</li> * <li>In URL-space</li> * </ol> * </p> * * <p>See {@link * org.apache.tools.ant.taskdefs.optional.XMLValidateTask * XMLValidateTask} for an example of a task that has integrated * support for XMLCatalogs.</p> * * <p>Possible future extension could provide for additional OASIS * entry types to be specified inline.</p> * */	TokenNameCOMMENT_JAVADOC	 <p>This data type provides a catalog of resource locations (such as DTDs and XML entities), based on the <a href="http://oasis-open.org/committees/entity/spec-2001-08-06.html"> OASIS "Open Catalog" standard</a>. The catalog entries are used both for Entity resolution and URI resolution, in accordance with the {@link org.xml.sax.EntityResolver EntityResolver} and {@link javax.xml.transform.URIResolver URIResolver} interfaces as defined in the <a href="http://java.sun.com/xml/jaxp">Java API for XML Processing Specification</a>.</p> * <p>Resource locations can be specified either in-line or in external catalog file(s), or both. In order to use an external catalog file, the xml-commons resolver library ("resolver.jar") must be in your classpath. External catalog files may be either <a href="http://oasis-open.org/committees/entity/background/9401.html"> plain text format</a> or <a href="http://www.oasis-open.org/committees/entity/spec-2001-08-06.html"> XML format</a>. If the xml-commons resolver library is not found in the classpath, external catalog files, specified in <code>&lt;catalogpath&gt;</code> paths, will be ignored and a warning will be logged. In this case, however, processing of inline entries will proceed normally.</p> * <p>Currently, only <code>&lt;dtd&gt;</code> and <code>&lt;entity&gt;</code> elements may be specified inline; these correspond to OASIS catalog entry types <code>PUBLIC</code> and <code>URI</code> respectively.</p> * <p>The following is a usage example:</p> * <code> &lt;xmlcatalog&gt;<br> &nbsp;&nbsp;&lt;dtd publicId="" location="/path/to/file.jar" /&gt;<br> &nbsp;&nbsp;&lt;dtd publicId="" location="/path/to/file2.jar" /&gt;<br> &nbsp;&nbsp;&lt;entity publicId="" location="/path/to/file3.jar" /&gt;<br> &nbsp;&nbsp;&lt;entity publicId="" location="/path/to/file4.jar" /&gt;<br> &nbsp;&nbsp;&lt;catalogpath&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&lt;pathelement location="/etc/sgml/catalog"/&gt;<br> &nbsp;&nbsp;&lt;/catalogpath&gt;<br> &nbsp;&nbsp;&lt;catalogfiles dir="/opt/catalogs/" includes="**\catalog.xml" /&gt;<br> &lt;/xmlcatalog&gt;<br> </code> <p> Tasks wishing to use <code>&lt;xmlcatalog&gt;</code> must provide a method called <code>createXMLCatalog</code> which returns an instance of <code>XMLCatalog</code>. Nested DTD and entity definitions are handled by the XMLCatalog object and must be labeled <code>dtd</code> and <code>entity</code> respectively.</p> * <p>The following is a description of the resolution algorithm: entities/URIs/dtds are looked up in each of the following contexts, stopping when a valid and readable resource is found: <ol> <li>In the local filesystem</li> <li>In the classpath</li> <li>Using the Apache xml-commons resolver (if it is available)</li> <li>In URL-space</li> </ol> </p> * <p>See {@link org.apache.tools.ant.taskdefs.optional.XMLValidateTask XMLValidateTask} for an example of a task that has integrated support for XMLCatalogs.</p> * <p>Possible future extension could provide for additional OASIS entry types to be specified inline.</p> 
public	TokenNamepublic	
class	TokenNameclass	
XMLCatalog	TokenNameIdentifier	 XML Catalog
extends	TokenNameextends	
DataType	TokenNameIdentifier	 Data Type
implements	TokenNameimplements	
Cloneable	TokenNameIdentifier	 Cloneable
,	TokenNameCOMMA	
EntityResolver	TokenNameIdentifier	 Entity Resolver
,	TokenNameCOMMA	
URIResolver	TokenNameIdentifier	 URI Resolver
{	TokenNameLBRACE	
/** helper for some File.toURL connversions */	TokenNameCOMMENT_JAVADOC	 helper for some File.toURL connversions 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
FileUtils	TokenNameIdentifier	 File Utils
FILE_UTILS	TokenNameIdentifier	 FILE  UTILS
=	TokenNameEQUAL	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
getFileUtils	TokenNameIdentifier	 get File Utils
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//-- Fields ---------------------------------------------------------------- 	TokenNameCOMMENT_LINE	-- Fields ---------------------------------------------------------------- 
/** Holds dtd/entity objects until needed. */	TokenNameCOMMENT_JAVADOC	 Holds dtd/entity objects until needed. 
private	TokenNameprivate	
Vector	TokenNameIdentifier	 Vector
elements	TokenNameIdentifier	 elements
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Classpath in which to attempt to resolve resources. */	TokenNameCOMMENT_JAVADOC	 Classpath in which to attempt to resolve resources. 
private	TokenNameprivate	
Path	TokenNameIdentifier	 Path
classpath	TokenNameIdentifier	 classpath
;	TokenNameSEMICOLON	
/** * Path listing external catalog files to search when resolving entities */	TokenNameCOMMENT_JAVADOC	 Path listing external catalog files to search when resolving entities 
private	TokenNameprivate	
Path	TokenNameIdentifier	 Path
catalogPath	TokenNameIdentifier	 catalog Path
;	TokenNameSEMICOLON	
/** * The name of the bridge to the Apache xml-commons resolver * class, used to determine whether resolver.jar is present in the * classpath. */	TokenNameCOMMENT_JAVADOC	 The name of the bridge to the Apache xml-commons resolver class, used to determine whether resolver.jar is present in the classpath. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
APACHE_RESOLVER	TokenNameIdentifier	 APACHE  RESOLVER
=	TokenNameEQUAL	
"org.apache.tools.ant.types.resolver.ApacheCatalogResolver"	TokenNameStringLiteral	org.apache.tools.ant.types.resolver.ApacheCatalogResolver
;	TokenNameSEMICOLON	
/** * Resolver base class */	TokenNameCOMMENT_JAVADOC	 Resolver base class 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
CATALOG_RESOLVER	TokenNameIdentifier	 CATALOG  RESOLVER
=	TokenNameEQUAL	
"org.apache.xml.resolver.tools.CatalogResolver"	TokenNameStringLiteral	org.apache.xml.resolver.tools.CatalogResolver
;	TokenNameSEMICOLON	
//-- Methods --------------------------------------------------------------- 	TokenNameCOMMENT_LINE	-- Methods --------------------------------------------------------------- 
/** * Default constructor */	TokenNameCOMMENT_JAVADOC	 Default constructor 
public	TokenNamepublic	
XMLCatalog	TokenNameIdentifier	 XML Catalog
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
setChecked	TokenNameIdentifier	 set Checked
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the elements of the catalog - ResourceLocation objects. * * @return the elements of the catalog - ResourceLocation objects */	TokenNameCOMMENT_JAVADOC	 Returns the elements of the catalog - ResourceLocation objects. * @return the elements of the catalog - ResourceLocation objects 
private	TokenNameprivate	
Vector	TokenNameIdentifier	 Vector
getElements	TokenNameIdentifier	 get Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getRef	TokenNameIdentifier	 get Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
elements	TokenNameIdentifier	 elements
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the classpath in which to attempt to resolve resources. * * @return the classpath */	TokenNameCOMMENT_JAVADOC	 Returns the classpath in which to attempt to resolve resources. * @return the classpath 
private	TokenNameprivate	
Path	TokenNameIdentifier	 Path
getClasspath	TokenNameIdentifier	 get Classpath
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getRef	TokenNameIdentifier	 get Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
classpath	TokenNameIdentifier	 classpath
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Allows nested classpath elements. Not allowed if this catalog * is itself a reference to another catalog -- that is, a catalog * cannot both refer to another <em>and</em> contain elements or * other attributes. * * @return a Path instance to be configured. */	TokenNameCOMMENT_JAVADOC	 Allows nested classpath elements. Not allowed if this catalog is itself a reference to another catalog -- that is, a catalog cannot both refer to another <em>and</em> contain elements or other attributes. * @return a Path instance to be configured. 
public	TokenNamepublic	
Path	TokenNameIdentifier	 Path
createClasspath	TokenNameIdentifier	 create Classpath
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isReference	TokenNameIdentifier	 is Reference
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
noChildrenAllowed	TokenNameIdentifier	 no Children Allowed
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
classpath	TokenNameIdentifier	 classpath
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
classpath	TokenNameIdentifier	 classpath
=	TokenNameEQUAL	
new	TokenNamenew	
Path	TokenNameIdentifier	 Path
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
setChecked	TokenNameIdentifier	 set Checked
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
this	TokenNamethis	
.	TokenNameDOT	
classpath	TokenNameIdentifier	 classpath
.	TokenNameDOT	
createPath	TokenNameIdentifier	 create Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Allows simple classpath string. Not allowed if this catalog is * itself a reference to another catalog -- that is, a catalog * cannot both refer to another <em>and</em> contain elements or * other attributes. * * @param classpath the classpath to use to look up entities. */	TokenNameCOMMENT_JAVADOC	 Allows simple classpath string. Not allowed if this catalog is itself a reference to another catalog -- that is, a catalog cannot both refer to another <em>and</em> contain elements or other attributes. * @param classpath the classpath to use to look up entities. 
public	TokenNamepublic	
void	TokenNamevoid	
setClasspath	TokenNameIdentifier	 set Classpath
(	TokenNameLPAREN	
Path	TokenNameIdentifier	 Path
classpath	TokenNameIdentifier	 classpath
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isReference	TokenNameIdentifier	 is Reference
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
tooManyAttributes	TokenNameIdentifier	 too Many Attributes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
classpath	TokenNameIdentifier	 classpath
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
classpath	TokenNameIdentifier	 classpath
=	TokenNameEQUAL	
classpath	TokenNameIdentifier	 classpath
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
classpath	TokenNameIdentifier	 classpath
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
classpath	TokenNameIdentifier	 classpath
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
setChecked	TokenNameIdentifier	 set Checked
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Allows classpath reference. Not allowed if this catalog is * itself a reference to another catalog -- that is, a catalog * cannot both refer to another <em>and</em> contain elements or * other attributes. * * @param r an Ant reference containing a classpath. */	TokenNameCOMMENT_JAVADOC	 Allows classpath reference. Not allowed if this catalog is itself a reference to another catalog -- that is, a catalog cannot both refer to another <em>and</em> contain elements or other attributes. * @param r an Ant reference containing a classpath. 
public	TokenNamepublic	
void	TokenNamevoid	
setClasspathRef	TokenNameIdentifier	 set Classpath Ref
(	TokenNameLPAREN	
Reference	TokenNameIdentifier	 Reference
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isReference	TokenNameIdentifier	 is Reference
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
tooManyAttributes	TokenNameIdentifier	 too Many Attributes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
createClasspath	TokenNameIdentifier	 create Classpath
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
setRefid	TokenNameIdentifier	 set Refid
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setChecked	TokenNameIdentifier	 set Checked
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Creates a nested <code>&lt;catalogpath&gt;</code> element. * Not allowed if this catalog is itself a reference to another * catalog -- that is, a catalog cannot both refer to another * <em>and</em> contain elements or other attributes. * * @return a path to be configured as the catalog path. * @exception BuildException * if this is a reference and no nested elements are allowed. */	TokenNameCOMMENT_JAVADOC	 Creates a nested <code>&lt;catalogpath&gt;</code> element. Not allowed if this catalog is itself a reference to another catalog -- that is, a catalog cannot both refer to another <em>and</em> contain elements or other attributes. * @return a path to be configured as the catalog path. @exception BuildException if this is a reference and no nested elements are allowed. 
public	TokenNamepublic	
Path	TokenNameIdentifier	 Path
createCatalogPath	TokenNameIdentifier	 create Catalog Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isReference	TokenNameIdentifier	 is Reference
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
noChildrenAllowed	TokenNameIdentifier	 no Children Allowed
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
catalogPath	TokenNameIdentifier	 catalog Path
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
catalogPath	TokenNameIdentifier	 catalog Path
=	TokenNameEQUAL	
new	TokenNamenew	
Path	TokenNameIdentifier	 Path
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
setChecked	TokenNameIdentifier	 set Checked
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
this	TokenNamethis	
.	TokenNameDOT	
catalogPath	TokenNameIdentifier	 catalog Path
.	TokenNameDOT	
createPath	TokenNameIdentifier	 create Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Allows catalogpath reference. Not allowed if this catalog is * itself a reference to another catalog -- that is, a catalog * cannot both refer to another <em>and</em> contain elements or * other attributes. * * @param r an Ant reference containing a classpath to be used as * the catalog path. */	TokenNameCOMMENT_JAVADOC	 Allows catalogpath reference. Not allowed if this catalog is itself a reference to another catalog -- that is, a catalog cannot both refer to another <em>and</em> contain elements or other attributes. * @param r an Ant reference containing a classpath to be used as the catalog path. 
public	TokenNamepublic	
void	TokenNamevoid	
setCatalogPathRef	TokenNameIdentifier	 set Catalog Path Ref
(	TokenNameLPAREN	
Reference	TokenNameIdentifier	 Reference
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isReference	TokenNameIdentifier	 is Reference
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
tooManyAttributes	TokenNameIdentifier	 too Many Attributes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
createCatalogPath	TokenNameIdentifier	 create Catalog Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
setRefid	TokenNameIdentifier	 set Refid
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setChecked	TokenNameIdentifier	 set Checked
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the catalog path in which to attempt to resolve DTDs. * * @return the catalog path */	TokenNameCOMMENT_JAVADOC	 Returns the catalog path in which to attempt to resolve DTDs. * @return the catalog path 
public	TokenNamepublic	
Path	TokenNameIdentifier	 Path
getCatalogPath	TokenNameIdentifier	 get Catalog Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getRef	TokenNameIdentifier	 get Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
catalogPath	TokenNameIdentifier	 catalog Path
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Creates the nested <code>&lt;dtd&gt;</code> element. Not * allowed if this catalog is itself a reference to another * catalog -- that is, a catalog cannot both refer to another * <em>and</em> contain elements or other attributes. * * @param dtd the information about the PUBLIC resource mapping to * be added to the catalog * @exception BuildException if this is a reference and no nested * elements are allowed. */	TokenNameCOMMENT_JAVADOC	 Creates the nested <code>&lt;dtd&gt;</code> element. Not allowed if this catalog is itself a reference to another catalog -- that is, a catalog cannot both refer to another <em>and</em> contain elements or other attributes. * @param dtd the information about the PUBLIC resource mapping to be added to the catalog @exception BuildException if this is a reference and no nested elements are allowed. 
public	TokenNamepublic	
void	TokenNamevoid	
addDTD	TokenNameIdentifier	 add DTD
(	TokenNameLPAREN	
ResourceLocation	TokenNameIdentifier	 Resource Location
dtd	TokenNameIdentifier	 dtd
)	TokenNameRPAREN	
throws	TokenNamethrows	
BuildException	TokenNameIdentifier	 Build Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isReference	TokenNameIdentifier	 is Reference
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
noChildrenAllowed	TokenNameIdentifier	 no Children Allowed
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
getElements	TokenNameIdentifier	 get Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
dtd	TokenNameIdentifier	 dtd
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setChecked	TokenNameIdentifier	 set Checked
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Creates the nested <code>&lt;entity&gt;</code> element. Not * allowed if this catalog is itself a reference to another * catalog -- that is, a catalog cannot both refer to another * <em>and</em> contain elements or other attributes. * * @param entity the information about the URI resource mapping to be * added to the catalog. * @exception BuildException if this is a reference and no nested * elements are allowed. */	TokenNameCOMMENT_JAVADOC	 Creates the nested <code>&lt;entity&gt;</code> element. Not allowed if this catalog is itself a reference to another catalog -- that is, a catalog cannot both refer to another <em>and</em> contain elements or other attributes. * @param entity the information about the URI resource mapping to be added to the catalog. @exception BuildException if this is a reference and no nested elements are allowed. 
public	TokenNamepublic	
void	TokenNamevoid	
addEntity	TokenNameIdentifier	 add Entity
(	TokenNameLPAREN	
ResourceLocation	TokenNameIdentifier	 Resource Location
entity	TokenNameIdentifier	 entity
)	TokenNameRPAREN	
throws	TokenNamethrows	
BuildException	TokenNameIdentifier	 Build Exception
{	TokenNameLBRACE	
addDTD	TokenNameIdentifier	 add DTD
(	TokenNameLPAREN	
entity	TokenNameIdentifier	 entity
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Loads a nested <code>&lt;xmlcatalog&gt;</code> into our * definition. Not allowed if this catalog is itself a reference * to another catalog -- that is, a catalog cannot both refer to * another <em>and</em> contain elements or other attributes. * * @param catalog Nested XMLCatalog */	TokenNameCOMMENT_JAVADOC	 Loads a nested <code>&lt;xmlcatalog&gt;</code> into our definition. Not allowed if this catalog is itself a reference to another catalog -- that is, a catalog cannot both refer to another <em>and</em> contain elements or other attributes. * @param catalog Nested XMLCatalog 
public	TokenNamepublic	
void	TokenNamevoid	
addConfiguredXMLCatalog	TokenNameIdentifier	 add Configured XML Catalog
(	TokenNameLPAREN	
XMLCatalog	TokenNameIdentifier	 XML Catalog
catalog	TokenNameIdentifier	 catalog
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isReference	TokenNameIdentifier	 is Reference
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
noChildrenAllowed	TokenNameIdentifier	 no Children Allowed
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Add all nested elements to our catalog 	TokenNameCOMMENT_LINE	Add all nested elements to our catalog 
Vector	TokenNameIdentifier	 Vector
newElements	TokenNameIdentifier	 new Elements
=	TokenNameEQUAL	
catalog	TokenNameIdentifier	 catalog
.	TokenNameDOT	
getElements	TokenNameIdentifier	 get Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Vector	TokenNameIdentifier	 Vector
ourElements	TokenNameIdentifier	 our Elements
=	TokenNameEQUAL	
getElements	TokenNameIdentifier	 get Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Enumeration	TokenNameIdentifier	 Enumeration
e	TokenNameIdentifier	 e
=	TokenNameEQUAL	
newElements	TokenNameIdentifier	 new Elements
.	TokenNameDOT	
elements	TokenNameIdentifier	 elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
hasMoreElements	TokenNameIdentifier	 has More Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ourElements	TokenNameIdentifier	 our Elements
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
nextElement	TokenNameIdentifier	 next Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Append the classpath of the nested catalog 	TokenNameCOMMENT_LINE	Append the classpath of the nested catalog 
Path	TokenNameIdentifier	 Path
nestedClasspath	TokenNameIdentifier	 nested Classpath
=	TokenNameEQUAL	
catalog	TokenNameIdentifier	 catalog
.	TokenNameDOT	
getClasspath	TokenNameIdentifier	 get Classpath
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
createClasspath	TokenNameIdentifier	 create Classpath
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
nestedClasspath	TokenNameIdentifier	 nested Classpath
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Append the catalog path of the nested catalog 	TokenNameCOMMENT_LINE	Append the catalog path of the nested catalog 
Path	TokenNameIdentifier	 Path
nestedCatalogPath	TokenNameIdentifier	 nested Catalog Path
=	TokenNameEQUAL	
catalog	TokenNameIdentifier	 catalog
.	TokenNameDOT	
getCatalogPath	TokenNameIdentifier	 get Catalog Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
createCatalogPath	TokenNameIdentifier	 create Catalog Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
nestedCatalogPath	TokenNameIdentifier	 nested Catalog Path
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setChecked	TokenNameIdentifier	 set Checked
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Makes this instance in effect a reference to another XMLCatalog * instance. * * <p>You must not set another attribute or nest elements inside * this element if you make it a reference. That is, a catalog * cannot both refer to another <em>and</em> contain elements or * attributes.</p> * * @param r the reference to which this catalog instance is associated * @exception BuildException if this instance already has been configured. */	TokenNameCOMMENT_JAVADOC	 Makes this instance in effect a reference to another XMLCatalog instance. * <p>You must not set another attribute or nest elements inside this element if you make it a reference. That is, a catalog cannot both refer to another <em>and</em> contain elements or attributes.</p> * @param r the reference to which this catalog instance is associated @exception BuildException if this instance already has been configured. 
public	TokenNamepublic	
void	TokenNamevoid	
setRefid	TokenNameIdentifier	 set Refid
(	TokenNameLPAREN	
Reference	TokenNameIdentifier	 Reference
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
throws	TokenNamethrows	
BuildException	TokenNameIdentifier	 Build Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
elements	TokenNameIdentifier	 elements
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
tooManyAttributes	TokenNameIdentifier	 too Many Attributes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
setRefid	TokenNameIdentifier	 set Refid
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Implements the EntityResolver.resolveEntity() interface method. * @param publicId the public id to resolve. * @param systemId the system id to resolve. * @throws SAXException if there is a parsing problem. * @throws IOException if there is an IO problem. * @return the resolved entity. * @see org.xml.sax.EntityResolver#resolveEntity */	TokenNameCOMMENT_JAVADOC	 Implements the EntityResolver.resolveEntity() interface method. @param publicId the public id to resolve. @param systemId the system id to resolve. @throws SAXException if there is a parsing problem. @throws IOException if there is an IO problem. @return the resolved entity. @see org.xml.sax.EntityResolver#resolveEntity 
public	TokenNamepublic	
InputSource	TokenNameIdentifier	 Input Source
resolveEntity	TokenNameIdentifier	 resolve Entity
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
publicId	TokenNameIdentifier	 public Id
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
systemId	TokenNameIdentifier	 system Id
)	TokenNameRPAREN	
throws	TokenNamethrows	
SAXException	TokenNameIdentifier	 SAX Exception
,	TokenNameCOMMA	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isReference	TokenNameIdentifier	 is Reference
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getRef	TokenNameIdentifier	 get Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
resolveEntity	TokenNameIdentifier	 resolve Entity
(	TokenNameLPAREN	
publicId	TokenNameIdentifier	 public Id
,	TokenNameCOMMA	
systemId	TokenNameIdentifier	 system Id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
dieOnCircularReference	TokenNameIdentifier	 die On Circular Reference
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"resolveEntity: '"	TokenNameStringLiteral	resolveEntity: '
+	TokenNamePLUS	
publicId	TokenNameIdentifier	 public Id
+	TokenNamePLUS	
"': '"	TokenNameStringLiteral	': '
+	TokenNamePLUS	
systemId	TokenNameIdentifier	 system Id
+	TokenNamePLUS	
"'"	TokenNameStringLiteral	'
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_DEBUG	TokenNameIdentifier	 MSG  DEBUG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
InputSource	TokenNameIdentifier	 Input Source
inputSource	TokenNameIdentifier	 input Source
=	TokenNameEQUAL	
getCatalogResolver	TokenNameIdentifier	 get Catalog Resolver
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
resolveEntity	TokenNameIdentifier	 resolve Entity
(	TokenNameLPAREN	
publicId	TokenNameIdentifier	 public Id
,	TokenNameCOMMA	
systemId	TokenNameIdentifier	 system Id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
inputSource	TokenNameIdentifier	 input Source
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"No matching catalog entry found, parser will use: '"	TokenNameStringLiteral	No matching catalog entry found, parser will use: '
+	TokenNamePLUS	
systemId	TokenNameIdentifier	 system Id
+	TokenNamePLUS	
"'"	TokenNameStringLiteral	'
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_DEBUG	TokenNameIdentifier	 MSG  DEBUG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
inputSource	TokenNameIdentifier	 input Source
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Implements the URIResolver.resolve() interface method. * @param href an href attribute. * @param base the base URI. * @return a Source object, or null if href cannot be resolved. * @throws TransformerException if an error occurs. * @see javax.xml.transform.URIResolver#resolve */	TokenNameCOMMENT_JAVADOC	 Implements the URIResolver.resolve() interface method. @param href an href attribute. @param base the base URI. @return a Source object, or null if href cannot be resolved. @throws TransformerException if an error occurs. @see javax.xml.transform.URIResolver#resolve 
public	TokenNamepublic	
Source	TokenNameIdentifier	 Source
resolve	TokenNameIdentifier	 resolve
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
href	TokenNameIdentifier	 href
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
base	TokenNameIdentifier	 base
)	TokenNameRPAREN	
throws	TokenNamethrows	
TransformerException	TokenNameIdentifier	 Transformer Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isReference	TokenNameIdentifier	 is Reference
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getRef	TokenNameIdentifier	 get Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
resolve	TokenNameIdentifier	 resolve
(	TokenNameLPAREN	
href	TokenNameIdentifier	 href
,	TokenNameCOMMA	
base	TokenNameIdentifier	 base
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
dieOnCircularReference	TokenNameIdentifier	 die On Circular Reference
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SAXSource	TokenNameIdentifier	 SAX Source
source	TokenNameIdentifier	 source
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
uri	TokenNameIdentifier	 uri
=	TokenNameEQUAL	
removeFragment	TokenNameIdentifier	 remove Fragment
(	TokenNameLPAREN	
href	TokenNameIdentifier	 href
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"resolve: '"	TokenNameStringLiteral	resolve: '
+	TokenNamePLUS	
uri	TokenNameIdentifier	 uri
+	TokenNamePLUS	
"' with base: '"	TokenNameStringLiteral	' with base: '
+	TokenNamePLUS	
base	TokenNameIdentifier	 base
+	TokenNamePLUS	
"'"	TokenNameStringLiteral	'
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_DEBUG	TokenNameIdentifier	 MSG  DEBUG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
source	TokenNameIdentifier	 source
=	TokenNameEQUAL	
(	TokenNameLPAREN	
SAXSource	TokenNameIdentifier	 SAX Source
)	TokenNameRPAREN	
getCatalogResolver	TokenNameIdentifier	 get Catalog Resolver
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
resolve	TokenNameIdentifier	 resolve
(	TokenNameLPAREN	
uri	TokenNameIdentifier	 uri
,	TokenNameCOMMA	
base	TokenNameIdentifier	 base
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
source	TokenNameIdentifier	 source
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"No matching catalog entry found, parser will use: '"	TokenNameStringLiteral	No matching catalog entry found, parser will use: '
+	TokenNamePLUS	
href	TokenNameIdentifier	 href
+	TokenNamePLUS	
"'"	TokenNameStringLiteral	'
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_DEBUG	TokenNameIdentifier	 MSG  DEBUG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Cannot return a null source, because we have to call 	TokenNameCOMMENT_LINE	Cannot return a null source, because we have to call 
// setEntityResolver (see setEntityResolver javadoc comment) 	TokenNameCOMMENT_LINE	setEntityResolver (see setEntityResolver javadoc comment) 
// 	TokenNameCOMMENT_LINE	 
source	TokenNameIdentifier	 source
=	TokenNameEQUAL	
new	TokenNamenew	
SAXSource	TokenNameIdentifier	 SAX Source
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
URL	TokenNameIdentifier	 URL
baseURL	TokenNameIdentifier	 base URL
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
baseURL	TokenNameIdentifier	 base URL
=	TokenNameEQUAL	
FILE_UTILS	TokenNameIdentifier	 FILE  UTILS
.	TokenNameDOT	
getFileURL	TokenNameIdentifier	 get File URL
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getBaseDir	TokenNameIdentifier	 get Base Dir
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
baseURL	TokenNameIdentifier	 base URL
=	TokenNameEQUAL	
new	TokenNamenew	
URL	TokenNameIdentifier	 URL
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
URL	TokenNameIdentifier	 URL
url	TokenNameIdentifier	 url
=	TokenNameEQUAL	
(	TokenNameLPAREN	
uri	TokenNameIdentifier	 uri
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
baseURL	TokenNameIdentifier	 base URL
:	TokenNameCOLON	
new	TokenNamenew	
URL	TokenNameIdentifier	 URL
(	TokenNameLPAREN	
baseURL	TokenNameIdentifier	 base URL
,	TokenNameCOMMA	
uri	TokenNameIdentifier	 uri
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
source	TokenNameIdentifier	 source
.	TokenNameDOT	
setInputSource	TokenNameIdentifier	 set Input Source
(	TokenNameLPAREN	
new	TokenNamenew	
InputSource	TokenNameIdentifier	 Input Source
(	TokenNameLPAREN	
url	TokenNameIdentifier	 url
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
MalformedURLException	TokenNameIdentifier	 Malformed URL Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// At this point we are probably in failure mode, but 	TokenNameCOMMENT_LINE	At this point we are probably in failure mode, but 
// try to use the bare URI as a last gasp 	TokenNameCOMMENT_LINE	try to use the bare URI as a last gasp 
source	TokenNameIdentifier	 source
.	TokenNameDOT	
setInputSource	TokenNameIdentifier	 set Input Source
(	TokenNameLPAREN	
new	TokenNamenew	
InputSource	TokenNameIdentifier	 Input Source
(	TokenNameLPAREN	
uri	TokenNameIdentifier	 uri
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
setEntityResolver	TokenNameIdentifier	 set Entity Resolver
(	TokenNameLPAREN	
source	TokenNameIdentifier	 source
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
source	TokenNameIdentifier	 source
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
dieOnCircularReference	TokenNameIdentifier	 die On Circular Reference
(	TokenNameLPAREN	
Stack	TokenNameIdentifier	 Stack
stk	TokenNameIdentifier	 stk
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
p	TokenNameIdentifier	 p
)	TokenNameRPAREN	
throws	TokenNamethrows	
BuildException	TokenNameIdentifier	 Build Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isChecked	TokenNameIdentifier	 is Checked
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isReference	TokenNameIdentifier	 is Reference
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
dieOnCircularReference	TokenNameIdentifier	 die On Circular Reference
(	TokenNameLPAREN	
stk	TokenNameIdentifier	 stk
,	TokenNameCOMMA	
p	TokenNameIdentifier	 p
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
classpath	TokenNameIdentifier	 classpath
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pushAndInvokeCircularReferenceCheck	TokenNameIdentifier	 push And Invoke Circular Reference Check
(	TokenNameLPAREN	
classpath	TokenNameIdentifier	 classpath
,	TokenNameCOMMA	
stk	TokenNameIdentifier	 stk
,	TokenNameCOMMA	
p	TokenNameIdentifier	 p
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
catalogPath	TokenNameIdentifier	 catalog Path
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pushAndInvokeCircularReferenceCheck	TokenNameIdentifier	 push And Invoke Circular Reference Check
(	TokenNameLPAREN	
catalogPath	TokenNameIdentifier	 catalog Path
,	TokenNameCOMMA	
stk	TokenNameIdentifier	 stk
,	TokenNameCOMMA	
p	TokenNameIdentifier	 p
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
setChecked	TokenNameIdentifier	 set Checked
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * @since Ant 1.6 */	TokenNameCOMMENT_JAVADOC	 @since Ant 1.6 
private	TokenNameprivate	
XMLCatalog	TokenNameIdentifier	 XML Catalog
getRef	TokenNameIdentifier	 get Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isReference	TokenNameIdentifier	 is Reference
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
this	TokenNamethis	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
XMLCatalog	TokenNameIdentifier	 XML Catalog
)	TokenNameRPAREN	
getCheckedRef	TokenNameIdentifier	 get Checked Ref
(	TokenNameLPAREN	
XMLCatalog	TokenNameIdentifier	 XML Catalog
.	TokenNameDOT	
class	TokenNameclass	
,	TokenNameCOMMA	
"xmlcatalog"	TokenNameStringLiteral	xmlcatalog
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The instance of the CatalogResolver strategy to use. */	TokenNameCOMMENT_JAVADOC	 The instance of the CatalogResolver strategy to use. 
private	TokenNameprivate	
CatalogResolver	TokenNameIdentifier	 Catalog Resolver
catalogResolver	TokenNameIdentifier	 catalog Resolver
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** * Factory method for creating the appropriate CatalogResolver * strategy implementation. * <p> Until we query the classpath, we don't know whether the Apache * resolver (Norm Walsh's library from xml-commons) is available or not. * This method determines whether the library is available and creates the * appropriate implementation of CatalogResolver based on the answer.</p> * <p>This is an application of the Gang of Four Strategy Pattern * combined with Template Method.</p> */	TokenNameCOMMENT_JAVADOC	 Factory method for creating the appropriate CatalogResolver strategy implementation. <p> Until we query the classpath, we don't know whether the Apache resolver (Norm Walsh's library from xml-commons) is available or not. This method determines whether the library is available and creates the appropriate implementation of CatalogResolver based on the answer.</p> <p>This is an application of the Gang of Four Strategy Pattern combined with Template Method.</p> 
private	TokenNameprivate	
CatalogResolver	TokenNameIdentifier	 Catalog Resolver
getCatalogResolver	TokenNameIdentifier	 get Catalog Resolver
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
catalogResolver	TokenNameIdentifier	 catalog Resolver
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
AntClassLoader	TokenNameIdentifier	 Ant Class Loader
loader	TokenNameIdentifier	 loader
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// Memory-Leak in line below 	TokenNameCOMMENT_LINE	Memory-Leak in line below 
loader	TokenNameIdentifier	 loader
=	TokenNameEQUAL	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
createClassLoader	TokenNameIdentifier	 create Class Loader
(	TokenNameLPAREN	
Path	TokenNameIdentifier	 Path
.	TokenNameDOT	
systemClasspath	TokenNameIdentifier	 system Classpath
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
Class	TokenNameIdentifier	 Class
clazz	TokenNameIdentifier	 clazz
=	TokenNameEQUAL	
Class	TokenNameIdentifier	 Class
.	TokenNameDOT	
forName	TokenNameIdentifier	 for Name
(	TokenNameLPAREN	
APACHE_RESOLVER	TokenNameIdentifier	 APACHE  RESOLVER
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
loader	TokenNameIdentifier	 loader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// The Apache resolver is present - Need to check if it can 	TokenNameCOMMENT_LINE	The Apache resolver is present - Need to check if it can 
// be seen by the catalog resolver class. Start by getting 	TokenNameCOMMENT_LINE	be seen by the catalog resolver class. Start by getting 
// the actual loader 	TokenNameCOMMENT_LINE	the actual loader 
ClassLoader	TokenNameIdentifier	 Class Loader
apacheResolverLoader	TokenNameIdentifier	 apache Resolver Loader
=	TokenNameEQUAL	
clazz	TokenNameIdentifier	 clazz
.	TokenNameDOT	
getClassLoader	TokenNameIdentifier	 get Class Loader
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// load the base class through this loader. 	TokenNameCOMMENT_LINE	load the base class through this loader. 
Class	TokenNameIdentifier	 Class
baseResolverClass	TokenNameIdentifier	 base Resolver Class
=	TokenNameEQUAL	
Class	TokenNameIdentifier	 Class
.	TokenNameDOT	
forName	TokenNameIdentifier	 for Name
(	TokenNameLPAREN	
CATALOG_RESOLVER	TokenNameIdentifier	 CATALOG  RESOLVER
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
apacheResolverLoader	TokenNameIdentifier	 apache Resolver Loader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// and find its actual loader 	TokenNameCOMMENT_LINE	and find its actual loader 
ClassLoader	TokenNameIdentifier	 Class Loader
baseResolverLoader	TokenNameIdentifier	 base Resolver Loader
=	TokenNameEQUAL	
baseResolverClass	TokenNameIdentifier	 base Resolver Class
.	TokenNameDOT	
getClassLoader	TokenNameIdentifier	 get Class Loader
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// We have the loader which is being used to load the 	TokenNameCOMMENT_LINE	We have the loader which is being used to load the 
// CatalogResolver. Can it see the ApacheResolver? The 	TokenNameCOMMENT_LINE	CatalogResolver. Can it see the ApacheResolver? The 
// base resolver will only be able to create the ApacheResolver 	TokenNameCOMMENT_LINE	base resolver will only be able to create the ApacheResolver 
// if it can see it - doesn't use the context loader. 	TokenNameCOMMENT_LINE	if it can see it - doesn't use the context loader. 
clazz	TokenNameIdentifier	 clazz
=	TokenNameEQUAL	
Class	TokenNameIdentifier	 Class
.	TokenNameDOT	
forName	TokenNameIdentifier	 for Name
(	TokenNameLPAREN	
APACHE_RESOLVER	TokenNameIdentifier	 APACHE  RESOLVER
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
baseResolverLoader	TokenNameIdentifier	 base Resolver Loader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Object	TokenNameIdentifier	 Object
obj	TokenNameIdentifier	 obj
=	TokenNameEQUAL	
clazz	TokenNameIdentifier	 clazz
.	TokenNameDOT	
newInstance	TokenNameIdentifier	 new Instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Success! The xml-commons resolver library is 	TokenNameCOMMENT_LINE	Success! The xml-commons resolver library is 
// available, so use it. 	TokenNameCOMMENT_LINE	available, so use it. 
// 	TokenNameCOMMENT_LINE	 
catalogResolver	TokenNameIdentifier	 catalog Resolver
=	TokenNameEQUAL	
new	TokenNamenew	
ExternalResolver	TokenNameIdentifier	 External Resolver
(	TokenNameLPAREN	
clazz	TokenNameIdentifier	 clazz
,	TokenNameCOMMA	
obj	TokenNameIdentifier	 obj
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Throwable	TokenNameIdentifier	 Throwable
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// The xml-commons resolver library is not 	TokenNameCOMMENT_LINE	The xml-commons resolver library is not 
// available, so we can't use it. 	TokenNameCOMMENT_LINE	available, so we can't use it. 
// 	TokenNameCOMMENT_LINE	 
catalogResolver	TokenNameIdentifier	 catalog Resolver
=	TokenNameEQUAL	
new	TokenNamenew	
InternalResolver	TokenNameIdentifier	 Internal Resolver
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
getCatalogPath	TokenNameIdentifier	 get Catalog Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
getCatalogPath	TokenNameIdentifier	 get Catalog Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
list	TokenNameIdentifier	 list
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Warning: XML resolver not found; external catalogs"	TokenNameStringLiteral	Warning: XML resolver not found; external catalogs
+	TokenNamePLUS	
" will be ignored"	TokenNameStringLiteral	 will be ignored
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_WARN	TokenNameIdentifier	 MSG  WARN
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Failed to load Apache resolver: "	TokenNameStringLiteral	Failed to load Apache resolver: 
+	TokenNamePLUS	
ex	TokenNameIdentifier	 ex
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_DEBUG	TokenNameIdentifier	 MSG  DEBUG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
catalogResolver	TokenNameIdentifier	 catalog Resolver
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * <p>This is called from the URIResolver to set an EntityResolver * on the SAX parser to be used for new XML documents that are * encountered as a result of the document() function, xsl:import, * or xsl:include. This is done because the XSLT processor calls * out to the SAXParserFactory itself to create a new SAXParser to * parse the new document. The new parser does not automatically * inherit the EntityResolver of the original (although arguably * it should). See below:</p> * * <tt>"If an application wants to set the ErrorHandler or * EntityResolver for an XMLReader used during a transformation, * it should use a URIResolver to return the SAXSource which * provides (with getXMLReader) a reference to the XMLReader"</tt> * * <p>...quoted from page 118 of the Java API for XML * Processing 1.1 specification</p> * */	TokenNameCOMMENT_JAVADOC	 <p>This is called from the URIResolver to set an EntityResolver on the SAX parser to be used for new XML documents that are encountered as a result of the document() function, xsl:import, or xsl:include. This is done because the XSLT processor calls out to the SAXParserFactory itself to create a new SAXParser to parse the new document. The new parser does not automatically inherit the EntityResolver of the original (although arguably it should). See below:</p> * <tt>"If an application wants to set the ErrorHandler or EntityResolver for an XMLReader used during a transformation, it should use a URIResolver to return the SAXSource which provides (with getXMLReader) a reference to the XMLReader"</tt> * <p>...quoted from page 118 of the Java API for XML Processing 1.1 specification</p> 
private	TokenNameprivate	
void	TokenNamevoid	
setEntityResolver	TokenNameIdentifier	 set Entity Resolver
(	TokenNameLPAREN	
SAXSource	TokenNameIdentifier	 SAX Source
source	TokenNameIdentifier	 source
)	TokenNameRPAREN	
throws	TokenNamethrows	
TransformerException	TokenNameIdentifier	 Transformer Exception
{	TokenNameLBRACE	
XMLReader	TokenNameIdentifier	 XML Reader
reader	TokenNameIdentifier	 reader
=	TokenNameEQUAL	
source	TokenNameIdentifier	 source
.	TokenNameDOT	
getXMLReader	TokenNameIdentifier	 get XML Reader
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SAXParserFactory	TokenNameIdentifier	 SAX Parser Factory
spFactory	TokenNameIdentifier	 sp Factory
=	TokenNameEQUAL	
SAXParserFactory	TokenNameIdentifier	 SAX Parser Factory
.	TokenNameDOT	
newInstance	TokenNameIdentifier	 new Instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
spFactory	TokenNameIdentifier	 sp Factory
.	TokenNameDOT	
setNamespaceAware	TokenNameIdentifier	 set Namespace Aware
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
reader	TokenNameIdentifier	 reader
=	TokenNameEQUAL	
spFactory	TokenNameIdentifier	 sp Factory
.	TokenNameDOT	
newSAXParser	TokenNameIdentifier	 new SAX Parser
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getXMLReader	TokenNameIdentifier	 get XML Reader
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ParserConfigurationException	TokenNameIdentifier	 Parser Configuration Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
TransformerException	TokenNameIdentifier	 Transformer Exception
(	TokenNameLPAREN	
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
SAXException	TokenNameIdentifier	 SAX Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
TransformerException	TokenNameIdentifier	 Transformer Exception
(	TokenNameLPAREN	
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
setEntityResolver	TokenNameIdentifier	 set Entity Resolver
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
source	TokenNameIdentifier	 source
.	TokenNameDOT	
setXMLReader	TokenNameIdentifier	 set XML Reader
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Find a ResourceLocation instance for the given publicId. * * @param publicId the publicId of the Resource for which local information * is required. * @return a ResourceLocation instance with information on the local location * of the Resource or null if no such information is available. */	TokenNameCOMMENT_JAVADOC	 Find a ResourceLocation instance for the given publicId. * @param publicId the publicId of the Resource for which local information is required. @return a ResourceLocation instance with information on the local location of the Resource or null if no such information is available. 
private	TokenNameprivate	
ResourceLocation	TokenNameIdentifier	 Resource Location
findMatchingEntry	TokenNameIdentifier	 find Matching Entry
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
publicId	TokenNameIdentifier	 public Id
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Enumeration	TokenNameIdentifier	 Enumeration
e	TokenNameIdentifier	 e
=	TokenNameEQUAL	
getElements	TokenNameIdentifier	 get Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
elements	TokenNameIdentifier	 elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ResourceLocation	TokenNameIdentifier	 Resource Location
element	TokenNameIdentifier	 element
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
hasMoreElements	TokenNameIdentifier	 has More Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
o	TokenNameIdentifier	 o
=	TokenNameEQUAL	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
nextElement	TokenNameIdentifier	 next Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
o	TokenNameIdentifier	 o
instanceof	TokenNameinstanceof	
ResourceLocation	TokenNameIdentifier	 Resource Location
)	TokenNameRPAREN	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ResourceLocation	TokenNameIdentifier	 Resource Location
)	TokenNameRPAREN	
o	TokenNameIdentifier	 o
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
getPublicId	TokenNameIdentifier	 get Public Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
publicId	TokenNameIdentifier	 public Id
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
element	TokenNameIdentifier	 element
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Utility method to remove trailing fragment from a URI. * For example, * <code>http://java.sun.com/index.html#chapter1</code> * would return <code>http://java.sun.com/index.html</code>. * * @param uri The URI to process. It may or may not contain a * fragment. * @return The URI sans fragment. */	TokenNameCOMMENT_JAVADOC	 Utility method to remove trailing fragment from a URI. For example, <code>http://java.sun.com/index.html#chapter1</code> would return <code>http://java.sun.com/index.html</code>. * @param uri The URI to process. It may or may not contain a fragment. @return The URI sans fragment. 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
removeFragment	TokenNameIdentifier	 remove Fragment
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
uri	TokenNameIdentifier	 uri
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
uri	TokenNameIdentifier	 uri
;	TokenNameSEMICOLON	
int	TokenNameint	
hashPos	TokenNameIdentifier	 hash Pos
=	TokenNameEQUAL	
uri	TokenNameIdentifier	 uri
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
"#"	TokenNameStringLiteral	#
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
hashPos	TokenNameIdentifier	 hash Pos
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
uri	TokenNameIdentifier	 uri
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
hashPos	TokenNameIdentifier	 hash Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
result	TokenNameIdentifier	 result
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Utility method to lookup a ResourceLocation in the filesystem. * * @return An InputSource for reading the file, or <code>null</code> * if the file does not exist or is not readable. */	TokenNameCOMMENT_JAVADOC	 Utility method to lookup a ResourceLocation in the filesystem. * @return An InputSource for reading the file, or <code>null</code> if the file does not exist or is not readable. 
private	TokenNameprivate	
InputSource	TokenNameIdentifier	 Input Source
filesystemLookup	TokenNameIdentifier	 filesystem Lookup
(	TokenNameLPAREN	
ResourceLocation	TokenNameIdentifier	 Resource Location
matchingEntry	TokenNameIdentifier	 matching Entry
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
uri	TokenNameIdentifier	 uri
=	TokenNameEQUAL	
matchingEntry	TokenNameIdentifier	 matching Entry
.	TokenNameDOT	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// the following line seems to be necessary on Windows under JDK 1.2 	TokenNameCOMMENT_LINE	the following line seems to be necessary on Windows under JDK 1.2 
uri	TokenNameIdentifier	 uri
=	TokenNameEQUAL	
uri	TokenNameIdentifier	 uri
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separatorChar	TokenNameIdentifier	 separator Char
,	TokenNameCOMMA	
'/'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
URL	TokenNameIdentifier	 URL
baseURL	TokenNameIdentifier	 base URL
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// The ResourceLocation may specify a relative path for its 	TokenNameCOMMENT_LINE	The ResourceLocation may specify a relative path for its 
// location attribute. This is resolved using the appropriate 	TokenNameCOMMENT_LINE	location attribute. This is resolved using the appropriate 
// base. 	TokenNameCOMMENT_LINE	base. 
// 	TokenNameCOMMENT_LINE	 
if	TokenNameif	
(	TokenNameLPAREN	
matchingEntry	TokenNameIdentifier	 matching Entry
.	TokenNameDOT	
getBase	TokenNameIdentifier	 get Base
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
baseURL	TokenNameIdentifier	 base URL
=	TokenNameEQUAL	
matchingEntry	TokenNameIdentifier	 matching Entry
.	TokenNameDOT	
getBase	TokenNameIdentifier	 get Base
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
baseURL	TokenNameIdentifier	 base URL
=	TokenNameEQUAL	
FILE_UTILS	TokenNameIdentifier	 FILE  UTILS
.	TokenNameDOT	
getFileURL	TokenNameIdentifier	 get File URL
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getBaseDir	TokenNameIdentifier	 get Base Dir
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
MalformedURLException	TokenNameIdentifier	 Malformed URL Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Project basedir cannot be converted to a URL"	TokenNameStringLiteral	Project basedir cannot be converted to a URL
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
InputSource	TokenNameIdentifier	 Input Source
source	TokenNameIdentifier	 source
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
URL	TokenNameIdentifier	 URL
url	TokenNameIdentifier	 url
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
url	TokenNameIdentifier	 url
=	TokenNameEQUAL	
new	TokenNamenew	
URL	TokenNameIdentifier	 URL
(	TokenNameLPAREN	
baseURL	TokenNameIdentifier	 base URL
,	TokenNameCOMMA	
uri	TokenNameIdentifier	 uri
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
MalformedURLException	TokenNameIdentifier	 Malformed URL Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// this processing is useful under Windows when the location of the DTD 	TokenNameCOMMENT_LINE	this processing is useful under Windows when the location of the DTD 
// has been given as an absolute path 	TokenNameCOMMENT_LINE	has been given as an absolute path 
// see Bugzilla Report 23913 	TokenNameCOMMENT_LINE	see Bugzilla Report 23913 
File	TokenNameIdentifier	 File
testFile	TokenNameIdentifier	 test File
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
uri	TokenNameIdentifier	 uri
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
testFile	TokenNameIdentifier	 test File
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
testFile	TokenNameIdentifier	 test File
.	TokenNameDOT	
canRead	TokenNameIdentifier	 can Read
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"uri : '"	TokenNameStringLiteral	uri : '
+	TokenNamePLUS	
uri	TokenNameIdentifier	 uri
+	TokenNamePLUS	
"' matches a readable file"	TokenNameStringLiteral	' matches a readable file
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_DEBUG	TokenNameIdentifier	 MSG  DEBUG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
url	TokenNameIdentifier	 url
=	TokenNameEQUAL	
FILE_UTILS	TokenNameIdentifier	 FILE  UTILS
.	TokenNameDOT	
getFileURL	TokenNameIdentifier	 get File URL
(	TokenNameLPAREN	
testFile	TokenNameIdentifier	 test File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
MalformedURLException	TokenNameIdentifier	 Malformed URL Exception
ex1	TokenNameIdentifier	 ex1
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"could not find an URL for :"	TokenNameStringLiteral	could not find an URL for :
+	TokenNamePLUS	
testFile	TokenNameIdentifier	 test File
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"uri : '"	TokenNameStringLiteral	uri : '
+	TokenNamePLUS	
uri	TokenNameIdentifier	 uri
+	TokenNamePLUS	
"' does not match a readable file"	TokenNameStringLiteral	' does not match a readable file
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_DEBUG	TokenNameIdentifier	 MSG  DEBUG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
url	TokenNameIdentifier	 url
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
url	TokenNameIdentifier	 url
.	TokenNameDOT	
getProtocol	TokenNameIdentifier	 get Protocol
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"file"	TokenNameStringLiteral	file
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
fileName	TokenNameIdentifier	 file Name
=	TokenNameEQUAL	
FILE_UTILS	TokenNameIdentifier	 FILE  UTILS
.	TokenNameDOT	
fromURI	TokenNameIdentifier	 from URI
(	TokenNameLPAREN	
url	TokenNameIdentifier	 url
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fileName	TokenNameIdentifier	 file Name
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"fileName "	TokenNameStringLiteral	fileName 
+	TokenNamePLUS	
fileName	TokenNameIdentifier	 file Name
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_DEBUG	TokenNameIdentifier	 MSG  DEBUG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
resFile	TokenNameIdentifier	 res File
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
fileName	TokenNameIdentifier	 file Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
resFile	TokenNameIdentifier	 res File
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
resFile	TokenNameIdentifier	 res File
.	TokenNameDOT	
canRead	TokenNameIdentifier	 can Read
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
source	TokenNameIdentifier	 source
=	TokenNameEQUAL	
new	TokenNamenew	
InputSource	TokenNameIdentifier	 Input Source
(	TokenNameLPAREN	
new	TokenNamenew	
FileInputStream	TokenNameIdentifier	 File Input Stream
(	TokenNameLPAREN	
resFile	TokenNameIdentifier	 res File
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
sysid	TokenNameIdentifier	 sysid
=	TokenNameEQUAL	
JAXPUtils	TokenNameIdentifier	 JAXP Utils
.	TokenNameDOT	
getSystemId	TokenNameIdentifier	 get System Id
(	TokenNameLPAREN	
resFile	TokenNameIdentifier	 res File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
source	TokenNameIdentifier	 source
.	TokenNameDOT	
setSystemId	TokenNameIdentifier	 set System Id
(	TokenNameLPAREN	
sysid	TokenNameIdentifier	 sysid
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"catalog entry matched a readable file: '"	TokenNameStringLiteral	catalog entry matched a readable file: '
+	TokenNamePLUS	
sysid	TokenNameIdentifier	 sysid
+	TokenNamePLUS	
"'"	TokenNameStringLiteral	'
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_DEBUG	TokenNameIdentifier	 MSG  DEBUG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// ignore 	TokenNameCOMMENT_LINE	ignore 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
source	TokenNameIdentifier	 source
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Utility method to lookup a ResourceLocation in the classpath. * * @return An InputSource for reading the resource, or <code>null</code> * if the resource does not exist in the classpath or is not readable. */	TokenNameCOMMENT_JAVADOC	 Utility method to lookup a ResourceLocation in the classpath. * @return An InputSource for reading the resource, or <code>null</code> if the resource does not exist in the classpath or is not readable. 
private	TokenNameprivate	
InputSource	TokenNameIdentifier	 Input Source
classpathLookup	TokenNameIdentifier	 classpath Lookup
(	TokenNameLPAREN	
ResourceLocation	TokenNameIdentifier	 Resource Location
matchingEntry	TokenNameIdentifier	 matching Entry
)	TokenNameRPAREN	
{	TokenNameLBRACE	
InputSource	TokenNameIdentifier	 Input Source
source	TokenNameIdentifier	 source
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
AntClassLoader	TokenNameIdentifier	 Ant Class Loader
loader	TokenNameIdentifier	 loader
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
Path	TokenNameIdentifier	 Path
cp	TokenNameIdentifier	 cp
=	TokenNameEQUAL	
classpath	TokenNameIdentifier	 classpath
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cp	TokenNameIdentifier	 cp
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
cp	TokenNameIdentifier	 cp
=	TokenNameEQUAL	
classpath	TokenNameIdentifier	 classpath
.	TokenNameDOT	
concatSystemClasspath	TokenNameIdentifier	 concat System Classpath
(	TokenNameLPAREN	
"ignore"	TokenNameStringLiteral	ignore
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
cp	TokenNameIdentifier	 cp
=	TokenNameEQUAL	
(	TokenNameLPAREN	
new	TokenNamenew	
Path	TokenNameIdentifier	 Path
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
concatSystemClasspath	TokenNameIdentifier	 concat System Classpath
(	TokenNameLPAREN	
"last"	TokenNameStringLiteral	last
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
loader	TokenNameIdentifier	 loader
=	TokenNameEQUAL	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
createClassLoader	TokenNameIdentifier	 create Class Loader
(	TokenNameLPAREN	
cp	TokenNameIdentifier	 cp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// for classpath lookup we ignore the base directory 	TokenNameCOMMENT_LINE	for classpath lookup we ignore the base directory 
// 	TokenNameCOMMENT_LINE	 
InputStream	TokenNameIdentifier	 Input Stream
is	TokenNameIdentifier	 is
=	TokenNameEQUAL	
loader	TokenNameIdentifier	 loader
.	TokenNameDOT	
getResourceAsStream	TokenNameIdentifier	 get Resource As Stream
(	TokenNameLPAREN	
matchingEntry	TokenNameIdentifier	 matching Entry
.	TokenNameDOT	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
source	TokenNameIdentifier	 source
=	TokenNameEQUAL	
new	TokenNamenew	
InputSource	TokenNameIdentifier	 Input Source
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
URL	TokenNameIdentifier	 URL
entryURL	TokenNameIdentifier	 entry URL
=	TokenNameEQUAL	
loader	TokenNameIdentifier	 loader
.	TokenNameDOT	
getResource	TokenNameIdentifier	 get Resource
(	TokenNameLPAREN	
matchingEntry	TokenNameIdentifier	 matching Entry
.	TokenNameDOT	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
sysid	TokenNameIdentifier	 sysid
=	TokenNameEQUAL	
entryURL	TokenNameIdentifier	 entry URL
.	TokenNameDOT	
toExternalForm	TokenNameIdentifier	 to External Form
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
source	TokenNameIdentifier	 source
.	TokenNameDOT	
setSystemId	TokenNameIdentifier	 set System Id
(	TokenNameLPAREN	
sysid	TokenNameIdentifier	 sysid
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"catalog entry matched a resource in the classpath: '"	TokenNameStringLiteral	catalog entry matched a resource in the classpath: '
+	TokenNamePLUS	
sysid	TokenNameIdentifier	 sysid
+	TokenNamePLUS	
"'"	TokenNameStringLiteral	'
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_DEBUG	TokenNameIdentifier	 MSG  DEBUG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
source	TokenNameIdentifier	 source
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Utility method to lookup a ResourceLocation in URL-space. * * @return An InputSource for reading the resource, or <code>null</code> * if the resource does not identify a valid URL or is not readable. */	TokenNameCOMMENT_JAVADOC	 Utility method to lookup a ResourceLocation in URL-space. * @return An InputSource for reading the resource, or <code>null</code> if the resource does not identify a valid URL or is not readable. 
private	TokenNameprivate	
InputSource	TokenNameIdentifier	 Input Source
urlLookup	TokenNameIdentifier	 url Lookup
(	TokenNameLPAREN	
ResourceLocation	TokenNameIdentifier	 Resource Location
matchingEntry	TokenNameIdentifier	 matching Entry
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
uri	TokenNameIdentifier	 uri
=	TokenNameEQUAL	
matchingEntry	TokenNameIdentifier	 matching Entry
.	TokenNameDOT	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
URL	TokenNameIdentifier	 URL
baseURL	TokenNameIdentifier	 base URL
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// The ResourceLocation may specify a relative url for its 	TokenNameCOMMENT_LINE	The ResourceLocation may specify a relative url for its 
// location attribute. This is resolved using the appropriate 	TokenNameCOMMENT_LINE	location attribute. This is resolved using the appropriate 
// base. 	TokenNameCOMMENT_LINE	base. 
// 	TokenNameCOMMENT_LINE	 
if	TokenNameif	
(	TokenNameLPAREN	
matchingEntry	TokenNameIdentifier	 matching Entry
.	TokenNameDOT	
getBase	TokenNameIdentifier	 get Base
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
baseURL	TokenNameIdentifier	 base URL
=	TokenNameEQUAL	
matchingEntry	TokenNameIdentifier	 matching Entry
.	TokenNameDOT	
getBase	TokenNameIdentifier	 get Base
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
baseURL	TokenNameIdentifier	 base URL
=	TokenNameEQUAL	
FILE_UTILS	TokenNameIdentifier	 FILE  UTILS
.	TokenNameDOT	
getFileURL	TokenNameIdentifier	 get File URL
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getBaseDir	TokenNameIdentifier	 get Base Dir
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
MalformedURLException	TokenNameIdentifier	 Malformed URL Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Project basedir cannot be converted to a URL"	TokenNameStringLiteral	Project basedir cannot be converted to a URL
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
InputSource	TokenNameIdentifier	 Input Source
source	TokenNameIdentifier	 source
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
URL	TokenNameIdentifier	 URL
url	TokenNameIdentifier	 url
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
url	TokenNameIdentifier	 url
=	TokenNameEQUAL	
new	TokenNamenew	
URL	TokenNameIdentifier	 URL
(	TokenNameLPAREN	
baseURL	TokenNameIdentifier	 base URL
,	TokenNameCOMMA	
uri	TokenNameIdentifier	 uri
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
MalformedURLException	TokenNameIdentifier	 Malformed URL Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// ignore 	TokenNameCOMMENT_LINE	ignore 
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
url	TokenNameIdentifier	 url
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
InputStream	TokenNameIdentifier	 Input Stream
is	TokenNameIdentifier	 is
=	TokenNameEQUAL	
url	TokenNameIdentifier	 url
.	TokenNameDOT	
openStream	TokenNameIdentifier	 open Stream
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
source	TokenNameIdentifier	 source
=	TokenNameEQUAL	
new	TokenNamenew	
InputSource	TokenNameIdentifier	 Input Source
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
sysid	TokenNameIdentifier	 sysid
=	TokenNameEQUAL	
url	TokenNameIdentifier	 url
.	TokenNameDOT	
toExternalForm	TokenNameIdentifier	 to External Form
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
source	TokenNameIdentifier	 source
.	TokenNameDOT	
setSystemId	TokenNameIdentifier	 set System Id
(	TokenNameLPAREN	
sysid	TokenNameIdentifier	 sysid
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"catalog entry matched as a URL: '"	TokenNameStringLiteral	catalog entry matched as a URL: '
+	TokenNamePLUS	
sysid	TokenNameIdentifier	 sysid
+	TokenNamePLUS	
"'"	TokenNameStringLiteral	'
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_DEBUG	TokenNameIdentifier	 MSG  DEBUG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// ignore 	TokenNameCOMMENT_LINE	ignore 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
source	TokenNameIdentifier	 source
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Interface implemented by both the InternalResolver strategy and * the ExternalResolver strategy. */	TokenNameCOMMENT_JAVADOC	 Interface implemented by both the InternalResolver strategy and the ExternalResolver strategy. 
private	TokenNameprivate	
interface	TokenNameinterface	
CatalogResolver	TokenNameIdentifier	 Catalog Resolver
extends	TokenNameextends	
URIResolver	TokenNameIdentifier	 URI Resolver
,	TokenNameCOMMA	
EntityResolver	TokenNameIdentifier	 Entity Resolver
{	TokenNameLBRACE	
InputSource	TokenNameIdentifier	 Input Source
resolveEntity	TokenNameIdentifier	 resolve Entity
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
publicId	TokenNameIdentifier	 public Id
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
systemId	TokenNameIdentifier	 system Id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Source	TokenNameIdentifier	 Source
resolve	TokenNameIdentifier	 resolve
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
href	TokenNameIdentifier	 href
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
base	TokenNameIdentifier	 base
)	TokenNameRPAREN	
throws	TokenNamethrows	
TransformerException	TokenNameIdentifier	 Transformer Exception
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The InternalResolver strategy is used if the Apache resolver * library (Norm Walsh's library from xml-commons) is not * available. In this case, external catalog files will be * ignored. * */	TokenNameCOMMENT_JAVADOC	 The InternalResolver strategy is used if the Apache resolver library (Norm Walsh's library from xml-commons) is not available. In this case, external catalog files will be ignored. 
private	TokenNameprivate	
class	TokenNameclass	
InternalResolver	TokenNameIdentifier	 Internal Resolver
implements	TokenNameimplements	
CatalogResolver	TokenNameIdentifier	 Catalog Resolver
{	TokenNameLBRACE	
public	TokenNamepublic	
InternalResolver	TokenNameIdentifier	 Internal Resolver
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Apache resolver library not found, internal resolver will be used"	TokenNameStringLiteral	Apache resolver library not found, internal resolver will be used
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_VERBOSE	TokenNameIdentifier	 MSG  VERBOSE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
InputSource	TokenNameIdentifier	 Input Source
resolveEntity	TokenNameIdentifier	 resolve Entity
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
publicId	TokenNameIdentifier	 public Id
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
systemId	TokenNameIdentifier	 system Id
)	TokenNameRPAREN	
{	TokenNameLBRACE	
InputSource	TokenNameIdentifier	 Input Source
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
ResourceLocation	TokenNameIdentifier	 Resource Location
matchingEntry	TokenNameIdentifier	 matching Entry
=	TokenNameEQUAL	
findMatchingEntry	TokenNameIdentifier	 find Matching Entry
(	TokenNameLPAREN	
publicId	TokenNameIdentifier	 public Id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
matchingEntry	TokenNameIdentifier	 matching Entry
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Matching catalog entry found for publicId: '"	TokenNameStringLiteral	Matching catalog entry found for publicId: '
+	TokenNamePLUS	
matchingEntry	TokenNameIdentifier	 matching Entry
.	TokenNameDOT	
getPublicId	TokenNameIdentifier	 get Public Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"' location: '"	TokenNameStringLiteral	' location: '
+	TokenNamePLUS	
matchingEntry	TokenNameIdentifier	 matching Entry
.	TokenNameDOT	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"'"	TokenNameStringLiteral	'
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_DEBUG	TokenNameIdentifier	 MSG  DEBUG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
filesystemLookup	TokenNameIdentifier	 filesystem Lookup
(	TokenNameLPAREN	
matchingEntry	TokenNameIdentifier	 matching Entry
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
classpathLookup	TokenNameIdentifier	 classpath Lookup
(	TokenNameLPAREN	
matchingEntry	TokenNameIdentifier	 matching Entry
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
urlLookup	TokenNameIdentifier	 url Lookup
(	TokenNameLPAREN	
matchingEntry	TokenNameIdentifier	 matching Entry
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
result	TokenNameIdentifier	 result
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Source	TokenNameIdentifier	 Source
resolve	TokenNameIdentifier	 resolve
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
href	TokenNameIdentifier	 href
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
base	TokenNameIdentifier	 base
)	TokenNameRPAREN	
throws	TokenNamethrows	
TransformerException	TokenNameIdentifier	 Transformer Exception
{	TokenNameLBRACE	
SAXSource	TokenNameIdentifier	 SAX Source
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
InputSource	TokenNameIdentifier	 Input Source
source	TokenNameIdentifier	 source
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
ResourceLocation	TokenNameIdentifier	 Resource Location
matchingEntry	TokenNameIdentifier	 matching Entry
=	TokenNameEQUAL	
findMatchingEntry	TokenNameIdentifier	 find Matching Entry
(	TokenNameLPAREN	
href	TokenNameIdentifier	 href
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
matchingEntry	TokenNameIdentifier	 matching Entry
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Matching catalog entry found for uri: '"	TokenNameStringLiteral	Matching catalog entry found for uri: '
+	TokenNamePLUS	
matchingEntry	TokenNameIdentifier	 matching Entry
.	TokenNameDOT	
getPublicId	TokenNameIdentifier	 get Public Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"' location: '"	TokenNameStringLiteral	' location: '
+	TokenNamePLUS	
matchingEntry	TokenNameIdentifier	 matching Entry
.	TokenNameDOT	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"'"	TokenNameStringLiteral	'
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_DEBUG	TokenNameIdentifier	 MSG  DEBUG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Use the passed in base in preference to the base 	TokenNameCOMMENT_LINE	Use the passed in base in preference to the base 
// from matchingEntry, which is either null or the 	TokenNameCOMMENT_LINE	from matchingEntry, which is either null or the 
// directory in which the external catalog file from 	TokenNameCOMMENT_LINE	directory in which the external catalog file from 
// which it was obtained is located. We make a copy 	TokenNameCOMMENT_LINE	which it was obtained is located. We make a copy 
// so matchingEntry's original base is untouched. 	TokenNameCOMMENT_LINE	so matchingEntry's original base is untouched. 
// 	TokenNameCOMMENT_LINE	 
// This is the standard behavior as per my reading of 	TokenNameCOMMENT_LINE	This is the standard behavior as per my reading of 
// the JAXP and XML Catalog specs. CKS 11/7/2002 	TokenNameCOMMENT_LINE	the JAXP and XML Catalog specs. CKS 11/7/2002 
// 	TokenNameCOMMENT_LINE	 
ResourceLocation	TokenNameIdentifier	 Resource Location
entryCopy	TokenNameIdentifier	 entry Copy
=	TokenNameEQUAL	
matchingEntry	TokenNameIdentifier	 matching Entry
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
URL	TokenNameIdentifier	 URL
baseURL	TokenNameIdentifier	 base URL
=	TokenNameEQUAL	
new	TokenNamenew	
URL	TokenNameIdentifier	 URL
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
entryCopy	TokenNameIdentifier	 entry Copy
=	TokenNameEQUAL	
new	TokenNamenew	
ResourceLocation	TokenNameIdentifier	 Resource Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
entryCopy	TokenNameIdentifier	 entry Copy
.	TokenNameDOT	
setBase	TokenNameIdentifier	 set Base
(	TokenNameLPAREN	
baseURL	TokenNameIdentifier	 base URL
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
MalformedURLException	TokenNameIdentifier	 Malformed URL Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// ignore 	TokenNameCOMMENT_LINE	ignore 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
entryCopy	TokenNameIdentifier	 entry Copy
.	TokenNameDOT	
setPublicId	TokenNameIdentifier	 set Public Id
(	TokenNameLPAREN	
matchingEntry	TokenNameIdentifier	 matching Entry
.	TokenNameDOT	
getPublicId	TokenNameIdentifier	 get Public Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
entryCopy	TokenNameIdentifier	 entry Copy
.	TokenNameDOT	
setLocation	TokenNameIdentifier	 set Location
(	TokenNameLPAREN	
matchingEntry	TokenNameIdentifier	 matching Entry
.	TokenNameDOT	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
source	TokenNameIdentifier	 source
=	TokenNameEQUAL	
filesystemLookup	TokenNameIdentifier	 filesystem Lookup
(	TokenNameLPAREN	
entryCopy	TokenNameIdentifier	 entry Copy
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
source	TokenNameIdentifier	 source
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
source	TokenNameIdentifier	 source
=	TokenNameEQUAL	
classpathLookup	TokenNameIdentifier	 classpath Lookup
(	TokenNameLPAREN	
entryCopy	TokenNameIdentifier	 entry Copy
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
source	TokenNameIdentifier	 source
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
source	TokenNameIdentifier	 source
=	TokenNameEQUAL	
urlLookup	TokenNameIdentifier	 url Lookup
(	TokenNameLPAREN	
entryCopy	TokenNameIdentifier	 entry Copy
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
source	TokenNameIdentifier	 source
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
new	TokenNamenew	
SAXSource	TokenNameIdentifier	 SAX Source
(	TokenNameLPAREN	
source	TokenNameIdentifier	 source
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
result	TokenNameIdentifier	 result
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * The ExternalResolver strategy is used if the Apache resolver * library (Norm Walsh's library from xml-commons) is available in * the classpath. The ExternalResolver is a essentially a superset * of the InternalResolver. * */	TokenNameCOMMENT_JAVADOC	 The ExternalResolver strategy is used if the Apache resolver library (Norm Walsh's library from xml-commons) is available in the classpath. The ExternalResolver is a essentially a superset of the InternalResolver. 
private	TokenNameprivate	
class	TokenNameclass	
ExternalResolver	TokenNameIdentifier	 External Resolver
implements	TokenNameimplements	
CatalogResolver	TokenNameIdentifier	 Catalog Resolver
{	TokenNameLBRACE	
private	TokenNameprivate	
Method	TokenNameIdentifier	 Method
setXMLCatalog	TokenNameIdentifier	 set XML Catalog
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Method	TokenNameIdentifier	 Method
parseCatalog	TokenNameIdentifier	 parse Catalog
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Method	TokenNameIdentifier	 Method
resolveEntity	TokenNameIdentifier	 resolve Entity
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Method	TokenNameIdentifier	 Method
resolve	TokenNameIdentifier	 resolve
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** The instance of the ApacheCatalogResolver bridge class */	TokenNameCOMMENT_JAVADOC	 The instance of the ApacheCatalogResolver bridge class 
private	TokenNameprivate	
Object	TokenNameIdentifier	 Object
resolverImpl	TokenNameIdentifier	 resolver Impl
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
externalCatalogsProcessed	TokenNameIdentifier	 external Catalogs Processed
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
ExternalResolver	TokenNameIdentifier	 External Resolver
(	TokenNameLPAREN	
Class	TokenNameIdentifier	 Class
resolverImplClass	TokenNameIdentifier	 resolver Impl Class
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
resolverImpl	TokenNameIdentifier	 resolver Impl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
resolverImpl	TokenNameIdentifier	 resolver Impl
=	TokenNameEQUAL	
resolverImpl	TokenNameIdentifier	 resolver Impl
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Get Method instances for each of the methods we need to 	TokenNameCOMMENT_LINE	Get Method instances for each of the methods we need to 
// call on the resolverImpl using reflection. We can't 	TokenNameCOMMENT_LINE	call on the resolverImpl using reflection. We can't 
// call them directly, because they require on the 	TokenNameCOMMENT_LINE	call them directly, because they require on the 
// xml-commons resolver library which may not be available 	TokenNameCOMMENT_LINE	xml-commons resolver library which may not be available 
// in the classpath. 	TokenNameCOMMENT_LINE	in the classpath. 
// 	TokenNameCOMMENT_LINE	 
try	TokenNametry	
{	TokenNameLBRACE	
setXMLCatalog	TokenNameIdentifier	 set XML Catalog
=	TokenNameEQUAL	
resolverImplClass	TokenNameIdentifier	 resolver Impl Class
.	TokenNameDOT	
getMethod	TokenNameIdentifier	 get Method
(	TokenNameLPAREN	
"setXMLCatalog"	TokenNameStringLiteral	setXMLCatalog
,	TokenNameCOMMA	
new	TokenNamenew	
Class	TokenNameIdentifier	 Class
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
XMLCatalog	TokenNameIdentifier	 XML Catalog
.	TokenNameDOT	
class	TokenNameclass	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
parseCatalog	TokenNameIdentifier	 parse Catalog
=	TokenNameEQUAL	
resolverImplClass	TokenNameIdentifier	 resolver Impl Class
.	TokenNameDOT	
getMethod	TokenNameIdentifier	 get Method
(	TokenNameLPAREN	
"parseCatalog"	TokenNameStringLiteral	parseCatalog
,	TokenNameCOMMA	
new	TokenNamenew	
Class	TokenNameIdentifier	 Class
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
class	TokenNameclass	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
resolveEntity	TokenNameIdentifier	 resolve Entity
=	TokenNameEQUAL	
resolverImplClass	TokenNameIdentifier	 resolver Impl Class
.	TokenNameDOT	
getMethod	TokenNameIdentifier	 get Method
(	TokenNameLPAREN	
"resolveEntity"	TokenNameStringLiteral	resolveEntity
,	TokenNameCOMMA	
new	TokenNamenew	
Class	TokenNameIdentifier	 Class
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
class	TokenNameclass	
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
class	TokenNameclass	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
resolve	TokenNameIdentifier	 resolve
=	TokenNameEQUAL	
resolverImplClass	TokenNameIdentifier	 resolver Impl Class
.	TokenNameDOT	
getMethod	TokenNameIdentifier	 get Method
(	TokenNameLPAREN	
"resolve"	TokenNameStringLiteral	resolve
,	TokenNameCOMMA	
new	TokenNamenew	
Class	TokenNameIdentifier	 Class
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
class	TokenNameclass	
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
class	TokenNameclass	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
NoSuchMethodException	TokenNameIdentifier	 No Such Method Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Apache resolver library found, xml-commons resolver will be used"	TokenNameStringLiteral	Apache resolver library found, xml-commons resolver will be used
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_VERBOSE	TokenNameIdentifier	 MSG  VERBOSE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
InputSource	TokenNameIdentifier	 Input Source
resolveEntity	TokenNameIdentifier	 resolve Entity
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
publicId	TokenNameIdentifier	 public Id
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
systemId	TokenNameIdentifier	 system Id
)	TokenNameRPAREN	
{	TokenNameLBRACE	
InputSource	TokenNameIdentifier	 Input Source
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
processExternalCatalogs	TokenNameIdentifier	 process External Catalogs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ResourceLocation	TokenNameIdentifier	 Resource Location
matchingEntry	TokenNameIdentifier	 matching Entry
=	TokenNameEQUAL	
findMatchingEntry	TokenNameIdentifier	 find Matching Entry
(	TokenNameLPAREN	
publicId	TokenNameIdentifier	 public Id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
matchingEntry	TokenNameIdentifier	 matching Entry
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Matching catalog entry found for publicId: '"	TokenNameStringLiteral	Matching catalog entry found for publicId: '
+	TokenNamePLUS	
matchingEntry	TokenNameIdentifier	 matching Entry
.	TokenNameDOT	
getPublicId	TokenNameIdentifier	 get Public Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"' location: '"	TokenNameStringLiteral	' location: '
+	TokenNamePLUS	
matchingEntry	TokenNameIdentifier	 matching Entry
.	TokenNameDOT	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"'"	TokenNameStringLiteral	'
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_DEBUG	TokenNameIdentifier	 MSG  DEBUG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
filesystemLookup	TokenNameIdentifier	 filesystem Lookup
(	TokenNameLPAREN	
matchingEntry	TokenNameIdentifier	 matching Entry
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
classpathLookup	TokenNameIdentifier	 classpath Lookup
(	TokenNameLPAREN	
matchingEntry	TokenNameIdentifier	 matching Entry
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
(	TokenNameLPAREN	
InputSource	TokenNameIdentifier	 Input Source
)	TokenNameRPAREN	
resolveEntity	TokenNameIdentifier	 resolve Entity
.	TokenNameDOT	
invoke	TokenNameIdentifier	 invoke
(	TokenNameLPAREN	
resolverImpl	TokenNameIdentifier	 resolver Impl
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
publicId	TokenNameIdentifier	 public Id
,	TokenNameCOMMA	
systemId	TokenNameIdentifier	 system Id
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// We didn't match a ResourceLocation, but since we 	TokenNameCOMMENT_LINE	We didn't match a ResourceLocation, but since we 
// only support PUBLIC and URI entry types internally, 	TokenNameCOMMENT_LINE	only support PUBLIC and URI entry types internally, 
// it is still possible that there is another entry in 	TokenNameCOMMENT_LINE	it is still possible that there is another entry in 
// an external catalog that will match. We call 	TokenNameCOMMENT_LINE	an external catalog that will match. We call 
// Apache resolver's resolveEntity method to cover 	TokenNameCOMMENT_LINE	Apache resolver's resolveEntity method to cover 
// this possibility. 	TokenNameCOMMENT_LINE	this possibility. 
// 	TokenNameCOMMENT_LINE	 
try	TokenNametry	
{	TokenNameLBRACE	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
(	TokenNameLPAREN	
InputSource	TokenNameIdentifier	 Input Source
)	TokenNameRPAREN	
resolveEntity	TokenNameIdentifier	 resolve Entity
.	TokenNameDOT	
invoke	TokenNameIdentifier	 invoke
(	TokenNameLPAREN	
resolverImpl	TokenNameIdentifier	 resolver Impl
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
publicId	TokenNameIdentifier	 public Id
,	TokenNameCOMMA	
systemId	TokenNameIdentifier	 system Id
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
result	TokenNameIdentifier	 result
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Source	TokenNameIdentifier	 Source
resolve	TokenNameIdentifier	 resolve
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
href	TokenNameIdentifier	 href
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
base	TokenNameIdentifier	 base
)	TokenNameRPAREN	
throws	TokenNamethrows	
TransformerException	TokenNameIdentifier	 Transformer Exception
{	TokenNameLBRACE	
SAXSource	TokenNameIdentifier	 SAX Source
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
InputSource	TokenNameIdentifier	 Input Source
source	TokenNameIdentifier	 source
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
processExternalCatalogs	TokenNameIdentifier	 process External Catalogs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ResourceLocation	TokenNameIdentifier	 Resource Location
matchingEntry	TokenNameIdentifier	 matching Entry
=	TokenNameEQUAL	
findMatchingEntry	TokenNameIdentifier	 find Matching Entry
(	TokenNameLPAREN	
href	TokenNameIdentifier	 href
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
matchingEntry	TokenNameIdentifier	 matching Entry
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Matching catalog entry found for uri: '"	TokenNameStringLiteral	Matching catalog entry found for uri: '
+	TokenNamePLUS	
matchingEntry	TokenNameIdentifier	 matching Entry
.	TokenNameDOT	
getPublicId	TokenNameIdentifier	 get Public Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"' location: '"	TokenNameStringLiteral	' location: '
+	TokenNamePLUS	
matchingEntry	TokenNameIdentifier	 matching Entry
.	TokenNameDOT	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"'"	TokenNameStringLiteral	'
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_DEBUG	TokenNameIdentifier	 MSG  DEBUG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Use the passed in base in preference to the base 	TokenNameCOMMENT_LINE	Use the passed in base in preference to the base 
// from matchingEntry, which is either null or the 	TokenNameCOMMENT_LINE	from matchingEntry, which is either null or the 
// directory in which the external catalog file from 	TokenNameCOMMENT_LINE	directory in which the external catalog file from 
// which it was obtained is located. We make a copy 	TokenNameCOMMENT_LINE	which it was obtained is located. We make a copy 
// so matchingEntry's original base is untouched. Of 	TokenNameCOMMENT_LINE	so matchingEntry's original base is untouched. Of 
// course, if there is no base, no need to make a 	TokenNameCOMMENT_LINE	course, if there is no base, no need to make a 
// copy... 	TokenNameCOMMENT_LINE	copy... 
// 	TokenNameCOMMENT_LINE	 
// This is the standard behavior as per my reading of 	TokenNameCOMMENT_LINE	This is the standard behavior as per my reading of 
// the JAXP and XML Catalog specs. CKS 11/7/2002 	TokenNameCOMMENT_LINE	the JAXP and XML Catalog specs. CKS 11/7/2002 
// 	TokenNameCOMMENT_LINE	 
ResourceLocation	TokenNameIdentifier	 Resource Location
entryCopy	TokenNameIdentifier	 entry Copy
=	TokenNameEQUAL	
matchingEntry	TokenNameIdentifier	 matching Entry
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
URL	TokenNameIdentifier	 URL
baseURL	TokenNameIdentifier	 base URL
=	TokenNameEQUAL	
new	TokenNamenew	
URL	TokenNameIdentifier	 URL
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
entryCopy	TokenNameIdentifier	 entry Copy
=	TokenNameEQUAL	
new	TokenNamenew	
ResourceLocation	TokenNameIdentifier	 Resource Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
entryCopy	TokenNameIdentifier	 entry Copy
.	TokenNameDOT	
setBase	TokenNameIdentifier	 set Base
(	TokenNameLPAREN	
baseURL	TokenNameIdentifier	 base URL
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
MalformedURLException	TokenNameIdentifier	 Malformed URL Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// ignore 	TokenNameCOMMENT_LINE	ignore 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
entryCopy	TokenNameIdentifier	 entry Copy
.	TokenNameDOT	
setPublicId	TokenNameIdentifier	 set Public Id
(	TokenNameLPAREN	
matchingEntry	TokenNameIdentifier	 matching Entry
.	TokenNameDOT	
getPublicId	TokenNameIdentifier	 get Public Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
entryCopy	TokenNameIdentifier	 entry Copy
.	TokenNameDOT	
setLocation	TokenNameIdentifier	 set Location
(	TokenNameLPAREN	
matchingEntry	TokenNameIdentifier	 matching Entry
.	TokenNameDOT	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
source	TokenNameIdentifier	 source
=	TokenNameEQUAL	
filesystemLookup	TokenNameIdentifier	 filesystem Lookup
(	TokenNameLPAREN	
entryCopy	TokenNameIdentifier	 entry Copy
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
source	TokenNameIdentifier	 source
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
source	TokenNameIdentifier	 source
=	TokenNameEQUAL	
classpathLookup	TokenNameIdentifier	 classpath Lookup
(	TokenNameLPAREN	
entryCopy	TokenNameIdentifier	 entry Copy
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
source	TokenNameIdentifier	 source
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
new	TokenNamenew	
SAXSource	TokenNameIdentifier	 SAX Source
(	TokenNameLPAREN	
source	TokenNameIdentifier	 source
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
(	TokenNameLPAREN	
SAXSource	TokenNameIdentifier	 SAX Source
)	TokenNameRPAREN	
resolve	TokenNameIdentifier	 resolve
.	TokenNameDOT	
invoke	TokenNameIdentifier	 invoke
(	TokenNameLPAREN	
resolverImpl	TokenNameIdentifier	 resolver Impl
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
href	TokenNameIdentifier	 href
,	TokenNameCOMMA	
base	TokenNameIdentifier	 base
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// We didn't match a ResourceLocation, but since we 	TokenNameCOMMENT_LINE	We didn't match a ResourceLocation, but since we 
// only support PUBLIC and URI entry types internally, 	TokenNameCOMMENT_LINE	only support PUBLIC and URI entry types internally, 
// it is still possible that there is another entry in 	TokenNameCOMMENT_LINE	it is still possible that there is another entry in 
// an external catalog that will match. We call 	TokenNameCOMMENT_LINE	an external catalog that will match. We call 
// Apache resolver's resolveEntity method to cover 	TokenNameCOMMENT_LINE	Apache resolver's resolveEntity method to cover 
// this possibility. 	TokenNameCOMMENT_LINE	this possibility. 
// 	TokenNameCOMMENT_LINE	 
try	TokenNametry	
{	TokenNameLBRACE	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
(	TokenNameLPAREN	
SAXSource	TokenNameIdentifier	 SAX Source
)	TokenNameRPAREN	
resolve	TokenNameIdentifier	 resolve
.	TokenNameDOT	
invoke	TokenNameIdentifier	 invoke
(	TokenNameLPAREN	
resolverImpl	TokenNameIdentifier	 resolver Impl
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
href	TokenNameIdentifier	 href
,	TokenNameCOMMA	
base	TokenNameIdentifier	 base
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
result	TokenNameIdentifier	 result
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Process each external catalog file specified in a * <code>&lt;catalogpath&gt;</code>. It will be * parsed by the resolver library, and the individual elements * will be added back to us (that is, the controlling * XMLCatalog instance) via a callback mechanism. */	TokenNameCOMMENT_JAVADOC	 Process each external catalog file specified in a <code>&lt;catalogpath&gt;</code>. It will be parsed by the resolver library, and the individual elements will be added back to us (that is, the controlling XMLCatalog instance) via a callback mechanism. 
private	TokenNameprivate	
void	TokenNamevoid	
processExternalCatalogs	TokenNameIdentifier	 process External Catalogs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
externalCatalogsProcessed	TokenNameIdentifier	 external Catalogs Processed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
setXMLCatalog	TokenNameIdentifier	 set XML Catalog
.	TokenNameDOT	
invoke	TokenNameIdentifier	 invoke
(	TokenNameLPAREN	
resolverImpl	TokenNameIdentifier	 resolver Impl
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
XMLCatalog	TokenNameIdentifier	 XML Catalog
.	TokenNameDOT	
this	TokenNamethis	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Parse each catalog listed in nested <catalogpath> elements 	TokenNameCOMMENT_LINE	Parse each catalog listed in nested <catalogpath> elements 
Path	TokenNameIdentifier	 Path
catPath	TokenNameIdentifier	 cat Path
=	TokenNameEQUAL	
getCatalogPath	TokenNameIdentifier	 get Catalog Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
catPath	TokenNameIdentifier	 cat Path
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Using catalogpath '"	TokenNameStringLiteral	Using catalogpath '
+	TokenNamePLUS	
getCatalogPath	TokenNameIdentifier	 get Catalog Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"'"	TokenNameStringLiteral	'
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_DEBUG	TokenNameIdentifier	 MSG  DEBUG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
catPathList	TokenNameIdentifier	 cat Path List
=	TokenNameEQUAL	
getCatalogPath	TokenNameIdentifier	 get Catalog Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
list	TokenNameIdentifier	 list
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
catPathList	TokenNameIdentifier	 cat Path List
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
catFile	TokenNameIdentifier	 cat File
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
catPathList	TokenNameIdentifier	 cat Path List
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Parsing "	TokenNameStringLiteral	Parsing 
+	TokenNamePLUS	
catFile	TokenNameIdentifier	 cat File
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_DEBUG	TokenNameIdentifier	 MSG  DEBUG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
parseCatalog	TokenNameIdentifier	 parse Catalog
.	TokenNameDOT	
invoke	TokenNameIdentifier	 invoke
(	TokenNameLPAREN	
resolverImpl	TokenNameIdentifier	 resolver Impl
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
catFile	TokenNameIdentifier	 cat File
.	TokenNameDOT	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
externalCatalogsProcessed	TokenNameIdentifier	 external Catalogs Processed
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//-- XMLCatalog 	TokenNameCOMMENT_LINE	-- XMLCatalog 
