package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
grouping	TokenNameIdentifier	 grouping
;	TokenNameSEMICOLON	
/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_JAVADOC	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
IndexReader	TokenNameIdentifier	 Index Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
IndexWriter	TokenNameIdentifier	 Index Writer
;	TokenNameSEMICOLON	
// javadocs 	TokenNameCOMMENT_LINE	javadocs 
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
Collector	TokenNameIdentifier	 Collector
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
DocIdSetIterator	TokenNameIdentifier	 Doc Id Set Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
FieldComparator	TokenNameIdentifier	 Field Comparator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
Filter	TokenNameIdentifier	 Filter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
Scorer	TokenNameIdentifier	 Scorer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
Sort	TokenNameIdentifier	 Sort
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
SortField	TokenNameIdentifier	 Sort Field
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
TopDocs	TokenNameIdentifier	 Top Docs
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
TopDocsCollector	TokenNameIdentifier	 Top Docs Collector
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
TopFieldCollector	TokenNameIdentifier	 Top Field Collector
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
TopScoreDocCollector	TokenNameIdentifier	 Top Score Doc Collector
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
Weight	TokenNameIdentifier	 Weight
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayUtil	TokenNameIdentifier	 Array Util
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
PriorityQueue	TokenNameIdentifier	 Priority Queue
;	TokenNameSEMICOLON	
/** BlockGroupingCollector performs grouping with a * single pass collector, as long as you are grouping by a * doc block field, ie all documents sharing a given group * value were indexed as a doc block using the atomic * {@link IndexWriter#addDocuments} or {@link * IndexWriter#updateDocuments} API. * * <p>This results in faster performance (~25% faster QPS) * than the two-pass grouping collectors, with the tradeoff * being that the documents in each group must always be * indexed as a block. This collector also fills in * TopGroups.totalGroupCount without requiring the separate * {@link TermAllGroupsCollector}. However, this collector does * not fill in the groupValue of each group; this field * will always be null. * * <p><b>NOTE</b>: this collector makes no effort to verify * the docs were in fact indexed as a block, so it's up to * you to ensure this was the case. * * <p>See {@link org.apache.lucene.search.grouping} for more * details including a full code example.</p> * * @lucene.experimental */	TokenNameCOMMENT_JAVADOC	 BlockGroupingCollector performs grouping with a single pass collector, as long as you are grouping by a doc block field, ie all documents sharing a given group value were indexed as a doc block using the atomic {@link IndexWriter#addDocuments} or {@link IndexWriter#updateDocuments} API. * <p>This results in faster performance (~25% faster QPS) than the two-pass grouping collectors, with the tradeoff being that the documents in each group must always be indexed as a block. This collector also fills in TopGroups.totalGroupCount without requiring the separate {@link TermAllGroupsCollector}. However, this collector does not fill in the groupValue of each group; this field will always be null. * <p><b>NOTE</b>: this collector makes no effort to verify the docs were in fact indexed as a block, so it's up to you to ensure this was the case. * <p>See {@link org.apache.lucene.search.grouping} for more details including a full code example.</p> * @lucene.experimental 
public	TokenNamepublic	
class	TokenNameclass	
BlockGroupingCollector	TokenNameIdentifier	 Block Grouping Collector
extends	TokenNameextends	
Collector	TokenNameIdentifier	 Collector
{	TokenNameLBRACE	
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
pendingSubDocs	TokenNameIdentifier	 pending Sub Docs
;	TokenNameSEMICOLON	
private	TokenNameprivate	
float	TokenNamefloat	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
pendingSubScores	TokenNameIdentifier	 pending Sub Scores
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
subDocUpto	TokenNameIdentifier	 sub Doc Upto
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Sort	TokenNameIdentifier	 Sort
groupSort	TokenNameIdentifier	 group Sort
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
topNGroups	TokenNameIdentifier	 top N Groups
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Filter	TokenNameIdentifier	 Filter
lastDocPerGroup	TokenNameIdentifier	 last Doc Per Group
;	TokenNameSEMICOLON	
// TODO: specialize into 2 classes, static "create" method: 	TokenNameCOMMENT_LINE	TODO: specialize into 2 classes, static "create" method: 
private	TokenNameprivate	
final	TokenNamefinal	
boolean	TokenNameboolean	
needsScores	TokenNameIdentifier	 needs Scores
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
FieldComparator	TokenNameIdentifier	 Field Comparator
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
comparators	TokenNameIdentifier	 comparators
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
reversed	TokenNameIdentifier	 reversed
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
compIDXEnd	TokenNameIdentifier	 comp IDX End
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
bottomSlot	TokenNameIdentifier	 bottom Slot
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
queueFull	TokenNameIdentifier	 queue Full
;	TokenNameSEMICOLON	
private	TokenNameprivate	
IndexReader	TokenNameIdentifier	 Index Reader
currentReader	TokenNameIdentifier	 current Reader
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
topGroupDoc	TokenNameIdentifier	 top Group Doc
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
totalHitCount	TokenNameIdentifier	 total Hit Count
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
totalGroupCount	TokenNameIdentifier	 total Group Count
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
docBase	TokenNameIdentifier	 doc Base
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
groupEndDocID	TokenNameIdentifier	 group End Doc ID
;	TokenNameSEMICOLON	
private	TokenNameprivate	
DocIdSetIterator	TokenNameIdentifier	 Doc Id Set Iterator
lastDocPerGroupBits	TokenNameIdentifier	 last Doc Per Group Bits
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Scorer	TokenNameIdentifier	 Scorer
scorer	TokenNameIdentifier	 scorer
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
GroupQueue	TokenNameIdentifier	 Group Queue
groupQueue	TokenNameIdentifier	 group Queue
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
groupCompetes	TokenNameIdentifier	 group Competes
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
static	TokenNamestatic	
class	TokenNameclass	
FakeScorer	TokenNameIdentifier	 Fake Scorer
extends	TokenNameextends	
Scorer	TokenNameIdentifier	 Scorer
{	TokenNameLBRACE	
float	TokenNamefloat	
score	TokenNameIdentifier	 score
;	TokenNameSEMICOLON	
int	TokenNameint	
doc	TokenNameIdentifier	 doc
;	TokenNameSEMICOLON	
public	TokenNamepublic	
FakeScorer	TokenNameIdentifier	 Fake Scorer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Weight	TokenNameIdentifier	 Weight
)	TokenNameRPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
float	TokenNamefloat	
score	TokenNameIdentifier	 score
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
score	TokenNameIdentifier	 score
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
int	TokenNameint	
docID	TokenNameIdentifier	 doc ID
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
doc	TokenNameIdentifier	 doc
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
int	TokenNameint	
advance	TokenNameIdentifier	 advance
(	TokenNameLPAREN	
int	TokenNameint	
target	TokenNameIdentifier	 target
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
UnsupportedOperationException	TokenNameIdentifier	 Unsupported Operation Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
int	TokenNameint	
nextDoc	TokenNameIdentifier	 next Doc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
UnsupportedOperationException	TokenNameIdentifier	 Unsupported Operation Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
class	TokenNameclass	
OneGroup	TokenNameIdentifier	 One Group
{	TokenNameLBRACE	
IndexReader	TokenNameIdentifier	 Index Reader
reader	TokenNameIdentifier	 reader
;	TokenNameSEMICOLON	
int	TokenNameint	
docBase	TokenNameIdentifier	 doc Base
;	TokenNameSEMICOLON	
//int groupOrd; 	TokenNameCOMMENT_LINE	int groupOrd; 
int	TokenNameint	
topGroupDoc	TokenNameIdentifier	 top Group Doc
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
docs	TokenNameIdentifier	 docs
;	TokenNameSEMICOLON	
float	TokenNamefloat	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
scores	TokenNameIdentifier	 scores
;	TokenNameSEMICOLON	
int	TokenNameint	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
int	TokenNameint	
comparatorSlot	TokenNameIdentifier	 comparator Slot
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Sorts by groupSort. Not static -- uses comparators, reversed 	TokenNameCOMMENT_LINE	Sorts by groupSort. Not static -- uses comparators, reversed 
private	TokenNameprivate	
final	TokenNamefinal	
class	TokenNameclass	
GroupQueue	TokenNameIdentifier	 Group Queue
extends	TokenNameextends	
PriorityQueue	TokenNameIdentifier	 Priority Queue
<	TokenNameLESS	
OneGroup	TokenNameIdentifier	 One Group
>	TokenNameGREATER	
{	TokenNameLBRACE	
public	TokenNamepublic	
GroupQueue	TokenNameIdentifier	 Group Queue
(	TokenNameLPAREN	
int	TokenNameint	
size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
initialize	TokenNameIdentifier	 initialize
(	TokenNameLPAREN	
size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
protected	TokenNameprotected	
boolean	TokenNameboolean	
lessThan	TokenNameIdentifier	 less Than
(	TokenNameLPAREN	
final	TokenNamefinal	
OneGroup	TokenNameIdentifier	 One Group
group1	TokenNameIdentifier	 group1
,	TokenNameCOMMA	
final	TokenNamefinal	
OneGroup	TokenNameIdentifier	 One Group
group2	TokenNameIdentifier	 group2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println(" ltcheck"); 	TokenNameCOMMENT_LINE	System.out.println(" ltcheck"); 
assert	TokenNameassert	
group1	TokenNameIdentifier	 group1
!=	TokenNameNOT_EQUAL	
group2	TokenNameIdentifier	 group2
;	TokenNameSEMICOLON	
assert	TokenNameassert	
group1	TokenNameIdentifier	 group1
.	TokenNameDOT	
comparatorSlot	TokenNameIdentifier	 comparator Slot
!=	TokenNameNOT_EQUAL	
group2	TokenNameIdentifier	 group2
.	TokenNameDOT	
comparatorSlot	TokenNameIdentifier	 comparator Slot
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
numComparators	TokenNameIdentifier	 num Comparators
=	TokenNameEQUAL	
comparators	TokenNameIdentifier	 comparators
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
compIDX	TokenNameIdentifier	 comp IDX
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
compIDX	TokenNameIdentifier	 comp IDX
<	TokenNameLESS	
numComparators	TokenNameIdentifier	 num Comparators
;	TokenNameSEMICOLON	
compIDX	TokenNameIdentifier	 comp IDX
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
reversed	TokenNameIdentifier	 reversed
[	TokenNameLBRACKET	
compIDX	TokenNameIdentifier	 comp IDX
]	TokenNameRBRACKET	
*	TokenNameMULTIPLY	
comparators	TokenNameIdentifier	 comparators
[	TokenNameLBRACKET	
compIDX	TokenNameIdentifier	 comp IDX
]	TokenNameRBRACKET	
.	TokenNameDOT	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
group1	TokenNameIdentifier	 group1
.	TokenNameDOT	
comparatorSlot	TokenNameIdentifier	 comparator Slot
,	TokenNameCOMMA	
group2	TokenNameIdentifier	 group2
.	TokenNameDOT	
comparatorSlot	TokenNameIdentifier	 comparator Slot
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Short circuit 	TokenNameCOMMENT_LINE	Short circuit 
return	TokenNamereturn	
c	TokenNameIdentifier	 c
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Break ties by docID; lower docID is always sorted first 	TokenNameCOMMENT_LINE	Break ties by docID; lower docID is always sorted first 
return	TokenNamereturn	
group1	TokenNameIdentifier	 group1
.	TokenNameDOT	
topGroupDoc	TokenNameIdentifier	 top Group Doc
>	TokenNameGREATER	
group2	TokenNameIdentifier	 group2
.	TokenNameDOT	
topGroupDoc	TokenNameIdentifier	 top Group Doc
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Called when we transition to another group; if the 	TokenNameCOMMENT_LINE	Called when we transition to another group; if the 
// group is competitive we insert into the group queue 	TokenNameCOMMENT_LINE	group is competitive we insert into the group queue 
private	TokenNameprivate	
void	TokenNamevoid	
processGroup	TokenNameIdentifier	 process Group
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
totalGroupCount	TokenNameIdentifier	 total Group Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
//System.out.println(" processGroup ord=" + lastGroupOrd + " competes=" + groupCompetes + " count=" + subDocUpto + " groupDoc=" + topGroupDoc); 	TokenNameCOMMENT_LINE	System.out.println(" processGroup ord=" + lastGroupOrd + " competes=" + groupCompetes + " count=" + subDocUpto + " groupDoc=" + topGroupDoc); 
if	TokenNameif	
(	TokenNameLPAREN	
groupCompetes	TokenNameIdentifier	 group Competes
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
queueFull	TokenNameIdentifier	 queue Full
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Startup transient: always add a new OneGroup 	TokenNameCOMMENT_LINE	Startup transient: always add a new OneGroup 
final	TokenNamefinal	
OneGroup	TokenNameIdentifier	 One Group
og	TokenNameIdentifier	 og
=	TokenNameEQUAL	
new	TokenNamenew	
OneGroup	TokenNameIdentifier	 One Group
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
subDocUpto	TokenNameIdentifier	 sub Doc Upto
;	TokenNameSEMICOLON	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
topGroupDoc	TokenNameIdentifier	 top Group Doc
=	TokenNameEQUAL	
docBase	TokenNameIdentifier	 doc Base
+	TokenNamePLUS	
topGroupDoc	TokenNameIdentifier	 top Group Doc
;	TokenNameSEMICOLON	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
docs	TokenNameIdentifier	 docs
=	TokenNameEQUAL	
pendingSubDocs	TokenNameIdentifier	 pending Sub Docs
;	TokenNameSEMICOLON	
pendingSubDocs	TokenNameIdentifier	 pending Sub Docs
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
10	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
needsScores	TokenNameIdentifier	 needs Scores
)	TokenNameRPAREN	
{	TokenNameLBRACE	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
scores	TokenNameIdentifier	 scores
=	TokenNameEQUAL	
pendingSubScores	TokenNameIdentifier	 pending Sub Scores
;	TokenNameSEMICOLON	
pendingSubScores	TokenNameIdentifier	 pending Sub Scores
=	TokenNameEQUAL	
new	TokenNamenew	
float	TokenNamefloat	
[	TokenNameLBRACKET	
10	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
reader	TokenNameIdentifier	 reader
=	TokenNameEQUAL	
currentReader	TokenNameIdentifier	 current Reader
;	TokenNameSEMICOLON	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
docBase	TokenNameIdentifier	 doc Base
=	TokenNameEQUAL	
docBase	TokenNameIdentifier	 doc Base
;	TokenNameSEMICOLON	
//og.groupOrd = lastGroupOrd; 	TokenNameCOMMENT_LINE	og.groupOrd = lastGroupOrd; 
og	TokenNameIdentifier	 og
.	TokenNameDOT	
comparatorSlot	TokenNameIdentifier	 comparator Slot
=	TokenNameEQUAL	
bottomSlot	TokenNameIdentifier	 bottom Slot
;	TokenNameSEMICOLON	
final	TokenNamefinal	
OneGroup	TokenNameIdentifier	 One Group
bottomGroup	TokenNameIdentifier	 bottom Group
=	TokenNameEQUAL	
groupQueue	TokenNameIdentifier	 group Queue
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
og	TokenNameIdentifier	 og
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println(" ADD group=" + getGroupString(lastGroupOrd) + " newBottom=" + getGroupString(bottomGroup.groupOrd)); 	TokenNameCOMMENT_LINE	System.out.println(" ADD group=" + getGroupString(lastGroupOrd) + " newBottom=" + getGroupString(bottomGroup.groupOrd)); 
queueFull	TokenNameIdentifier	 queue Full
=	TokenNameEQUAL	
groupQueue	TokenNameIdentifier	 group Queue
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
topNGroups	TokenNameIdentifier	 top N Groups
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
queueFull	TokenNameIdentifier	 queue Full
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Queue just became full; now set the real bottom 	TokenNameCOMMENT_LINE	Queue just became full; now set the real bottom 
// in the comparators: 	TokenNameCOMMENT_LINE	in the comparators: 
bottomSlot	TokenNameIdentifier	 bottom Slot
=	TokenNameEQUAL	
bottomGroup	TokenNameIdentifier	 bottom Group
.	TokenNameDOT	
comparatorSlot	TokenNameIdentifier	 comparator Slot
;	TokenNameSEMICOLON	
//System.out.println(" set bottom=" + bottomSlot); 	TokenNameCOMMENT_LINE	System.out.println(" set bottom=" + bottomSlot); 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
comparators	TokenNameIdentifier	 comparators
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
comparators	TokenNameIdentifier	 comparators
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
setBottom	TokenNameIdentifier	 set Bottom
(	TokenNameLPAREN	
bottomSlot	TokenNameIdentifier	 bottom Slot
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//System.out.println(" QUEUE FULL"); 	TokenNameCOMMENT_LINE	System.out.println(" QUEUE FULL"); 
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Queue not full yet -- just advance bottomSlot: 	TokenNameCOMMENT_LINE	Queue not full yet -- just advance bottomSlot: 
bottomSlot	TokenNameIdentifier	 bottom Slot
=	TokenNameEQUAL	
groupQueue	TokenNameIdentifier	 group Queue
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Replace bottom element in PQ and then updateTop 	TokenNameCOMMENT_LINE	Replace bottom element in PQ and then updateTop 
final	TokenNamefinal	
OneGroup	TokenNameIdentifier	 One Group
og	TokenNameIdentifier	 og
=	TokenNameEQUAL	
groupQueue	TokenNameIdentifier	 group Queue
.	TokenNameDOT	
top	TokenNameIdentifier	 top
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
og	TokenNameIdentifier	 og
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
subDocUpto	TokenNameIdentifier	 sub Doc Upto
;	TokenNameSEMICOLON	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
topGroupDoc	TokenNameIdentifier	 top Group Doc
=	TokenNameEQUAL	
docBase	TokenNameIdentifier	 doc Base
+	TokenNamePLUS	
topGroupDoc	TokenNameIdentifier	 top Group Doc
;	TokenNameSEMICOLON	
// Swap pending docs 	TokenNameCOMMENT_LINE	Swap pending docs 
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
savDocs	TokenNameIdentifier	 sav Docs
=	TokenNameEQUAL	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
docs	TokenNameIdentifier	 docs
;	TokenNameSEMICOLON	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
docs	TokenNameIdentifier	 docs
=	TokenNameEQUAL	
pendingSubDocs	TokenNameIdentifier	 pending Sub Docs
;	TokenNameSEMICOLON	
pendingSubDocs	TokenNameIdentifier	 pending Sub Docs
=	TokenNameEQUAL	
savDocs	TokenNameIdentifier	 sav Docs
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
needsScores	TokenNameIdentifier	 needs Scores
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Swap pending scores 	TokenNameCOMMENT_LINE	Swap pending scores 
final	TokenNamefinal	
float	TokenNamefloat	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
savScores	TokenNameIdentifier	 sav Scores
=	TokenNameEQUAL	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
scores	TokenNameIdentifier	 scores
;	TokenNameSEMICOLON	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
scores	TokenNameIdentifier	 scores
=	TokenNameEQUAL	
pendingSubScores	TokenNameIdentifier	 pending Sub Scores
;	TokenNameSEMICOLON	
pendingSubScores	TokenNameIdentifier	 pending Sub Scores
=	TokenNameEQUAL	
savScores	TokenNameIdentifier	 sav Scores
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
reader	TokenNameIdentifier	 reader
=	TokenNameEQUAL	
currentReader	TokenNameIdentifier	 current Reader
;	TokenNameSEMICOLON	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
docBase	TokenNameIdentifier	 doc Base
=	TokenNameEQUAL	
docBase	TokenNameIdentifier	 doc Base
;	TokenNameSEMICOLON	
//og.groupOrd = lastGroupOrd; 	TokenNameCOMMENT_LINE	og.groupOrd = lastGroupOrd; 
bottomSlot	TokenNameIdentifier	 bottom Slot
=	TokenNameEQUAL	
groupQueue	TokenNameIdentifier	 group Queue
.	TokenNameDOT	
updateTop	TokenNameIdentifier	 update Top
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
comparatorSlot	TokenNameIdentifier	 comparator Slot
;	TokenNameSEMICOLON	
//System.out.println(" set bottom=" + bottomSlot); 	TokenNameCOMMENT_LINE	System.out.println(" set bottom=" + bottomSlot); 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
comparators	TokenNameIdentifier	 comparators
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
comparators	TokenNameIdentifier	 comparators
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
setBottom	TokenNameIdentifier	 set Bottom
(	TokenNameLPAREN	
bottomSlot	TokenNameIdentifier	 bottom Slot
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
subDocUpto	TokenNameIdentifier	 sub Doc Upto
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Create the single pass collector. * * @param groupSort The {@link Sort} used to sort the * groups. The top sorted document within each group * according to groupSort, determines how that group * sorts against other groups. This must be non-null, * ie, if you want to groupSort by relevance use * Sort.RELEVANCE. * @param topNGroups How many top groups to keep. * @param needsScores true if the collected documents * require scores, either because relevance is included * in the withinGroupSort or because you plan to pass true * for either getSscores or getMaxScores to {@link * #getTopGroups} * @param lastDocPerGroup a {@link Filter} that marks the * last document in each group. */	TokenNameCOMMENT_JAVADOC	 Create the single pass collector. * @param groupSort The {@link Sort} used to sort the groups. The top sorted document within each group according to groupSort, determines how that group sorts against other groups. This must be non-null, ie, if you want to groupSort by relevance use Sort.RELEVANCE. @param topNGroups How many top groups to keep. @param needsScores true if the collected documents require scores, either because relevance is included in the withinGroupSort or because you plan to pass true for either getSscores or getMaxScores to {@link #getTopGroups} @param lastDocPerGroup a {@link Filter} that marks the last document in each group. 
public	TokenNamepublic	
BlockGroupingCollector	TokenNameIdentifier	 Block Grouping Collector
(	TokenNameLPAREN	
Sort	TokenNameIdentifier	 Sort
groupSort	TokenNameIdentifier	 group Sort
,	TokenNameCOMMA	
int	TokenNameint	
topNGroups	TokenNameIdentifier	 top N Groups
,	TokenNameCOMMA	
boolean	TokenNameboolean	
needsScores	TokenNameIdentifier	 needs Scores
,	TokenNameCOMMA	
Filter	TokenNameIdentifier	 Filter
lastDocPerGroup	TokenNameIdentifier	 last Doc Per Group
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
topNGroups	TokenNameIdentifier	 top N Groups
<	TokenNameLESS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"topNGroups must be >= 1 (got "	TokenNameStringLiteral	topNGroups must be >= 1 (got 
+	TokenNamePLUS	
topNGroups	TokenNameIdentifier	 top N Groups
+	TokenNamePLUS	
")"	TokenNameStringLiteral	)
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
groupQueue	TokenNameIdentifier	 group Queue
=	TokenNameEQUAL	
new	TokenNamenew	
GroupQueue	TokenNameIdentifier	 Group Queue
(	TokenNameLPAREN	
topNGroups	TokenNameIdentifier	 top N Groups
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pendingSubDocs	TokenNameIdentifier	 pending Sub Docs
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
10	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
needsScores	TokenNameIdentifier	 needs Scores
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pendingSubScores	TokenNameIdentifier	 pending Sub Scores
=	TokenNameEQUAL	
new	TokenNamenew	
float	TokenNamefloat	
[	TokenNameLBRACKET	
10	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
this	TokenNamethis	
.	TokenNameDOT	
needsScores	TokenNameIdentifier	 needs Scores
=	TokenNameEQUAL	
needsScores	TokenNameIdentifier	 needs Scores
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
lastDocPerGroup	TokenNameIdentifier	 last Doc Per Group
=	TokenNameEQUAL	
lastDocPerGroup	TokenNameIdentifier	 last Doc Per Group
;	TokenNameSEMICOLON	
// TODO: allow null groupSort to mean "by relevance", 	TokenNameCOMMENT_LINE	TODO: allow null groupSort to mean "by relevance", 
// and specialize it? 	TokenNameCOMMENT_LINE	and specialize it? 
this	TokenNamethis	
.	TokenNameDOT	
groupSort	TokenNameIdentifier	 group Sort
=	TokenNameEQUAL	
groupSort	TokenNameIdentifier	 group Sort
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
topNGroups	TokenNameIdentifier	 top N Groups
=	TokenNameEQUAL	
topNGroups	TokenNameIdentifier	 top N Groups
;	TokenNameSEMICOLON	
final	TokenNamefinal	
SortField	TokenNameIdentifier	 Sort Field
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
sortFields	TokenNameIdentifier	 sort Fields
=	TokenNameEQUAL	
groupSort	TokenNameIdentifier	 group Sort
.	TokenNameDOT	
getSort	TokenNameIdentifier	 get Sort
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
comparators	TokenNameIdentifier	 comparators
=	TokenNameEQUAL	
new	TokenNamenew	
FieldComparator	TokenNameIdentifier	 Field Comparator
[	TokenNameLBRACKET	
sortFields	TokenNameIdentifier	 sort Fields
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
compIDXEnd	TokenNameIdentifier	 comp IDX End
=	TokenNameEQUAL	
comparators	TokenNameIdentifier	 comparators
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
reversed	TokenNameIdentifier	 reversed
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
sortFields	TokenNameIdentifier	 sort Fields
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
sortFields	TokenNameIdentifier	 sort Fields
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
SortField	TokenNameIdentifier	 Sort Field
sortField	TokenNameIdentifier	 sort Field
=	TokenNameEQUAL	
sortFields	TokenNameIdentifier	 sort Fields
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
comparators	TokenNameIdentifier	 comparators
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
sortField	TokenNameIdentifier	 sort Field
.	TokenNameDOT	
getComparator	TokenNameIdentifier	 get Comparator
(	TokenNameLPAREN	
topNGroups	TokenNameIdentifier	 top N Groups
,	TokenNameCOMMA	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reversed	TokenNameIdentifier	 reversed
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
sortField	TokenNameIdentifier	 sort Field
.	TokenNameDOT	
getReverse	TokenNameIdentifier	 get Reverse
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// TODO: maybe allow no sort on retrieving groups? app 	TokenNameCOMMENT_LINE	TODO: maybe allow no sort on retrieving groups? app 
// may want to simply process docs in the group itself? 	TokenNameCOMMENT_LINE	may want to simply process docs in the group itself? 
// typically they will be presented as a "single" result 	TokenNameCOMMENT_LINE	typically they will be presented as a "single" result 
// in the UI? 	TokenNameCOMMENT_LINE	in the UI? 
/** Returns the grouped results. Returns null if the * number of groups collected is <= groupOffset. * * <p><b>NOTE</b>: This collector is unable to compute * the groupValue per group so it will always be null. * This is normally not a problem, as you can obtain the * value just like you obtain other values for each * matching document (eg, via stored fields, via * FieldCache, etc.) * * @param withinGroupSort The {@link Sort} used to sort * documents within each group. Passing null is * allowed, to sort by relevance. * @param groupOffset Which group to start from * @param withinGroupOffset Which document to start from * within each group * @param maxDocsPerGroup How many top documents to keep * within each group. * @param fillSortFields If true then the Comparable * values for the sort fields will be set */	TokenNameCOMMENT_JAVADOC	 Returns the grouped results. Returns null if the number of groups collected is <= groupOffset. * <p><b>NOTE</b>: This collector is unable to compute the groupValue per group so it will always be null. This is normally not a problem, as you can obtain the value just like you obtain other values for each matching document (eg, via stored fields, via FieldCache, etc.) * @param withinGroupSort The {@link Sort} used to sort documents within each group. Passing null is allowed, to sort by relevance. @param groupOffset Which group to start from @param withinGroupOffset Which document to start from within each group @param maxDocsPerGroup How many top documents to keep within each group. @param fillSortFields If true then the Comparable values for the sort fields will be set 
public	TokenNamepublic	
TopGroups	TokenNameIdentifier	 Top Groups
getTopGroups	TokenNameIdentifier	 get Top Groups
(	TokenNameLPAREN	
Sort	TokenNameIdentifier	 Sort
withinGroupSort	TokenNameIdentifier	 within Group Sort
,	TokenNameCOMMA	
int	TokenNameint	
groupOffset	TokenNameIdentifier	 group Offset
,	TokenNameCOMMA	
int	TokenNameint	
withinGroupOffset	TokenNameIdentifier	 within Group Offset
,	TokenNameCOMMA	
int	TokenNameint	
maxDocsPerGroup	TokenNameIdentifier	 max Docs Per Group
,	TokenNameCOMMA	
boolean	TokenNameboolean	
fillSortFields	TokenNameIdentifier	 fill Sort Fields
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
//if (queueFull) { 	TokenNameCOMMENT_LINE	if (queueFull) { 
//System.out.println("getTopGroups groupOffset=" + groupOffset + " topNGroups=" + topNGroups); 	TokenNameCOMMENT_LINE	System.out.println("getTopGroups groupOffset=" + groupOffset + " topNGroups=" + topNGroups); 
//} 	TokenNameCOMMENT_LINE	} 
if	TokenNameif	
(	TokenNameLPAREN	
subDocUpto	TokenNameIdentifier	 sub Doc Upto
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
processGroup	TokenNameIdentifier	 process Group
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
groupOffset	TokenNameIdentifier	 group Offset
>=	TokenNameGREATER_EQUAL	
groupQueue	TokenNameIdentifier	 group Queue
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
totalGroupedHitCount	TokenNameIdentifier	 total Grouped Hit Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
FakeScorer	TokenNameIdentifier	 Fake Scorer
fakeScorer	TokenNameIdentifier	 fake Scorer
=	TokenNameEQUAL	
new	TokenNamenew	
FakeScorer	TokenNameIdentifier	 Fake Scorer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
@	TokenNameAT	
SuppressWarnings	TokenNameIdentifier	 Suppress Warnings
(	TokenNameLPAREN	
{	TokenNameLBRACE	
"unchecked"	TokenNameStringLiteral	unchecked
,	TokenNameCOMMA	
"rawtypes"	TokenNameStringLiteral	rawtypes
}	TokenNameRBRACE	
)	TokenNameRPAREN	
final	TokenNamefinal	
GroupDocs	TokenNameIdentifier	 Group Docs
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
groups	TokenNameIdentifier	 groups
=	TokenNameEQUAL	
(	TokenNameLPAREN	
GroupDocs	TokenNameIdentifier	 Group Docs
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
new	TokenNamenew	
GroupDocs	TokenNameIdentifier	 Group Docs
[	TokenNameLBRACKET	
groupQueue	TokenNameIdentifier	 group Queue
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
groupOffset	TokenNameIdentifier	 group Offset
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
downTo	TokenNameIdentifier	 down To
=	TokenNameEQUAL	
groupQueue	TokenNameIdentifier	 group Queue
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
groupOffset	TokenNameIdentifier	 group Offset
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
downTo	TokenNameIdentifier	 down To
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
downTo	TokenNameIdentifier	 down To
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
OneGroup	TokenNameIdentifier	 One Group
og	TokenNameIdentifier	 og
=	TokenNameEQUAL	
groupQueue	TokenNameIdentifier	 group Queue
.	TokenNameDOT	
pop	TokenNameIdentifier	 pop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// At this point we hold all docs w/ in each group, 	TokenNameCOMMENT_LINE	At this point we hold all docs w/ in each group, 
// unsorted; we now sort them: 	TokenNameCOMMENT_LINE	unsorted; we now sort them: 
final	TokenNamefinal	
TopDocsCollector	TokenNameIdentifier	 Top Docs Collector
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
collector	TokenNameIdentifier	 collector
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
withinGroupSort	TokenNameIdentifier	 within Group Sort
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Sort by score 	TokenNameCOMMENT_LINE	Sort by score 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
needsScores	TokenNameIdentifier	 needs Scores
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"cannot sort by relevance within group: needsScores=false"	TokenNameStringLiteral	cannot sort by relevance within group: needsScores=false
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
collector	TokenNameIdentifier	 collector
=	TokenNameEQUAL	
TopScoreDocCollector	TokenNameIdentifier	 Top Score Doc Collector
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
maxDocsPerGroup	TokenNameIdentifier	 max Docs Per Group
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Sort by fields 	TokenNameCOMMENT_LINE	Sort by fields 
collector	TokenNameIdentifier	 collector
=	TokenNameEQUAL	
TopFieldCollector	TokenNameIdentifier	 Top Field Collector
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
withinGroupSort	TokenNameIdentifier	 within Group Sort
,	TokenNameCOMMA	
maxDocsPerGroup	TokenNameIdentifier	 max Docs Per Group
,	TokenNameCOMMA	
fillSortFields	TokenNameIdentifier	 fill Sort Fields
,	TokenNameCOMMA	
needsScores	TokenNameIdentifier	 needs Scores
,	TokenNameCOMMA	
needsScores	TokenNameIdentifier	 needs Scores
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
collector	TokenNameIdentifier	 collector
.	TokenNameDOT	
setScorer	TokenNameIdentifier	 set Scorer
(	TokenNameLPAREN	
fakeScorer	TokenNameIdentifier	 fake Scorer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
collector	TokenNameIdentifier	 collector
.	TokenNameDOT	
setNextReader	TokenNameIdentifier	 set Next Reader
(	TokenNameLPAREN	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
reader	TokenNameIdentifier	 reader
,	TokenNameCOMMA	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
docBase	TokenNameIdentifier	 doc Base
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
docIDX	TokenNameIdentifier	 doc IDX
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
docIDX	TokenNameIdentifier	 doc IDX
<	TokenNameLESS	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
docIDX	TokenNameIdentifier	 doc IDX
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
doc	TokenNameIdentifier	 doc
=	TokenNameEQUAL	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
docs	TokenNameIdentifier	 docs
[	TokenNameLBRACKET	
docIDX	TokenNameIdentifier	 doc IDX
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fakeScorer	TokenNameIdentifier	 fake Scorer
.	TokenNameDOT	
doc	TokenNameIdentifier	 doc
=	TokenNameEQUAL	
doc	TokenNameIdentifier	 doc
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
needsScores	TokenNameIdentifier	 needs Scores
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fakeScorer	TokenNameIdentifier	 fake Scorer
.	TokenNameDOT	
score	TokenNameIdentifier	 score
=	TokenNameEQUAL	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
scores	TokenNameIdentifier	 scores
[	TokenNameLBRACKET	
docIDX	TokenNameIdentifier	 doc IDX
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
collector	TokenNameIdentifier	 collector
.	TokenNameDOT	
collect	TokenNameIdentifier	 collect
(	TokenNameLPAREN	
doc	TokenNameIdentifier	 doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
totalGroupedHitCount	TokenNameIdentifier	 total Grouped Hit Count
+=	TokenNamePLUS_EQUAL	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
groupSortValues	TokenNameIdentifier	 group Sort Values
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fillSortFields	TokenNameIdentifier	 fill Sort Fields
)	TokenNameRPAREN	
{	TokenNameLBRACE	
groupSortValues	TokenNameIdentifier	 group Sort Values
=	TokenNameEQUAL	
new	TokenNamenew	
Comparable	TokenNameIdentifier	 Comparable
[	TokenNameLBRACKET	
comparators	TokenNameIdentifier	 comparators
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
sortFieldIDX	TokenNameIdentifier	 sort Field IDX
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
sortFieldIDX	TokenNameIdentifier	 sort Field IDX
<	TokenNameLESS	
comparators	TokenNameIdentifier	 comparators
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
sortFieldIDX	TokenNameIdentifier	 sort Field IDX
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
groupSortValues	TokenNameIdentifier	 group Sort Values
[	TokenNameLBRACKET	
sortFieldIDX	TokenNameIdentifier	 sort Field IDX
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
comparators	TokenNameIdentifier	 comparators
[	TokenNameLBRACKET	
sortFieldIDX	TokenNameIdentifier	 sort Field IDX
]	TokenNameRBRACKET	
.	TokenNameDOT	
value	TokenNameIdentifier	 value
(	TokenNameLPAREN	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
comparatorSlot	TokenNameIdentifier	 comparator Slot
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
groupSortValues	TokenNameIdentifier	 group Sort Values
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
TopDocs	TokenNameIdentifier	 Top Docs
topDocs	TokenNameIdentifier	 top Docs
=	TokenNameEQUAL	
collector	TokenNameIdentifier	 collector
.	TokenNameDOT	
topDocs	TokenNameIdentifier	 top Docs
(	TokenNameLPAREN	
withinGroupOffset	TokenNameIdentifier	 within Group Offset
,	TokenNameCOMMA	
maxDocsPerGroup	TokenNameIdentifier	 max Docs Per Group
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
groups	TokenNameIdentifier	 groups
[	TokenNameLBRACKET	
downTo	TokenNameIdentifier	 down To
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
GroupDocs	TokenNameIdentifier	 Group Docs
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
(	TokenNameLPAREN	
topDocs	TokenNameIdentifier	 top Docs
.	TokenNameDOT	
getMaxScore	TokenNameIdentifier	 get Max Score
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
count	TokenNameIdentifier	 count
,	TokenNameCOMMA	
topDocs	TokenNameIdentifier	 top Docs
.	TokenNameDOT	
scoreDocs	TokenNameIdentifier	 score Docs
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
groupSortValues	TokenNameIdentifier	 group Sort Values
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* while (groupQueue.size() != 0) { final OneGroup og = groupQueue.pop(); //System.out.println(" leftover: og ord=" + og.groupOrd + " count=" + og.count); totalGroupedHitCount += og.count; } */	TokenNameCOMMENT_BLOCK	 while (groupQueue.size() != 0) { final OneGroup og = groupQueue.pop(); //System.out.println(" leftover: og ord=" + og.groupOrd + " count=" + og.count); totalGroupedHitCount += og.count; } 
return	TokenNamereturn	
new	TokenNamenew	
TopGroups	TokenNameIdentifier	 Top Groups
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
(	TokenNameLPAREN	
new	TokenNamenew	
TopGroups	TokenNameIdentifier	 Top Groups
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
(	TokenNameLPAREN	
groupSort	TokenNameIdentifier	 group Sort
.	TokenNameDOT	
getSort	TokenNameIdentifier	 get Sort
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
withinGroupSort	TokenNameIdentifier	 within Group Sort
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
withinGroupSort	TokenNameIdentifier	 within Group Sort
.	TokenNameDOT	
getSort	TokenNameIdentifier	 get Sort
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
totalHitCount	TokenNameIdentifier	 total Hit Count
,	TokenNameCOMMA	
totalGroupedHitCount	TokenNameIdentifier	 total Grouped Hit Count
,	TokenNameCOMMA	
groups	TokenNameIdentifier	 groups
)	TokenNameRPAREN	
,	TokenNameCOMMA	
totalGroupCount	TokenNameIdentifier	 total Group Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
setScorer	TokenNameIdentifier	 set Scorer
(	TokenNameLPAREN	
Scorer	TokenNameIdentifier	 Scorer
scorer	TokenNameIdentifier	 scorer
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
scorer	TokenNameIdentifier	 scorer
=	TokenNameEQUAL	
scorer	TokenNameIdentifier	 scorer
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
FieldComparator	TokenNameIdentifier	 Field Comparator
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
comparator	TokenNameIdentifier	 comparator
:	TokenNameCOLON	
comparators	TokenNameIdentifier	 comparators
)	TokenNameRPAREN	
{	TokenNameLBRACE	
comparator	TokenNameIdentifier	 comparator
.	TokenNameDOT	
setScorer	TokenNameIdentifier	 set Scorer
(	TokenNameLPAREN	
scorer	TokenNameIdentifier	 scorer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
collect	TokenNameIdentifier	 collect
(	TokenNameLPAREN	
int	TokenNameint	
doc	TokenNameIdentifier	 doc
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// System.out.println("C " + doc); 	TokenNameCOMMENT_LINE	System.out.println("C " + doc); 
if	TokenNameif	
(	TokenNameLPAREN	
doc	TokenNameIdentifier	 doc
>	TokenNameGREATER	
groupEndDocID	TokenNameIdentifier	 group End Doc ID
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Group changed 	TokenNameCOMMENT_LINE	Group changed 
if	TokenNameif	
(	TokenNameLPAREN	
subDocUpto	TokenNameIdentifier	 sub Doc Upto
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
processGroup	TokenNameIdentifier	 process Group
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
groupEndDocID	TokenNameIdentifier	 group End Doc ID
=	TokenNameEQUAL	
lastDocPerGroupBits	TokenNameIdentifier	 last Doc Per Group Bits
.	TokenNameDOT	
advance	TokenNameIdentifier	 advance
(	TokenNameLPAREN	
doc	TokenNameIdentifier	 doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println(" adv " + groupEndDocID + " " + lastDocPerGroupBits); 	TokenNameCOMMENT_LINE	System.out.println(" adv " + groupEndDocID + " " + lastDocPerGroupBits); 
subDocUpto	TokenNameIdentifier	 sub Doc Upto
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
groupCompetes	TokenNameIdentifier	 group Competes
=	TokenNameEQUAL	
!	TokenNameNOT	
queueFull	TokenNameIdentifier	 queue Full
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
totalHitCount	TokenNameIdentifier	 total Hit Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
// Always cache doc/score within this group: 	TokenNameCOMMENT_LINE	Always cache doc/score within this group: 
if	TokenNameif	
(	TokenNameLPAREN	
subDocUpto	TokenNameIdentifier	 sub Doc Upto
==	TokenNameEQUAL_EQUAL	
pendingSubDocs	TokenNameIdentifier	 pending Sub Docs
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pendingSubDocs	TokenNameIdentifier	 pending Sub Docs
=	TokenNameEQUAL	
ArrayUtil	TokenNameIdentifier	 Array Util
.	TokenNameDOT	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
pendingSubDocs	TokenNameIdentifier	 pending Sub Docs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
pendingSubDocs	TokenNameIdentifier	 pending Sub Docs
[	TokenNameLBRACKET	
subDocUpto	TokenNameIdentifier	 sub Doc Upto
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
doc	TokenNameIdentifier	 doc
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
needsScores	TokenNameIdentifier	 needs Scores
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
subDocUpto	TokenNameIdentifier	 sub Doc Upto
==	TokenNameEQUAL_EQUAL	
pendingSubScores	TokenNameIdentifier	 pending Sub Scores
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pendingSubScores	TokenNameIdentifier	 pending Sub Scores
=	TokenNameEQUAL	
ArrayUtil	TokenNameIdentifier	 Array Util
.	TokenNameDOT	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
pendingSubScores	TokenNameIdentifier	 pending Sub Scores
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
pendingSubScores	TokenNameIdentifier	 pending Sub Scores
[	TokenNameLBRACKET	
subDocUpto	TokenNameIdentifier	 sub Doc Upto
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
scorer	TokenNameIdentifier	 scorer
.	TokenNameDOT	
score	TokenNameIdentifier	 score
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
subDocUpto	TokenNameIdentifier	 sub Doc Upto
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
groupCompetes	TokenNameIdentifier	 group Competes
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
subDocUpto	TokenNameIdentifier	 sub Doc Upto
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
!	TokenNameNOT	
queueFull	TokenNameIdentifier	 queue Full
;	TokenNameSEMICOLON	
//System.out.println(" init copy to bottomSlot=" + bottomSlot); 	TokenNameCOMMENT_LINE	System.out.println(" init copy to bottomSlot=" + bottomSlot); 
for	TokenNamefor	
(	TokenNameLPAREN	
FieldComparator	TokenNameIdentifier	 Field Comparator
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
fc	TokenNameIdentifier	 fc
:	TokenNameCOLON	
comparators	TokenNameIdentifier	 comparators
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fc	TokenNameIdentifier	 fc
.	TokenNameDOT	
copy	TokenNameIdentifier	 copy
(	TokenNameLPAREN	
bottomSlot	TokenNameIdentifier	 bottom Slot
,	TokenNameCOMMA	
doc	TokenNameIdentifier	 doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fc	TokenNameIdentifier	 fc
.	TokenNameDOT	
setBottom	TokenNameIdentifier	 set Bottom
(	TokenNameLPAREN	
bottomSlot	TokenNameIdentifier	 bottom Slot
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
topGroupDoc	TokenNameIdentifier	 top Group Doc
=	TokenNameEQUAL	
doc	TokenNameIdentifier	 doc
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Compare to bottomSlot 	TokenNameCOMMENT_LINE	Compare to bottomSlot 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
compIDX	TokenNameIdentifier	 comp IDX
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
compIDX	TokenNameIdentifier	 comp IDX
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
reversed	TokenNameIdentifier	 reversed
[	TokenNameLBRACKET	
compIDX	TokenNameIdentifier	 comp IDX
]	TokenNameRBRACKET	
*	TokenNameMULTIPLY	
comparators	TokenNameIdentifier	 comparators
[	TokenNameLBRACKET	
compIDX	TokenNameIdentifier	 comp IDX
]	TokenNameRBRACKET	
.	TokenNameDOT	
compareBottom	TokenNameIdentifier	 compare Bottom
(	TokenNameLPAREN	
doc	TokenNameIdentifier	 doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Definitely not competitive -- done 	TokenNameCOMMENT_LINE	Definitely not competitive -- done 
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Definitely competitive. 	TokenNameCOMMENT_LINE	Definitely competitive. 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compIDX	TokenNameIdentifier	 comp IDX
==	TokenNameEQUAL_EQUAL	
compIDXEnd	TokenNameIdentifier	 comp IDX End
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Ties with bottom, except we know this docID is 	TokenNameCOMMENT_LINE	Ties with bottom, except we know this docID is 
// > docID in the queue (docs are visited in 	TokenNameCOMMENT_LINE	> docID in the queue (docs are visited in 
// order), so not competitive: 	TokenNameCOMMENT_LINE	order), so not competitive: 
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//System.out.println(" best w/in group!"); 	TokenNameCOMMENT_LINE	System.out.println(" best w/in group!"); 
for	TokenNamefor	
(	TokenNameLPAREN	
FieldComparator	TokenNameIdentifier	 Field Comparator
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
fc	TokenNameIdentifier	 fc
:	TokenNameCOLON	
comparators	TokenNameIdentifier	 comparators
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fc	TokenNameIdentifier	 fc
.	TokenNameDOT	
copy	TokenNameIdentifier	 copy
(	TokenNameLPAREN	
bottomSlot	TokenNameIdentifier	 bottom Slot
,	TokenNameCOMMA	
doc	TokenNameIdentifier	 doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Necessary because some comparators cache 	TokenNameCOMMENT_LINE	Necessary because some comparators cache 
// details of bottom slot; this forces them to 	TokenNameCOMMENT_LINE	details of bottom slot; this forces them to 
// re-cache: 	TokenNameCOMMENT_LINE	re-cache: 
fc	TokenNameIdentifier	 fc
.	TokenNameDOT	
setBottom	TokenNameIdentifier	 set Bottom
(	TokenNameLPAREN	
bottomSlot	TokenNameIdentifier	 bottom Slot
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
topGroupDoc	TokenNameIdentifier	 top Group Doc
=	TokenNameEQUAL	
doc	TokenNameIdentifier	 doc
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// We're not sure this group will make it into the 	TokenNameCOMMENT_LINE	We're not sure this group will make it into the 
// queue yet 	TokenNameCOMMENT_LINE	queue yet 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
compIDX	TokenNameIdentifier	 comp IDX
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
compIDX	TokenNameIdentifier	 comp IDX
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
reversed	TokenNameIdentifier	 reversed
[	TokenNameLBRACKET	
compIDX	TokenNameIdentifier	 comp IDX
]	TokenNameRBRACKET	
*	TokenNameMULTIPLY	
comparators	TokenNameIdentifier	 comparators
[	TokenNameLBRACKET	
compIDX	TokenNameIdentifier	 comp IDX
]	TokenNameRBRACKET	
.	TokenNameDOT	
compareBottom	TokenNameIdentifier	 compare Bottom
(	TokenNameLPAREN	
doc	TokenNameIdentifier	 doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Definitely not competitive -- done 	TokenNameCOMMENT_LINE	Definitely not competitive -- done 
//System.out.println(" doc doesn't compete w/ top groups"); 	TokenNameCOMMENT_LINE	System.out.println(" doc doesn't compete w/ top groups"); 
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Definitely competitive. 	TokenNameCOMMENT_LINE	Definitely competitive. 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compIDX	TokenNameIdentifier	 comp IDX
==	TokenNameEQUAL_EQUAL	
compIDXEnd	TokenNameIdentifier	 comp IDX End
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Ties with bottom, except we know this docID is 	TokenNameCOMMENT_LINE	Ties with bottom, except we know this docID is 
// > docID in the queue (docs are visited in 	TokenNameCOMMENT_LINE	> docID in the queue (docs are visited in 
// order), so not competitive: 	TokenNameCOMMENT_LINE	order), so not competitive: 
//System.out.println(" doc doesn't compete w/ top groups"); 	TokenNameCOMMENT_LINE	System.out.println(" doc doesn't compete w/ top groups"); 
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
groupCompetes	TokenNameIdentifier	 group Competes
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
FieldComparator	TokenNameIdentifier	 Field Comparator
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
fc	TokenNameIdentifier	 fc
:	TokenNameCOLON	
comparators	TokenNameIdentifier	 comparators
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fc	TokenNameIdentifier	 fc
.	TokenNameDOT	
copy	TokenNameIdentifier	 copy
(	TokenNameLPAREN	
bottomSlot	TokenNameIdentifier	 bottom Slot
,	TokenNameCOMMA	
doc	TokenNameIdentifier	 doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Necessary because some comparators cache 	TokenNameCOMMENT_LINE	Necessary because some comparators cache 
// details of bottom slot; this forces them to 	TokenNameCOMMENT_LINE	details of bottom slot; this forces them to 
// re-cache: 	TokenNameCOMMENT_LINE	re-cache: 
fc	TokenNameIdentifier	 fc
.	TokenNameDOT	
setBottom	TokenNameIdentifier	 set Bottom
(	TokenNameLPAREN	
bottomSlot	TokenNameIdentifier	 bottom Slot
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
topGroupDoc	TokenNameIdentifier	 top Group Doc
=	TokenNameEQUAL	
doc	TokenNameIdentifier	 doc
;	TokenNameSEMICOLON	
//System.out.println(" doc competes w/ top groups"); 	TokenNameCOMMENT_LINE	System.out.println(" doc competes w/ top groups"); 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
boolean	TokenNameboolean	
acceptsDocsOutOfOrder	TokenNameIdentifier	 accepts Docs Out Of Order
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
setNextReader	TokenNameIdentifier	 set Next Reader
(	TokenNameLPAREN	
IndexReader	TokenNameIdentifier	 Index Reader
reader	TokenNameIdentifier	 reader
,	TokenNameCOMMA	
int	TokenNameint	
docBase	TokenNameIdentifier	 doc Base
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
subDocUpto	TokenNameIdentifier	 sub Doc Upto
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
processGroup	TokenNameIdentifier	 process Group
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
subDocUpto	TokenNameIdentifier	 sub Doc Upto
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
docBase	TokenNameIdentifier	 doc Base
=	TokenNameEQUAL	
docBase	TokenNameIdentifier	 doc Base
;	TokenNameSEMICOLON	
//System.out.println("setNextReader base=" + docBase + " r=" + readerContext.reader); 	TokenNameCOMMENT_LINE	System.out.println("setNextReader base=" + docBase + " r=" + readerContext.reader); 
lastDocPerGroupBits	TokenNameIdentifier	 last Doc Per Group Bits
=	TokenNameEQUAL	
lastDocPerGroup	TokenNameIdentifier	 last Doc Per Group
.	TokenNameDOT	
getDocIdSet	TokenNameIdentifier	 get Doc Id Set
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
groupEndDocID	TokenNameIdentifier	 group End Doc ID
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
currentReader	TokenNameIdentifier	 current Reader
=	TokenNameEQUAL	
reader	TokenNameIdentifier	 reader
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
comparators	TokenNameIdentifier	 comparators
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
comparators	TokenNameIdentifier	 comparators
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
setNextReader	TokenNameIdentifier	 set Next Reader
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
,	TokenNameCOMMA	
docBase	TokenNameIdentifier	 doc Base
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
