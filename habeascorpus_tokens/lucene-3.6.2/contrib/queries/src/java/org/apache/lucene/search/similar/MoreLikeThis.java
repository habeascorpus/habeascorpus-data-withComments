/** * Copyright 2004-2005 The Apache Software Foundation. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_JAVADOC	 Copyright 2004-2005 The Apache Software Foundation. * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
similar	TokenNameIdentifier	 similar
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
File	TokenNameIdentifier	 File
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
FileReader	TokenNameIdentifier	 File Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
InputStreamReader	TokenNameIdentifier	 Input Stream Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
Reader	TokenNameIdentifier	 Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
StringReader	TokenNameIdentifier	 String Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
net	TokenNameIdentifier	 net
.	TokenNameDOT	
URL	TokenNameIdentifier	 URL
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Collection	TokenNameIdentifier	 Collection
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
HashMap	TokenNameIdentifier	 Hash Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Iterator	TokenNameIdentifier	 Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Map	TokenNameIdentifier	 Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Set	TokenNameIdentifier	 Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
Analyzer	TokenNameIdentifier	 Analyzer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
TokenStream	TokenNameIdentifier	 Token Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
standard	TokenNameIdentifier	 standard
.	TokenNameDOT	
StandardAnalyzer	TokenNameIdentifier	 Standard Analyzer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
tokenattributes	TokenNameIdentifier	 tokenattributes
.	TokenNameDOT	
CharTermAttribute	TokenNameIdentifier	 Char Term Attribute
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
document	TokenNameIdentifier	 document
.	TokenNameDOT	
Document	TokenNameIdentifier	 Document
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
IndexReader	TokenNameIdentifier	 Index Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
Term	TokenNameIdentifier	 Term
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
TermFreqVector	TokenNameIdentifier	 Term Freq Vector
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
BooleanClause	TokenNameIdentifier	 Boolean Clause
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
BooleanQuery	TokenNameIdentifier	 Boolean Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
DefaultSimilarity	TokenNameIdentifier	 Default Similarity
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
Query	TokenNameIdentifier	 Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
Similarity	TokenNameIdentifier	 Similarity
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
TermQuery	TokenNameIdentifier	 Term Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
PriorityQueue	TokenNameIdentifier	 Priority Queue
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ReaderUtil	TokenNameIdentifier	 Reader Util
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Version	TokenNameIdentifier	 Version
;	TokenNameSEMICOLON	
/** * Generate "more like this" similarity queries. Based on this mail: <code><pre> * Lucene does let you access the document frequency of terms, with IndexReader.docFreq(). * Term frequencies can be computed by re-tokenizing the text, which, for a single document, * is usually fast enough. But looking up the docFreq() of every term in the document is * probably too slow. * * You can use some heuristics to prune the set of terms, to avoid calling docFreq() too much, * or at all. Since you're trying to maximize a tf*idf score, you're probably most interested * in terms with a high tf. Choosing a tf threshold even as low as two or three will radically * reduce the number of terms under consideration. Another heuristic is that terms with a * high idf (i.e., a low df) tend to be longer. So you could threshold the terms by the * number of characters, not selecting anything less than, e.g., six or seven characters. * With these sorts of heuristics you can usually find small set of, e.g., ten or fewer terms * that do a pretty good job of characterizing a document. * * It all depends on what you're trying to do. If you're trying to eek out that last percent * of precision and recall regardless of computational difficulty so that you can win a TREC * competition, then the techniques I mention above are useless. But if you're trying to * provide a "more like this" button on a search results page that does a decent job and has * good performance, such techniques might be useful. * * An efficient, effective "more-like-this" query generator would be a great contribution, if * anyone's interested. I'd imagine that it would take a Reader or a String (the document's * text), analyzer Analyzer, and return a set of representative terms using heuristics like those * above. The frequency and length thresholds could be parameters, etc. * * Doug * </pre></code> * * * <p> * <h3>Initial Usage</h3> * <p/> * This class has lots of options to try to make it efficient and flexible. * The simplest possible usage is as follows. The bold * fragment is specific to this class. * * <pre class="prettyprint"> * * IndexReader ir = ... * IndexSearcher is = ... * * MoreLikeThis mlt = new MoreLikeThis(ir); * Reader target = ... // orig source of doc you want to find similarities to * Query query = mlt.like( target); * * Hits hits = is.search(query); * // now the usual iteration thru 'hits' - the only thing to watch for is to make sure * //you ignore the doc if it matches your 'target' document, as it should be similar to itself * * </pre> * * Thus you: * <ol> * <li>do your normal, Lucene setup for searching, * <li>create a MoreLikeThis, * <li>get the text of the doc you want to find similarities to * <li>then call one of the like() calls to generate a similarity query * <li>call the searcher to find the similar docs * </ol> * * <h3>More Advanced Usage</h3> * * You may want to use {@link #setFieldNames setFieldNames(...)} so you can * examine multiple fields (e.g. body and title) for similarity. * <p> * * Depending on the size of your index and the size and makeup of your documents * you may want to call the other set methods to control how the similarity * queries are generated: * <ul> * <li> {@link #setMinTermFreq setMinTermFreq(...)} * <li> {@link #setMinDocFreq setMinDocFreq(...)} * <li> {@link #setMaxDocFreq setMaxDocFreq(...)} * <li> {@link #setMaxDocFreqPct setMaxDocFreqPct(...)} * <li> {@link #setMinWordLen setMinWordLen(...)} * <li> {@link #setMaxWordLen setMaxWordLen(...)} * <li> {@link #setMaxQueryTerms setMaxQueryTerms(...)} * <li> {@link #setMaxNumTokensParsed setMaxNumTokensParsed(...)} * <li> {@link #setStopWords setStopWord(...)} * </ul> * * <hr> * * <pre> * Changes: Mark Harwood 29/02/04 * Some bugfixing, some refactoring, some optimisation. * - bugfix: retrieveTerms(int docNum) was not working for indexes without a termvector -added missing code * - bugfix: No significant terms being created for fields with a termvector - because * was only counting one occurrence per term/field pair in calculations(ie not including frequency info from TermVector) * - refactor: moved common code into isNoiseWord() * - optimise: when no termvector support available - used maxNumTermsParsed to limit amount of tokenization * </pre> * */	TokenNameCOMMENT_JAVADOC	 Generate "more like this" similarity queries. Based on this mail: <code><pre> Lucene does let you access the document frequency of terms, with IndexReader.docFreq(). Term frequencies can be computed by re-tokenizing the text, which, for a single document, is usually fast enough. But looking up the docFreq() of every term in the document is probably too slow. * You can use some heuristics to prune the set of terms, to avoid calling docFreq() too much, or at all. Since you're trying to maximize a tf*idf score, you're probably most interested in terms with a high tf. Choosing a tf threshold even as low as two or three will radically reduce the number of terms under consideration. Another heuristic is that terms with a high idf (i.e., a low df) tend to be longer. So you could threshold the terms by the number of characters, not selecting anything less than, e.g., six or seven characters. With these sorts of heuristics you can usually find small set of, e.g., ten or fewer terms that do a pretty good job of characterizing a document. * It all depends on what you're trying to do. If you're trying to eek out that last percent of precision and recall regardless of computational difficulty so that you can win a TREC competition, then the techniques I mention above are useless. But if you're trying to provide a "more like this" button on a search results page that does a decent job and has good performance, such techniques might be useful. * An efficient, effective "more-like-this" query generator would be a great contribution, if anyone's interested. I'd imagine that it would take a Reader or a String (the document's text), analyzer Analyzer, and return a set of representative terms using heuristics like those above. The frequency and length thresholds could be parameters, etc. * Doug </pre></code> * <p> <h3>Initial Usage</h3> <p/> This class has lots of options to try to make it efficient and flexible. The simplest possible usage is as follows. The bold fragment is specific to this class. * <pre class="prettyprint"> * IndexReader ir = ... IndexSearcher is = ... * MoreLikeThis mlt = new MoreLikeThis(ir); Reader target = ... // orig source of doc you want to find similarities to Query query = mlt.like( target); * Hits hits = is.search(query); // now the usual iteration thru 'hits' - the only thing to watch for is to make sure //you ignore the doc if it matches your 'target' document, as it should be similar to itself * </pre> * Thus you: <ol> <li>do your normal, Lucene setup for searching, <li>create a MoreLikeThis, <li>get the text of the doc you want to find similarities to <li>then call one of the like() calls to generate a similarity query <li>call the searcher to find the similar docs </ol> * <h3>More Advanced Usage</h3> * You may want to use {@link #setFieldNames setFieldNames(...)} so you can examine multiple fields (e.g. body and title) for similarity. <p> * Depending on the size of your index and the size and makeup of your documents you may want to call the other set methods to control how the similarity queries are generated: <ul> <li> {@link #setMinTermFreq setMinTermFreq(...)} <li> {@link #setMinDocFreq setMinDocFreq(...)} <li> {@link #setMaxDocFreq setMaxDocFreq(...)} <li> {@link #setMaxDocFreqPct setMaxDocFreqPct(...)} <li> {@link #setMinWordLen setMinWordLen(...)} <li> {@link #setMaxWordLen setMaxWordLen(...)} <li> {@link #setMaxQueryTerms setMaxQueryTerms(...)} <li> {@link #setMaxNumTokensParsed setMaxNumTokensParsed(...)} <li> {@link #setStopWords setStopWord(...)} </ul> * <hr> * <pre> Changes: Mark Harwood 29/02/04 Some bugfixing, some refactoring, some optimisation. - bugfix: retrieveTerms(int docNum) was not working for indexes without a termvector -added missing code - bugfix: No significant terms being created for fields with a termvector - because was only counting one occurrence per term/field pair in calculations(ie not including frequency info from TermVector) - refactor: moved common code into isNoiseWord() - optimise: when no termvector support available - used maxNumTermsParsed to limit amount of tokenization </pre> 
public	TokenNamepublic	
final	TokenNamefinal	
class	TokenNameclass	
MoreLikeThis	TokenNameIdentifier	 More Like This
{	TokenNameLBRACE	
/** * Default maximum number of tokens to parse in each example doc field that is * not stored with TermVector support. * * @see #getMaxNumTokensParsed */	TokenNameCOMMENT_JAVADOC	 Default maximum number of tokens to parse in each example doc field that is not stored with TermVector support. * @see #getMaxNumTokensParsed 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
DEFAULT_MAX_NUM_TOKENS_PARSED	TokenNameIdentifier	 DEFAULT  MAX  NUM  TOKENS  PARSED
=	TokenNameEQUAL	
5000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** * Default analyzer to parse source doc with. * * @see #getAnalyzer * @deprecated This default will be removed in Lucene 4.0 (with the default * being null). If you are not using term vectors, explicitly set * your analyzer instead. */	TokenNameCOMMENT_JAVADOC	 Default analyzer to parse source doc with. * @see #getAnalyzer @deprecated This default will be removed in Lucene 4.0 (with the default being null). If you are not using term vectors, explicitly set your analyzer instead. 
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
Analyzer	TokenNameIdentifier	 Analyzer
DEFAULT_ANALYZER	TokenNameIdentifier	 DEFAULT  ANALYZER
=	TokenNameEQUAL	
new	TokenNamenew	
StandardAnalyzer	TokenNameIdentifier	 Standard Analyzer
(	TokenNameLPAREN	
Version	TokenNameIdentifier	 Version
.	TokenNameDOT	
LUCENE_CURRENT	TokenNameIdentifier	 LUCENE  CURRENT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Ignore terms with less than this frequency in the source doc. * * @see #getMinTermFreq * @see #setMinTermFreq */	TokenNameCOMMENT_JAVADOC	 Ignore terms with less than this frequency in the source doc. * @see #getMinTermFreq @see #setMinTermFreq 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
DEFAULT_MIN_TERM_FREQ	TokenNameIdentifier	 DEFAULT  MIN  TERM  FREQ
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** * Ignore words which do not occur in at least this many docs. * * @see #getMinDocFreq * @see #setMinDocFreq */	TokenNameCOMMENT_JAVADOC	 Ignore words which do not occur in at least this many docs. * @see #getMinDocFreq @see #setMinDocFreq 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
DEFAULT_MIN_DOC_FREQ	TokenNameIdentifier	 DEFAULT  MIN  DOC  FREQ
=	TokenNameEQUAL	
5	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** * Ignore words which occur in more than this many docs. * * @see #getMaxDocFreq * @see #setMaxDocFreq * @see #setMaxDocFreqPct */	TokenNameCOMMENT_JAVADOC	 Ignore words which occur in more than this many docs. * @see #getMaxDocFreq @see #setMaxDocFreq @see #setMaxDocFreqPct 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
DEFAULT_MAX_DOC_FREQ	TokenNameIdentifier	 DEFAULT  MAX  DOC  FREQ
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
;	TokenNameSEMICOLON	
/** * Boost terms in query based on score. * * @see #isBoost * @see #setBoost */	TokenNameCOMMENT_JAVADOC	 Boost terms in query based on score. * @see #isBoost @see #setBoost 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
DEFAULT_BOOST	TokenNameIdentifier	 DEFAULT  BOOST
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** * Default field names. Null is used to specify that the field names should be * looked up at runtime from the provided reader. */	TokenNameCOMMENT_JAVADOC	 Default field names. Null is used to specify that the field names should be looked up at runtime from the provided reader. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
DEFAULT_FIELD_NAMES	TokenNameIdentifier	 DEFAULT  FIELD  NAMES
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"contents"	TokenNameStringLiteral	contents
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** * Ignore words less than this length or if 0 then this has no effect. * * @see #getMinWordLen * @see #setMinWordLen */	TokenNameCOMMENT_JAVADOC	 Ignore words less than this length or if 0 then this has no effect. * @see #getMinWordLen @see #setMinWordLen 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
DEFAULT_MIN_WORD_LENGTH	TokenNameIdentifier	 DEFAULT  MIN  WORD  LENGTH
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** * Ignore words greater than this length or if 0 then this has no effect. * * @see #getMaxWordLen * @see #setMaxWordLen */	TokenNameCOMMENT_JAVADOC	 Ignore words greater than this length or if 0 then this has no effect. * @see #getMaxWordLen @see #setMaxWordLen 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
DEFAULT_MAX_WORD_LENGTH	TokenNameIdentifier	 DEFAULT  MAX  WORD  LENGTH
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** * Default set of stopwords. If null means to allow stop words. * * @see #setStopWords * @see #getStopWords */	TokenNameCOMMENT_JAVADOC	 Default set of stopwords. If null means to allow stop words. * @see #setStopWords @see #getStopWords 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
DEFAULT_STOP_WORDS	TokenNameIdentifier	 DEFAULT  STOP  WORDS
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** * Current set of stop words. */	TokenNameCOMMENT_JAVADOC	 Current set of stop words. 
private	TokenNameprivate	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
stopWords	TokenNameIdentifier	 stop Words
=	TokenNameEQUAL	
DEFAULT_STOP_WORDS	TokenNameIdentifier	 DEFAULT  STOP  WORDS
;	TokenNameSEMICOLON	
/** * Return a Query with no more than this many terms. * * @see BooleanQuery#getMaxClauseCount * @see #getMaxQueryTerms * @see #setMaxQueryTerms */	TokenNameCOMMENT_JAVADOC	 Return a Query with no more than this many terms. * @see BooleanQuery#getMaxClauseCount @see #getMaxQueryTerms @see #setMaxQueryTerms 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
DEFAULT_MAX_QUERY_TERMS	TokenNameIdentifier	 DEFAULT  MAX  QUERY  TERMS
=	TokenNameEQUAL	
25	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** * Analyzer that will be used to parse the doc. */	TokenNameCOMMENT_JAVADOC	 Analyzer that will be used to parse the doc. 
private	TokenNameprivate	
Analyzer	TokenNameIdentifier	 Analyzer
analyzer	TokenNameIdentifier	 analyzer
=	TokenNameEQUAL	
DEFAULT_ANALYZER	TokenNameIdentifier	 DEFAULT  ANALYZER
;	TokenNameSEMICOLON	
/** * Ignore words less frequent that this. */	TokenNameCOMMENT_JAVADOC	 Ignore words less frequent that this. 
private	TokenNameprivate	
int	TokenNameint	
minTermFreq	TokenNameIdentifier	 min Term Freq
=	TokenNameEQUAL	
DEFAULT_MIN_TERM_FREQ	TokenNameIdentifier	 DEFAULT  MIN  TERM  FREQ
;	TokenNameSEMICOLON	
/** * Ignore words which do not occur in at least this many docs. */	TokenNameCOMMENT_JAVADOC	 Ignore words which do not occur in at least this many docs. 
private	TokenNameprivate	
int	TokenNameint	
minDocFreq	TokenNameIdentifier	 min Doc Freq
=	TokenNameEQUAL	
DEFAULT_MIN_DOC_FREQ	TokenNameIdentifier	 DEFAULT  MIN  DOC  FREQ
;	TokenNameSEMICOLON	
/** * Ignore words which occur in more than this many docs. */	TokenNameCOMMENT_JAVADOC	 Ignore words which occur in more than this many docs. 
private	TokenNameprivate	
int	TokenNameint	
maxDocFreq	TokenNameIdentifier	 max Doc Freq
=	TokenNameEQUAL	
DEFAULT_MAX_DOC_FREQ	TokenNameIdentifier	 DEFAULT  MAX  DOC  FREQ
;	TokenNameSEMICOLON	
/** * Should we apply a boost to the Query based on the scores? */	TokenNameCOMMENT_JAVADOC	 Should we apply a boost to the Query based on the scores? 
private	TokenNameprivate	
boolean	TokenNameboolean	
boost	TokenNameIdentifier	 boost
=	TokenNameEQUAL	
DEFAULT_BOOST	TokenNameIdentifier	 DEFAULT  BOOST
;	TokenNameSEMICOLON	
/** * Field name we'll analyze. */	TokenNameCOMMENT_JAVADOC	 Field name we'll analyze. 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fieldNames	TokenNameIdentifier	 field Names
=	TokenNameEQUAL	
DEFAULT_FIELD_NAMES	TokenNameIdentifier	 DEFAULT  FIELD  NAMES
;	TokenNameSEMICOLON	
/** * The maximum number of tokens to parse in each example doc field that is not * stored with TermVector support */	TokenNameCOMMENT_JAVADOC	 The maximum number of tokens to parse in each example doc field that is not stored with TermVector support 
private	TokenNameprivate	
int	TokenNameint	
maxNumTokensParsed	TokenNameIdentifier	 max Num Tokens Parsed
=	TokenNameEQUAL	
DEFAULT_MAX_NUM_TOKENS_PARSED	TokenNameIdentifier	 DEFAULT  MAX  NUM  TOKENS  PARSED
;	TokenNameSEMICOLON	
/** * Ignore words if less than this len. */	TokenNameCOMMENT_JAVADOC	 Ignore words if less than this len. 
private	TokenNameprivate	
int	TokenNameint	
minWordLen	TokenNameIdentifier	 min Word Len
=	TokenNameEQUAL	
DEFAULT_MIN_WORD_LENGTH	TokenNameIdentifier	 DEFAULT  MIN  WORD  LENGTH
;	TokenNameSEMICOLON	
/** * Ignore words if greater than this len. */	TokenNameCOMMENT_JAVADOC	 Ignore words if greater than this len. 
private	TokenNameprivate	
int	TokenNameint	
maxWordLen	TokenNameIdentifier	 max Word Len
=	TokenNameEQUAL	
DEFAULT_MAX_WORD_LENGTH	TokenNameIdentifier	 DEFAULT  MAX  WORD  LENGTH
;	TokenNameSEMICOLON	
/** * Don't return a query longer than this. */	TokenNameCOMMENT_JAVADOC	 Don't return a query longer than this. 
private	TokenNameprivate	
int	TokenNameint	
maxQueryTerms	TokenNameIdentifier	 max Query Terms
=	TokenNameEQUAL	
DEFAULT_MAX_QUERY_TERMS	TokenNameIdentifier	 DEFAULT  MAX  QUERY  TERMS
;	TokenNameSEMICOLON	
/** * For idf() calculations. */	TokenNameCOMMENT_JAVADOC	 For idf() calculations. 
private	TokenNameprivate	
Similarity	TokenNameIdentifier	 Similarity
similarity	TokenNameIdentifier	 similarity
;	TokenNameSEMICOLON	
// = new DefaultSimilarity(); 	TokenNameCOMMENT_LINE	= new DefaultSimilarity(); 
/** * IndexReader to use */	TokenNameCOMMENT_JAVADOC	 IndexReader to use 
private	TokenNameprivate	
final	TokenNamefinal	
IndexReader	TokenNameIdentifier	 Index Reader
ir	TokenNameIdentifier	 ir
;	TokenNameSEMICOLON	
/** * Boost factor to use when boosting the terms */	TokenNameCOMMENT_JAVADOC	 Boost factor to use when boosting the terms 
private	TokenNameprivate	
float	TokenNamefloat	
boostFactor	TokenNameIdentifier	 boost Factor
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** * Returns the boost factor used when boosting terms * * @return the boost factor used when boosting terms */	TokenNameCOMMENT_JAVADOC	 Returns the boost factor used when boosting terms * @return the boost factor used when boosting terms 
public	TokenNamepublic	
float	TokenNamefloat	
getBoostFactor	TokenNameIdentifier	 get Boost Factor
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
boostFactor	TokenNameIdentifier	 boost Factor
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets the boost factor to use when boosting terms * * @param boostFactor */	TokenNameCOMMENT_JAVADOC	 Sets the boost factor to use when boosting terms * @param boostFactor 
public	TokenNamepublic	
void	TokenNamevoid	
setBoostFactor	TokenNameIdentifier	 set Boost Factor
(	TokenNameLPAREN	
float	TokenNamefloat	
boostFactor	TokenNameIdentifier	 boost Factor
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
boostFactor	TokenNameIdentifier	 boost Factor
=	TokenNameEQUAL	
boostFactor	TokenNameIdentifier	 boost Factor
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Constructor requiring an IndexReader. */	TokenNameCOMMENT_JAVADOC	 Constructor requiring an IndexReader. 
public	TokenNamepublic	
MoreLikeThis	TokenNameIdentifier	 More Like This
(	TokenNameLPAREN	
IndexReader	TokenNameIdentifier	 Index Reader
ir	TokenNameIdentifier	 ir
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
(	TokenNameLPAREN	
ir	TokenNameIdentifier	 ir
,	TokenNameCOMMA	
new	TokenNamenew	
DefaultSimilarity	TokenNameIdentifier	 Default Similarity
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
MoreLikeThis	TokenNameIdentifier	 More Like This
(	TokenNameLPAREN	
IndexReader	TokenNameIdentifier	 Index Reader
ir	TokenNameIdentifier	 ir
,	TokenNameCOMMA	
Similarity	TokenNameIdentifier	 Similarity
sim	TokenNameIdentifier	 sim
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
ir	TokenNameIdentifier	 ir
=	TokenNameEQUAL	
ir	TokenNameIdentifier	 ir
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
similarity	TokenNameIdentifier	 similarity
=	TokenNameEQUAL	
sim	TokenNameIdentifier	 sim
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Similarity	TokenNameIdentifier	 Similarity
getSimilarity	TokenNameIdentifier	 get Similarity
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
similarity	TokenNameIdentifier	 similarity
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setSimilarity	TokenNameIdentifier	 set Similarity
(	TokenNameLPAREN	
Similarity	TokenNameIdentifier	 Similarity
similarity	TokenNameIdentifier	 similarity
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
similarity	TokenNameIdentifier	 similarity
=	TokenNameEQUAL	
similarity	TokenNameIdentifier	 similarity
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns an analyzer that will be used to parse source doc with. The default * analyzer is the {@link #DEFAULT_ANALYZER}. * * @return the analyzer that will be used to parse source doc with. * @see #DEFAULT_ANALYZER */	TokenNameCOMMENT_JAVADOC	 Returns an analyzer that will be used to parse source doc with. The default analyzer is the {@link #DEFAULT_ANALYZER}. * @return the analyzer that will be used to parse source doc with. @see #DEFAULT_ANALYZER 
public	TokenNamepublic	
Analyzer	TokenNameIdentifier	 Analyzer
getAnalyzer	TokenNameIdentifier	 get Analyzer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
analyzer	TokenNameIdentifier	 analyzer
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets the analyzer to use. An analyzer is not required for generating a * query with the {@link #like(int)} method, all other 'like' methods require * an analyzer. * * @param analyzer * the analyzer to use to tokenize text. */	TokenNameCOMMENT_JAVADOC	 Sets the analyzer to use. An analyzer is not required for generating a query with the {@link #like(int)} method, all other 'like' methods require an analyzer. * @param analyzer the analyzer to use to tokenize text. 
public	TokenNamepublic	
void	TokenNamevoid	
setAnalyzer	TokenNameIdentifier	 set Analyzer
(	TokenNameLPAREN	
Analyzer	TokenNameIdentifier	 Analyzer
analyzer	TokenNameIdentifier	 analyzer
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
analyzer	TokenNameIdentifier	 analyzer
=	TokenNameEQUAL	
analyzer	TokenNameIdentifier	 analyzer
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the frequency below which terms will be ignored in the source doc. * The default frequency is the {@link #DEFAULT_MIN_TERM_FREQ}. * * @return the frequency below which terms will be ignored in the source doc. */	TokenNameCOMMENT_JAVADOC	 Returns the frequency below which terms will be ignored in the source doc. The default frequency is the {@link #DEFAULT_MIN_TERM_FREQ}. * @return the frequency below which terms will be ignored in the source doc. 
public	TokenNamepublic	
int	TokenNameint	
getMinTermFreq	TokenNameIdentifier	 get Min Term Freq
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
minTermFreq	TokenNameIdentifier	 min Term Freq
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets the frequency below which terms will be ignored in the source doc. * * @param minTermFreq * the frequency below which terms will be ignored in the source doc. */	TokenNameCOMMENT_JAVADOC	 Sets the frequency below which terms will be ignored in the source doc. * @param minTermFreq the frequency below which terms will be ignored in the source doc. 
public	TokenNamepublic	
void	TokenNamevoid	
setMinTermFreq	TokenNameIdentifier	 set Min Term Freq
(	TokenNameLPAREN	
int	TokenNameint	
minTermFreq	TokenNameIdentifier	 min Term Freq
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
minTermFreq	TokenNameIdentifier	 min Term Freq
=	TokenNameEQUAL	
minTermFreq	TokenNameIdentifier	 min Term Freq
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the frequency at which words will be ignored which do not occur in * at least this many docs. The default frequency is * {@link #DEFAULT_MIN_DOC_FREQ}. * * @return the frequency at which words will be ignored which do not occur in * at least this many docs. */	TokenNameCOMMENT_JAVADOC	 Returns the frequency at which words will be ignored which do not occur in at least this many docs. The default frequency is {@link #DEFAULT_MIN_DOC_FREQ}. * @return the frequency at which words will be ignored which do not occur in at least this many docs. 
public	TokenNamepublic	
int	TokenNameint	
getMinDocFreq	TokenNameIdentifier	 get Min Doc Freq
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
minDocFreq	TokenNameIdentifier	 min Doc Freq
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets the frequency at which words will be ignored which do not occur in at * least this many docs. * * @param minDocFreq * the frequency at which words will be ignored which do not occur in * at least this many docs. */	TokenNameCOMMENT_JAVADOC	 Sets the frequency at which words will be ignored which do not occur in at least this many docs. * @param minDocFreq the frequency at which words will be ignored which do not occur in at least this many docs. 
public	TokenNamepublic	
void	TokenNamevoid	
setMinDocFreq	TokenNameIdentifier	 set Min Doc Freq
(	TokenNameLPAREN	
int	TokenNameint	
minDocFreq	TokenNameIdentifier	 min Doc Freq
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
minDocFreq	TokenNameIdentifier	 min Doc Freq
=	TokenNameEQUAL	
minDocFreq	TokenNameIdentifier	 min Doc Freq
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the maximum frequency in which words may still appear. Words that * appear in more than this many docs will be ignored. The default frequency * is {@link #DEFAULT_MAX_DOC_FREQ}. * * @return get the maximum frequency at which words are still allowed, words * which occur in more docs than this are ignored. */	TokenNameCOMMENT_JAVADOC	 Returns the maximum frequency in which words may still appear. Words that appear in more than this many docs will be ignored. The default frequency is {@link #DEFAULT_MAX_DOC_FREQ}. * @return get the maximum frequency at which words are still allowed, words which occur in more docs than this are ignored. 
public	TokenNamepublic	
int	TokenNameint	
getMaxDocFreq	TokenNameIdentifier	 get Max Doc Freq
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
maxDocFreq	TokenNameIdentifier	 max Doc Freq
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set the maximum frequency in which words may still appear. Words that * appear in more than this many docs will be ignored. * * @param maxFreq * the maximum count of documents that a term may appear in to be * still considered relevant */	TokenNameCOMMENT_JAVADOC	 Set the maximum frequency in which words may still appear. Words that appear in more than this many docs will be ignored. * @param maxFreq the maximum count of documents that a term may appear in to be still considered relevant 
public	TokenNamepublic	
void	TokenNamevoid	
setMaxDocFreq	TokenNameIdentifier	 set Max Doc Freq
(	TokenNameLPAREN	
int	TokenNameint	
maxFreq	TokenNameIdentifier	 max Freq
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
maxDocFreq	TokenNameIdentifier	 max Doc Freq
=	TokenNameEQUAL	
maxFreq	TokenNameIdentifier	 max Freq
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set the maximum percentage in which words may still appear. Words that * appear in more than this many percent of all docs will be ignored. * * @param maxPercentage * the maximum percentage of documents (0-100) that a term may appear * in to be still considered relevant */	TokenNameCOMMENT_JAVADOC	 Set the maximum percentage in which words may still appear. Words that appear in more than this many percent of all docs will be ignored. * @param maxPercentage the maximum percentage of documents (0-100) that a term may appear in to be still considered relevant 
public	TokenNamepublic	
void	TokenNamevoid	
setMaxDocFreqPct	TokenNameIdentifier	 set Max Doc Freq Pct
(	TokenNameLPAREN	
int	TokenNameint	
maxPercentage	TokenNameIdentifier	 max Percentage
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
maxDocFreq	TokenNameIdentifier	 max Doc Freq
=	TokenNameEQUAL	
maxPercentage	TokenNameIdentifier	 max Percentage
*	TokenNameMULTIPLY	
ir	TokenNameIdentifier	 ir
.	TokenNameDOT	
numDocs	TokenNameIdentifier	 num Docs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
100	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns whether to boost terms in query based on "score" or not. The * default is {@link #DEFAULT_BOOST}. * * @return whether to boost terms in query based on "score" or not. * @see #setBoost */	TokenNameCOMMENT_JAVADOC	 Returns whether to boost terms in query based on "score" or not. The default is {@link #DEFAULT_BOOST}. * @return whether to boost terms in query based on "score" or not. @see #setBoost 
public	TokenNamepublic	
boolean	TokenNameboolean	
isBoost	TokenNameIdentifier	 is Boost
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
boost	TokenNameIdentifier	 boost
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets whether to boost terms in query based on "score" or not. * * @param boost * true to boost terms in query based on "score", false otherwise. * @see #isBoost */	TokenNameCOMMENT_JAVADOC	 Sets whether to boost terms in query based on "score" or not. * @param boost true to boost terms in query based on "score", false otherwise. @see #isBoost 
public	TokenNamepublic	
void	TokenNamevoid	
setBoost	TokenNameIdentifier	 set Boost
(	TokenNameLPAREN	
boolean	TokenNameboolean	
boost	TokenNameIdentifier	 boost
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
boost	TokenNameIdentifier	 boost
=	TokenNameEQUAL	
boost	TokenNameIdentifier	 boost
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the field names that will be used when generating the 'More Like * This' query. The default field names that will be used is * {@link #DEFAULT_FIELD_NAMES}. * * @return the field names that will be used when generating the 'More Like * This' query. */	TokenNameCOMMENT_JAVADOC	 Returns the field names that will be used when generating the 'More Like This' query. The default field names that will be used is {@link #DEFAULT_FIELD_NAMES}. * @return the field names that will be used when generating the 'More Like This' query. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getFieldNames	TokenNameIdentifier	 get Field Names
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fieldNames	TokenNameIdentifier	 field Names
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets the field names that will be used when generating the 'More Like This' * query. Set this to null for the field names to be determined at runtime * from the IndexReader provided in the constructor. * * @param fieldNames * the field names that will be used when generating the 'More Like * This' query. */	TokenNameCOMMENT_JAVADOC	 Sets the field names that will be used when generating the 'More Like This' query. Set this to null for the field names to be determined at runtime from the IndexReader provided in the constructor. * @param fieldNames the field names that will be used when generating the 'More Like This' query. 
public	TokenNamepublic	
void	TokenNamevoid	
setFieldNames	TokenNameIdentifier	 set Field Names
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fieldNames	TokenNameIdentifier	 field Names
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fieldNames	TokenNameIdentifier	 field Names
=	TokenNameEQUAL	
fieldNames	TokenNameIdentifier	 field Names
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the minimum word length below which words will be ignored. Set this * to 0 for no minimum word length. The default is * {@link #DEFAULT_MIN_WORD_LENGTH}. * * @return the minimum word length below which words will be ignored. */	TokenNameCOMMENT_JAVADOC	 Returns the minimum word length below which words will be ignored. Set this to 0 for no minimum word length. The default is {@link #DEFAULT_MIN_WORD_LENGTH}. * @return the minimum word length below which words will be ignored. 
public	TokenNamepublic	
int	TokenNameint	
getMinWordLen	TokenNameIdentifier	 get Min Word Len
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
minWordLen	TokenNameIdentifier	 min Word Len
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets the minimum word length below which words will be ignored. * * @param minWordLen * the minimum word length below which words will be ignored. */	TokenNameCOMMENT_JAVADOC	 Sets the minimum word length below which words will be ignored. * @param minWordLen the minimum word length below which words will be ignored. 
public	TokenNamepublic	
void	TokenNamevoid	
setMinWordLen	TokenNameIdentifier	 set Min Word Len
(	TokenNameLPAREN	
int	TokenNameint	
minWordLen	TokenNameIdentifier	 min Word Len
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
minWordLen	TokenNameIdentifier	 min Word Len
=	TokenNameEQUAL	
minWordLen	TokenNameIdentifier	 min Word Len
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the maximum word length above which words will be ignored. Set this * to 0 for no maximum word length. The default is * {@link #DEFAULT_MAX_WORD_LENGTH}. * * @return the maximum word length above which words will be ignored. */	TokenNameCOMMENT_JAVADOC	 Returns the maximum word length above which words will be ignored. Set this to 0 for no maximum word length. The default is {@link #DEFAULT_MAX_WORD_LENGTH}. * @return the maximum word length above which words will be ignored. 
public	TokenNamepublic	
int	TokenNameint	
getMaxWordLen	TokenNameIdentifier	 get Max Word Len
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
maxWordLen	TokenNameIdentifier	 max Word Len
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets the maximum word length above which words will be ignored. * * @param maxWordLen * the maximum word length above which words will be ignored. */	TokenNameCOMMENT_JAVADOC	 Sets the maximum word length above which words will be ignored. * @param maxWordLen the maximum word length above which words will be ignored. 
public	TokenNamepublic	
void	TokenNamevoid	
setMaxWordLen	TokenNameIdentifier	 set Max Word Len
(	TokenNameLPAREN	
int	TokenNameint	
maxWordLen	TokenNameIdentifier	 max Word Len
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
maxWordLen	TokenNameIdentifier	 max Word Len
=	TokenNameEQUAL	
maxWordLen	TokenNameIdentifier	 max Word Len
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set the set of stopwords. Any word in this set is considered * "uninteresting" and ignored. Even if your Analyzer allows stopwords, you * might want to tell the MoreLikeThis code to ignore them, as for the * purposes of document similarity it seems reasonable to assume that * "a stop word is never interesting". * * @param stopWords * set of stopwords, if null it means to allow stop words * * @see org.apache.lucene.analysis.StopFilter#makeStopSet * StopFilter.makeStopSet() * @see #getStopWords */	TokenNameCOMMENT_JAVADOC	 Set the set of stopwords. Any word in this set is considered "uninteresting" and ignored. Even if your Analyzer allows stopwords, you might want to tell the MoreLikeThis code to ignore them, as for the purposes of document similarity it seems reasonable to assume that "a stop word is never interesting". * @param stopWords set of stopwords, if null it means to allow stop words * @see org.apache.lucene.analysis.StopFilter#makeStopSet StopFilter.makeStopSet() @see #getStopWords 
public	TokenNamepublic	
void	TokenNamevoid	
setStopWords	TokenNameIdentifier	 set Stop Words
(	TokenNameLPAREN	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
stopWords	TokenNameIdentifier	 stop Words
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
stopWords	TokenNameIdentifier	 stop Words
=	TokenNameEQUAL	
stopWords	TokenNameIdentifier	 stop Words
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the current stop words being used. * * @see #setStopWords */	TokenNameCOMMENT_JAVADOC	 Get the current stop words being used. * @see #setStopWords 
public	TokenNamepublic	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
getStopWords	TokenNameIdentifier	 get Stop Words
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
stopWords	TokenNameIdentifier	 stop Words
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the maximum number of query terms that will be included in any * generated query. The default is {@link #DEFAULT_MAX_QUERY_TERMS}. * * @return the maximum number of query terms that will be included in any * generated query. */	TokenNameCOMMENT_JAVADOC	 Returns the maximum number of query terms that will be included in any generated query. The default is {@link #DEFAULT_MAX_QUERY_TERMS}. * @return the maximum number of query terms that will be included in any generated query. 
public	TokenNamepublic	
int	TokenNameint	
getMaxQueryTerms	TokenNameIdentifier	 get Max Query Terms
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
maxQueryTerms	TokenNameIdentifier	 max Query Terms
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets the maximum number of query terms that will be included in any * generated query. * * @param maxQueryTerms * the maximum number of query terms that will be included in any * generated query. */	TokenNameCOMMENT_JAVADOC	 Sets the maximum number of query terms that will be included in any generated query. * @param maxQueryTerms the maximum number of query terms that will be included in any generated query. 
public	TokenNamepublic	
void	TokenNamevoid	
setMaxQueryTerms	TokenNameIdentifier	 set Max Query Terms
(	TokenNameLPAREN	
int	TokenNameint	
maxQueryTerms	TokenNameIdentifier	 max Query Terms
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
maxQueryTerms	TokenNameIdentifier	 max Query Terms
=	TokenNameEQUAL	
maxQueryTerms	TokenNameIdentifier	 max Query Terms
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @return The maximum number of tokens to parse in each example doc field * that is not stored with TermVector support * @see #DEFAULT_MAX_NUM_TOKENS_PARSED */	TokenNameCOMMENT_JAVADOC	 @return The maximum number of tokens to parse in each example doc field that is not stored with TermVector support @see #DEFAULT_MAX_NUM_TOKENS_PARSED 
public	TokenNamepublic	
int	TokenNameint	
getMaxNumTokensParsed	TokenNameIdentifier	 get Max Num Tokens Parsed
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
maxNumTokensParsed	TokenNameIdentifier	 max Num Tokens Parsed
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @param i * The maximum number of tokens to parse in each example doc field * that is not stored with TermVector support */	TokenNameCOMMENT_JAVADOC	 @param i The maximum number of tokens to parse in each example doc field that is not stored with TermVector support 
public	TokenNamepublic	
void	TokenNamevoid	
setMaxNumTokensParsed	TokenNameIdentifier	 set Max Num Tokens Parsed
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
maxNumTokensParsed	TokenNameIdentifier	 max Num Tokens Parsed
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return a query that will return docs like the passed lucene document ID. * * @param docNum * the documentID of the lucene doc to generate the 'More Like This" * query for. * @return a query that will return docs like the passed lucene document ID. */	TokenNameCOMMENT_JAVADOC	 Return a query that will return docs like the passed lucene document ID. * @param docNum the documentID of the lucene doc to generate the 'More Like This" query for. @return a query that will return docs like the passed lucene document ID. 
public	TokenNamepublic	
Query	TokenNameIdentifier	 Query
like	TokenNameIdentifier	 like
(	TokenNameLPAREN	
int	TokenNameint	
docNum	TokenNameIdentifier	 doc Num
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fieldNames	TokenNameIdentifier	 field Names
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// gather list of valid fields from lucene 	TokenNameCOMMENT_LINE	gather list of valid fields from lucene 
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
fields	TokenNameIdentifier	 fields
=	TokenNameEQUAL	
ReaderUtil	TokenNameIdentifier	 Reader Util
.	TokenNameDOT	
getIndexedFields	TokenNameIdentifier	 get Indexed Fields
(	TokenNameLPAREN	
ir	TokenNameIdentifier	 ir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fieldNames	TokenNameIdentifier	 field Names
=	TokenNameEQUAL	
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
createQuery	TokenNameIdentifier	 create Query
(	TokenNameLPAREN	
retrieveTerms	TokenNameIdentifier	 retrieve Terms
(	TokenNameLPAREN	
docNum	TokenNameIdentifier	 doc Num
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return a query that will return docs like the passed file. * * @return a query that will return docs like the passed file. * @deprecated use {@link #like(Reader, String)} instead */	TokenNameCOMMENT_JAVADOC	 Return a query that will return docs like the passed file. * @return a query that will return docs like the passed file. @deprecated use {@link #like(Reader, String)} instead 
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
public	TokenNamepublic	
Query	TokenNameIdentifier	 Query
like	TokenNameIdentifier	 like
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
f	TokenNameIdentifier	 f
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fieldNames	TokenNameIdentifier	 field Names
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// gather list of valid fields from lucene 	TokenNameCOMMENT_LINE	gather list of valid fields from lucene 
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
fields	TokenNameIdentifier	 fields
=	TokenNameEQUAL	
ReaderUtil	TokenNameIdentifier	 Reader Util
.	TokenNameDOT	
getIndexedFields	TokenNameIdentifier	 get Indexed Fields
(	TokenNameLPAREN	
ir	TokenNameIdentifier	 ir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fieldNames	TokenNameIdentifier	 field Names
=	TokenNameEQUAL	
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
like	TokenNameIdentifier	 like
(	TokenNameLPAREN	
new	TokenNamenew	
FileReader	TokenNameIdentifier	 File Reader
(	TokenNameLPAREN	
f	TokenNameIdentifier	 f
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return a query that will return docs like the passed URL. * * @return a query that will return docs like the passed URL. * @deprecated use {@link #like(Reader, String)} instead */	TokenNameCOMMENT_JAVADOC	 Return a query that will return docs like the passed URL. * @return a query that will return docs like the passed URL. @deprecated use {@link #like(Reader, String)} instead 
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
public	TokenNamepublic	
Query	TokenNameIdentifier	 Query
like	TokenNameIdentifier	 like
(	TokenNameLPAREN	
URL	TokenNameIdentifier	 URL
u	TokenNameIdentifier	 u
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
like	TokenNameIdentifier	 like
(	TokenNameLPAREN	
new	TokenNamenew	
InputStreamReader	TokenNameIdentifier	 Input Stream Reader
(	TokenNameLPAREN	
u	TokenNameIdentifier	 u
.	TokenNameDOT	
openConnection	TokenNameIdentifier	 open Connection
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getInputStream	TokenNameIdentifier	 get Input Stream
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return a query that will return docs like the passed stream. * * @return a query that will return docs like the passed stream. * @deprecated use {@link #like(Reader, String)} instead */	TokenNameCOMMENT_JAVADOC	 Return a query that will return docs like the passed stream. * @return a query that will return docs like the passed stream. @deprecated use {@link #like(Reader, String)} instead 
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
public	TokenNamepublic	
Query	TokenNameIdentifier	 Query
like	TokenNameIdentifier	 like
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
InputStream	TokenNameIdentifier	 Input Stream
is	TokenNameIdentifier	 is
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
like	TokenNameIdentifier	 like
(	TokenNameLPAREN	
new	TokenNamenew	
InputStreamReader	TokenNameIdentifier	 Input Stream Reader
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** @deprecated use {@link #like(Reader, String)} instead */	TokenNameCOMMENT_JAVADOC	 @deprecated use {@link #like(Reader, String)} instead 
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
public	TokenNamepublic	
Query	TokenNameIdentifier	 Query
like	TokenNameIdentifier	 like
(	TokenNameLPAREN	
Reader	TokenNameIdentifier	 Reader
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
createQuery	TokenNameIdentifier	 create Query
(	TokenNameLPAREN	
retrieveTerms	TokenNameIdentifier	 retrieve Terms
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
fieldNames	TokenNameIdentifier	 field Names
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return a query that will return docs like the passed Reader. * * @return a query that will return docs like the passed Reader. */	TokenNameCOMMENT_JAVADOC	 Return a query that will return docs like the passed Reader. * @return a query that will return docs like the passed Reader. 
public	TokenNamepublic	
Query	TokenNameIdentifier	 Query
like	TokenNameIdentifier	 like
(	TokenNameLPAREN	
Reader	TokenNameIdentifier	 Reader
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
fieldName	TokenNameIdentifier	 field Name
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
createQuery	TokenNameIdentifier	 create Query
(	TokenNameLPAREN	
retrieveTerms	TokenNameIdentifier	 retrieve Terms
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
fieldName	TokenNameIdentifier	 field Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Create the More like query from a PriorityQueue */	TokenNameCOMMENT_JAVADOC	 Create the More like query from a PriorityQueue 
private	TokenNameprivate	
Query	TokenNameIdentifier	 Query
createQuery	TokenNameIdentifier	 create Query
(	TokenNameLPAREN	
PriorityQueue	TokenNameIdentifier	 Priority Queue
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
>	TokenNameGREATER	
q	TokenNameIdentifier	 q
)	TokenNameRPAREN	
{	TokenNameLBRACE	
BooleanQuery	TokenNameIdentifier	 Boolean Query
query	TokenNameIdentifier	 query
=	TokenNameEQUAL	
new	TokenNamenew	
BooleanQuery	TokenNameIdentifier	 Boolean Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Object	TokenNameIdentifier	 Object
cur	TokenNameIdentifier	 cur
;	TokenNameSEMICOLON	
int	TokenNameint	
qterms	TokenNameIdentifier	 qterms
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
bestScore	TokenNameIdentifier	 best Score
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
cur	TokenNameIdentifier	 cur
=	TokenNameEQUAL	
q	TokenNameIdentifier	 q
.	TokenNameDOT	
pop	TokenNameIdentifier	 pop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
ar	TokenNameIdentifier	 ar
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
cur	TokenNameIdentifier	 cur
;	TokenNameSEMICOLON	
TermQuery	TokenNameIdentifier	 Term Query
tq	TokenNameIdentifier	 tq
=	TokenNameEQUAL	
new	TokenNamenew	
TermQuery	TokenNameIdentifier	 Term Query
(	TokenNameLPAREN	
new	TokenNamenew	
Term	TokenNameIdentifier	 Term
(	TokenNameLPAREN	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
ar	TokenNameIdentifier	 ar
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
ar	TokenNameIdentifier	 ar
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
boost	TokenNameIdentifier	 boost
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
qterms	TokenNameIdentifier	 qterms
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bestScore	TokenNameIdentifier	 best Score
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Float	TokenNameIdentifier	 Float
)	TokenNameRPAREN	
ar	TokenNameIdentifier	 ar
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
.	TokenNameDOT	
floatValue	TokenNameIdentifier	 float Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
float	TokenNamefloat	
myScore	TokenNameIdentifier	 my Score
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Float	TokenNameIdentifier	 Float
)	TokenNameRPAREN	
ar	TokenNameIdentifier	 ar
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
.	TokenNameDOT	
floatValue	TokenNameIdentifier	 float Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tq	TokenNameIdentifier	 tq
.	TokenNameDOT	
setBoost	TokenNameIdentifier	 set Boost
(	TokenNameLPAREN	
boostFactor	TokenNameIdentifier	 boost Factor
*	TokenNameMULTIPLY	
myScore	TokenNameIdentifier	 my Score
/	TokenNameDIVIDE	
bestScore	TokenNameIdentifier	 best Score
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
tq	TokenNameIdentifier	 tq
,	TokenNameCOMMA	
BooleanClause	TokenNameIdentifier	 Boolean Clause
.	TokenNameDOT	
Occur	TokenNameIdentifier	 Occur
.	TokenNameDOT	
SHOULD	TokenNameIdentifier	 SHOULD
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
BooleanQuery	TokenNameIdentifier	 Boolean Query
.	TokenNameDOT	
TooManyClauses	TokenNameIdentifier	 Too Many Clauses
ignore	TokenNameIdentifier	 ignore
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
qterms	TokenNameIdentifier	 qterms
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
maxQueryTerms	TokenNameIdentifier	 max Query Terms
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
qterms	TokenNameIdentifier	 qterms
>=	TokenNameGREATER_EQUAL	
maxQueryTerms	TokenNameIdentifier	 max Query Terms
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
query	TokenNameIdentifier	 query
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Create a PriorityQueue from a word->tf map. * * @param words * a map of words keyed on the word(String) with Int objects as the * values. */	TokenNameCOMMENT_JAVADOC	 Create a PriorityQueue from a word->tf map. * @param words a map of words keyed on the word(String) with Int objects as the values. 
private	TokenNameprivate	
PriorityQueue	TokenNameIdentifier	 Priority Queue
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
>	TokenNameGREATER	
createQueue	TokenNameIdentifier	 create Queue
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Int	TokenNameIdentifier	 Int
>	TokenNameGREATER	
words	TokenNameIdentifier	 words
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// have collected all words in doc and their freqs 	TokenNameCOMMENT_LINE	have collected all words in doc and their freqs 
int	TokenNameint	
numDocs	TokenNameIdentifier	 num Docs
=	TokenNameEQUAL	
ir	TokenNameIdentifier	 ir
.	TokenNameDOT	
numDocs	TokenNameIdentifier	 num Docs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
FreqQ	TokenNameIdentifier	 Freq Q
res	TokenNameIdentifier	 res
=	TokenNameEQUAL	
new	TokenNamenew	
FreqQ	TokenNameIdentifier	 Freq Q
(	TokenNameLPAREN	
words	TokenNameIdentifier	 words
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// will order words by score 	TokenNameCOMMENT_LINE	will order words by score 
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
it	TokenNameIdentifier	 it
=	TokenNameEQUAL	
words	TokenNameIdentifier	 words
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
it	TokenNameIdentifier	 it
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// for every word 	TokenNameCOMMENT_LINE	for every word 
String	TokenNameIdentifier	 String
word	TokenNameIdentifier	 word
=	TokenNameEQUAL	
it	TokenNameIdentifier	 it
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
tf	TokenNameIdentifier	 tf
=	TokenNameEQUAL	
words	TokenNameIdentifier	 words
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
word	TokenNameIdentifier	 word
)	TokenNameRPAREN	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
;	TokenNameSEMICOLON	
// term freq in the source doc 	TokenNameCOMMENT_LINE	term freq in the source doc 
if	TokenNameif	
(	TokenNameLPAREN	
minTermFreq	TokenNameIdentifier	 min Term Freq
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
tf	TokenNameIdentifier	 tf
<	TokenNameLESS	
minTermFreq	TokenNameIdentifier	 min Term Freq
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
// filter out words that don't occur enough times in the 	TokenNameCOMMENT_LINE	filter out words that don't occur enough times in the 
// source 	TokenNameCOMMENT_LINE	source 
}	TokenNameRBRACE	
// go through all the fields and find the largest document frequency 	TokenNameCOMMENT_LINE	go through all the fields and find the largest document frequency 
String	TokenNameIdentifier	 String
topField	TokenNameIdentifier	 top Field
=	TokenNameEQUAL	
fieldNames	TokenNameIdentifier	 field Names
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
docFreq	TokenNameIdentifier	 doc Freq
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fieldNames	TokenNameIdentifier	 field Names
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
freq	TokenNameIdentifier	 freq
=	TokenNameEQUAL	
ir	TokenNameIdentifier	 ir
.	TokenNameDOT	
docFreq	TokenNameIdentifier	 doc Freq
(	TokenNameLPAREN	
new	TokenNamenew	
Term	TokenNameIdentifier	 Term
(	TokenNameLPAREN	
fieldNames	TokenNameIdentifier	 field Names
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
word	TokenNameIdentifier	 word
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
topField	TokenNameIdentifier	 top Field
=	TokenNameEQUAL	
(	TokenNameLPAREN	
freq	TokenNameIdentifier	 freq
>	TokenNameGREATER	
docFreq	TokenNameIdentifier	 doc Freq
)	TokenNameRPAREN	
?	TokenNameQUESTION	
fieldNames	TokenNameIdentifier	 field Names
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
:	TokenNameCOLON	
topField	TokenNameIdentifier	 top Field
;	TokenNameSEMICOLON	
docFreq	TokenNameIdentifier	 doc Freq
=	TokenNameEQUAL	
(	TokenNameLPAREN	
freq	TokenNameIdentifier	 freq
>	TokenNameGREATER	
docFreq	TokenNameIdentifier	 doc Freq
)	TokenNameRPAREN	
?	TokenNameQUESTION	
freq	TokenNameIdentifier	 freq
:	TokenNameCOLON	
docFreq	TokenNameIdentifier	 doc Freq
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
minDocFreq	TokenNameIdentifier	 min Doc Freq
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
docFreq	TokenNameIdentifier	 doc Freq
<	TokenNameLESS	
minDocFreq	TokenNameIdentifier	 min Doc Freq
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
// filter out words that don't occur in enough docs 	TokenNameCOMMENT_LINE	filter out words that don't occur in enough docs 
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
docFreq	TokenNameIdentifier	 doc Freq
>	TokenNameGREATER	
maxDocFreq	TokenNameIdentifier	 max Doc Freq
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
// filter out words that occur in too many docs 	TokenNameCOMMENT_LINE	filter out words that occur in too many docs 
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
docFreq	TokenNameIdentifier	 doc Freq
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
// index update problem? 	TokenNameCOMMENT_LINE	index update problem? 
}	TokenNameRBRACE	
float	TokenNamefloat	
idf	TokenNameIdentifier	 idf
=	TokenNameEQUAL	
similarity	TokenNameIdentifier	 similarity
.	TokenNameDOT	
idf	TokenNameIdentifier	 idf
(	TokenNameLPAREN	
docFreq	TokenNameIdentifier	 doc Freq
,	TokenNameCOMMA	
numDocs	TokenNameIdentifier	 num Docs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
score	TokenNameIdentifier	 score
=	TokenNameEQUAL	
tf	TokenNameIdentifier	 tf
*	TokenNameMULTIPLY	
idf	TokenNameIdentifier	 idf
;	TokenNameSEMICOLON	
// only really need 1st 3 entries, other ones are for troubleshooting 	TokenNameCOMMENT_LINE	only really need 1st 3 entries, other ones are for troubleshooting 
res	TokenNameIdentifier	 res
.	TokenNameDOT	
insertWithOverflow	TokenNameIdentifier	 insert With Overflow
(	TokenNameLPAREN	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
word	TokenNameIdentifier	 word
,	TokenNameCOMMA	
// the word 	TokenNameCOMMENT_LINE	the word 
topField	TokenNameIdentifier	 top Field
,	TokenNameCOMMA	
// the top field 	TokenNameCOMMENT_LINE	the top field 
Float	TokenNameIdentifier	 Float
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
score	TokenNameIdentifier	 score
)	TokenNameRPAREN	
,	TokenNameCOMMA	
// overall score 	TokenNameCOMMENT_LINE	overall score 
Float	TokenNameIdentifier	 Float
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
idf	TokenNameIdentifier	 idf
)	TokenNameRPAREN	
,	TokenNameCOMMA	
// idf 	TokenNameCOMMENT_LINE	idf 
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
docFreq	TokenNameIdentifier	 doc Freq
)	TokenNameRPAREN	
,	TokenNameCOMMA	
// freq in all docs 	TokenNameCOMMENT_LINE	freq in all docs 
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
tf	TokenNameIdentifier	 tf
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
res	TokenNameIdentifier	 res
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Describe the parameters that control how the "more like this" query is * formed. */	TokenNameCOMMENT_JAVADOC	 Describe the parameters that control how the "more like this" query is formed. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
describeParams	TokenNameIdentifier	 describe Params
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StringBuilder	TokenNameIdentifier	 String Builder
sb	TokenNameIdentifier	 sb
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuilder	TokenNameIdentifier	 String Builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
"maxQueryTerms : "	TokenNameStringLiteral	maxQueryTerms : 
+	TokenNamePLUS	
maxQueryTerms	TokenNameIdentifier	 max Query Terms
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
"minWordLen : "	TokenNameStringLiteral	minWordLen : 
+	TokenNamePLUS	
minWordLen	TokenNameIdentifier	 min Word Len
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
"maxWordLen : "	TokenNameStringLiteral	maxWordLen : 
+	TokenNamePLUS	
maxWordLen	TokenNameIdentifier	 max Word Len
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
"fieldNames : "	TokenNameStringLiteral	fieldNames : 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
delim	TokenNameIdentifier	 delim
=	TokenNameEQUAL	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fieldNames	TokenNameIdentifier	 field Names
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
fieldName	TokenNameIdentifier	 field Name
=	TokenNameEQUAL	
fieldNames	TokenNameIdentifier	 field Names
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
delim	TokenNameIdentifier	 delim
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
fieldName	TokenNameIdentifier	 field Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
delim	TokenNameIdentifier	 delim
=	TokenNameEQUAL	
", "	TokenNameStringLiteral	, 
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" "	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
"boost : "	TokenNameStringLiteral	boost : 
+	TokenNamePLUS	
boost	TokenNameIdentifier	 boost
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
"minTermFreq : "	TokenNameStringLiteral	minTermFreq : 
+	TokenNamePLUS	
minTermFreq	TokenNameIdentifier	 min Term Freq
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
"minDocFreq : "	TokenNameStringLiteral	minDocFreq : 
+	TokenNamePLUS	
minDocFreq	TokenNameIdentifier	 min Doc Freq
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Find words for a more-like-this query former. * * @param docNum * the id of the lucene document from which to find terms */	TokenNameCOMMENT_JAVADOC	 Find words for a more-like-this query former. * @param docNum the id of the lucene document from which to find terms 
public	TokenNamepublic	
PriorityQueue	TokenNameIdentifier	 Priority Queue
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
>	TokenNameGREATER	
retrieveTerms	TokenNameIdentifier	 retrieve Terms
(	TokenNameLPAREN	
int	TokenNameint	
docNum	TokenNameIdentifier	 doc Num
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Int	TokenNameIdentifier	 Int
>	TokenNameGREATER	
termFreqMap	TokenNameIdentifier	 term Freq Map
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Int	TokenNameIdentifier	 Int
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fieldNames	TokenNameIdentifier	 field Names
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
fieldName	TokenNameIdentifier	 field Name
=	TokenNameEQUAL	
fieldNames	TokenNameIdentifier	 field Names
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
TermFreqVector	TokenNameIdentifier	 Term Freq Vector
vector	TokenNameIdentifier	 vector
=	TokenNameEQUAL	
ir	TokenNameIdentifier	 ir
.	TokenNameDOT	
getTermFreqVector	TokenNameIdentifier	 get Term Freq Vector
(	TokenNameLPAREN	
docNum	TokenNameIdentifier	 doc Num
,	TokenNameCOMMA	
fieldName	TokenNameIdentifier	 field Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// field does not store term vector info 	TokenNameCOMMENT_LINE	field does not store term vector info 
if	TokenNameif	
(	TokenNameLPAREN	
vector	TokenNameIdentifier	 vector
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Document	TokenNameIdentifier	 Document
d	TokenNameIdentifier	 d
=	TokenNameEQUAL	
ir	TokenNameIdentifier	 ir
.	TokenNameDOT	
document	TokenNameIdentifier	 document
(	TokenNameLPAREN	
docNum	TokenNameIdentifier	 doc Num
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
text	TokenNameIdentifier	 text
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
d	TokenNameIdentifier	 d
.	TokenNameDOT	
getValues	TokenNameIdentifier	 get Values
(	TokenNameLPAREN	
fieldName	TokenNameIdentifier	 field Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addTermFrequencies	TokenNameIdentifier	 add Term Frequencies
(	TokenNameLPAREN	
new	TokenNamenew	
StringReader	TokenNameIdentifier	 String Reader
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
termFreqMap	TokenNameIdentifier	 term Freq Map
,	TokenNameCOMMA	
fieldName	TokenNameIdentifier	 field Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
addTermFrequencies	TokenNameIdentifier	 add Term Frequencies
(	TokenNameLPAREN	
termFreqMap	TokenNameIdentifier	 term Freq Map
,	TokenNameCOMMA	
vector	TokenNameIdentifier	 vector
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
createQueue	TokenNameIdentifier	 create Queue
(	TokenNameLPAREN	
termFreqMap	TokenNameIdentifier	 term Freq Map
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Adds terms and frequencies found in vector into the Map termFreqMap * * @param termFreqMap * a Map of terms and their frequencies * @param vector * List of terms and their frequencies for a doc/field */	TokenNameCOMMENT_JAVADOC	 Adds terms and frequencies found in vector into the Map termFreqMap * @param termFreqMap a Map of terms and their frequencies @param vector List of terms and their frequencies for a doc/field 
private	TokenNameprivate	
void	TokenNamevoid	
addTermFrequencies	TokenNameIdentifier	 add Term Frequencies
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Int	TokenNameIdentifier	 Int
>	TokenNameGREATER	
termFreqMap	TokenNameIdentifier	 term Freq Map
,	TokenNameCOMMA	
TermFreqVector	TokenNameIdentifier	 Term Freq Vector
vector	TokenNameIdentifier	 vector
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
terms	TokenNameIdentifier	 terms
=	TokenNameEQUAL	
vector	TokenNameIdentifier	 vector
.	TokenNameDOT	
getTerms	TokenNameIdentifier	 get Terms
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
freqs	TokenNameIdentifier	 freqs
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
vector	TokenNameIdentifier	 vector
.	TokenNameDOT	
getTermFrequencies	TokenNameIdentifier	 get Term Frequencies
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
terms	TokenNameIdentifier	 terms
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
terms	TokenNameIdentifier	 terms
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isNoiseWord	TokenNameIdentifier	 is Noise Word
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// increment frequency 	TokenNameCOMMENT_LINE	increment frequency 
Int	TokenNameIdentifier	 Int
cnt	TokenNameIdentifier	 cnt
=	TokenNameEQUAL	
termFreqMap	TokenNameIdentifier	 term Freq Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cnt	TokenNameIdentifier	 cnt
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
cnt	TokenNameIdentifier	 cnt
=	TokenNameEQUAL	
new	TokenNamenew	
Int	TokenNameIdentifier	 Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
termFreqMap	TokenNameIdentifier	 term Freq Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
,	TokenNameCOMMA	
cnt	TokenNameIdentifier	 cnt
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cnt	TokenNameIdentifier	 cnt
.	TokenNameDOT	
x	TokenNameIdentifier	 x
=	TokenNameEQUAL	
freqs	TokenNameIdentifier	 freqs
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
cnt	TokenNameIdentifier	 cnt
.	TokenNameDOT	
x	TokenNameIdentifier	 x
+=	TokenNamePLUS_EQUAL	
freqs	TokenNameIdentifier	 freqs
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Adds term frequencies found by tokenizing text from reader into the Map * words * * @param r * a source of text to be tokenized * @param termFreqMap * a Map of terms and their frequencies * @param fieldName * Used by analyzer for any special per-field analysis */	TokenNameCOMMENT_JAVADOC	 Adds term frequencies found by tokenizing text from reader into the Map words * @param r a source of text to be tokenized @param termFreqMap a Map of terms and their frequencies @param fieldName Used by analyzer for any special per-field analysis 
private	TokenNameprivate	
void	TokenNamevoid	
addTermFrequencies	TokenNameIdentifier	 add Term Frequencies
(	TokenNameLPAREN	
Reader	TokenNameIdentifier	 Reader
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Int	TokenNameIdentifier	 Int
>	TokenNameGREATER	
termFreqMap	TokenNameIdentifier	 term Freq Map
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
fieldName	TokenNameIdentifier	 field Name
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
TokenStream	TokenNameIdentifier	 Token Stream
ts	TokenNameIdentifier	 ts
=	TokenNameEQUAL	
analyzer	TokenNameIdentifier	 analyzer
.	TokenNameDOT	
reusableTokenStream	TokenNameIdentifier	 reusable Token Stream
(	TokenNameLPAREN	
fieldName	TokenNameIdentifier	 field Name
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
tokenCount	TokenNameIdentifier	 token Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// for every token 	TokenNameCOMMENT_LINE	for every token 
CharTermAttribute	TokenNameIdentifier	 Char Term Attribute
termAtt	TokenNameIdentifier	 term Att
=	TokenNameEQUAL	
ts	TokenNameIdentifier	 ts
.	TokenNameDOT	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
CharTermAttribute	TokenNameIdentifier	 Char Term Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ts	TokenNameIdentifier	 ts
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
ts	TokenNameIdentifier	 ts
.	TokenNameDOT	
incrementToken	TokenNameIdentifier	 increment Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
word	TokenNameIdentifier	 word
=	TokenNameEQUAL	
termAtt	TokenNameIdentifier	 term Att
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tokenCount	TokenNameIdentifier	 token Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
tokenCount	TokenNameIdentifier	 token Count
>	TokenNameGREATER	
maxNumTokensParsed	TokenNameIdentifier	 max Num Tokens Parsed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isNoiseWord	TokenNameIdentifier	 is Noise Word
(	TokenNameLPAREN	
word	TokenNameIdentifier	 word
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// increment frequency 	TokenNameCOMMENT_LINE	increment frequency 
Int	TokenNameIdentifier	 Int
cnt	TokenNameIdentifier	 cnt
=	TokenNameEQUAL	
termFreqMap	TokenNameIdentifier	 term Freq Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
word	TokenNameIdentifier	 word
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cnt	TokenNameIdentifier	 cnt
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
termFreqMap	TokenNameIdentifier	 term Freq Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
word	TokenNameIdentifier	 word
,	TokenNameCOMMA	
new	TokenNamenew	
Int	TokenNameIdentifier	 Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
cnt	TokenNameIdentifier	 cnt
.	TokenNameDOT	
x	TokenNameIdentifier	 x
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
ts	TokenNameIdentifier	 ts
.	TokenNameDOT	
end	TokenNameIdentifier	 end
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ts	TokenNameIdentifier	 ts
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * determines if the passed term is likely to be of interest in "more like" * comparisons * * @param term * The word being considered * @return true if should be ignored, false if should be used in further * analysis */	TokenNameCOMMENT_JAVADOC	 determines if the passed term is likely to be of interest in "more like" comparisons * @param term The word being considered @return true if should be ignored, false if should be used in further analysis 
private	TokenNameprivate	
boolean	TokenNameboolean	
isNoiseWord	TokenNameIdentifier	 is Noise Word
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
minWordLen	TokenNameIdentifier	 min Word Len
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
len	TokenNameIdentifier	 len
<	TokenNameLESS	
minWordLen	TokenNameIdentifier	 min Word Len
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
maxWordLen	TokenNameIdentifier	 max Word Len
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
len	TokenNameIdentifier	 len
>	TokenNameGREATER	
maxWordLen	TokenNameIdentifier	 max Word Len
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
stopWords	TokenNameIdentifier	 stop Words
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
stopWords	TokenNameIdentifier	 stop Words
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Find words for a more-like-this query former. The result is a priority * queue of arrays with one entry for <b>every word</b> in the document. Each * array has 6 elements. The elements are: * <ol> * <li>The word (String) * <li>The top field that this word comes from (String) * <li>The score for this word (Float) * <li>The IDF value (Float) * <li>The frequency of this word in the index (Integer) * <li>The frequency of this word in the source document (Integer) * </ol> * This is a somewhat "advanced" routine, and in general only the 1st entry in the array is of interest. * This method is exposed so that you can identify the "interesting words" in a document. * For an easier method to call see {@link #retrieveInterestingTerms retrieveInterestingTerms()}. * * @param r the reader that has the content of the document * @param fieldName field passed to the analyzer to use when analyzing the content * @return the most interesting words in the document ordered by score, with the highest scoring, or best entry, first * @see #retrieveInterestingTerms */	TokenNameCOMMENT_JAVADOC	 Find words for a more-like-this query former. The result is a priority queue of arrays with one entry for <b>every word</b> in the document. Each array has 6 elements. The elements are: <ol> <li>The word (String) <li>The top field that this word comes from (String) <li>The score for this word (Float) <li>The IDF value (Float) <li>The frequency of this word in the index (Integer) <li>The frequency of this word in the source document (Integer) </ol> This is a somewhat "advanced" routine, and in general only the 1st entry in the array is of interest. This method is exposed so that you can identify the "interesting words" in a document. For an easier method to call see {@link #retrieveInterestingTerms retrieveInterestingTerms()}. * @param r the reader that has the content of the document @param fieldName field passed to the analyzer to use when analyzing the content @return the most interesting words in the document ordered by score, with the highest scoring, or best entry, first @see #retrieveInterestingTerms 
public	TokenNamepublic	
PriorityQueue	TokenNameIdentifier	 Priority Queue
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
>	TokenNameGREATER	
retrieveTerms	TokenNameIdentifier	 retrieve Terms
(	TokenNameLPAREN	
Reader	TokenNameIdentifier	 Reader
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
fieldName	TokenNameIdentifier	 field Name
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Int	TokenNameIdentifier	 Int
>	TokenNameGREATER	
words	TokenNameIdentifier	 words
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Int	TokenNameIdentifier	 Int
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
addTermFrequencies	TokenNameIdentifier	 add Term Frequencies
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
words	TokenNameIdentifier	 words
,	TokenNameCOMMA	
fieldName	TokenNameIdentifier	 field Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
createQueue	TokenNameIdentifier	 create Queue
(	TokenNameLPAREN	
words	TokenNameIdentifier	 words
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** @deprecated use {@link #retrieveTerms(Reader, String)} instead */	TokenNameCOMMENT_JAVADOC	 @deprecated use {@link #retrieveTerms(Reader, String)} instead 
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
public	TokenNamepublic	
PriorityQueue	TokenNameIdentifier	 Priority Queue
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
>	TokenNameGREATER	
retrieveTerms	TokenNameIdentifier	 retrieve Terms
(	TokenNameLPAREN	
Reader	TokenNameIdentifier	 Reader
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
retrieveTerms	TokenNameIdentifier	 retrieve Terms
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
fieldNames	TokenNameIdentifier	 field Names
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @see #retrieveInterestingTerms(java.io.Reader, String) */	TokenNameCOMMENT_JAVADOC	 @see #retrieveInterestingTerms(java.io.Reader, String) 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
retrieveInterestingTerms	TokenNameIdentifier	 retrieve Interesting Terms
(	TokenNameLPAREN	
int	TokenNameint	
docNum	TokenNameIdentifier	 doc Num
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
al	TokenNameIdentifier	 al
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
(	TokenNameLPAREN	
maxQueryTerms	TokenNameIdentifier	 max Query Terms
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
PriorityQueue	TokenNameIdentifier	 Priority Queue
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
>	TokenNameGREATER	
pq	TokenNameIdentifier	 pq
=	TokenNameEQUAL	
retrieveTerms	TokenNameIdentifier	 retrieve Terms
(	TokenNameLPAREN	
docNum	TokenNameIdentifier	 doc Num
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Object	TokenNameIdentifier	 Object
cur	TokenNameIdentifier	 cur
;	TokenNameSEMICOLON	
int	TokenNameint	
lim	TokenNameIdentifier	 lim
=	TokenNameEQUAL	
maxQueryTerms	TokenNameIdentifier	 max Query Terms
;	TokenNameSEMICOLON	
// have to be careful, retrieveTerms returns all 	TokenNameCOMMENT_LINE	have to be careful, retrieveTerms returns all 
// words but that's probably not useful to our 	TokenNameCOMMENT_LINE	words but that's probably not useful to our 
// caller... 	TokenNameCOMMENT_LINE	caller... 
// we just want to return the top words 	TokenNameCOMMENT_LINE	we just want to return the top words 
while	TokenNamewhile	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
cur	TokenNameIdentifier	 cur
=	TokenNameEQUAL	
pq	TokenNameIdentifier	 pq
.	TokenNameDOT	
pop	TokenNameIdentifier	 pop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
lim	TokenNameIdentifier	 lim
--	TokenNameMINUS_MINUS	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
ar	TokenNameIdentifier	 ar
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
cur	TokenNameIdentifier	 cur
;	TokenNameSEMICOLON	
al	TokenNameIdentifier	 al
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
ar	TokenNameIdentifier	 ar
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// the 1st entry is the interesting word 	TokenNameCOMMENT_LINE	the 1st entry is the interesting word 
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
res	TokenNameIdentifier	 res
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
al	TokenNameIdentifier	 al
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
al	TokenNameIdentifier	 al
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
res	TokenNameIdentifier	 res
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Convenience routine to make it easy to return the most interesting words in a document. * More advanced users will call {@link #retrieveTerms(Reader, String) retrieveTerms()} directly. * * @param r the source document * @param fieldName field passed to analyzer to use when analyzing the content * @return the most interesting words in the document * @see #retrieveTerms(java.io.Reader, String) * @see #setMaxQueryTerms */	TokenNameCOMMENT_JAVADOC	 Convenience routine to make it easy to return the most interesting words in a document. More advanced users will call {@link #retrieveTerms(Reader, String) retrieveTerms()} directly. * @param r the source document @param fieldName field passed to analyzer to use when analyzing the content @return the most interesting words in the document @see #retrieveTerms(java.io.Reader, String) @see #setMaxQueryTerms 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
retrieveInterestingTerms	TokenNameIdentifier	 retrieve Interesting Terms
(	TokenNameLPAREN	
Reader	TokenNameIdentifier	 Reader
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
fieldName	TokenNameIdentifier	 field Name
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
al	TokenNameIdentifier	 al
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
(	TokenNameLPAREN	
maxQueryTerms	TokenNameIdentifier	 max Query Terms
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
PriorityQueue	TokenNameIdentifier	 Priority Queue
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
>	TokenNameGREATER	
pq	TokenNameIdentifier	 pq
=	TokenNameEQUAL	
retrieveTerms	TokenNameIdentifier	 retrieve Terms
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
fieldName	TokenNameIdentifier	 field Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Object	TokenNameIdentifier	 Object
cur	TokenNameIdentifier	 cur
;	TokenNameSEMICOLON	
int	TokenNameint	
lim	TokenNameIdentifier	 lim
=	TokenNameEQUAL	
maxQueryTerms	TokenNameIdentifier	 max Query Terms
;	TokenNameSEMICOLON	
// have to be careful, retrieveTerms returns all 	TokenNameCOMMENT_LINE	have to be careful, retrieveTerms returns all 
// words but that's probably not useful to our 	TokenNameCOMMENT_LINE	words but that's probably not useful to our 
// caller... 	TokenNameCOMMENT_LINE	caller... 
// we just want to return the top words 	TokenNameCOMMENT_LINE	we just want to return the top words 
while	TokenNamewhile	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
cur	TokenNameIdentifier	 cur
=	TokenNameEQUAL	
pq	TokenNameIdentifier	 pq
.	TokenNameDOT	
pop	TokenNameIdentifier	 pop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
lim	TokenNameIdentifier	 lim
--	TokenNameMINUS_MINUS	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
ar	TokenNameIdentifier	 ar
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
cur	TokenNameIdentifier	 cur
;	TokenNameSEMICOLON	
al	TokenNameIdentifier	 al
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
ar	TokenNameIdentifier	 ar
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// the 1st entry is the interesting word 	TokenNameCOMMENT_LINE	the 1st entry is the interesting word 
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
res	TokenNameIdentifier	 res
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
al	TokenNameIdentifier	 al
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
al	TokenNameIdentifier	 al
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
res	TokenNameIdentifier	 res
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** @deprecated use {@link #retrieveInterestingTerms(Reader, String)} instead. */	TokenNameCOMMENT_JAVADOC	 @deprecated use {@link #retrieveInterestingTerms(Reader, String)} instead. 
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
retrieveInterestingTerms	TokenNameIdentifier	 retrieve Interesting Terms
(	TokenNameLPAREN	
Reader	TokenNameIdentifier	 Reader
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
retrieveInterestingTerms	TokenNameIdentifier	 retrieve Interesting Terms
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
fieldNames	TokenNameIdentifier	 field Names
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * PriorityQueue that orders words by score. */	TokenNameCOMMENT_JAVADOC	 PriorityQueue that orders words by score. 
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
FreqQ	TokenNameIdentifier	 Freq Q
extends	TokenNameextends	
PriorityQueue	TokenNameIdentifier	 Priority Queue
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
>	TokenNameGREATER	
{	TokenNameLBRACE	
FreqQ	TokenNameIdentifier	 Freq Q
(	TokenNameLPAREN	
int	TokenNameint	
s	TokenNameIdentifier	 s
)	TokenNameRPAREN	
{	TokenNameLBRACE	
initialize	TokenNameIdentifier	 initialize
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
protected	TokenNameprotected	
boolean	TokenNameboolean	
lessThan	TokenNameIdentifier	 less Than
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
aa	TokenNameIdentifier	 aa
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bb	TokenNameIdentifier	 bb
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Float	TokenNameIdentifier	 Float
fa	TokenNameIdentifier	 fa
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Float	TokenNameIdentifier	 Float
)	TokenNameRPAREN	
aa	TokenNameIdentifier	 aa
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
Float	TokenNameIdentifier	 Float
fb	TokenNameIdentifier	 fb
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Float	TokenNameIdentifier	 Float
)	TokenNameRPAREN	
bb	TokenNameIdentifier	 bb
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
fa	TokenNameIdentifier	 fa
.	TokenNameDOT	
floatValue	TokenNameIdentifier	 float Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
fb	TokenNameIdentifier	 fb
.	TokenNameDOT	
floatValue	TokenNameIdentifier	 float Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Use for frequencies and to avoid renewing Integers. */	TokenNameCOMMENT_JAVADOC	 Use for frequencies and to avoid renewing Integers. 
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
Int	TokenNameIdentifier	 Int
{	TokenNameLBRACE	
int	TokenNameint	
x	TokenNameIdentifier	 x
;	TokenNameSEMICOLON	
Int	TokenNameIdentifier	 Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
x	TokenNameIdentifier	 x
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
