/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
/* * $Id: ExsltDynamic.java 468639 2006-10-28 06:52:33Z minchau $ */	TokenNameCOMMENT_BLOCK	 $Id: ExsltDynamic.java 468639 2006-10-28 06:52:33Z minchau $ 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xalan	TokenNameIdentifier	 xalan
.	TokenNameDOT	
lib	TokenNameIdentifier	 lib
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
parsers	TokenNameIdentifier	 parsers
.	TokenNameDOT	
DocumentBuilder	TokenNameIdentifier	 Document Builder
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
parsers	TokenNameIdentifier	 parsers
.	TokenNameDOT	
DocumentBuilderFactory	TokenNameIdentifier	 Document Builder Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
TransformerException	TokenNameIdentifier	 Transformer Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xalan	TokenNameIdentifier	 xalan
.	TokenNameDOT	
extensions	TokenNameIdentifier	 extensions
.	TokenNameDOT	
ExpressionContext	TokenNameIdentifier	 Expression Context
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xalan	TokenNameIdentifier	 xalan
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XSLMessages	TokenNameIdentifier	 XSL Messages
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xalan	TokenNameIdentifier	 xalan
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XSLTErrorResources	TokenNameIdentifier	 XSLT Error Resources
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xpath	TokenNameIdentifier	 xpath
.	TokenNameDOT	
NodeSet	TokenNameIdentifier	 Node Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xpath	TokenNameIdentifier	 xpath
.	TokenNameDOT	
NodeSetDTM	TokenNameIdentifier	 Node Set DTM
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xpath	TokenNameIdentifier	 xpath
.	TokenNameDOT	
XPath	TokenNameIdentifier	 X Path
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xpath	TokenNameIdentifier	 xpath
.	TokenNameDOT	
XPathContext	TokenNameIdentifier	 X Path Context
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xpath	TokenNameIdentifier	 xpath
.	TokenNameDOT	
objects	TokenNameIdentifier	 objects
.	TokenNameDOT	
XBoolean	TokenNameIdentifier	 X Boolean
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xpath	TokenNameIdentifier	 xpath
.	TokenNameDOT	
objects	TokenNameIdentifier	 objects
.	TokenNameDOT	
XNodeSet	TokenNameIdentifier	 X Node Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xpath	TokenNameIdentifier	 xpath
.	TokenNameDOT	
objects	TokenNameIdentifier	 objects
.	TokenNameDOT	
XNumber	TokenNameIdentifier	 X Number
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xpath	TokenNameIdentifier	 xpath
.	TokenNameDOT	
objects	TokenNameIdentifier	 objects
.	TokenNameDOT	
XObject	TokenNameIdentifier	 X Object
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Document	TokenNameIdentifier	 Document
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Element	TokenNameIdentifier	 Element
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Node	TokenNameIdentifier	 Node
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
NodeList	TokenNameIdentifier	 Node List
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Text	TokenNameIdentifier	 Text
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
SAXNotSupportedException	TokenNameIdentifier	 SAX Not Supported Exception
;	TokenNameSEMICOLON	
/** * This class contains EXSLT dynamic extension functions. * * It is accessed by specifying a namespace URI as follows: * <pre> * xmlns:dyn="http://exslt.org/dynamic" * </pre> * The documentation for each function has been copied from the relevant * EXSLT Implementer page. * * @see <a href="http://www.exslt.org/">EXSLT</a> * @xsl.usage general */	TokenNameCOMMENT_JAVADOC	 This class contains EXSLT dynamic extension functions. * It is accessed by specifying a namespace URI as follows: <pre> xmlns:dyn="http://exslt.org/dynamic" </pre> The documentation for each function has been copied from the relevant EXSLT Implementer page. * @see <a href="http://www.exslt.org/">EXSLT</a> @xsl.usage general 
public	TokenNamepublic	
class	TokenNameclass	
ExsltDynamic	TokenNameIdentifier	 Exslt Dynamic
extends	TokenNameextends	
ExsltBase	TokenNameIdentifier	 Exslt Base
{	TokenNameLBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
EXSL_URI	TokenNameIdentifier	 EXSL  URI
=	TokenNameEQUAL	
"http://exslt.org/common"	TokenNameStringLiteral	http://exslt.org/common
;	TokenNameSEMICOLON	
/** * The dyn:max function calculates the maximum value for the nodes passed as * the first argument, where the value of each node is calculated dynamically * using an XPath expression passed as a string as the second argument. * <p> * The expressions are evaluated relative to the nodes passed as the first argument. * In other words, the value for each node is calculated by evaluating the XPath * expression with all context information being the same as that for the call to * the dyn:max function itself, except for the following: * <p> * <ul> * <li>the context node is the node whose value is being calculated.</li> * <li>the context position is the position of the node within the node set passed as * the first argument to the dyn:max function, arranged in document order.</li> * <li>the context size is the number of nodes passed as the first argument to the * dyn:max function.</li> * </ul> * <p> * The dyn:max function returns the maximum of these values, calculated in exactly * the same way as for math:max. * <p> * If the expression string passed as the second argument is an invalid XPath * expression (including an empty string), this function returns NaN. * <p> * This function must take a second argument. To calculate the maximum of a set of * nodes based on their string values, you should use the math:max function. * * @param myContext The ExpressionContext passed by the extension processor * @param nl The node set * @param expr The expression string * * @return The maximum evaluation value */	TokenNameCOMMENT_JAVADOC	 The dyn:max function calculates the maximum value for the nodes passed as the first argument, where the value of each node is calculated dynamically using an XPath expression passed as a string as the second argument. <p> The expressions are evaluated relative to the nodes passed as the first argument. In other words, the value for each node is calculated by evaluating the XPath expression with all context information being the same as that for the call to the dyn:max function itself, except for the following: <p> <ul> <li>the context node is the node whose value is being calculated.</li> <li>the context position is the position of the node within the node set passed as the first argument to the dyn:max function, arranged in document order.</li> <li>the context size is the number of nodes passed as the first argument to the dyn:max function.</li> </ul> <p> The dyn:max function returns the maximum of these values, calculated in exactly the same way as for math:max. <p> If the expression string passed as the second argument is an invalid XPath expression (including an empty string), this function returns NaN. <p> This function must take a second argument. To calculate the maximum of a set of nodes based on their string values, you should use the math:max function. * @param myContext The ExpressionContext passed by the extension processor @param nl The node set @param expr The expression string * @return The maximum evaluation value 
public	TokenNamepublic	
static	TokenNamestatic	
double	TokenNamedouble	
max	TokenNameIdentifier	 max
(	TokenNameLPAREN	
ExpressionContext	TokenNameIdentifier	 Expression Context
myContext	TokenNameIdentifier	 my Context
,	TokenNameCOMMA	
NodeList	TokenNameIdentifier	 Node List
nl	TokenNameIdentifier	 nl
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
expr	TokenNameIdentifier	 expr
)	TokenNameRPAREN	
throws	TokenNamethrows	
SAXNotSupportedException	TokenNameIdentifier	 SAX Not Supported Exception
{	TokenNameLBRACE	
XPathContext	TokenNameIdentifier	 X Path Context
xctxt	TokenNameIdentifier	 xctxt
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
myContext	TokenNameIdentifier	 my Context
instanceof	TokenNameinstanceof	
XPathContext	TokenNameIdentifier	 X Path Context
.	TokenNameDOT	
XPathExpressionContext	TokenNameIdentifier	 X Path Expression Context
)	TokenNameRPAREN	
xctxt	TokenNameIdentifier	 xctxt
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XPathContext	TokenNameIdentifier	 X Path Context
.	TokenNameDOT	
XPathExpressionContext	TokenNameIdentifier	 X Path Expression Context
)	TokenNameRPAREN	
myContext	TokenNameIdentifier	 my Context
)	TokenNameRPAREN	
.	TokenNameDOT	
getXPathContext	TokenNameIdentifier	 get X Path Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
throw	TokenNamethrow	
new	TokenNamenew	
SAXNotSupportedException	TokenNameIdentifier	 SAX Not Supported Exception
(	TokenNameLPAREN	
XSLMessages	TokenNameIdentifier	 XSL Messages
.	TokenNameDOT	
createMessage	TokenNameIdentifier	 create Message
(	TokenNameLPAREN	
XSLTErrorResources	TokenNameIdentifier	 XSLT Error Resources
.	TokenNameDOT	
ER_INVALID_CONTEXT_PASSED	TokenNameIdentifier	 ER  INVALID  CONTEXT  PASSED
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
myContext	TokenNameIdentifier	 my Context
}	TokenNameRBRACE	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
expr	TokenNameIdentifier	 expr
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
expr	TokenNameIdentifier	 expr
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
Double	TokenNameIdentifier	 Double
.	TokenNameDOT	
NaN	TokenNameIdentifier	 Na N
;	TokenNameSEMICOLON	
NodeSetDTM	TokenNameIdentifier	 Node Set DTM
contextNodes	TokenNameIdentifier	 context Nodes
=	TokenNameEQUAL	
new	TokenNamenew	
NodeSetDTM	TokenNameIdentifier	 Node Set DTM
(	TokenNameLPAREN	
nl	TokenNameIdentifier	 nl
,	TokenNameCOMMA	
xctxt	TokenNameIdentifier	 xctxt
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
pushContextNodeList	TokenNameIdentifier	 push Context Node List
(	TokenNameLPAREN	
contextNodes	TokenNameIdentifier	 context Nodes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
maxValue	TokenNameIdentifier	 max Value
=	TokenNameEQUAL	
-	TokenNameMINUS	
Double	TokenNameIdentifier	 Double
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
contextNodes	TokenNameIdentifier	 context Nodes
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
contextNode	TokenNameIdentifier	 context Node
=	TokenNameEQUAL	
contextNodes	TokenNameIdentifier	 context Nodes
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
pushCurrentNode	TokenNameIdentifier	 push Current Node
(	TokenNameLPAREN	
contextNode	TokenNameIdentifier	 context Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
XPath	TokenNameIdentifier	 X Path
dynamicXPath	TokenNameIdentifier	 dynamic X Path
=	TokenNameEQUAL	
new	TokenNamenew	
XPath	TokenNameIdentifier	 X Path
(	TokenNameLPAREN	
expr	TokenNameIdentifier	 expr
,	TokenNameCOMMA	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
getSAXLocator	TokenNameIdentifier	 get SAX Locator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
getNamespaceContext	TokenNameIdentifier	 get Namespace Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
XPath	TokenNameIdentifier	 X Path
.	TokenNameDOT	
SELECT	TokenNameIdentifier	 SELECT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
dynamicXPath	TokenNameIdentifier	 dynamic X Path
.	TokenNameDOT	
execute	TokenNameIdentifier	 execute
(	TokenNameLPAREN	
xctxt	TokenNameIdentifier	 xctxt
,	TokenNameCOMMA	
contextNode	TokenNameIdentifier	 context Node
,	TokenNameCOMMA	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
getNamespaceContext	TokenNameIdentifier	 get Namespace Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
num	TokenNameIdentifier	 num
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
TransformerException	TokenNameIdentifier	 Transformer Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
popCurrentNode	TokenNameIdentifier	 pop Current Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
popContextNodeList	TokenNameIdentifier	 pop Context Node List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
Double	TokenNameIdentifier	 Double
.	TokenNameDOT	
NaN	TokenNameIdentifier	 Na N
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
popCurrentNode	TokenNameIdentifier	 pop Current Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
>	TokenNameGREATER	
maxValue	TokenNameIdentifier	 max Value
)	TokenNameRPAREN	
maxValue	TokenNameIdentifier	 max Value
=	TokenNameEQUAL	
result	TokenNameIdentifier	 result
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
popContextNodeList	TokenNameIdentifier	 pop Context Node List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
maxValue	TokenNameIdentifier	 max Value
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The dyn:min function calculates the minimum value for the nodes passed as the * first argument, where the value of each node is calculated dynamically using * an XPath expression passed as a string as the second argument. * <p> * The expressions are evaluated relative to the nodes passed as the first argument. * In other words, the value for each node is calculated by evaluating the XPath * expression with all context information being the same as that for the call to * the dyn:min function itself, except for the following: * <p> * <ul> * <li>the context node is the node whose value is being calculated.</li> * <li>the context position is the position of the node within the node set passed * as the first argument to the dyn:min function, arranged in document order.</li> * <li>the context size is the number of nodes passed as the first argument to the * dyn:min function.</li> * </ul> * <p> * The dyn:min function returns the minimum of these values, calculated in exactly * the same way as for math:min. * <p> * If the expression string passed as the second argument is an invalid XPath expression * (including an empty string), this function returns NaN. * <p> * This function must take a second argument. To calculate the minimum of a set of * nodes based on their string values, you should use the math:min function. * * @param myContext The ExpressionContext passed by the extension processor * @param nl The node set * @param expr The expression string * * @return The minimum evaluation value */	TokenNameCOMMENT_JAVADOC	 The dyn:min function calculates the minimum value for the nodes passed as the first argument, where the value of each node is calculated dynamically using an XPath expression passed as a string as the second argument. <p> The expressions are evaluated relative to the nodes passed as the first argument. In other words, the value for each node is calculated by evaluating the XPath expression with all context information being the same as that for the call to the dyn:min function itself, except for the following: <p> <ul> <li>the context node is the node whose value is being calculated.</li> <li>the context position is the position of the node within the node set passed as the first argument to the dyn:min function, arranged in document order.</li> <li>the context size is the number of nodes passed as the first argument to the dyn:min function.</li> </ul> <p> The dyn:min function returns the minimum of these values, calculated in exactly the same way as for math:min. <p> If the expression string passed as the second argument is an invalid XPath expression (including an empty string), this function returns NaN. <p> This function must take a second argument. To calculate the minimum of a set of nodes based on their string values, you should use the math:min function. * @param myContext The ExpressionContext passed by the extension processor @param nl The node set @param expr The expression string * @return The minimum evaluation value 
public	TokenNamepublic	
static	TokenNamestatic	
double	TokenNamedouble	
min	TokenNameIdentifier	 min
(	TokenNameLPAREN	
ExpressionContext	TokenNameIdentifier	 Expression Context
myContext	TokenNameIdentifier	 my Context
,	TokenNameCOMMA	
NodeList	TokenNameIdentifier	 Node List
nl	TokenNameIdentifier	 nl
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
expr	TokenNameIdentifier	 expr
)	TokenNameRPAREN	
throws	TokenNamethrows	
SAXNotSupportedException	TokenNameIdentifier	 SAX Not Supported Exception
{	TokenNameLBRACE	
XPathContext	TokenNameIdentifier	 X Path Context
xctxt	TokenNameIdentifier	 xctxt
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
myContext	TokenNameIdentifier	 my Context
instanceof	TokenNameinstanceof	
XPathContext	TokenNameIdentifier	 X Path Context
.	TokenNameDOT	
XPathExpressionContext	TokenNameIdentifier	 X Path Expression Context
)	TokenNameRPAREN	
xctxt	TokenNameIdentifier	 xctxt
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XPathContext	TokenNameIdentifier	 X Path Context
.	TokenNameDOT	
XPathExpressionContext	TokenNameIdentifier	 X Path Expression Context
)	TokenNameRPAREN	
myContext	TokenNameIdentifier	 my Context
)	TokenNameRPAREN	
.	TokenNameDOT	
getXPathContext	TokenNameIdentifier	 get X Path Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
throw	TokenNamethrow	
new	TokenNamenew	
SAXNotSupportedException	TokenNameIdentifier	 SAX Not Supported Exception
(	TokenNameLPAREN	
XSLMessages	TokenNameIdentifier	 XSL Messages
.	TokenNameDOT	
createMessage	TokenNameIdentifier	 create Message
(	TokenNameLPAREN	
XSLTErrorResources	TokenNameIdentifier	 XSLT Error Resources
.	TokenNameDOT	
ER_INVALID_CONTEXT_PASSED	TokenNameIdentifier	 ER  INVALID  CONTEXT  PASSED
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
myContext	TokenNameIdentifier	 my Context
}	TokenNameRBRACE	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
expr	TokenNameIdentifier	 expr
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
expr	TokenNameIdentifier	 expr
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
Double	TokenNameIdentifier	 Double
.	TokenNameDOT	
NaN	TokenNameIdentifier	 Na N
;	TokenNameSEMICOLON	
NodeSetDTM	TokenNameIdentifier	 Node Set DTM
contextNodes	TokenNameIdentifier	 context Nodes
=	TokenNameEQUAL	
new	TokenNamenew	
NodeSetDTM	TokenNameIdentifier	 Node Set DTM
(	TokenNameLPAREN	
nl	TokenNameIdentifier	 nl
,	TokenNameCOMMA	
xctxt	TokenNameIdentifier	 xctxt
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
pushContextNodeList	TokenNameIdentifier	 push Context Node List
(	TokenNameLPAREN	
contextNodes	TokenNameIdentifier	 context Nodes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
minValue	TokenNameIdentifier	 min Value
=	TokenNameEQUAL	
Double	TokenNameIdentifier	 Double
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
nl	TokenNameIdentifier	 nl
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
contextNode	TokenNameIdentifier	 context Node
=	TokenNameEQUAL	
contextNodes	TokenNameIdentifier	 context Nodes
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
pushCurrentNode	TokenNameIdentifier	 push Current Node
(	TokenNameLPAREN	
contextNode	TokenNameIdentifier	 context Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
XPath	TokenNameIdentifier	 X Path
dynamicXPath	TokenNameIdentifier	 dynamic X Path
=	TokenNameEQUAL	
new	TokenNamenew	
XPath	TokenNameIdentifier	 X Path
(	TokenNameLPAREN	
expr	TokenNameIdentifier	 expr
,	TokenNameCOMMA	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
getSAXLocator	TokenNameIdentifier	 get SAX Locator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
getNamespaceContext	TokenNameIdentifier	 get Namespace Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
XPath	TokenNameIdentifier	 X Path
.	TokenNameDOT	
SELECT	TokenNameIdentifier	 SELECT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
dynamicXPath	TokenNameIdentifier	 dynamic X Path
.	TokenNameDOT	
execute	TokenNameIdentifier	 execute
(	TokenNameLPAREN	
xctxt	TokenNameIdentifier	 xctxt
,	TokenNameCOMMA	
contextNode	TokenNameIdentifier	 context Node
,	TokenNameCOMMA	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
getNamespaceContext	TokenNameIdentifier	 get Namespace Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
num	TokenNameIdentifier	 num
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
TransformerException	TokenNameIdentifier	 Transformer Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
popCurrentNode	TokenNameIdentifier	 pop Current Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
popContextNodeList	TokenNameIdentifier	 pop Context Node List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
Double	TokenNameIdentifier	 Double
.	TokenNameDOT	
NaN	TokenNameIdentifier	 Na N
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
popCurrentNode	TokenNameIdentifier	 pop Current Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
<	TokenNameLESS	
minValue	TokenNameIdentifier	 min Value
)	TokenNameRPAREN	
minValue	TokenNameIdentifier	 min Value
=	TokenNameEQUAL	
result	TokenNameIdentifier	 result
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
popContextNodeList	TokenNameIdentifier	 pop Context Node List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
minValue	TokenNameIdentifier	 min Value
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The dyn:sum function calculates the sum for the nodes passed as the first argument, * where the value of each node is calculated dynamically using an XPath expression * passed as a string as the second argument. * <p> * The expressions are evaluated relative to the nodes passed as the first argument. * In other words, the value for each node is calculated by evaluating the XPath * expression with all context information being the same as that for the call to * the dyn:sum function itself, except for the following: * <p> * <ul> * <li>the context node is the node whose value is being calculated.</li> * <li>the context position is the position of the node within the node set passed as * the first argument to the dyn:sum function, arranged in document order.</li> * <li>the context size is the number of nodes passed as the first argument to the * dyn:sum function.</li> * </ul> * <p> * The dyn:sum function returns the sumimum of these values, calculated in exactly * the same way as for sum. * <p> * If the expression string passed as the second argument is an invalid XPath * expression (including an empty string), this function returns NaN. * <p> * This function must take a second argument. To calculate the sumimum of a set of * nodes based on their string values, you should use the sum function. * * @param myContext The ExpressionContext passed by the extension processor * @param nl The node set * @param expr The expression string * * @return The sum of the evaluation value on each node */	TokenNameCOMMENT_JAVADOC	 The dyn:sum function calculates the sum for the nodes passed as the first argument, where the value of each node is calculated dynamically using an XPath expression passed as a string as the second argument. <p> The expressions are evaluated relative to the nodes passed as the first argument. In other words, the value for each node is calculated by evaluating the XPath expression with all context information being the same as that for the call to the dyn:sum function itself, except for the following: <p> <ul> <li>the context node is the node whose value is being calculated.</li> <li>the context position is the position of the node within the node set passed as the first argument to the dyn:sum function, arranged in document order.</li> <li>the context size is the number of nodes passed as the first argument to the dyn:sum function.</li> </ul> <p> The dyn:sum function returns the sumimum of these values, calculated in exactly the same way as for sum. <p> If the expression string passed as the second argument is an invalid XPath expression (including an empty string), this function returns NaN. <p> This function must take a second argument. To calculate the sumimum of a set of nodes based on their string values, you should use the sum function. * @param myContext The ExpressionContext passed by the extension processor @param nl The node set @param expr The expression string * @return The sum of the evaluation value on each node 
public	TokenNamepublic	
static	TokenNamestatic	
double	TokenNamedouble	
sum	TokenNameIdentifier	 sum
(	TokenNameLPAREN	
ExpressionContext	TokenNameIdentifier	 Expression Context
myContext	TokenNameIdentifier	 my Context
,	TokenNameCOMMA	
NodeList	TokenNameIdentifier	 Node List
nl	TokenNameIdentifier	 nl
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
expr	TokenNameIdentifier	 expr
)	TokenNameRPAREN	
throws	TokenNamethrows	
SAXNotSupportedException	TokenNameIdentifier	 SAX Not Supported Exception
{	TokenNameLBRACE	
XPathContext	TokenNameIdentifier	 X Path Context
xctxt	TokenNameIdentifier	 xctxt
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
myContext	TokenNameIdentifier	 my Context
instanceof	TokenNameinstanceof	
XPathContext	TokenNameIdentifier	 X Path Context
.	TokenNameDOT	
XPathExpressionContext	TokenNameIdentifier	 X Path Expression Context
)	TokenNameRPAREN	
xctxt	TokenNameIdentifier	 xctxt
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XPathContext	TokenNameIdentifier	 X Path Context
.	TokenNameDOT	
XPathExpressionContext	TokenNameIdentifier	 X Path Expression Context
)	TokenNameRPAREN	
myContext	TokenNameIdentifier	 my Context
)	TokenNameRPAREN	
.	TokenNameDOT	
getXPathContext	TokenNameIdentifier	 get X Path Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
throw	TokenNamethrow	
new	TokenNamenew	
SAXNotSupportedException	TokenNameIdentifier	 SAX Not Supported Exception
(	TokenNameLPAREN	
XSLMessages	TokenNameIdentifier	 XSL Messages
.	TokenNameDOT	
createMessage	TokenNameIdentifier	 create Message
(	TokenNameLPAREN	
XSLTErrorResources	TokenNameIdentifier	 XSLT Error Resources
.	TokenNameDOT	
ER_INVALID_CONTEXT_PASSED	TokenNameIdentifier	 ER  INVALID  CONTEXT  PASSED
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
myContext	TokenNameIdentifier	 my Context
}	TokenNameRBRACE	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
expr	TokenNameIdentifier	 expr
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
expr	TokenNameIdentifier	 expr
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
Double	TokenNameIdentifier	 Double
.	TokenNameDOT	
NaN	TokenNameIdentifier	 Na N
;	TokenNameSEMICOLON	
NodeSetDTM	TokenNameIdentifier	 Node Set DTM
contextNodes	TokenNameIdentifier	 context Nodes
=	TokenNameEQUAL	
new	TokenNamenew	
NodeSetDTM	TokenNameIdentifier	 Node Set DTM
(	TokenNameLPAREN	
nl	TokenNameIdentifier	 nl
,	TokenNameCOMMA	
xctxt	TokenNameIdentifier	 xctxt
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
pushContextNodeList	TokenNameIdentifier	 push Context Node List
(	TokenNameLPAREN	
contextNodes	TokenNameIdentifier	 context Nodes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
sum	TokenNameIdentifier	 sum
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
nl	TokenNameIdentifier	 nl
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
contextNode	TokenNameIdentifier	 context Node
=	TokenNameEQUAL	
contextNodes	TokenNameIdentifier	 context Nodes
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
pushCurrentNode	TokenNameIdentifier	 push Current Node
(	TokenNameLPAREN	
contextNode	TokenNameIdentifier	 context Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
XPath	TokenNameIdentifier	 X Path
dynamicXPath	TokenNameIdentifier	 dynamic X Path
=	TokenNameEQUAL	
new	TokenNamenew	
XPath	TokenNameIdentifier	 X Path
(	TokenNameLPAREN	
expr	TokenNameIdentifier	 expr
,	TokenNameCOMMA	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
getSAXLocator	TokenNameIdentifier	 get SAX Locator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
getNamespaceContext	TokenNameIdentifier	 get Namespace Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
XPath	TokenNameIdentifier	 X Path
.	TokenNameDOT	
SELECT	TokenNameIdentifier	 SELECT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
dynamicXPath	TokenNameIdentifier	 dynamic X Path
.	TokenNameDOT	
execute	TokenNameIdentifier	 execute
(	TokenNameLPAREN	
xctxt	TokenNameIdentifier	 xctxt
,	TokenNameCOMMA	
contextNode	TokenNameIdentifier	 context Node
,	TokenNameCOMMA	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
getNamespaceContext	TokenNameIdentifier	 get Namespace Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
num	TokenNameIdentifier	 num
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
TransformerException	TokenNameIdentifier	 Transformer Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
popCurrentNode	TokenNameIdentifier	 pop Current Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
popContextNodeList	TokenNameIdentifier	 pop Context Node List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
Double	TokenNameIdentifier	 Double
.	TokenNameDOT	
NaN	TokenNameIdentifier	 Na N
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
popCurrentNode	TokenNameIdentifier	 pop Current Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sum	TokenNameIdentifier	 sum
=	TokenNameEQUAL	
sum	TokenNameIdentifier	 sum
+	TokenNamePLUS	
result	TokenNameIdentifier	 result
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
popContextNodeList	TokenNameIdentifier	 pop Context Node List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
sum	TokenNameIdentifier	 sum
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The dyn:map function evaluates the expression passed as the second argument for * each of the nodes passed as the first argument, and returns a node set of those values. * <p> * The expressions are evaluated relative to the nodes passed as the first argument. * In other words, the value for each node is calculated by evaluating the XPath * expression with all context information being the same as that for the call to * the dyn:map function itself, except for the following: * <p> * <ul> * <li>The context node is the node whose value is being calculated.</li> * <li>the context position is the position of the node within the node set passed * as the first argument to the dyn:map function, arranged in document order.</li> * <li>the context size is the number of nodes passed as the first argument to the * dyn:map function.</li> * </ul> * <p> * If the expression string passed as the second argument is an invalid XPath * expression (including an empty string), this function returns an empty node set. * <p> * If the XPath expression evaluates as a node set, the dyn:map function returns * the union of the node sets returned by evaluating the expression for each of the * nodes in the first argument. Note that this may mean that the node set resulting * from the call to the dyn:map function contains a different number of nodes from * the number in the node set passed as the first argument to the function. * <p> * If the XPath expression evaluates as a number, the dyn:map function returns a * node set containing one exsl:number element (namespace http://exslt.org/common) * for each node in the node set passed as the first argument to the dyn:map function, * in document order. The string value of each exsl:number element is the same as * the result of converting the number resulting from evaluating the expression to * a string as with the number function, with the exception that Infinity results * in an exsl:number holding the highest number the implementation can store, and * -Infinity results in an exsl:number holding the lowest number the implementation * can store. * <p> * If the XPath expression evaluates as a boolean, the dyn:map function returns a * node set containing one exsl:boolean element (namespace http://exslt.org/common) * for each node in the node set passed as the first argument to the dyn:map function, * in document order. The string value of each exsl:boolean element is 'true' if the * expression evaluates as true for the node, and '' if the expression evaluates as * false. * <p> * Otherwise, the dyn:map function returns a node set containing one exsl:string * element (namespace http://exslt.org/common) for each node in the node set passed * as the first argument to the dyn:map function, in document order. The string * value of each exsl:string element is the same as the result of converting the * result of evaluating the expression for the relevant node to a string as with * the string function. * * @param myContext The ExpressionContext passed by the extension processor * @param nl The node set * @param expr The expression string * * @return The node set after evaluation */	TokenNameCOMMENT_JAVADOC	 The dyn:map function evaluates the expression passed as the second argument for each of the nodes passed as the first argument, and returns a node set of those values. <p> The expressions are evaluated relative to the nodes passed as the first argument. In other words, the value for each node is calculated by evaluating the XPath expression with all context information being the same as that for the call to the dyn:map function itself, except for the following: <p> <ul> <li>The context node is the node whose value is being calculated.</li> <li>the context position is the position of the node within the node set passed as the first argument to the dyn:map function, arranged in document order.</li> <li>the context size is the number of nodes passed as the first argument to the dyn:map function.</li> </ul> <p> If the expression string passed as the second argument is an invalid XPath expression (including an empty string), this function returns an empty node set. <p> If the XPath expression evaluates as a node set, the dyn:map function returns the union of the node sets returned by evaluating the expression for each of the nodes in the first argument. Note that this may mean that the node set resulting from the call to the dyn:map function contains a different number of nodes from the number in the node set passed as the first argument to the function. <p> If the XPath expression evaluates as a number, the dyn:map function returns a node set containing one exsl:number element (namespace http://exslt.org/common) for each node in the node set passed as the first argument to the dyn:map function, in document order. The string value of each exsl:number element is the same as the result of converting the number resulting from evaluating the expression to a string as with the number function, with the exception that Infinity results in an exsl:number holding the highest number the implementation can store, and -Infinity results in an exsl:number holding the lowest number the implementation can store. <p> If the XPath expression evaluates as a boolean, the dyn:map function returns a node set containing one exsl:boolean element (namespace http://exslt.org/common) for each node in the node set passed as the first argument to the dyn:map function, in document order. The string value of each exsl:boolean element is 'true' if the expression evaluates as true for the node, and '' if the expression evaluates as false. <p> Otherwise, the dyn:map function returns a node set containing one exsl:string element (namespace http://exslt.org/common) for each node in the node set passed as the first argument to the dyn:map function, in document order. The string value of each exsl:string element is the same as the result of converting the result of evaluating the expression for the relevant node to a string as with the string function. * @param myContext The ExpressionContext passed by the extension processor @param nl The node set @param expr The expression string * @return The node set after evaluation 
public	TokenNamepublic	
static	TokenNamestatic	
NodeList	TokenNameIdentifier	 Node List
map	TokenNameIdentifier	 map
(	TokenNameLPAREN	
ExpressionContext	TokenNameIdentifier	 Expression Context
myContext	TokenNameIdentifier	 my Context
,	TokenNameCOMMA	
NodeList	TokenNameIdentifier	 Node List
nl	TokenNameIdentifier	 nl
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
expr	TokenNameIdentifier	 expr
)	TokenNameRPAREN	
throws	TokenNamethrows	
SAXNotSupportedException	TokenNameIdentifier	 SAX Not Supported Exception
{	TokenNameLBRACE	
XPathContext	TokenNameIdentifier	 X Path Context
xctxt	TokenNameIdentifier	 xctxt
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
Document	TokenNameIdentifier	 Document
lDoc	TokenNameIdentifier	 l Doc
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
myContext	TokenNameIdentifier	 my Context
instanceof	TokenNameinstanceof	
XPathContext	TokenNameIdentifier	 X Path Context
.	TokenNameDOT	
XPathExpressionContext	TokenNameIdentifier	 X Path Expression Context
)	TokenNameRPAREN	
xctxt	TokenNameIdentifier	 xctxt
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XPathContext	TokenNameIdentifier	 X Path Context
.	TokenNameDOT	
XPathExpressionContext	TokenNameIdentifier	 X Path Expression Context
)	TokenNameRPAREN	
myContext	TokenNameIdentifier	 my Context
)	TokenNameRPAREN	
.	TokenNameDOT	
getXPathContext	TokenNameIdentifier	 get X Path Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
throw	TokenNamethrow	
new	TokenNamenew	
SAXNotSupportedException	TokenNameIdentifier	 SAX Not Supported Exception
(	TokenNameLPAREN	
XSLMessages	TokenNameIdentifier	 XSL Messages
.	TokenNameDOT	
createMessage	TokenNameIdentifier	 create Message
(	TokenNameLPAREN	
XSLTErrorResources	TokenNameIdentifier	 XSLT Error Resources
.	TokenNameDOT	
ER_INVALID_CONTEXT_PASSED	TokenNameIdentifier	 ER  INVALID  CONTEXT  PASSED
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
myContext	TokenNameIdentifier	 my Context
}	TokenNameRBRACE	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
expr	TokenNameIdentifier	 expr
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
expr	TokenNameIdentifier	 expr
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
new	TokenNamenew	
NodeSet	TokenNameIdentifier	 Node Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
NodeSetDTM	TokenNameIdentifier	 Node Set DTM
contextNodes	TokenNameIdentifier	 context Nodes
=	TokenNameEQUAL	
new	TokenNamenew	
NodeSetDTM	TokenNameIdentifier	 Node Set DTM
(	TokenNameLPAREN	
nl	TokenNameIdentifier	 nl
,	TokenNameCOMMA	
xctxt	TokenNameIdentifier	 xctxt
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
pushContextNodeList	TokenNameIdentifier	 push Context Node List
(	TokenNameLPAREN	
contextNodes	TokenNameIdentifier	 context Nodes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
NodeSet	TokenNameIdentifier	 Node Set
resultSet	TokenNameIdentifier	 result Set
=	TokenNameEQUAL	
new	TokenNamenew	
NodeSet	TokenNameIdentifier	 Node Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
resultSet	TokenNameIdentifier	 result Set
.	TokenNameDOT	
setShouldCacheNodes	TokenNameIdentifier	 set Should Cache Nodes
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
nl	TokenNameIdentifier	 nl
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
contextNode	TokenNameIdentifier	 context Node
=	TokenNameEQUAL	
contextNodes	TokenNameIdentifier	 context Nodes
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
pushCurrentNode	TokenNameIdentifier	 push Current Node
(	TokenNameLPAREN	
contextNode	TokenNameIdentifier	 context Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XObject	TokenNameIdentifier	 X Object
object	TokenNameIdentifier	 object
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
XPath	TokenNameIdentifier	 X Path
dynamicXPath	TokenNameIdentifier	 dynamic X Path
=	TokenNameEQUAL	
new	TokenNamenew	
XPath	TokenNameIdentifier	 X Path
(	TokenNameLPAREN	
expr	TokenNameIdentifier	 expr
,	TokenNameCOMMA	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
getSAXLocator	TokenNameIdentifier	 get SAX Locator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
getNamespaceContext	TokenNameIdentifier	 get Namespace Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
XPath	TokenNameIdentifier	 X Path
.	TokenNameDOT	
SELECT	TokenNameIdentifier	 SELECT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
object	TokenNameIdentifier	 object
=	TokenNameEQUAL	
dynamicXPath	TokenNameIdentifier	 dynamic X Path
.	TokenNameDOT	
execute	TokenNameIdentifier	 execute
(	TokenNameLPAREN	
xctxt	TokenNameIdentifier	 xctxt
,	TokenNameCOMMA	
contextNode	TokenNameIdentifier	 context Node
,	TokenNameCOMMA	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
getNamespaceContext	TokenNameIdentifier	 get Namespace Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
object	TokenNameIdentifier	 object
instanceof	TokenNameinstanceof	
XNodeSet	TokenNameIdentifier	 X Node Set
)	TokenNameRPAREN	
{	TokenNameLBRACE	
NodeList	TokenNameIdentifier	 Node List
nodelist	TokenNameIdentifier	 nodelist
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
nodelist	TokenNameIdentifier	 nodelist
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XNodeSet	TokenNameIdentifier	 X Node Set
)	TokenNameRPAREN	
object	TokenNameIdentifier	 object
)	TokenNameRPAREN	
.	TokenNameDOT	
nodelist	TokenNameIdentifier	 nodelist
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
k	TokenNameIdentifier	 k
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
<	TokenNameLESS	
nodelist	TokenNameIdentifier	 nodelist
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Node	TokenNameIdentifier	 Node
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
nodelist	TokenNameIdentifier	 nodelist
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
k	TokenNameIdentifier	 k
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
resultSet	TokenNameIdentifier	 result Set
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
)	TokenNameRPAREN	
resultSet	TokenNameIdentifier	 result Set
.	TokenNameDOT	
addNode	TokenNameIdentifier	 add Node
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
lDoc	TokenNameIdentifier	 l Doc
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DocumentBuilderFactory	TokenNameIdentifier	 Document Builder Factory
dbf	TokenNameIdentifier	 dbf
=	TokenNameEQUAL	
DocumentBuilderFactory	TokenNameIdentifier	 Document Builder Factory
.	TokenNameDOT	
newInstance	TokenNameIdentifier	 new Instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dbf	TokenNameIdentifier	 dbf
.	TokenNameDOT	
setNamespaceAware	TokenNameIdentifier	 set Namespace Aware
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DocumentBuilder	TokenNameIdentifier	 Document Builder
db	TokenNameIdentifier	 db
=	TokenNameEQUAL	
dbf	TokenNameIdentifier	 dbf
.	TokenNameDOT	
newDocumentBuilder	TokenNameIdentifier	 new Document Builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
lDoc	TokenNameIdentifier	 l Doc
=	TokenNameEQUAL	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
newDocument	TokenNameIdentifier	 new Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Element	TokenNameIdentifier	 Element
element	TokenNameIdentifier	 element
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
object	TokenNameIdentifier	 object
instanceof	TokenNameinstanceof	
XNumber	TokenNameIdentifier	 X Number
)	TokenNameRPAREN	
element	TokenNameIdentifier	 element
=	TokenNameEQUAL	
lDoc	TokenNameIdentifier	 l Doc
.	TokenNameDOT	
createElementNS	TokenNameIdentifier	 create Element NS
(	TokenNameLPAREN	
EXSL_URI	TokenNameIdentifier	 EXSL  URI
,	TokenNameCOMMA	
"exsl:number"	TokenNameStringLiteral	exsl:number
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
object	TokenNameIdentifier	 object
instanceof	TokenNameinstanceof	
XBoolean	TokenNameIdentifier	 X Boolean
)	TokenNameRPAREN	
element	TokenNameIdentifier	 element
=	TokenNameEQUAL	
lDoc	TokenNameIdentifier	 l Doc
.	TokenNameDOT	
createElementNS	TokenNameIdentifier	 create Element NS
(	TokenNameLPAREN	
EXSL_URI	TokenNameIdentifier	 EXSL  URI
,	TokenNameCOMMA	
"exsl:boolean"	TokenNameStringLiteral	exsl:boolean
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
element	TokenNameIdentifier	 element
=	TokenNameEQUAL	
lDoc	TokenNameIdentifier	 l Doc
.	TokenNameDOT	
createElementNS	TokenNameIdentifier	 create Element NS
(	TokenNameLPAREN	
EXSL_URI	TokenNameIdentifier	 EXSL  URI
,	TokenNameCOMMA	
"exsl:string"	TokenNameStringLiteral	exsl:string
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Text	TokenNameIdentifier	 Text
textNode	TokenNameIdentifier	 text Node
=	TokenNameEQUAL	
lDoc	TokenNameIdentifier	 l Doc
.	TokenNameDOT	
createTextNode	TokenNameIdentifier	 create Text Node
(	TokenNameLPAREN	
object	TokenNameIdentifier	 object
.	TokenNameDOT	
str	TokenNameIdentifier	 str
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
appendChild	TokenNameIdentifier	 append Child
(	TokenNameLPAREN	
textNode	TokenNameIdentifier	 text Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
resultSet	TokenNameIdentifier	 result Set
.	TokenNameDOT	
addNode	TokenNameIdentifier	 add Node
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
popCurrentNode	TokenNameIdentifier	 pop Current Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
popContextNodeList	TokenNameIdentifier	 pop Context Node List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
NodeSet	TokenNameIdentifier	 Node Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
popCurrentNode	TokenNameIdentifier	 pop Current Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
popContextNodeList	TokenNameIdentifier	 pop Context Node List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
resultSet	TokenNameIdentifier	 result Set
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The dyn:evaluate function evaluates a string as an XPath expression and returns * the resulting value, which might be a boolean, number, string, node set, result * tree fragment or external object. The sole argument is the string to be evaluated. * <p> * If the expression string passed as the second argument is an invalid XPath * expression (including an empty string), this function returns an empty node set. * <p> * You should only use this function if the expression must be constructed dynamically, * otherwise it is much more efficient to use the expression literally. * * @param myContext The ExpressionContext passed by the extension processor * @param xpathExpr The XPath expression string * * @return The evaluation result */	TokenNameCOMMENT_JAVADOC	 The dyn:evaluate function evaluates a string as an XPath expression and returns the resulting value, which might be a boolean, number, string, node set, result tree fragment or external object. The sole argument is the string to be evaluated. <p> If the expression string passed as the second argument is an invalid XPath expression (including an empty string), this function returns an empty node set. <p> You should only use this function if the expression must be constructed dynamically, otherwise it is much more efficient to use the expression literally. * @param myContext The ExpressionContext passed by the extension processor @param xpathExpr The XPath expression string * @return The evaluation result 
public	TokenNamepublic	
static	TokenNamestatic	
XObject	TokenNameIdentifier	 X Object
evaluate	TokenNameIdentifier	 evaluate
(	TokenNameLPAREN	
ExpressionContext	TokenNameIdentifier	 Expression Context
myContext	TokenNameIdentifier	 my Context
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
xpathExpr	TokenNameIdentifier	 xpath Expr
)	TokenNameRPAREN	
throws	TokenNamethrows	
SAXNotSupportedException	TokenNameIdentifier	 SAX Not Supported Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
myContext	TokenNameIdentifier	 my Context
instanceof	TokenNameinstanceof	
XPathContext	TokenNameIdentifier	 X Path Context
.	TokenNameDOT	
XPathExpressionContext	TokenNameIdentifier	 X Path Expression Context
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XPathContext	TokenNameIdentifier	 X Path Context
xctxt	TokenNameIdentifier	 xctxt
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
xctxt	TokenNameIdentifier	 xctxt
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XPathContext	TokenNameIdentifier	 X Path Context
.	TokenNameDOT	
XPathExpressionContext	TokenNameIdentifier	 X Path Expression Context
)	TokenNameRPAREN	
myContext	TokenNameIdentifier	 my Context
)	TokenNameRPAREN	
.	TokenNameDOT	
getXPathContext	TokenNameIdentifier	 get X Path Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XPath	TokenNameIdentifier	 X Path
dynamicXPath	TokenNameIdentifier	 dynamic X Path
=	TokenNameEQUAL	
new	TokenNamenew	
XPath	TokenNameIdentifier	 X Path
(	TokenNameLPAREN	
xpathExpr	TokenNameIdentifier	 xpath Expr
,	TokenNameCOMMA	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
getSAXLocator	TokenNameIdentifier	 get SAX Locator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
getNamespaceContext	TokenNameIdentifier	 get Namespace Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
XPath	TokenNameIdentifier	 X Path
.	TokenNameDOT	
SELECT	TokenNameIdentifier	 SELECT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
dynamicXPath	TokenNameIdentifier	 dynamic X Path
.	TokenNameDOT	
execute	TokenNameIdentifier	 execute
(	TokenNameLPAREN	
xctxt	TokenNameIdentifier	 xctxt
,	TokenNameCOMMA	
myContext	TokenNameIdentifier	 my Context
.	TokenNameDOT	
getContextNode	TokenNameIdentifier	 get Context Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
getNamespaceContext	TokenNameIdentifier	 get Namespace Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
TransformerException	TokenNameIdentifier	 Transformer Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
XNodeSet	TokenNameIdentifier	 X Node Set
(	TokenNameLPAREN	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
getDTMManager	TokenNameIdentifier	 get DTM Manager
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
throw	TokenNamethrow	
new	TokenNamenew	
SAXNotSupportedException	TokenNameIdentifier	 SAX Not Supported Exception
(	TokenNameLPAREN	
XSLMessages	TokenNameIdentifier	 XSL Messages
.	TokenNameDOT	
createMessage	TokenNameIdentifier	 create Message
(	TokenNameLPAREN	
XSLTErrorResources	TokenNameIdentifier	 XSLT Error Resources
.	TokenNameDOT	
ER_INVALID_CONTEXT_PASSED	TokenNameIdentifier	 ER  INVALID  CONTEXT  PASSED
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
myContext	TokenNameIdentifier	 my Context
}	TokenNameRBRACE	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//"Invalid context passed to evaluate " 	TokenNameCOMMENT_LINE	"Invalid context passed to evaluate " 
}	TokenNameRBRACE	
/** * The dyn:closure function creates a node set resulting from transitive closure of * evaluating the expression passed as the second argument on each of the nodes passed * as the first argument, then on the node set resulting from that and so on until no * more nodes are found. For example: * <pre> * dyn:closure(., '*') * </pre> * returns all the descendant elements of the node (its element children, their * children, their children's children and so on). * <p> * The expression is thus evaluated several times, each with a different node set * acting as the context of the expression. The first time the expression is * evaluated, the context node set is the first argument passed to the dyn:closure * function. In other words, the node set for each node is calculated by evaluating * the XPath expression with all context information being the same as that for * the call to the dyn:closure function itself, except for the following: * <p> * <ul> * <li>the context node is the node whose value is being calculated.</li> * <li>the context position is the position of the node within the node set passed * as the first argument to the dyn:closure function, arranged in document order.</li> * <li>the context size is the number of nodes passed as the first argument to the * dyn:closure function.</li> * <li>the current node is the node whose value is being calculated.</li> * </ul> * <p> * The result for a particular iteration is the union of the node sets resulting * from evaluting the expression for each of the nodes in the source node set for * that iteration. This result is then used as the source node set for the next * iteration, and so on. The result of the function as a whole is the union of * the node sets generated by each iteration. * <p> * If the expression string passed as the second argument is an invalid XPath * expression (including an empty string) or an expression that does not return a * node set, this function returns an empty node set. * * @param myContext The ExpressionContext passed by the extension processor * @param nl The node set * @param expr The expression string * * @return The node set after evaluation */	TokenNameCOMMENT_JAVADOC	 The dyn:closure function creates a node set resulting from transitive closure of evaluating the expression passed as the second argument on each of the nodes passed as the first argument, then on the node set resulting from that and so on until no more nodes are found. For example: <pre> dyn:closure(., '*') </pre> returns all the descendant elements of the node (its element children, their children, their children's children and so on). <p> The expression is thus evaluated several times, each with a different node set acting as the context of the expression. The first time the expression is evaluated, the context node set is the first argument passed to the dyn:closure function. In other words, the node set for each node is calculated by evaluating the XPath expression with all context information being the same as that for the call to the dyn:closure function itself, except for the following: <p> <ul> <li>the context node is the node whose value is being calculated.</li> <li>the context position is the position of the node within the node set passed as the first argument to the dyn:closure function, arranged in document order.</li> <li>the context size is the number of nodes passed as the first argument to the dyn:closure function.</li> <li>the current node is the node whose value is being calculated.</li> </ul> <p> The result for a particular iteration is the union of the node sets resulting from evaluting the expression for each of the nodes in the source node set for that iteration. This result is then used as the source node set for the next iteration, and so on. The result of the function as a whole is the union of the node sets generated by each iteration. <p> If the expression string passed as the second argument is an invalid XPath expression (including an empty string) or an expression that does not return a node set, this function returns an empty node set. * @param myContext The ExpressionContext passed by the extension processor @param nl The node set @param expr The expression string * @return The node set after evaluation 
public	TokenNamepublic	
static	TokenNamestatic	
NodeList	TokenNameIdentifier	 Node List
closure	TokenNameIdentifier	 closure
(	TokenNameLPAREN	
ExpressionContext	TokenNameIdentifier	 Expression Context
myContext	TokenNameIdentifier	 my Context
,	TokenNameCOMMA	
NodeList	TokenNameIdentifier	 Node List
nl	TokenNameIdentifier	 nl
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
expr	TokenNameIdentifier	 expr
)	TokenNameRPAREN	
throws	TokenNamethrows	
SAXNotSupportedException	TokenNameIdentifier	 SAX Not Supported Exception
{	TokenNameLBRACE	
XPathContext	TokenNameIdentifier	 X Path Context
xctxt	TokenNameIdentifier	 xctxt
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
myContext	TokenNameIdentifier	 my Context
instanceof	TokenNameinstanceof	
XPathContext	TokenNameIdentifier	 X Path Context
.	TokenNameDOT	
XPathExpressionContext	TokenNameIdentifier	 X Path Expression Context
)	TokenNameRPAREN	
xctxt	TokenNameIdentifier	 xctxt
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XPathContext	TokenNameIdentifier	 X Path Context
.	TokenNameDOT	
XPathExpressionContext	TokenNameIdentifier	 X Path Expression Context
)	TokenNameRPAREN	
myContext	TokenNameIdentifier	 my Context
)	TokenNameRPAREN	
.	TokenNameDOT	
getXPathContext	TokenNameIdentifier	 get X Path Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
throw	TokenNamethrow	
new	TokenNamenew	
SAXNotSupportedException	TokenNameIdentifier	 SAX Not Supported Exception
(	TokenNameLPAREN	
XSLMessages	TokenNameIdentifier	 XSL Messages
.	TokenNameDOT	
createMessage	TokenNameIdentifier	 create Message
(	TokenNameLPAREN	
XSLTErrorResources	TokenNameIdentifier	 XSLT Error Resources
.	TokenNameDOT	
ER_INVALID_CONTEXT_PASSED	TokenNameIdentifier	 ER  INVALID  CONTEXT  PASSED
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
myContext	TokenNameIdentifier	 my Context
}	TokenNameRBRACE	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
expr	TokenNameIdentifier	 expr
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
expr	TokenNameIdentifier	 expr
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
new	TokenNamenew	
NodeSet	TokenNameIdentifier	 Node Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
NodeSet	TokenNameIdentifier	 Node Set
closureSet	TokenNameIdentifier	 closure Set
=	TokenNameEQUAL	
new	TokenNamenew	
NodeSet	TokenNameIdentifier	 Node Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
closureSet	TokenNameIdentifier	 closure Set
.	TokenNameDOT	
setShouldCacheNodes	TokenNameIdentifier	 set Should Cache Nodes
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
NodeList	TokenNameIdentifier	 Node List
iterationList	TokenNameIdentifier	 iteration List
=	TokenNameEQUAL	
nl	TokenNameIdentifier	 nl
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
NodeSet	TokenNameIdentifier	 Node Set
iterationSet	TokenNameIdentifier	 iteration Set
=	TokenNameEQUAL	
new	TokenNamenew	
NodeSet	TokenNameIdentifier	 Node Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
NodeSetDTM	TokenNameIdentifier	 Node Set DTM
contextNodes	TokenNameIdentifier	 context Nodes
=	TokenNameEQUAL	
new	TokenNamenew	
NodeSetDTM	TokenNameIdentifier	 Node Set DTM
(	TokenNameLPAREN	
iterationList	TokenNameIdentifier	 iteration List
,	TokenNameCOMMA	
xctxt	TokenNameIdentifier	 xctxt
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
pushContextNodeList	TokenNameIdentifier	 push Context Node List
(	TokenNameLPAREN	
contextNodes	TokenNameIdentifier	 context Nodes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
iterationList	TokenNameIdentifier	 iteration List
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
contextNode	TokenNameIdentifier	 context Node
=	TokenNameEQUAL	
contextNodes	TokenNameIdentifier	 context Nodes
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
pushCurrentNode	TokenNameIdentifier	 push Current Node
(	TokenNameLPAREN	
contextNode	TokenNameIdentifier	 context Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XObject	TokenNameIdentifier	 X Object
object	TokenNameIdentifier	 object
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
XPath	TokenNameIdentifier	 X Path
dynamicXPath	TokenNameIdentifier	 dynamic X Path
=	TokenNameEQUAL	
new	TokenNamenew	
XPath	TokenNameIdentifier	 X Path
(	TokenNameLPAREN	
expr	TokenNameIdentifier	 expr
,	TokenNameCOMMA	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
getSAXLocator	TokenNameIdentifier	 get SAX Locator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
getNamespaceContext	TokenNameIdentifier	 get Namespace Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
XPath	TokenNameIdentifier	 X Path
.	TokenNameDOT	
SELECT	TokenNameIdentifier	 SELECT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
object	TokenNameIdentifier	 object
=	TokenNameEQUAL	
dynamicXPath	TokenNameIdentifier	 dynamic X Path
.	TokenNameDOT	
execute	TokenNameIdentifier	 execute
(	TokenNameLPAREN	
xctxt	TokenNameIdentifier	 xctxt
,	TokenNameCOMMA	
contextNode	TokenNameIdentifier	 context Node
,	TokenNameCOMMA	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
getNamespaceContext	TokenNameIdentifier	 get Namespace Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
object	TokenNameIdentifier	 object
instanceof	TokenNameinstanceof	
XNodeSet	TokenNameIdentifier	 X Node Set
)	TokenNameRPAREN	
{	TokenNameLBRACE	
NodeList	TokenNameIdentifier	 Node List
nodelist	TokenNameIdentifier	 nodelist
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
nodelist	TokenNameIdentifier	 nodelist
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XNodeSet	TokenNameIdentifier	 X Node Set
)	TokenNameRPAREN	
object	TokenNameIdentifier	 object
)	TokenNameRPAREN	
.	TokenNameDOT	
nodelist	TokenNameIdentifier	 nodelist
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
k	TokenNameIdentifier	 k
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
<	TokenNameLESS	
nodelist	TokenNameIdentifier	 nodelist
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Node	TokenNameIdentifier	 Node
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
nodelist	TokenNameIdentifier	 nodelist
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
k	TokenNameIdentifier	 k
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
iterationSet	TokenNameIdentifier	 iteration Set
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
)	TokenNameRPAREN	
iterationSet	TokenNameIdentifier	 iteration Set
.	TokenNameDOT	
addNode	TokenNameIdentifier	 add Node
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
popCurrentNode	TokenNameIdentifier	 pop Current Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
popContextNodeList	TokenNameIdentifier	 pop Context Node List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
NodeSet	TokenNameIdentifier	 Node Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
TransformerException	TokenNameIdentifier	 Transformer Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
popCurrentNode	TokenNameIdentifier	 pop Current Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
popContextNodeList	TokenNameIdentifier	 pop Context Node List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
NodeSet	TokenNameIdentifier	 Node Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
popCurrentNode	TokenNameIdentifier	 pop Current Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
popContextNodeList	TokenNameIdentifier	 pop Context Node List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
iterationList	TokenNameIdentifier	 iteration List
=	TokenNameEQUAL	
iterationSet	TokenNameIdentifier	 iteration Set
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
iterationList	TokenNameIdentifier	 iteration List
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Node	TokenNameIdentifier	 Node
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
iterationList	TokenNameIdentifier	 iteration List
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
closureSet	TokenNameIdentifier	 closure Set
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
)	TokenNameRPAREN	
closureSet	TokenNameIdentifier	 closure Set
.	TokenNameDOT	
addNode	TokenNameIdentifier	 add Node
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
iterationList	TokenNameIdentifier	 iteration List
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
closureSet	TokenNameIdentifier	 closure Set
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
