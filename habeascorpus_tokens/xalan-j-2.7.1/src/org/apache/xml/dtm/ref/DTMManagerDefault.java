/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
/* * $Id: DTMManagerDefault.java 468653 2006-10-28 07:07:05Z minchau $ */	TokenNameCOMMENT_BLOCK	 $Id: DTMManagerDefault.java 468653 2006-10-28 07:07:05Z minchau $ 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
ref	TokenNameIdentifier	 ref
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
parsers	TokenNameIdentifier	 parsers
.	TokenNameDOT	
DocumentBuilder	TokenNameIdentifier	 Document Builder
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
parsers	TokenNameIdentifier	 parsers
.	TokenNameDOT	
DocumentBuilderFactory	TokenNameIdentifier	 Document Builder Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
Source	TokenNameIdentifier	 Source
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
DOMSource	TokenNameIdentifier	 DOM Source
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
SAXSource	TokenNameIdentifier	 SAX Source
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
StreamSource	TokenNameIdentifier	 Stream Source
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
DTM	TokenNameIdentifier	 DTM
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
DTMException	TokenNameIdentifier	 DTM Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
DTMFilter	TokenNameIdentifier	 DTM Filter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
DTMIterator	TokenNameIdentifier	 DTM Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
DTMManager	TokenNameIdentifier	 DTM Manager
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
DTMWSFilter	TokenNameIdentifier	 DTMWS Filter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
ref	TokenNameIdentifier	 ref
.	TokenNameDOT	
dom2dtm	TokenNameIdentifier	 dom2dtm
.	TokenNameDOT	
DOM2DTM	TokenNameIdentifier	 DO M2 DTM
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
ref	TokenNameIdentifier	 ref
.	TokenNameDOT	
sax2dtm	TokenNameIdentifier	 sax2dtm
.	TokenNameDOT	
SAX2DTM	TokenNameIdentifier	 SA X2 DTM
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
ref	TokenNameIdentifier	 ref
.	TokenNameDOT	
sax2dtm	TokenNameIdentifier	 sax2dtm
.	TokenNameDOT	
SAX2RTFDTM	TokenNameIdentifier	 SA X2 RTFDTM
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XMLErrorResources	TokenNameIdentifier	 XML Error Resources
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XMLMessages	TokenNameIdentifier	 XML Messages
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
PrefixResolver	TokenNameIdentifier	 Prefix Resolver
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
SystemIDResolver	TokenNameIdentifier	 System ID Resolver
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
XMLReaderManager	TokenNameIdentifier	 XML Reader Manager
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
XMLStringFactory	TokenNameIdentifier	 XML String Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Document	TokenNameIdentifier	 Document
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Node	TokenNameIdentifier	 Node
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
InputSource	TokenNameIdentifier	 Input Source
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
SAXException	TokenNameIdentifier	 SAX Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
SAXNotRecognizedException	TokenNameIdentifier	 SAX Not Recognized Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
SAXNotSupportedException	TokenNameIdentifier	 SAX Not Supported Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
XMLReader	TokenNameIdentifier	 XML Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
helpers	TokenNameIdentifier	 helpers
.	TokenNameDOT	
DefaultHandler	TokenNameIdentifier	 Default Handler
;	TokenNameSEMICOLON	
/** * The default implementation for the DTMManager. * * %REVIEW% There is currently a reentrancy issue, since the finalizer * for XRTreeFrag (which runs in the GC thread) wants to call * DTMManager.release(), and may do so at the same time that the main * transformation thread is accessing the manager. Our current solution is * to make most of the manager's methods <code>synchronized</code>. * Early tests suggest that doing so is not causing a significant * performance hit in Xalan. However, it should be noted that there * is a possible alternative solution: rewrite release() so it merely * posts a request for release onto a threadsafe queue, and explicitly * process that queue on an infrequent basis during main-thread * activity (eg, when getDTM() is invoked). The downside of that solution * would be a greater delay before the DTM's storage is actually released * for reuse. * */	TokenNameCOMMENT_JAVADOC	 The default implementation for the DTMManager. * %REVIEW% There is currently a reentrancy issue, since the finalizer for XRTreeFrag (which runs in the GC thread) wants to call DTMManager.release(), and may do so at the same time that the main transformation thread is accessing the manager. Our current solution is to make most of the manager's methods <code>synchronized</code>. Early tests suggest that doing so is not causing a significant performance hit in Xalan. However, it should be noted that there is a possible alternative solution: rewrite release() so it merely posts a request for release onto a threadsafe queue, and explicitly process that queue on an infrequent basis during main-thread activity (eg, when getDTM() is invoked). The downside of that solution would be a greater delay before the DTM's storage is actually released for reuse. 
public	TokenNamepublic	
class	TokenNameclass	
DTMManagerDefault	TokenNameIdentifier	 DTM Manager Default
extends	TokenNameextends	
DTMManager	TokenNameIdentifier	 DTM Manager
{	TokenNameLBRACE	
//static final boolean JKESS_XNI_EXPERIMENT=true; 	TokenNameCOMMENT_LINE	static final boolean JKESS_XNI_EXPERIMENT=true; 
/** Set this to true if you want a dump of the DTM after creation. */	TokenNameCOMMENT_JAVADOC	 Set this to true if you want a dump of the DTM after creation. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
DUMPTREE	TokenNameIdentifier	 DUMPTREE
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** Set this to true if you want a basic diagnostics. */	TokenNameCOMMENT_JAVADOC	 Set this to true if you want a basic diagnostics. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
DEBUG	TokenNameIdentifier	 DEBUG
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** * Map from DTM identifier numbers to DTM objects that this manager manages. * One DTM may have several prefix numbers, if extended node indexing * is in use; in that case, m_dtm_offsets[] will used to control which * prefix maps to which section of the DTM. * * This array grows as necessary; see addDTM(). * * This array grows as necessary; see addDTM(). Growth is uncommon... but * access needs to be blindingly fast since it's used in node addressing. */	TokenNameCOMMENT_JAVADOC	 Map from DTM identifier numbers to DTM objects that this manager manages. One DTM may have several prefix numbers, if extended node indexing is in use; in that case, m_dtm_offsets[] will used to control which prefix maps to which section of the DTM. * This array grows as necessary; see addDTM(). * This array grows as necessary; see addDTM(). Growth is uncommon... but access needs to be blindingly fast since it's used in node addressing. 
protected	TokenNameprotected	
DTM	TokenNameIdentifier	 DTM
m_dtms	TokenNameIdentifier	 m dtms
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
DTM	TokenNameIdentifier	 DTM
[	TokenNameLBRACKET	
256	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/** Map from DTM identifier numbers to offsets. For small DTMs with a * single identifier, this will always be 0. In overflow addressing, where * additional identifiers are allocated to access nodes beyond the range of * a single Node Handle, this table is used to map the handle's node field * into the actual node identifier. * * This array grows as necessary; see addDTM(). * * This array grows as necessary; see addDTM(). Growth is uncommon... but * access needs to be blindingly fast since it's used in node addressing. * (And at the moment, that includes accessing it from DTMDefaultBase, * which is why this is not Protected or Private.) */	TokenNameCOMMENT_JAVADOC	 Map from DTM identifier numbers to offsets. For small DTMs with a single identifier, this will always be 0. In overflow addressing, where additional identifiers are allocated to access nodes beyond the range of a single Node Handle, this table is used to map the handle's node field into the actual node identifier. * This array grows as necessary; see addDTM(). * This array grows as necessary; see addDTM(). Growth is uncommon... but access needs to be blindingly fast since it's used in node addressing. (And at the moment, that includes accessing it from DTMDefaultBase, which is why this is not Protected or Private.) 
int	TokenNameint	
m_dtm_offsets	TokenNameIdentifier	 m dtm offsets
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
256	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/** * The cache for XMLReader objects to be used if the user did not * supply an XMLReader for a SAXSource or supplied a StreamSource. */	TokenNameCOMMENT_JAVADOC	 The cache for XMLReader objects to be used if the user did not supply an XMLReader for a SAXSource or supplied a StreamSource. 
protected	TokenNameprotected	
XMLReaderManager	TokenNameIdentifier	 XML Reader Manager
m_readerManager	TokenNameIdentifier	 m reader Manager
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** * The default implementation of ContentHandler, DTDHandler and ErrorHandler. */	TokenNameCOMMENT_JAVADOC	 The default implementation of ContentHandler, DTDHandler and ErrorHandler. 
protected	TokenNameprotected	
DefaultHandler	TokenNameIdentifier	 Default Handler
m_defaultHandler	TokenNameIdentifier	 m default Handler
=	TokenNameEQUAL	
new	TokenNamenew	
DefaultHandler	TokenNameIdentifier	 Default Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Add a DTM to the DTM table. This convenience call adds it as the * "base DTM ID", with offset 0. The other version of addDTM should * be used if you want to add "extended" DTM IDs with nonzero offsets. * * @param dtm Should be a valid reference to a DTM. * @param id Integer DTM ID to be bound to this DTM */	TokenNameCOMMENT_JAVADOC	 Add a DTM to the DTM table. This convenience call adds it as the "base DTM ID", with offset 0. The other version of addDTM should be used if you want to add "extended" DTM IDs with nonzero offsets. * @param dtm Should be a valid reference to a DTM. @param id Integer DTM ID to be bound to this DTM 
synchronized	TokenNamesynchronized	
public	TokenNamepublic	
void	TokenNamevoid	
addDTM	TokenNameIdentifier	 add DTM
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
dtm	TokenNameIdentifier	 dtm
,	TokenNameCOMMA	
int	TokenNameint	
id	TokenNameIdentifier	 id
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addDTM	TokenNameIdentifier	 add DTM
(	TokenNameLPAREN	
dtm	TokenNameIdentifier	 dtm
,	TokenNameCOMMA	
id	TokenNameIdentifier	 id
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Add a DTM to the DTM table. * * @param dtm Should be a valid reference to a DTM. * @param id Integer DTM ID to be bound to this DTM. * @param offset Integer addressing offset. The internal DTM Node ID is * obtained by adding this offset to the node-number field of the * public DTM Handle. For the first DTM ID accessing each DTM, this is 0; * for overflow addressing it will be a multiple of 1<<IDENT_DTM_NODE_BITS. */	TokenNameCOMMENT_JAVADOC	 Add a DTM to the DTM table. * @param dtm Should be a valid reference to a DTM. @param id Integer DTM ID to be bound to this DTM. @param offset Integer addressing offset. The internal DTM Node ID is obtained by adding this offset to the node-number field of the public DTM Handle. For the first DTM ID accessing each DTM, this is 0; for overflow addressing it will be a multiple of 1<<IDENT_DTM_NODE_BITS. 
synchronized	TokenNamesynchronized	
public	TokenNamepublic	
void	TokenNamevoid	
addDTM	TokenNameIdentifier	 add DTM
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
dtm	TokenNameIdentifier	 dtm
,	TokenNameCOMMA	
int	TokenNameint	
id	TokenNameIdentifier	 id
,	TokenNameCOMMA	
int	TokenNameint	
offset	TokenNameIdentifier	 offset
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
id	TokenNameIdentifier	 id
>=	TokenNameGREATER_EQUAL	
IDENT_MAX_DTMS	TokenNameIdentifier	 IDENT  MAX  DTMS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// TODO: %REVIEW% Not really the right error message. 	TokenNameCOMMENT_LINE	TODO: %REVIEW% Not really the right error message. 
throw	TokenNamethrow	
new	TokenNamenew	
DTMException	TokenNameIdentifier	 DTM Exception
(	TokenNameLPAREN	
XMLMessages	TokenNameIdentifier	 XML Messages
.	TokenNameDOT	
createXMLMessage	TokenNameIdentifier	 create XML Message
(	TokenNameLPAREN	
XMLErrorResources	TokenNameIdentifier	 XML Error Resources
.	TokenNameDOT	
ER_NO_DTMIDS_AVAIL	TokenNameIdentifier	 ER  NO  DTMIDS  AVAIL
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//"No more DTM IDs are available!"); 	TokenNameCOMMENT_LINE	"No more DTM IDs are available!"); 
}	TokenNameRBRACE	
// We used to just allocate the array size to IDENT_MAX_DTMS. 	TokenNameCOMMENT_LINE	We used to just allocate the array size to IDENT_MAX_DTMS. 
// But we expect to increase that to 16 bits, and I'm not willing 	TokenNameCOMMENT_LINE	But we expect to increase that to 16 bits, and I'm not willing 
// to allocate that much space unless needed. We could use one of our 	TokenNameCOMMENT_LINE	to allocate that much space unless needed. We could use one of our 
// handy-dandy Fast*Vectors, but this will do for now. 	TokenNameCOMMENT_LINE	handy-dandy Fast*Vectors, but this will do for now. 
// %REVIEW% 	TokenNameCOMMENT_LINE	%REVIEW% 
int	TokenNameint	
oldlen	TokenNameIdentifier	 oldlen
=	TokenNameEQUAL	
m_dtms	TokenNameIdentifier	 m dtms
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
oldlen	TokenNameIdentifier	 oldlen
<=	TokenNameLESS_EQUAL	
id	TokenNameIdentifier	 id
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Various growth strategies are possible. I think we don't want 	TokenNameCOMMENT_LINE	Various growth strategies are possible. I think we don't want 
// to over-allocate excessively, and I'm willing to reallocate 	TokenNameCOMMENT_LINE	to over-allocate excessively, and I'm willing to reallocate 
// more often to get that. See also Fast*Vector classes. 	TokenNameCOMMENT_LINE	more often to get that. See also Fast*Vector classes. 
// 	TokenNameCOMMENT_LINE	 
// %REVIEW% Should throw a more diagnostic error if we go over the max... 	TokenNameCOMMENT_LINE	%REVIEW% Should throw a more diagnostic error if we go over the max... 
int	TokenNameint	
newlen	TokenNameIdentifier	 newlen
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
min	TokenNameIdentifier	 min
(	TokenNameLPAREN	
(	TokenNameLPAREN	
id	TokenNameIdentifier	 id
+	TokenNamePLUS	
256	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
IDENT_MAX_DTMS	TokenNameIdentifier	 IDENT  MAX  DTMS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DTM	TokenNameIdentifier	 DTM
new_m_dtms	TokenNameIdentifier	 new m dtms
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
DTM	TokenNameIdentifier	 DTM
[	TokenNameLBRACKET	
newlen	TokenNameIdentifier	 newlen
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
m_dtms	TokenNameIdentifier	 m dtms
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
new_m_dtms	TokenNameIdentifier	 new m dtms
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
oldlen	TokenNameIdentifier	 oldlen
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
m_dtms	TokenNameIdentifier	 m dtms
=	TokenNameEQUAL	
new_m_dtms	TokenNameIdentifier	 new m dtms
;	TokenNameSEMICOLON	
int	TokenNameint	
new_m_dtm_offsets	TokenNameIdentifier	 new m dtm offsets
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
newlen	TokenNameIdentifier	 newlen
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
m_dtm_offsets	TokenNameIdentifier	 m dtm offsets
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
new_m_dtm_offsets	TokenNameIdentifier	 new m dtm offsets
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
oldlen	TokenNameIdentifier	 oldlen
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
m_dtm_offsets	TokenNameIdentifier	 m dtm offsets
=	TokenNameEQUAL	
new_m_dtm_offsets	TokenNameIdentifier	 new m dtm offsets
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
m_dtms	TokenNameIdentifier	 m dtms
[	TokenNameLBRACKET	
id	TokenNameIdentifier	 id
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
dtm	TokenNameIdentifier	 dtm
;	TokenNameSEMICOLON	
m_dtm_offsets	TokenNameIdentifier	 m dtm offsets
[	TokenNameLBRACKET	
id	TokenNameIdentifier	 id
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
offset	TokenNameIdentifier	 offset
;	TokenNameSEMICOLON	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
documentRegistration	TokenNameIdentifier	 document Registration
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// The DTM should have been told who its manager was when we created it. 	TokenNameCOMMENT_LINE	The DTM should have been told who its manager was when we created it. 
// Do we need to allow for adopting DTMs _not_ created by this manager? 	TokenNameCOMMENT_LINE	Do we need to allow for adopting DTMs _not_ created by this manager? 
}	TokenNameRBRACE	
/** * Get the first free DTM ID available. %OPT% Linear search is inefficient! */	TokenNameCOMMENT_JAVADOC	 Get the first free DTM ID available. %OPT% Linear search is inefficient! 
synchronized	TokenNamesynchronized	
public	TokenNamepublic	
int	TokenNameint	
getFirstFreeDTMID	TokenNameIdentifier	 get First Free DTMID
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
m_dtms	TokenNameIdentifier	 m dtms
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
n	TokenNameIdentifier	 n
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
m_dtms	TokenNameIdentifier	 m dtms
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
n	TokenNameIdentifier	 n
;	TokenNameSEMICOLON	
// count on addDTM() to throw exception if out of range 	TokenNameCOMMENT_LINE	count on addDTM() to throw exception if out of range 
}	TokenNameRBRACE	
/** * The default table for exandedNameID lookups. */	TokenNameCOMMENT_JAVADOC	 The default table for exandedNameID lookups. 
private	TokenNameprivate	
ExpandedNameTable	TokenNameIdentifier	 Expanded Name Table
m_expandedNameTable	TokenNameIdentifier	 m expanded Name Table
=	TokenNameEQUAL	
new	TokenNamenew	
ExpandedNameTable	TokenNameIdentifier	 Expanded Name Table
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Constructor DTMManagerDefault * */	TokenNameCOMMENT_JAVADOC	 Constructor DTMManagerDefault 
public	TokenNamepublic	
DTMManagerDefault	TokenNameIdentifier	 DTM Manager Default
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
/** * Get an instance of a DTM, loaded with the content from the * specified source. If the unique flag is true, a new instance will * always be returned. Otherwise it is up to the DTMManager to return a * new instance or an instance that it already created and may be being used * by someone else. * * A bit of magic in this implementation: If the source is null, unique is true, * and incremental and doIndexing are both false, we return an instance of * SAX2RTFDTM, which see. * * (I think more parameters will need to be added for error handling, and entity * resolution, and more explicit control of the RTF situation). * * @param source the specification of the source object. * @param unique true if the returned DTM must be unique, probably because it * is going to be mutated. * @param whiteSpaceFilter Enables filtering of whitespace nodes, and may * be null. * @param incremental true if the DTM should be built incrementally, if * possible. * @param doIndexing true if the caller considers it worth it to use * indexing schemes. * * @return a non-null DTM reference. */	TokenNameCOMMENT_JAVADOC	 Get an instance of a DTM, loaded with the content from the specified source. If the unique flag is true, a new instance will always be returned. Otherwise it is up to the DTMManager to return a new instance or an instance that it already created and may be being used by someone else. * A bit of magic in this implementation: If the source is null, unique is true, and incremental and doIndexing are both false, we return an instance of SAX2RTFDTM, which see. * (I think more parameters will need to be added for error handling, and entity resolution, and more explicit control of the RTF situation). * @param source the specification of the source object. @param unique true if the returned DTM must be unique, probably because it is going to be mutated. @param whiteSpaceFilter Enables filtering of whitespace nodes, and may be null. @param incremental true if the DTM should be built incrementally, if possible. @param doIndexing true if the caller considers it worth it to use indexing schemes. * @return a non-null DTM reference. 
synchronized	TokenNamesynchronized	
public	TokenNamepublic	
DTM	TokenNameIdentifier	 DTM
getDTM	TokenNameIdentifier	 get DTM
(	TokenNameLPAREN	
Source	TokenNameIdentifier	 Source
source	TokenNameIdentifier	 source
,	TokenNameCOMMA	
boolean	TokenNameboolean	
unique	TokenNameIdentifier	 unique
,	TokenNameCOMMA	
DTMWSFilter	TokenNameIdentifier	 DTMWS Filter
whiteSpaceFilter	TokenNameIdentifier	 white Space Filter
,	TokenNameCOMMA	
boolean	TokenNameboolean	
incremental	TokenNameIdentifier	 incremental
,	TokenNameCOMMA	
boolean	TokenNameboolean	
doIndexing	TokenNameIdentifier	 do Indexing
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG	TokenNameIdentifier	 DEBUG
&&	TokenNameAND_AND	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
source	TokenNameIdentifier	 source
)	TokenNameRPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Starting "	TokenNameStringLiteral	Starting 
+	TokenNamePLUS	
(	TokenNameLPAREN	
unique	TokenNameIdentifier	 unique
?	TokenNameQUESTION	
"UNIQUE"	TokenNameStringLiteral	UNIQUE
:	TokenNameCOLON	
"shared"	TokenNameStringLiteral	shared
)	TokenNameRPAREN	
+	TokenNamePLUS	
" source: "	TokenNameStringLiteral	 source: 
+	TokenNamePLUS	
source	TokenNameIdentifier	 source
.	TokenNameDOT	
getSystemId	TokenNameIdentifier	 get System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XMLStringFactory	TokenNameIdentifier	 XML String Factory
xstringFactory	TokenNameIdentifier	 xstring Factory
=	TokenNameEQUAL	
m_xsf	TokenNameIdentifier	 m xsf
;	TokenNameSEMICOLON	
int	TokenNameint	
dtmPos	TokenNameIdentifier	 dtm Pos
=	TokenNameEQUAL	
getFirstFreeDTMID	TokenNameIdentifier	 get First Free DTMID
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
documentID	TokenNameIdentifier	 document ID
=	TokenNameEQUAL	
dtmPos	TokenNameIdentifier	 dtm Pos
<<	TokenNameLEFT_SHIFT	
IDENT_DTM_NODE_BITS	TokenNameIdentifier	 IDENT  DTM  NODE  BITS
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
source	TokenNameIdentifier	 source
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
source	TokenNameIdentifier	 source
instanceof	TokenNameinstanceof	
DOMSource	TokenNameIdentifier	 DOM Source
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DOM2DTM	TokenNameIdentifier	 DO M2 DTM
dtm	TokenNameIdentifier	 dtm
=	TokenNameEQUAL	
new	TokenNamenew	
DOM2DTM	TokenNameIdentifier	 DO M2 DTM
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
DOMSource	TokenNameIdentifier	 DOM Source
)	TokenNameRPAREN	
source	TokenNameIdentifier	 source
,	TokenNameCOMMA	
documentID	TokenNameIdentifier	 document ID
,	TokenNameCOMMA	
whiteSpaceFilter	TokenNameIdentifier	 white Space Filter
,	TokenNameCOMMA	
xstringFactory	TokenNameIdentifier	 xstring Factory
,	TokenNameCOMMA	
doIndexing	TokenNameIdentifier	 do Indexing
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
addDTM	TokenNameIdentifier	 add DTM
(	TokenNameLPAREN	
dtm	TokenNameIdentifier	 dtm
,	TokenNameCOMMA	
dtmPos	TokenNameIdentifier	 dtm Pos
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// if (DUMPTREE) 	TokenNameCOMMENT_LINE	if (DUMPTREE) 
// { 	TokenNameCOMMENT_LINE	{ 
// dtm.dumpDTM(); 	TokenNameCOMMENT_LINE	dtm.dumpDTM(); 
// } 	TokenNameCOMMENT_LINE	} 
return	TokenNamereturn	
dtm	TokenNameIdentifier	 dtm
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
isSAXSource	TokenNameIdentifier	 is SAX Source
=	TokenNameEQUAL	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
source	TokenNameIdentifier	 source
)	TokenNameRPAREN	
?	TokenNameQUESTION	
(	TokenNameLPAREN	
source	TokenNameIdentifier	 source
instanceof	TokenNameinstanceof	
SAXSource	TokenNameIdentifier	 SAX Source
)	TokenNameRPAREN	
:	TokenNameCOLON	
true	TokenNametrue	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
isStreamSource	TokenNameIdentifier	 is Stream Source
=	TokenNameEQUAL	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
source	TokenNameIdentifier	 source
)	TokenNameRPAREN	
?	TokenNameQUESTION	
(	TokenNameLPAREN	
source	TokenNameIdentifier	 source
instanceof	TokenNameinstanceof	
StreamSource	TokenNameIdentifier	 Stream Source
)	TokenNameRPAREN	
:	TokenNameCOLON	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isSAXSource	TokenNameIdentifier	 is SAX Source
||	TokenNameOR_OR	
isStreamSource	TokenNameIdentifier	 is Stream Source
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XMLReader	TokenNameIdentifier	 XML Reader
reader	TokenNameIdentifier	 reader
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
SAX2DTM	TokenNameIdentifier	 SA X2 DTM
dtm	TokenNameIdentifier	 dtm
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
InputSource	TokenNameIdentifier	 Input Source
xmlSource	TokenNameIdentifier	 xml Source
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
source	TokenNameIdentifier	 source
)	TokenNameRPAREN	
{	TokenNameLBRACE	
xmlSource	TokenNameIdentifier	 xml Source
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
reader	TokenNameIdentifier	 reader
=	TokenNameEQUAL	
getXMLReader	TokenNameIdentifier	 get XML Reader
(	TokenNameLPAREN	
source	TokenNameIdentifier	 source
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
xmlSource	TokenNameIdentifier	 xml Source
=	TokenNameEQUAL	
SAXSource	TokenNameIdentifier	 SAX Source
.	TokenNameDOT	
sourceToInputSource	TokenNameIdentifier	 source To Input Source
(	TokenNameLPAREN	
source	TokenNameIdentifier	 source
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
urlOfSource	TokenNameIdentifier	 url Of Source
=	TokenNameEQUAL	
xmlSource	TokenNameIdentifier	 xml Source
.	TokenNameDOT	
getSystemId	TokenNameIdentifier	 get System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
urlOfSource	TokenNameIdentifier	 url Of Source
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
urlOfSource	TokenNameIdentifier	 url Of Source
=	TokenNameEQUAL	
SystemIDResolver	TokenNameIdentifier	 System ID Resolver
.	TokenNameDOT	
getAbsoluteURI	TokenNameIdentifier	 get Absolute URI
(	TokenNameLPAREN	
urlOfSource	TokenNameIdentifier	 url Of Source
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// %REVIEW% Is there a better way to send a warning? 	TokenNameCOMMENT_LINE	%REVIEW% Is there a better way to send a warning? 
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Can not absolutize URL: "	TokenNameStringLiteral	Can not absolutize URL: 
+	TokenNamePLUS	
urlOfSource	TokenNameIdentifier	 url Of Source
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
xmlSource	TokenNameIdentifier	 xml Source
.	TokenNameDOT	
setSystemId	TokenNameIdentifier	 set System Id
(	TokenNameLPAREN	
urlOfSource	TokenNameIdentifier	 url Of Source
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
source	TokenNameIdentifier	 source
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
unique	TokenNameIdentifier	 unique
&&	TokenNameAND_AND	
!	TokenNameNOT	
incremental	TokenNameIdentifier	 incremental
&&	TokenNameAND_AND	
!	TokenNameNOT	
doIndexing	TokenNameIdentifier	 do Indexing
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Special case to support RTF construction into shared DTM. 	TokenNameCOMMENT_LINE	Special case to support RTF construction into shared DTM. 
// It should actually still work for other uses, 	TokenNameCOMMENT_LINE	It should actually still work for other uses, 
// but may be slightly deoptimized relative to the base 	TokenNameCOMMENT_LINE	but may be slightly deoptimized relative to the base 
// to allow it to deal with carrying multiple documents. 	TokenNameCOMMENT_LINE	to allow it to deal with carrying multiple documents. 
// 	TokenNameCOMMENT_LINE	 
// %REVIEW% This is a sloppy way to request this mode; 	TokenNameCOMMENT_LINE	%REVIEW% This is a sloppy way to request this mode; 
// we need to consider architectural improvements. 	TokenNameCOMMENT_LINE	we need to consider architectural improvements. 
dtm	TokenNameIdentifier	 dtm
=	TokenNameEQUAL	
new	TokenNamenew	
SAX2RTFDTM	TokenNameIdentifier	 SA X2 RTFDTM
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
source	TokenNameIdentifier	 source
,	TokenNameCOMMA	
documentID	TokenNameIdentifier	 document ID
,	TokenNameCOMMA	
whiteSpaceFilter	TokenNameIdentifier	 white Space Filter
,	TokenNameCOMMA	
xstringFactory	TokenNameIdentifier	 xstring Factory
,	TokenNameCOMMA	
doIndexing	TokenNameIdentifier	 do Indexing
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/************************************************************** // EXPERIMENTAL 3/22/02 else if(JKESS_XNI_EXPERIMENT && m_incremental) { dtm = new XNI2DTM(this, source, documentID, whiteSpaceFilter, xstringFactory, doIndexing); } **************************************************************/	TokenNameCOMMENT_JAVADOC	************************************************************ // EXPERIMENTAL 3/22/02 else if(JKESS_XNI_EXPERIMENT && m_incremental) { dtm = new XNI2DTM(this, source, documentID, whiteSpaceFilter, xstringFactory, doIndexing); } *************************************************************
// Create the basic SAX2DTM. 	TokenNameCOMMENT_LINE	Create the basic SAX2DTM. 
else	TokenNameelse	
{	TokenNameLBRACE	
dtm	TokenNameIdentifier	 dtm
=	TokenNameEQUAL	
new	TokenNamenew	
SAX2DTM	TokenNameIdentifier	 SA X2 DTM
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
source	TokenNameIdentifier	 source
,	TokenNameCOMMA	
documentID	TokenNameIdentifier	 document ID
,	TokenNameCOMMA	
whiteSpaceFilter	TokenNameIdentifier	 white Space Filter
,	TokenNameCOMMA	
xstringFactory	TokenNameIdentifier	 xstring Factory
,	TokenNameCOMMA	
doIndexing	TokenNameIdentifier	 do Indexing
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Go ahead and add the DTM to the lookup table. This needs to be 	TokenNameCOMMENT_LINE	Go ahead and add the DTM to the lookup table. This needs to be 
// done before any parsing occurs. Note offset 0, since we've just 	TokenNameCOMMENT_LINE	done before any parsing occurs. Note offset 0, since we've just 
// created a new DTM. 	TokenNameCOMMENT_LINE	created a new DTM. 
addDTM	TokenNameIdentifier	 add DTM
(	TokenNameLPAREN	
dtm	TokenNameIdentifier	 dtm
,	TokenNameCOMMA	
dtmPos	TokenNameIdentifier	 dtm Pos
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
haveXercesParser	TokenNameIdentifier	 have Xerces Parser
=	TokenNameEQUAL	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
getClass	TokenNameIdentifier	 get Class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"org.apache.xerces.parsers.SAXParser"	TokenNameStringLiteral	org.apache.xerces.parsers.SAXParser
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
haveXercesParser	TokenNameIdentifier	 have Xerces Parser
)	TokenNameRPAREN	
{	TokenNameLBRACE	
incremental	TokenNameIdentifier	 incremental
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// No matter what. %REVIEW% 	TokenNameCOMMENT_LINE	No matter what. %REVIEW% 
}	TokenNameRBRACE	
// If the reader is null, but they still requested an incremental 	TokenNameCOMMENT_LINE	If the reader is null, but they still requested an incremental 
// build, then we still want to set up the IncrementalSAXSource stuff. 	TokenNameCOMMENT_LINE	build, then we still want to set up the IncrementalSAXSource stuff. 
if	TokenNameif	
(	TokenNameLPAREN	
m_incremental	TokenNameIdentifier	 m incremental
&&	TokenNameAND_AND	
incremental	TokenNameIdentifier	 incremental
/* || ((null == reader) && incremental) */	TokenNameCOMMENT_BLOCK	 || ((null == reader) && incremental) 
)	TokenNameRPAREN	
{	TokenNameLBRACE	
IncrementalSAXSource	TokenNameIdentifier	 Incremental SAX Source
coParser	TokenNameIdentifier	 co Parser
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
haveXercesParser	TokenNameIdentifier	 have Xerces Parser
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// IncrementalSAXSource_Xerces to avoid threading. 	TokenNameCOMMENT_LINE	IncrementalSAXSource_Xerces to avoid threading. 
try	TokenNametry	
{	TokenNameLBRACE	
coParser	TokenNameIdentifier	 co Parser
=	TokenNameEQUAL	
(	TokenNameLPAREN	
IncrementalSAXSource	TokenNameIdentifier	 Incremental SAX Source
)	TokenNameRPAREN	
Class	TokenNameIdentifier	 Class
.	TokenNameDOT	
forName	TokenNameIdentifier	 for Name
(	TokenNameLPAREN	
"org.apache.xml.dtm.ref.IncrementalSAXSource_Xerces"	TokenNameStringLiteral	org.apache.xml.dtm.ref.IncrementalSAXSource_Xerces
)	TokenNameRPAREN	
.	TokenNameDOT	
newInstance	TokenNameIdentifier	 new Instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ex	TokenNameIdentifier	 ex
.	TokenNameDOT	
printStackTrace	TokenNameIdentifier	 print Stack Trace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
coParser	TokenNameIdentifier	 co Parser
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
coParser	TokenNameIdentifier	 co Parser
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Create a IncrementalSAXSource to run on the secondary thread. 	TokenNameCOMMENT_LINE	Create a IncrementalSAXSource to run on the secondary thread. 
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
{	TokenNameLBRACE	
coParser	TokenNameIdentifier	 co Parser
=	TokenNameEQUAL	
new	TokenNamenew	
IncrementalSAXSource_Filter	TokenNameIdentifier	 Incremental SAX Source  Filter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
IncrementalSAXSource_Filter	TokenNameIdentifier	 Incremental SAX Source  Filter
filter	TokenNameIdentifier	 filter
=	TokenNameEQUAL	
new	TokenNamenew	
IncrementalSAXSource_Filter	TokenNameIdentifier	 Incremental SAX Source  Filter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
setXMLReader	TokenNameIdentifier	 set XML Reader
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
coParser	TokenNameIdentifier	 co Parser
=	TokenNameEQUAL	
filter	TokenNameIdentifier	 filter
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/************************************************************** // EXPERIMENTAL 3/22/02 if (JKESS_XNI_EXPERIMENT && m_incremental && dtm instanceof XNI2DTM && coParser instanceof IncrementalSAXSource_Xerces) { org.apache.xerces.xni.parser.XMLPullParserConfiguration xpc= ((IncrementalSAXSource_Xerces)coParser) .getXNIParserConfiguration(); if (xpc!=null) { // Bypass SAX; listen to the XNI stream ((XNI2DTM)dtm).setIncrementalXNISource(xpc); } else { // Listen to the SAX stream (will fail, diagnostically...) dtm.setIncrementalSAXSource(coParser); } } else ***************************************************************/	TokenNameCOMMENT_JAVADOC	************************************************************ // EXPERIMENTAL 3/22/02 if (JKESS_XNI_EXPERIMENT && m_incremental && dtm instanceof XNI2DTM && coParser instanceof IncrementalSAXSource_Xerces) { org.apache.xerces.xni.parser.XMLPullParserConfiguration xpc= ((IncrementalSAXSource_Xerces)coParser) .getXNIParserConfiguration(); if (xpc!=null) { // Bypass SAX; listen to the XNI stream ((XNI2DTM)dtm).setIncrementalXNISource(xpc); } else { // Listen to the SAX stream (will fail, diagnostically...) dtm.setIncrementalSAXSource(coParser); } } else **************************************************************
// Have the DTM set itself up as IncrementalSAXSource's listener. 	TokenNameCOMMENT_LINE	Have the DTM set itself up as IncrementalSAXSource's listener. 
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
setIncrementalSAXSource	TokenNameIdentifier	 set Incremental SAX Source
(	TokenNameLPAREN	
coParser	TokenNameIdentifier	 co Parser
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
xmlSource	TokenNameIdentifier	 xml Source
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Then the user will construct it themselves. 	TokenNameCOMMENT_LINE	Then the user will construct it themselves. 
return	TokenNamereturn	
dtm	TokenNameIdentifier	 dtm
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
getErrorHandler	TokenNameIdentifier	 get Error Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
setErrorHandler	TokenNameIdentifier	 set Error Handler
(	TokenNameLPAREN	
dtm	TokenNameIdentifier	 dtm
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
setDTDHandler	TokenNameIdentifier	 set DTD Handler
(	TokenNameLPAREN	
dtm	TokenNameIdentifier	 dtm
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
// Launch parsing coroutine. Launches a second thread, 	TokenNameCOMMENT_LINE	Launch parsing coroutine. Launches a second thread, 
// if we're using IncrementalSAXSource.filter(). 	TokenNameCOMMENT_LINE	if we're using IncrementalSAXSource.filter(). 
coParser	TokenNameIdentifier	 co Parser
.	TokenNameDOT	
startParse	TokenNameIdentifier	 start Parse
(	TokenNameLPAREN	
xmlSource	TokenNameIdentifier	 xml Source
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
RuntimeException	TokenNameIdentifier	 Runtime Exception
re	TokenNameIdentifier	 re
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
clearCoRoutine	TokenNameIdentifier	 clear Co Routine
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
re	TokenNameIdentifier	 re
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
clearCoRoutine	TokenNameIdentifier	 clear Co Routine
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
WrappedRuntimeException	TokenNameIdentifier	 Wrapped Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Then the user will construct it themselves. 	TokenNameCOMMENT_LINE	Then the user will construct it themselves. 
return	TokenNamereturn	
dtm	TokenNameIdentifier	 dtm
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// not incremental 	TokenNameCOMMENT_LINE	not incremental 
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
setContentHandler	TokenNameIdentifier	 set Content Handler
(	TokenNameLPAREN	
dtm	TokenNameIdentifier	 dtm
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
setDTDHandler	TokenNameIdentifier	 set DTD Handler
(	TokenNameLPAREN	
dtm	TokenNameIdentifier	 dtm
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
getErrorHandler	TokenNameIdentifier	 get Error Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
setErrorHandler	TokenNameIdentifier	 set Error Handler
(	TokenNameLPAREN	
dtm	TokenNameIdentifier	 dtm
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
"http://xml.org/sax/properties/lexical-handler"	TokenNameStringLiteral	http://xml.org/sax/properties/lexical-handler
,	TokenNameCOMMA	
dtm	TokenNameIdentifier	 dtm
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
SAXNotRecognizedException	TokenNameIdentifier	 SAX Not Recognized Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
SAXNotSupportedException	TokenNameIdentifier	 SAX Not Supported Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
parse	TokenNameIdentifier	 parse
(	TokenNameLPAREN	
xmlSource	TokenNameIdentifier	 xml Source
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
RuntimeException	TokenNameIdentifier	 Runtime Exception
re	TokenNameIdentifier	 re
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
clearCoRoutine	TokenNameIdentifier	 clear Co Routine
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
re	TokenNameIdentifier	 re
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
clearCoRoutine	TokenNameIdentifier	 clear Co Routine
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
WrappedRuntimeException	TokenNameIdentifier	 Wrapped Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
DUMPTREE	TokenNameIdentifier	 DUMPTREE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Dumping SAX2DOM"	TokenNameStringLiteral	Dumping SAX2DOM
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
dumpDTM	TokenNameIdentifier	 dump DTM
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
dtm	TokenNameIdentifier	 dtm
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
// Reset the ContentHandler, DTDHandler, ErrorHandler to the DefaultHandler 	TokenNameCOMMENT_LINE	Reset the ContentHandler, DTDHandler, ErrorHandler to the DefaultHandler 
// after creating the DTM. 	TokenNameCOMMENT_LINE	after creating the DTM. 
if	TokenNameif	
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
(	TokenNameLPAREN	
m_incremental	TokenNameIdentifier	 m incremental
&&	TokenNameAND_AND	
incremental	TokenNameIdentifier	 incremental
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
setContentHandler	TokenNameIdentifier	 set Content Handler
(	TokenNameLPAREN	
m_defaultHandler	TokenNameIdentifier	 m default Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
setDTDHandler	TokenNameIdentifier	 set DTD Handler
(	TokenNameLPAREN	
m_defaultHandler	TokenNameIdentifier	 m default Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
setErrorHandler	TokenNameIdentifier	 set Error Handler
(	TokenNameLPAREN	
m_defaultHandler	TokenNameIdentifier	 m default Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Reset the LexicalHandler to null after creating the DTM. 	TokenNameCOMMENT_LINE	Reset the LexicalHandler to null after creating the DTM. 
try	TokenNametry	
{	TokenNameLBRACE	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
"http://xml.org/sax/properties/lexical-handler"	TokenNameStringLiteral	http://xml.org/sax/properties/lexical-handler
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
releaseXMLReader	TokenNameIdentifier	 release XML Reader
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// It should have been handled by a derived class or the caller 	TokenNameCOMMENT_LINE	It should have been handled by a derived class or the caller 
// made a mistake. 	TokenNameCOMMENT_LINE	made a mistake. 
throw	TokenNamethrow	
new	TokenNamenew	
DTMException	TokenNameIdentifier	 DTM Exception
(	TokenNameLPAREN	
XMLMessages	TokenNameIdentifier	 XML Messages
.	TokenNameDOT	
createXMLMessage	TokenNameIdentifier	 create XML Message
(	TokenNameLPAREN	
XMLErrorResources	TokenNameIdentifier	 XML Error Resources
.	TokenNameDOT	
ER_NOT_SUPPORTED	TokenNameIdentifier	 ER  NOT  SUPPORTED
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
source	TokenNameIdentifier	 source
}	TokenNameRBRACE	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//"Not supported: " + source); 	TokenNameCOMMENT_LINE	"Not supported: " + source); 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Given a W3C DOM node, try and return a DTM handle. * Note: calling this may be non-optimal, and there is no guarantee that * the node will be found in any particular DTM. * * @param node Non-null reference to a DOM node. * * @return a valid DTM handle. */	TokenNameCOMMENT_JAVADOC	 Given a W3C DOM node, try and return a DTM handle. Note: calling this may be non-optimal, and there is no guarantee that the node will be found in any particular DTM. * @param node Non-null reference to a DOM node. * @return a valid DTM handle. 
synchronized	TokenNamesynchronized	
public	TokenNamepublic	
int	TokenNameint	
getDTMHandleFromNode	TokenNameIdentifier	 get DTM Handle From Node
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
XMLMessages	TokenNameIdentifier	 XML Messages
.	TokenNameDOT	
createXMLMessage	TokenNameIdentifier	 create XML Message
(	TokenNameLPAREN	
XMLErrorResources	TokenNameIdentifier	 XML Error Resources
.	TokenNameDOT	
ER_NODE_NON_NULL	TokenNameIdentifier	 ER  NODE  NON  NULL
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//"node must be non-null for getDTMHandleFromNode!"); 	TokenNameCOMMENT_LINE	"node must be non-null for getDTMHandleFromNode!"); 
if	TokenNameif	
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
instanceof	TokenNameinstanceof	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
ref	TokenNameIdentifier	 ref
.	TokenNameDOT	
DTMNodeProxy	TokenNameIdentifier	 DTM Node Proxy
)	TokenNameRPAREN	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
ref	TokenNameIdentifier	 ref
.	TokenNameDOT	
DTMNodeProxy	TokenNameIdentifier	 DTM Node Proxy
)	TokenNameRPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
.	TokenNameDOT	
getDTMNodeNumber	TokenNameIdentifier	 get DTM Node Number
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
{	TokenNameLBRACE	
// Find the DOM2DTMs wrapped around this Document (if any) 	TokenNameCOMMENT_LINE	Find the DOM2DTMs wrapped around this Document (if any) 
// and check whether they contain the Node in question. 	TokenNameCOMMENT_LINE	and check whether they contain the Node in question. 
// 	TokenNameCOMMENT_LINE	 
// NOTE that since a DOM2DTM may represent a subtree rather 	TokenNameCOMMENT_LINE	NOTE that since a DOM2DTM may represent a subtree rather 
// than a full document, we have to be prepared to check more 	TokenNameCOMMENT_LINE	than a full document, we have to be prepared to check more 
// than one -- and there is no guarantee that we will find 	TokenNameCOMMENT_LINE	than one -- and there is no guarantee that we will find 
// one that contains ancestors or siblings of the node we're 	TokenNameCOMMENT_LINE	one that contains ancestors or siblings of the node we're 
// seeking. 	TokenNameCOMMENT_LINE	seeking. 
// 	TokenNameCOMMENT_LINE	 
// %REVIEW% We could search for the one which contains this 	TokenNameCOMMENT_LINE	%REVIEW% We could search for the one which contains this 
// node at the deepest level, and thus covers the widest 	TokenNameCOMMENT_LINE	node at the deepest level, and thus covers the widest 
// subtree, but that's going to entail additional work 	TokenNameCOMMENT_LINE	subtree, but that's going to entail additional work 
// checking more DTMs... and getHandleOfNode is not a 	TokenNameCOMMENT_LINE	checking more DTMs... and getHandleOfNode is not a 
// cheap operation in most implementations. 	TokenNameCOMMENT_LINE	cheap operation in most implementations. 
// 	TokenNameCOMMENT_LINE	 
// TODO: %REVIEW% If overflow addressing, we may recheck a DTM 	TokenNameCOMMENT_LINE	TODO: %REVIEW% If overflow addressing, we may recheck a DTM 
// already examined. Ouch. But with the increased number of DTMs, 	TokenNameCOMMENT_LINE	already examined. Ouch. But with the increased number of DTMs, 
// scanning back to check this is painful. 	TokenNameCOMMENT_LINE	scanning back to check this is painful. 
// POSSIBLE SOLUTIONS: 	TokenNameCOMMENT_LINE	POSSIBLE SOLUTIONS: 
// Generate a list of _unique_ DTM objects? 	TokenNameCOMMENT_LINE	Generate a list of _unique_ DTM objects? 
// Have each DTM cache last DOM node search? 	TokenNameCOMMENT_LINE	Have each DTM cache last DOM node search? 
int	TokenNameint	
max	TokenNameIdentifier	 max
=	TokenNameEQUAL	
m_dtms	TokenNameIdentifier	 m dtms
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
max	TokenNameIdentifier	 max
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DTM	TokenNameIdentifier	 DTM
thisDTM	TokenNameIdentifier	 this DTM
=	TokenNameEQUAL	
m_dtms	TokenNameIdentifier	 m dtms
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
thisDTM	TokenNameIdentifier	 this DTM
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
thisDTM	TokenNameIdentifier	 this DTM
instanceof	TokenNameinstanceof	
DOM2DTM	TokenNameIdentifier	 DO M2 DTM
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
handle	TokenNameIdentifier	 handle
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
DOM2DTM	TokenNameIdentifier	 DO M2 DTM
)	TokenNameRPAREN	
thisDTM	TokenNameIdentifier	 this DTM
)	TokenNameRPAREN	
.	TokenNameDOT	
getHandleOfNode	TokenNameIdentifier	 get Handle Of Node
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
handle	TokenNameIdentifier	 handle
!=	TokenNameNOT_EQUAL	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
)	TokenNameRPAREN	
return	TokenNamereturn	
handle	TokenNameIdentifier	 handle
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Not found; generate a new DTM. 	TokenNameCOMMENT_LINE	Not found; generate a new DTM. 
// 	TokenNameCOMMENT_LINE	 
// %REVIEW% Is this really desirable, or should we return null 	TokenNameCOMMENT_LINE	%REVIEW% Is this really desirable, or should we return null 
// and make folks explicitly instantiate from a DOMSource? The 	TokenNameCOMMENT_LINE	and make folks explicitly instantiate from a DOMSource? The 
// latter is more work but gives the caller the opportunity to 	TokenNameCOMMENT_LINE	latter is more work but gives the caller the opportunity to 
// explicitly add the DTM to a DTMManager... and thus to know when 	TokenNameCOMMENT_LINE	explicitly add the DTM to a DTMManager... and thus to know when 
// it can be discarded again, which is something we need to pay much 	TokenNameCOMMENT_LINE	it can be discarded again, which is something we need to pay much 
// more attention to. (Especially since only DTMs which are assigned 	TokenNameCOMMENT_LINE	more attention to. (Especially since only DTMs which are assigned 
// to a manager can use the overflow addressing scheme.) 	TokenNameCOMMENT_LINE	to a manager can use the overflow addressing scheme.) 
// 	TokenNameCOMMENT_LINE	 
// %BUG% If the source node was a DOM2DTM$defaultNamespaceDeclarationNode 	TokenNameCOMMENT_LINE	%BUG% If the source node was a DOM2DTM$defaultNamespaceDeclarationNode 
// and the DTM wasn't registered with this DTMManager, we will create 	TokenNameCOMMENT_LINE	and the DTM wasn't registered with this DTMManager, we will create 
// a new DTM and _still_ not be able to find the node (since it will 	TokenNameCOMMENT_LINE	a new DTM and _still_ not be able to find the node (since it will 
// be resynthesized). Another reason to push hard on making all DTMs 	TokenNameCOMMENT_LINE	be resynthesized). Another reason to push hard on making all DTMs 
// be managed DTMs. 	TokenNameCOMMENT_LINE	be managed DTMs. 
// Since the real root of our tree may be a DocumentFragment, we need to 	TokenNameCOMMENT_LINE	Since the real root of our tree may be a DocumentFragment, we need to 
// use getParent to find the root, instead of getOwnerDocument. Otherwise 	TokenNameCOMMENT_LINE	use getParent to find the root, instead of getOwnerDocument. Otherwise 
// DOM2DTM#getHandleOfNode will be very unhappy. 	TokenNameCOMMENT_LINE	DOM2DTM#getHandleOfNode will be very unhappy. 
Node	TokenNameIdentifier	 Node
root	TokenNameIdentifier	 root
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
;	TokenNameSEMICOLON	
Node	TokenNameIdentifier	 Node
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
(	TokenNameLPAREN	
root	TokenNameIdentifier	 root
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ATTRIBUTE_NODE	TokenNameIdentifier	 ATTRIBUTE  NODE
)	TokenNameRPAREN	
?	TokenNameQUESTION	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Attr	TokenNameIdentifier	 Attr
)	TokenNameRPAREN	
root	TokenNameIdentifier	 root
)	TokenNameRPAREN	
.	TokenNameDOT	
getOwnerElement	TokenNameIdentifier	 get Owner Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
root	TokenNameIdentifier	 root
.	TokenNameDOT	
getParentNode	TokenNameIdentifier	 get Parent Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
p	TokenNameIdentifier	 p
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
getParentNode	TokenNameIdentifier	 get Parent Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
root	TokenNameIdentifier	 root
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
DOM2DTM	TokenNameIdentifier	 DO M2 DTM
dtm	TokenNameIdentifier	 dtm
=	TokenNameEQUAL	
(	TokenNameLPAREN	
DOM2DTM	TokenNameIdentifier	 DO M2 DTM
)	TokenNameRPAREN	
getDTM	TokenNameIdentifier	 get DTM
(	TokenNameLPAREN	
new	TokenNamenew	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
DOMSource	TokenNameIdentifier	 DOM Source
(	TokenNameLPAREN	
root	TokenNameIdentifier	 root
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
handle	TokenNameIdentifier	 handle
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
instanceof	TokenNameinstanceof	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
ref	TokenNameIdentifier	 ref
.	TokenNameDOT	
dom2dtm	TokenNameIdentifier	 dom2dtm
.	TokenNameDOT	
DOM2DTMdefaultNamespaceDeclarationNode	TokenNameIdentifier	 DO M2 DT Mdefault Namespace Declaration Node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Can't return the same node since it's unique to a specific DTM, 	TokenNameCOMMENT_LINE	Can't return the same node since it's unique to a specific DTM, 
// but can return the equivalent node -- find the corresponding 	TokenNameCOMMENT_LINE	but can return the equivalent node -- find the corresponding 
// Document Element, then ask it for the xml: namespace decl. 	TokenNameCOMMENT_LINE	Document Element, then ask it for the xml: namespace decl. 
handle	TokenNameIdentifier	 handle
=	TokenNameEQUAL	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
getHandleOfNode	TokenNameIdentifier	 get Handle Of Node
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Attr	TokenNameIdentifier	 Attr
)	TokenNameRPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
.	TokenNameDOT	
getOwnerElement	TokenNameIdentifier	 get Owner Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
handle	TokenNameIdentifier	 handle
=	TokenNameEQUAL	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
getAttributeNode	TokenNameIdentifier	 get Attribute Node
(	TokenNameLPAREN	
handle	TokenNameIdentifier	 handle
,	TokenNameCOMMA	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNamespaceURI	TokenNameIdentifier	 get Namespace URI
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
handle	TokenNameIdentifier	 handle
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
DOM2DTM	TokenNameIdentifier	 DO M2 DTM
)	TokenNameRPAREN	
dtm	TokenNameIdentifier	 dtm
)	TokenNameRPAREN	
.	TokenNameDOT	
getHandleOfNode	TokenNameIdentifier	 get Handle Of Node
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
==	TokenNameEQUAL_EQUAL	
handle	TokenNameIdentifier	 handle
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
XMLMessages	TokenNameIdentifier	 XML Messages
.	TokenNameDOT	
createXMLMessage	TokenNameIdentifier	 create XML Message
(	TokenNameLPAREN	
XMLErrorResources	TokenNameIdentifier	 XML Error Resources
.	TokenNameDOT	
ER_COULD_NOT_RESOLVE_NODE	TokenNameIdentifier	 ER  COULD  NOT  RESOLVE  NODE
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//"Could not resolve the node to a handle!"); 	TokenNameCOMMENT_LINE	"Could not resolve the node to a handle!"); 
return	TokenNamereturn	
handle	TokenNameIdentifier	 handle
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * This method returns the SAX2 parser to use with the InputSource * obtained from this URI. * It may return null if any SAX2-conformant XML parser can be used, * or if getInputSource() will also return null. The parser must * be free for use (i.e., not currently in use for another parse(). * After use of the parser is completed, the releaseXMLReader(XMLReader) * must be called. * * @param inputSource The value returned from the URIResolver. * @return a SAX2 XMLReader to use to resolve the inputSource argument. * * @return non-null XMLReader reference ready to parse. */	TokenNameCOMMENT_JAVADOC	 This method returns the SAX2 parser to use with the InputSource obtained from this URI. It may return null if any SAX2-conformant XML parser can be used, or if getInputSource() will also return null. The parser must be free for use (i.e., not currently in use for another parse(). After use of the parser is completed, the releaseXMLReader(XMLReader) must be called. * @param inputSource The value returned from the URIResolver. @return a SAX2 XMLReader to use to resolve the inputSource argument. * @return non-null XMLReader reference ready to parse. 
synchronized	TokenNamesynchronized	
public	TokenNamepublic	
XMLReader	TokenNameIdentifier	 XML Reader
getXMLReader	TokenNameIdentifier	 get XML Reader
(	TokenNameLPAREN	
Source	TokenNameIdentifier	 Source
inputSource	TokenNameIdentifier	 input Source
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
XMLReader	TokenNameIdentifier	 XML Reader
reader	TokenNameIdentifier	 reader
=	TokenNameEQUAL	
(	TokenNameLPAREN	
inputSource	TokenNameIdentifier	 input Source
instanceof	TokenNameinstanceof	
SAXSource	TokenNameIdentifier	 SAX Source
)	TokenNameRPAREN	
?	TokenNameQUESTION	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
SAXSource	TokenNameIdentifier	 SAX Source
)	TokenNameRPAREN	
inputSource	TokenNameIdentifier	 input Source
)	TokenNameRPAREN	
.	TokenNameDOT	
getXMLReader	TokenNameIdentifier	 get XML Reader
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// If user did not supply a reader, ask for one from the reader manager 	TokenNameCOMMENT_LINE	If user did not supply a reader, ask for one from the reader manager 
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
m_readerManager	TokenNameIdentifier	 m reader Manager
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
m_readerManager	TokenNameIdentifier	 m reader Manager
=	TokenNameEQUAL	
XMLReaderManager	TokenNameIdentifier	 XML Reader Manager
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
reader	TokenNameIdentifier	 reader
=	TokenNameEQUAL	
m_readerManager	TokenNameIdentifier	 m reader Manager
.	TokenNameDOT	
getXMLReader	TokenNameIdentifier	 get XML Reader
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
reader	TokenNameIdentifier	 reader
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
SAXException	TokenNameIdentifier	 SAX Exception
se	TokenNameIdentifier	 se
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
DTMException	TokenNameIdentifier	 DTM Exception
(	TokenNameLPAREN	
se	TokenNameIdentifier	 se
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
se	TokenNameIdentifier	 se
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Indicates that the XMLReader object is no longer in use for the transform. * * Note that the getXMLReader method may return an XMLReader that was * specified on the SAXSource object by the application code. Such a * reader should still be passed to releaseXMLReader, but the reader manager * will only re-use XMLReaders that it created. * * @param reader The XMLReader to be released. */	TokenNameCOMMENT_JAVADOC	 Indicates that the XMLReader object is no longer in use for the transform. * Note that the getXMLReader method may return an XMLReader that was specified on the SAXSource object by the application code. Such a reader should still be passed to releaseXMLReader, but the reader manager will only re-use XMLReaders that it created. * @param reader The XMLReader to be released. 
synchronized	TokenNamesynchronized	
public	TokenNamepublic	
void	TokenNamevoid	
releaseXMLReader	TokenNameIdentifier	 release XML Reader
(	TokenNameLPAREN	
XMLReader	TokenNameIdentifier	 XML Reader
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
m_readerManager	TokenNameIdentifier	 m reader Manager
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
m_readerManager	TokenNameIdentifier	 m reader Manager
.	TokenNameDOT	
releaseXMLReader	TokenNameIdentifier	 release XML Reader
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Return the DTM object containing a representation of this node. * * @param nodeHandle DTM Handle indicating which node to retrieve * * @return a reference to the DTM object containing this node. */	TokenNameCOMMENT_JAVADOC	 Return the DTM object containing a representation of this node. * @param nodeHandle DTM Handle indicating which node to retrieve * @return a reference to the DTM object containing this node. 
synchronized	TokenNamesynchronized	
public	TokenNamepublic	
DTM	TokenNameIdentifier	 DTM
getDTM	TokenNameIdentifier	 get DTM
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
// Performance critical function. 	TokenNameCOMMENT_LINE	Performance critical function. 
return	TokenNamereturn	
m_dtms	TokenNameIdentifier	 m dtms
[	TokenNameLBRACKET	
nodeHandle	TokenNameIdentifier	 node Handle
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
IDENT_DTM_NODE_BITS	TokenNameIdentifier	 IDENT  DTM  NODE  BITS
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
ArrayIndexOutOfBoundsException	TokenNameIdentifier	 Array Index Out Of Bounds Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
==	TokenNameEQUAL_EQUAL	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// Accept as a special case. 	TokenNameCOMMENT_LINE	Accept as a special case. 
else	TokenNameelse	
throw	TokenNamethrow	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
// Programming error; want to know about it. 	TokenNameCOMMENT_LINE	Programming error; want to know about it. 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Given a DTM, find the ID number in the DTM tables which addresses * the start of the document. If overflow addressing is in use, other * DTM IDs may also be assigned to this DTM. * * @param dtm The DTM which (hopefully) contains this node. * * @return The DTM ID (as the high bits of a NodeHandle, not as our * internal index), or -1 if the DTM doesn't belong to this manager. */	TokenNameCOMMENT_JAVADOC	 Given a DTM, find the ID number in the DTM tables which addresses the start of the document. If overflow addressing is in use, other DTM IDs may also be assigned to this DTM. * @param dtm The DTM which (hopefully) contains this node. * @return The DTM ID (as the high bits of a NodeHandle, not as our internal index), or -1 if the DTM doesn't belong to this manager. 
synchronized	TokenNamesynchronized	
public	TokenNamepublic	
int	TokenNameint	
getDTMIdentity	TokenNameIdentifier	 get DTM Identity
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
dtm	TokenNameIdentifier	 dtm
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Shortcut using DTMDefaultBase's extension hooks 	TokenNameCOMMENT_LINE	Shortcut using DTMDefaultBase's extension hooks 
// %REVIEW% Should the lookup be part of the basic DTM API? 	TokenNameCOMMENT_LINE	%REVIEW% Should the lookup be part of the basic DTM API? 
if	TokenNameif	
(	TokenNameLPAREN	
dtm	TokenNameIdentifier	 dtm
instanceof	TokenNameinstanceof	
DTMDefaultBase	TokenNameIdentifier	 DTM Default Base
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DTMDefaultBase	TokenNameIdentifier	 DTM Default Base
dtmdb	TokenNameIdentifier	 dtmdb
=	TokenNameEQUAL	
(	TokenNameLPAREN	
DTMDefaultBase	TokenNameIdentifier	 DTM Default Base
)	TokenNameRPAREN	
dtm	TokenNameIdentifier	 dtm
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dtmdb	TokenNameIdentifier	 dtmdb
.	TokenNameDOT	
getManager	TokenNameIdentifier	 get Manager
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
this	TokenNamethis	
)	TokenNameRPAREN	
return	TokenNamereturn	
dtmdb	TokenNameIdentifier	 dtmdb
.	TokenNameDOT	
getDTMIDs	TokenNameIdentifier	 get DTMI Ds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
m_dtms	TokenNameIdentifier	 m dtms
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
n	TokenNameIdentifier	 n
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DTM	TokenNameIdentifier	 DTM
tdtm	TokenNameIdentifier	 tdtm
=	TokenNameEQUAL	
m_dtms	TokenNameIdentifier	 m dtms
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
tdtm	TokenNameIdentifier	 tdtm
==	TokenNameEQUAL_EQUAL	
dtm	TokenNameIdentifier	 dtm
&&	TokenNameAND_AND	
m_dtm_offsets	TokenNameIdentifier	 m dtm offsets
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
i	TokenNameIdentifier	 i
<<	TokenNameLEFT_SHIFT	
IDENT_DTM_NODE_BITS	TokenNameIdentifier	 IDENT  DTM  NODE  BITS
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Release the DTMManager's reference(s) to a DTM, making it unmanaged. * This is typically done as part of returning the DTM to the heap after * we're done with it. * * @param dtm the DTM to be released. * * @param shouldHardDelete If false, this call is a suggestion rather than an * order, and we may not actually release the DTM. This is intended to * support intelligent caching of documents... which is not implemented * in this version of the DTM manager. * * @return true if the DTM was released, false if shouldHardDelete was set * and we decided not to. */	TokenNameCOMMENT_JAVADOC	 Release the DTMManager's reference(s) to a DTM, making it unmanaged. This is typically done as part of returning the DTM to the heap after we're done with it. * @param dtm the DTM to be released. * @param shouldHardDelete If false, this call is a suggestion rather than an order, and we may not actually release the DTM. This is intended to support intelligent caching of documents... which is not implemented in this version of the DTM manager. * @return true if the DTM was released, false if shouldHardDelete was set and we decided not to. 
synchronized	TokenNamesynchronized	
public	TokenNamepublic	
boolean	TokenNameboolean	
release	TokenNameIdentifier	 release
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
dtm	TokenNameIdentifier	 dtm
,	TokenNameCOMMA	
boolean	TokenNameboolean	
shouldHardDelete	TokenNameIdentifier	 should Hard Delete
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG	TokenNameIdentifier	 DEBUG
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Releasing "	TokenNameStringLiteral	Releasing 
+	TokenNamePLUS	
(	TokenNameLPAREN	
shouldHardDelete	TokenNameIdentifier	 should Hard Delete
?	TokenNameQUESTION	
"HARD"	TokenNameStringLiteral	HARD
:	TokenNameCOLON	
"soft"	TokenNameStringLiteral	soft
)	TokenNameRPAREN	
+	TokenNamePLUS	
" dtm="	TokenNameStringLiteral	 dtm=
+	TokenNamePLUS	
// Following shouldn't need a nodeHandle, but does... 	TokenNameCOMMENT_LINE	Following shouldn't need a nodeHandle, but does... 
// and doesn't seem to report the intended value 	TokenNameCOMMENT_LINE	and doesn't seem to report the intended value 
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
getDocumentBaseURI	TokenNameIdentifier	 get Document Base URI
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
dtm	TokenNameIdentifier	 dtm
instanceof	TokenNameinstanceof	
SAX2DTM	TokenNameIdentifier	 SA X2 DTM
)	TokenNameRPAREN	
{	TokenNameLBRACE	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
SAX2DTM	TokenNameIdentifier	 SA X2 DTM
)	TokenNameRPAREN	
dtm	TokenNameIdentifier	 dtm
)	TokenNameRPAREN	
.	TokenNameDOT	
clearCoRoutine	TokenNameIdentifier	 clear Co Routine
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Multiple DTM IDs may be assigned to a single DTM. 	TokenNameCOMMENT_LINE	Multiple DTM IDs may be assigned to a single DTM. 
// The Right Answer is to ask which (if it supports 	TokenNameCOMMENT_LINE	The Right Answer is to ask which (if it supports 
// extension, the DTM will need a list anyway). The 	TokenNameCOMMENT_LINE	extension, the DTM will need a list anyway). The 
// Wrong Answer, applied if the DTM can't help us, 	TokenNameCOMMENT_LINE	Wrong Answer, applied if the DTM can't help us, 
// is to linearly search them all; this may be very 	TokenNameCOMMENT_LINE	is to linearly search them all; this may be very 
// painful. 	TokenNameCOMMENT_LINE	painful. 
// 	TokenNameCOMMENT_LINE	 
// %REVIEW% Should the lookup move up into the basic DTM API? 	TokenNameCOMMENT_LINE	%REVIEW% Should the lookup move up into the basic DTM API? 
if	TokenNameif	
(	TokenNameLPAREN	
dtm	TokenNameIdentifier	 dtm
instanceof	TokenNameinstanceof	
DTMDefaultBase	TokenNameIdentifier	 DTM Default Base
)	TokenNameRPAREN	
{	TokenNameLBRACE	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
SuballocatedIntVector	TokenNameIdentifier	 Suballocated Int Vector
ids	TokenNameIdentifier	 ids
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
DTMDefaultBase	TokenNameIdentifier	 DTM Default Base
)	TokenNameRPAREN	
dtm	TokenNameIdentifier	 dtm
)	TokenNameRPAREN	
.	TokenNameDOT	
getDTMIDs	TokenNameIdentifier	 get DTMI Ds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
ids	TokenNameIdentifier	 ids
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
m_dtms	TokenNameIdentifier	 m dtms
[	TokenNameLBRACKET	
ids	TokenNameIdentifier	 ids
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
DTMManager	TokenNameIdentifier	 DTM Manager
.	TokenNameDOT	
IDENT_DTM_NODE_BITS	TokenNameIdentifier	 IDENT  DTM  NODE  BITS
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
getDTMIdentity	TokenNameIdentifier	 get DTM Identity
(	TokenNameLPAREN	
dtm	TokenNameIdentifier	 dtm
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
m_dtms	TokenNameIdentifier	 m dtms
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
DTMManager	TokenNameIdentifier	 DTM Manager
.	TokenNameDOT	
IDENT_DTM_NODE_BITS	TokenNameIdentifier	 IDENT  DTM  NODE  BITS
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
documentRelease	TokenNameIdentifier	 document Release
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Method createDocumentFragment * * * NEEDSDOC (createDocumentFragment) @return */	TokenNameCOMMENT_JAVADOC	 Method createDocumentFragment * NEEDSDOC (createDocumentFragment) @return 
synchronized	TokenNamesynchronized	
public	TokenNamepublic	
DTM	TokenNameIdentifier	 DTM
createDocumentFragment	TokenNameIdentifier	 create Document Fragment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
DocumentBuilderFactory	TokenNameIdentifier	 Document Builder Factory
dbf	TokenNameIdentifier	 dbf
=	TokenNameEQUAL	
DocumentBuilderFactory	TokenNameIdentifier	 Document Builder Factory
.	TokenNameDOT	
newInstance	TokenNameIdentifier	 new Instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dbf	TokenNameIdentifier	 dbf
.	TokenNameDOT	
setNamespaceAware	TokenNameIdentifier	 set Namespace Aware
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DocumentBuilder	TokenNameIdentifier	 Document Builder
db	TokenNameIdentifier	 db
=	TokenNameEQUAL	
dbf	TokenNameIdentifier	 dbf
.	TokenNameDOT	
newDocumentBuilder	TokenNameIdentifier	 new Document Builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Document	TokenNameIdentifier	 Document
doc	TokenNameIdentifier	 doc
=	TokenNameEQUAL	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
newDocument	TokenNameIdentifier	 new Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Node	TokenNameIdentifier	 Node
df	TokenNameIdentifier	 df
=	TokenNameEQUAL	
doc	TokenNameIdentifier	 doc
.	TokenNameDOT	
createDocumentFragment	TokenNameIdentifier	 create Document Fragment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
getDTM	TokenNameIdentifier	 get DTM
(	TokenNameLPAREN	
new	TokenNamenew	
DOMSource	TokenNameIdentifier	 DOM Source
(	TokenNameLPAREN	
df	TokenNameIdentifier	 df
)	TokenNameRPAREN	
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
DTMException	TokenNameIdentifier	 DTM Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * NEEDSDOC Method createDTMIterator * * * NEEDSDOC @param whatToShow * NEEDSDOC @param filter * NEEDSDOC @param entityReferenceExpansion * * NEEDSDOC (createDTMIterator) @return */	TokenNameCOMMENT_JAVADOC	 NEEDSDOC Method createDTMIterator * NEEDSDOC @param whatToShow NEEDSDOC @param filter NEEDSDOC @param entityReferenceExpansion * NEEDSDOC (createDTMIterator) @return 
synchronized	TokenNamesynchronized	
public	TokenNamepublic	
DTMIterator	TokenNameIdentifier	 DTM Iterator
createDTMIterator	TokenNameIdentifier	 create DTM Iterator
(	TokenNameLPAREN	
int	TokenNameint	
whatToShow	TokenNameIdentifier	 what To Show
,	TokenNameCOMMA	
DTMFilter	TokenNameIdentifier	 DTM Filter
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
boolean	TokenNameboolean	
entityReferenceExpansion	TokenNameIdentifier	 entity Reference Expansion
)	TokenNameRPAREN	
{	TokenNameLBRACE	
/** @todo: implement this org.apache.xml.dtm.DTMManager abstract method */	TokenNameCOMMENT_JAVADOC	 @todo: implement this org.apache.xml.dtm.DTMManager abstract method 
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * NEEDSDOC Method createDTMIterator * * * NEEDSDOC @param xpathString * NEEDSDOC @param presolver * * NEEDSDOC (createDTMIterator) @return */	TokenNameCOMMENT_JAVADOC	 NEEDSDOC Method createDTMIterator * NEEDSDOC @param xpathString NEEDSDOC @param presolver * NEEDSDOC (createDTMIterator) @return 
synchronized	TokenNamesynchronized	
public	TokenNamepublic	
DTMIterator	TokenNameIdentifier	 DTM Iterator
createDTMIterator	TokenNameIdentifier	 create DTM Iterator
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
xpathString	TokenNameIdentifier	 xpath String
,	TokenNameCOMMA	
PrefixResolver	TokenNameIdentifier	 Prefix Resolver
presolver	TokenNameIdentifier	 presolver
)	TokenNameRPAREN	
{	TokenNameLBRACE	
/** @todo: implement this org.apache.xml.dtm.DTMManager abstract method */	TokenNameCOMMENT_JAVADOC	 @todo: implement this org.apache.xml.dtm.DTMManager abstract method 
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * NEEDSDOC Method createDTMIterator * * * NEEDSDOC @param node * * NEEDSDOC (createDTMIterator) @return */	TokenNameCOMMENT_JAVADOC	 NEEDSDOC Method createDTMIterator * NEEDSDOC @param node * NEEDSDOC (createDTMIterator) @return 
synchronized	TokenNamesynchronized	
public	TokenNamepublic	
DTMIterator	TokenNameIdentifier	 DTM Iterator
createDTMIterator	TokenNameIdentifier	 create DTM Iterator
(	TokenNameLPAREN	
int	TokenNameint	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
/** @todo: implement this org.apache.xml.dtm.DTMManager abstract method */	TokenNameCOMMENT_JAVADOC	 @todo: implement this org.apache.xml.dtm.DTMManager abstract method 
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * NEEDSDOC Method createDTMIterator * * * NEEDSDOC @param xpathCompiler * NEEDSDOC @param pos * * NEEDSDOC (createDTMIterator) @return */	TokenNameCOMMENT_JAVADOC	 NEEDSDOC Method createDTMIterator * NEEDSDOC @param xpathCompiler NEEDSDOC @param pos * NEEDSDOC (createDTMIterator) @return 
synchronized	TokenNamesynchronized	
public	TokenNamepublic	
DTMIterator	TokenNameIdentifier	 DTM Iterator
createDTMIterator	TokenNameIdentifier	 create DTM Iterator
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
xpathCompiler	TokenNameIdentifier	 xpath Compiler
,	TokenNameCOMMA	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
/** @todo: implement this org.apache.xml.dtm.DTMManager abstract method */	TokenNameCOMMENT_JAVADOC	 @todo: implement this org.apache.xml.dtm.DTMManager abstract method 
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * return the expanded name table. * * NEEDSDOC @param dtm * * NEEDSDOC ($objectName$) @return */	TokenNameCOMMENT_JAVADOC	 return the expanded name table. * NEEDSDOC @param dtm * NEEDSDOC ($objectName$) @return 
public	TokenNamepublic	
ExpandedNameTable	TokenNameIdentifier	 Expanded Name Table
getExpandedNameTable	TokenNameIdentifier	 get Expanded Name Table
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
dtm	TokenNameIdentifier	 dtm
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
m_expandedNameTable	TokenNameIdentifier	 m expanded Name Table
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
