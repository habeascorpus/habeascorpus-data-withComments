/* Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
ext	TokenNameIdentifier	 ext
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
renderable	TokenNameIdentifier	 renderable
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
Rectangle	TokenNameIdentifier	 Rectangle
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
RenderingHints	TokenNameIdentifier	 Rendering Hints
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
Shape	TokenNameIdentifier	 Shape
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
geom	TokenNameIdentifier	 geom
.	TokenNameDOT	
AffineTransform	TokenNameIdentifier	 Affine Transform
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
geom	TokenNameIdentifier	 geom
.	TokenNameDOT	
NoninvertibleTransformException	TokenNameIdentifier	 Noninvertible Transform Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
geom	TokenNameIdentifier	 geom
.	TokenNameDOT	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
RenderedImage	TokenNameIdentifier	 Rendered Image
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
renderable	TokenNameIdentifier	 renderable
.	TokenNameDOT	
RenderContext	TokenNameIdentifier	 Render Context
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
ext	TokenNameIdentifier	 ext
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
PadMode	TokenNameIdentifier	 Pad Mode
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
ext	TokenNameIdentifier	 ext
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
rendered	TokenNameIdentifier	 rendered
.	TokenNameDOT	
AffineRed	TokenNameIdentifier	 Affine Red
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
ext	TokenNameIdentifier	 ext
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
rendered	TokenNameIdentifier	 rendered
.	TokenNameDOT	
CachableRed	TokenNameIdentifier	 Cachable Red
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
ext	TokenNameIdentifier	 ext
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
rendered	TokenNameIdentifier	 rendered
.	TokenNameDOT	
GaussianBlurRed8Bit	TokenNameIdentifier	 Gaussian Blur Red8 Bit
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
ext	TokenNameIdentifier	 ext
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
rendered	TokenNameIdentifier	 rendered
.	TokenNameDOT	
PadRed	TokenNameIdentifier	 Pad Red
;	TokenNameSEMICOLON	
/** * GaussianBlurRable implementation * * @author <a href="mailto:vincent.hardy@eng.sun.com">Vincent Hardy</a> * @version $Id: GaussianBlurRable8Bit.java 501495 2007-01-30 18:00:36Z dvholten $ */	TokenNameCOMMENT_JAVADOC	 GaussianBlurRable implementation * @author <a href="mailto:vincent.hardy@eng.sun.com">Vincent Hardy</a> @version $Id: GaussianBlurRable8Bit.java 501495 2007-01-30 18:00:36Z dvholten $ 
public	TokenNamepublic	
class	TokenNameclass	
GaussianBlurRable8Bit	TokenNameIdentifier	 Gaussian Blur Rable8 Bit
extends	TokenNameextends	
AbstractColorInterpolationRable	TokenNameIdentifier	 Abstract Color Interpolation Rable
implements	TokenNameimplements	
GaussianBlurRable	TokenNameIdentifier	 Gaussian Blur Rable
{	TokenNameLBRACE	
/** * Deviation along the x-axis */	TokenNameCOMMENT_JAVADOC	 Deviation along the x-axis 
private	TokenNameprivate	
double	TokenNamedouble	
stdDeviationX	TokenNameIdentifier	 std Deviation X
;	TokenNameSEMICOLON	
/** * Deviation along the y-axis */	TokenNameCOMMENT_JAVADOC	 Deviation along the y-axis 
private	TokenNameprivate	
double	TokenNamedouble	
stdDeviationY	TokenNameIdentifier	 std Deviation Y
;	TokenNameSEMICOLON	
public	TokenNamepublic	
GaussianBlurRable8Bit	TokenNameIdentifier	 Gaussian Blur Rable8 Bit
(	TokenNameLPAREN	
Filter	TokenNameIdentifier	 Filter
src	TokenNameIdentifier	 src
,	TokenNameCOMMA	
double	TokenNamedouble	
stdevX	TokenNameIdentifier	 stdev X
,	TokenNameCOMMA	
double	TokenNamedouble	
stdevY	TokenNameIdentifier	 stdev Y
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setStdDeviationX	TokenNameIdentifier	 set Std Deviation X
(	TokenNameLPAREN	
stdevX	TokenNameIdentifier	 stdev X
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setStdDeviationY	TokenNameIdentifier	 set Std Deviation Y
(	TokenNameLPAREN	
stdevY	TokenNameIdentifier	 stdev Y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The deviation along the x axis, in user space. * @param stdDeviationX should be greater than zero. */	TokenNameCOMMENT_JAVADOC	 The deviation along the x axis, in user space. @param stdDeviationX should be greater than zero. 
public	TokenNamepublic	
void	TokenNamevoid	
setStdDeviationX	TokenNameIdentifier	 set Std Deviation X
(	TokenNameLPAREN	
double	TokenNamedouble	
stdDeviationX	TokenNameIdentifier	 std Deviation X
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
stdDeviationX	TokenNameIdentifier	 std Deviation X
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
touch	TokenNameIdentifier	 touch
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
stdDeviationX	TokenNameIdentifier	 std Deviation X
=	TokenNameEQUAL	
stdDeviationX	TokenNameIdentifier	 std Deviation X
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The deviation along the y axis, in user space. * @param stdDeviationY should be greater than zero */	TokenNameCOMMENT_JAVADOC	 The deviation along the y axis, in user space. @param stdDeviationY should be greater than zero 
public	TokenNamepublic	
void	TokenNamevoid	
setStdDeviationY	TokenNameIdentifier	 set Std Deviation Y
(	TokenNameLPAREN	
double	TokenNamedouble	
stdDeviationY	TokenNameIdentifier	 std Deviation Y
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
stdDeviationY	TokenNameIdentifier	 std Deviation Y
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
touch	TokenNameIdentifier	 touch
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
stdDeviationY	TokenNameIdentifier	 std Deviation Y
=	TokenNameEQUAL	
stdDeviationY	TokenNameIdentifier	 std Deviation Y
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the deviation along the x-axis, in user space. */	TokenNameCOMMENT_JAVADOC	 Returns the deviation along the x-axis, in user space. 
public	TokenNamepublic	
double	TokenNamedouble	
getStdDeviationX	TokenNameIdentifier	 get Std Deviation X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
stdDeviationX	TokenNameIdentifier	 std Deviation X
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the deviation along the y-axis, in user space. */	TokenNameCOMMENT_JAVADOC	 Returns the deviation along the y-axis, in user space. 
public	TokenNamepublic	
double	TokenNamedouble	
getStdDeviationY	TokenNameIdentifier	 get Std Deviation Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
stdDeviationY	TokenNameIdentifier	 std Deviation Y
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets the source of the blur operation */	TokenNameCOMMENT_JAVADOC	 Sets the source of the blur operation 
public	TokenNamepublic	
void	TokenNamevoid	
setSource	TokenNameIdentifier	 set Source
(	TokenNameLPAREN	
Filter	TokenNameIdentifier	 Filter
src	TokenNameIdentifier	 src
)	TokenNameRPAREN	
{	TokenNameLBRACE	
init	TokenNameIdentifier	 init
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Constant: 3*sqrt(2*PI)/4 */	TokenNameCOMMENT_JAVADOC	 Constant: 3*sqrt(2*PI)/4 
static	TokenNamestatic	
final	TokenNamefinal	
double	TokenNamedouble	
DSQRT2PI	TokenNameIdentifier	 DSQR T2 PI
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
sqrt	TokenNameIdentifier	 sqrt
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
PI	TokenNameIdentifier	 PI
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
3.0	TokenNameDoubleLiteral	
/	TokenNameDIVIDE	
4.0	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Grow the source's bounds */	TokenNameCOMMENT_JAVADOC	 Grow the source's bounds 
public	TokenNamepublic	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
getBounds2D	TokenNameIdentifier	 get Bounds2 D
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
src	TokenNameIdentifier	 src
=	TokenNameEQUAL	
getSource	TokenNameIdentifier	 get Source
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getBounds2D	TokenNameIdentifier	 get Bounds2 D
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
dX	TokenNameIdentifier	 d X
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
stdDeviationX	TokenNameIdentifier	 std Deviation X
*	TokenNameMULTIPLY	
DSQRT2PI	TokenNameIdentifier	 DSQR T2 PI
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
dY	TokenNameIdentifier	 d Y
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
stdDeviationY	TokenNameIdentifier	 std Deviation Y
*	TokenNameMULTIPLY	
DSQRT2PI	TokenNameIdentifier	 DSQR T2 PI
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
radX	TokenNameIdentifier	 rad X
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
dX	TokenNameIdentifier	 d X
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
radY	TokenNameIdentifier	 rad Y
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
dY	TokenNameIdentifier	 d Y
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
(	TokenNameLPAREN	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getMinX	TokenNameIdentifier	 get Min X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
radX	TokenNameIdentifier	 rad X
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getMinY	TokenNameIdentifier	 get Min Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
radY	TokenNameIdentifier	 rad Y
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
radX	TokenNameIdentifier	 rad X
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
radY	TokenNameIdentifier	 rad Y
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the source of the blur operation */	TokenNameCOMMENT_JAVADOC	 Returns the source of the blur operation 
public	TokenNamepublic	
Filter	TokenNameIdentifier	 Filter
getSource	TokenNameIdentifier	 get Source
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
Filter	TokenNameIdentifier	 Filter
)	TokenNameRPAREN	
getSources	TokenNameIdentifier	 get Sources
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
double	TokenNamedouble	
eps	TokenNameIdentifier	 eps
=	TokenNameEQUAL	
0.0001	TokenNameDoubleLiteral	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
eps_eq	TokenNameIdentifier	 eps eq
(	TokenNameLPAREN	
double	TokenNamedouble	
f1	TokenNameIdentifier	 f1
,	TokenNameCOMMA	
double	TokenNamedouble	
f2	TokenNameIdentifier	 f2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
f1	TokenNameIdentifier	 f1
>=	TokenNameGREATER_EQUAL	
f2	TokenNameIdentifier	 f2
-	TokenNameMINUS	
eps	TokenNameIdentifier	 eps
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
f1	TokenNameIdentifier	 f1
<=	TokenNameLESS_EQUAL	
f2	TokenNameIdentifier	 f2
+	TokenNamePLUS	
eps	TokenNameIdentifier	 eps
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
eps_abs_eq	TokenNameIdentifier	 eps abs eq
(	TokenNameLPAREN	
double	TokenNamedouble	
f1	TokenNameIdentifier	 f1
,	TokenNameCOMMA	
double	TokenNamedouble	
f2	TokenNameIdentifier	 f2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
f1	TokenNameIdentifier	 f1
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
f1	TokenNameIdentifier	 f1
=	TokenNameEQUAL	
-	TokenNameMINUS	
f1	TokenNameIdentifier	 f1
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
f2	TokenNameIdentifier	 f2
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
f2	TokenNameIdentifier	 f2
=	TokenNameEQUAL	
-	TokenNameMINUS	
f2	TokenNameIdentifier	 f2
;	TokenNameSEMICOLON	
return	TokenNamereturn	
eps_eq	TokenNameIdentifier	 eps eq
(	TokenNameLPAREN	
f1	TokenNameIdentifier	 f1
,	TokenNameCOMMA	
f2	TokenNameIdentifier	 f2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
RenderedImage	TokenNameIdentifier	 Rendered Image
createRendering	TokenNameIdentifier	 create Rendering
(	TokenNameLPAREN	
RenderContext	TokenNameIdentifier	 Render Context
rc	TokenNameIdentifier	 rc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Just copy over the rendering hints. 	TokenNameCOMMENT_LINE	Just copy over the rendering hints. 
RenderingHints	TokenNameIdentifier	 Rendering Hints
rh	TokenNameIdentifier	 rh
=	TokenNameEQUAL	
rc	TokenNameIdentifier	 rc
.	TokenNameDOT	
getRenderingHints	TokenNameIdentifier	 get Rendering Hints
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
rh	TokenNameIdentifier	 rh
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
rh	TokenNameIdentifier	 rh
=	TokenNameEQUAL	
new	TokenNamenew	
RenderingHints	TokenNameIdentifier	 Rendering Hints
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// update the current affine transform 	TokenNameCOMMENT_LINE	update the current affine transform 
AffineTransform	TokenNameIdentifier	 Affine Transform
at	TokenNameIdentifier	 at
=	TokenNameEQUAL	
rc	TokenNameIdentifier	 rc
.	TokenNameDOT	
getTransform	TokenNameIdentifier	 get Transform
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// This splits out the scale and applies it 	TokenNameCOMMENT_LINE	This splits out the scale and applies it 
// prior to the Gaussian. Then after appying the gaussian 	TokenNameCOMMENT_LINE	prior to the Gaussian. Then after appying the gaussian 
// it applies the shear (rotation) and translation components. 	TokenNameCOMMENT_LINE	it applies the shear (rotation) and translation components. 
double	TokenNamedouble	
sx	TokenNameIdentifier	 sx
=	TokenNameEQUAL	
at	TokenNameIdentifier	 at
.	TokenNameDOT	
getScaleX	TokenNameIdentifier	 get Scale X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
sy	TokenNameIdentifier	 sy
=	TokenNameEQUAL	
at	TokenNameIdentifier	 at
.	TokenNameDOT	
getScaleY	TokenNameIdentifier	 get Scale Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
shx	TokenNameIdentifier	 shx
=	TokenNameEQUAL	
at	TokenNameIdentifier	 at
.	TokenNameDOT	
getShearX	TokenNameIdentifier	 get Shear X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
shy	TokenNameIdentifier	 shy
=	TokenNameEQUAL	
at	TokenNameIdentifier	 at
.	TokenNameDOT	
getShearY	TokenNameIdentifier	 get Shear Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
tx	TokenNameIdentifier	 tx
=	TokenNameEQUAL	
at	TokenNameIdentifier	 at
.	TokenNameDOT	
getTranslateX	TokenNameIdentifier	 get Translate X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
ty	TokenNameIdentifier	 ty
=	TokenNameEQUAL	
at	TokenNameIdentifier	 at
.	TokenNameDOT	
getTranslateY	TokenNameIdentifier	 get Translate Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// The Scale is the "hypotonose" of the matrix vectors. 	TokenNameCOMMENT_LINE	The Scale is the "hypotonose" of the matrix vectors. 
double	TokenNamedouble	
scaleX	TokenNameIdentifier	 scale X
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
sqrt	TokenNameIdentifier	 sqrt
(	TokenNameLPAREN	
sx	TokenNameIdentifier	 sx
*	TokenNameMULTIPLY	
sx	TokenNameIdentifier	 sx
+	TokenNamePLUS	
shy	TokenNameIdentifier	 shy
*	TokenNameMULTIPLY	
shy	TokenNameIdentifier	 shy
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
scaleY	TokenNameIdentifier	 scale Y
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
sqrt	TokenNameIdentifier	 sqrt
(	TokenNameLPAREN	
sy	TokenNameIdentifier	 sy
*	TokenNameMULTIPLY	
sy	TokenNameIdentifier	 sy
+	TokenNamePLUS	
shx	TokenNameIdentifier	 shx
*	TokenNameMULTIPLY	
shx	TokenNameIdentifier	 shx
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
sdx	TokenNameIdentifier	 sdx
=	TokenNameEQUAL	
stdDeviationX	TokenNameIdentifier	 std Deviation X
*	TokenNameMULTIPLY	
scaleX	TokenNameIdentifier	 scale X
;	TokenNameSEMICOLON	
double	TokenNamedouble	
sdy	TokenNameIdentifier	 sdy
=	TokenNameEQUAL	
stdDeviationY	TokenNameIdentifier	 std Deviation Y
*	TokenNameMULTIPLY	
scaleY	TokenNameIdentifier	 scale Y
;	TokenNameSEMICOLON	
// This is the affine transform between our usr space and an 	TokenNameCOMMENT_LINE	This is the affine transform between our usr space and an 
// intermediate space which is scaled similarly to our device 	TokenNameCOMMENT_LINE	intermediate space which is scaled similarly to our device 
// space but is still axially aligned with our device space. 	TokenNameCOMMENT_LINE	space but is still axially aligned with our device space. 
AffineTransform	TokenNameIdentifier	 Affine Transform
srcAt	TokenNameIdentifier	 src At
;	TokenNameSEMICOLON	
// This is the affine transform between our intermediate 	TokenNameCOMMENT_LINE	This is the affine transform between our intermediate 
// coordinate space and the real device space, or null (if 	TokenNameCOMMENT_LINE	coordinate space and the real device space, or null (if 
// we don't need an intermediate space). 	TokenNameCOMMENT_LINE	we don't need an intermediate space). 
AffineTransform	TokenNameIdentifier	 Affine Transform
resAt	TokenNameIdentifier	 res At
;	TokenNameSEMICOLON	
int	TokenNameint	
outsetX	TokenNameIdentifier	 outset X
,	TokenNameCOMMA	
outsetY	TokenNameIdentifier	 outset Y
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
sdx	TokenNameIdentifier	 sdx
<	TokenNameLESS	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
sdy	TokenNameIdentifier	 sdy
<	TokenNameLESS	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
eps_eq	TokenNameIdentifier	 eps eq
(	TokenNameLPAREN	
sdx	TokenNameIdentifier	 sdx
,	TokenNameCOMMA	
sdy	TokenNameIdentifier	 sdy
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
eps_abs_eq	TokenNameIdentifier	 eps abs eq
(	TokenNameLPAREN	
sx	TokenNameIdentifier	 sx
/	TokenNameDIVIDE	
scaleX	TokenNameIdentifier	 scale X
,	TokenNameCOMMA	
sy	TokenNameIdentifier	 sy
/	TokenNameDIVIDE	
scaleY	TokenNameIdentifier	 scale Y
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Ok we have a square Gaussian kernel which means it is 	TokenNameCOMMENT_LINE	Ok we have a square Gaussian kernel which means it is 
// circularly symetric, further our residual matrix (after 	TokenNameCOMMENT_LINE	circularly symetric, further our residual matrix (after 
// removing scaling) is a rotation matrix (perhaps with 	TokenNameCOMMENT_LINE	removing scaling) is a rotation matrix (perhaps with 
// mirroring), thus we can generate our source directly in 	TokenNameCOMMENT_LINE	mirroring), thus we can generate our source directly in 
// device space and convolve there rather than going to an 	TokenNameCOMMENT_LINE	device space and convolve there rather than going to an 
// intermediate space (axially aligned with usr space) and 	TokenNameCOMMENT_LINE	intermediate space (axially aligned with usr space) and 
// then completing the requested rotation/shear, with an 	TokenNameCOMMENT_LINE	then completing the requested rotation/shear, with an 
// AffineRed... 	TokenNameCOMMENT_LINE	AffineRed... 
srcAt	TokenNameIdentifier	 src At
=	TokenNameEQUAL	
at	TokenNameIdentifier	 at
;	TokenNameSEMICOLON	
resAt	TokenNameIdentifier	 res At
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
outsetX	TokenNameIdentifier	 outset X
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
outsetY	TokenNameIdentifier	 outset Y
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Limit std dev to 10. Put any extra into our 	TokenNameCOMMENT_LINE	Limit std dev to 10. Put any extra into our 
// residual matrix. This will effectively linearly 	TokenNameCOMMENT_LINE	residual matrix. This will effectively linearly 
// interpolate, but with such a large StdDev the 	TokenNameCOMMENT_LINE	interpolate, but with such a large StdDev the 
// function is fairly smooth anyway... 	TokenNameCOMMENT_LINE	function is fairly smooth anyway... 
if	TokenNameif	
(	TokenNameLPAREN	
sdx	TokenNameIdentifier	 sdx
>	TokenNameGREATER	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
scaleX	TokenNameIdentifier	 scale X
=	TokenNameEQUAL	
scaleX	TokenNameIdentifier	 scale X
*	TokenNameMULTIPLY	
10	TokenNameIntegerLiteral	
/	TokenNameDIVIDE	
sdx	TokenNameIdentifier	 sdx
;	TokenNameSEMICOLON	
sdx	TokenNameIdentifier	 sdx
=	TokenNameEQUAL	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
sdy	TokenNameIdentifier	 sdy
>	TokenNameGREATER	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
scaleY	TokenNameIdentifier	 scale Y
=	TokenNameEQUAL	
scaleY	TokenNameIdentifier	 scale Y
*	TokenNameMULTIPLY	
10	TokenNameIntegerLiteral	
/	TokenNameDIVIDE	
sdy	TokenNameIdentifier	 sdy
;	TokenNameSEMICOLON	
sdy	TokenNameIdentifier	 sdy
=	TokenNameEQUAL	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Scale to device coords. 	TokenNameCOMMENT_LINE	Scale to device coords. 
srcAt	TokenNameIdentifier	 src At
=	TokenNameEQUAL	
AffineTransform	TokenNameIdentifier	 Affine Transform
.	TokenNameDOT	
getScaleInstance	TokenNameIdentifier	 get Scale Instance
(	TokenNameLPAREN	
scaleX	TokenNameIdentifier	 scale X
,	TokenNameCOMMA	
scaleY	TokenNameIdentifier	 scale Y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// The shear/rotation simply divides out the 	TokenNameCOMMENT_LINE	The shear/rotation simply divides out the 
// common scale factor in the matrix. 	TokenNameCOMMENT_LINE	common scale factor in the matrix. 
resAt	TokenNameIdentifier	 res At
=	TokenNameEQUAL	
new	TokenNamenew	
AffineTransform	TokenNameIdentifier	 Affine Transform
(	TokenNameLPAREN	
sx	TokenNameIdentifier	 sx
/	TokenNameDIVIDE	
scaleX	TokenNameIdentifier	 scale X
,	TokenNameCOMMA	
shy	TokenNameIdentifier	 shy
/	TokenNameDIVIDE	
scaleX	TokenNameIdentifier	 scale X
,	TokenNameCOMMA	
shx	TokenNameIdentifier	 shx
/	TokenNameDIVIDE	
scaleY	TokenNameIdentifier	 scale Y
,	TokenNameCOMMA	
sy	TokenNameIdentifier	 sy
/	TokenNameDIVIDE	
scaleY	TokenNameIdentifier	 scale Y
,	TokenNameCOMMA	
tx	TokenNameIdentifier	 tx
,	TokenNameCOMMA	
ty	TokenNameIdentifier	 ty
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Add a pixel all around for the affine to interpolate with. 	TokenNameCOMMENT_LINE	Add a pixel all around for the affine to interpolate with. 
outsetX	TokenNameIdentifier	 outset X
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
outsetY	TokenNameIdentifier	 outset Y
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Shape	TokenNameIdentifier	 Shape
aoi	TokenNameIdentifier	 aoi
=	TokenNameEQUAL	
rc	TokenNameIdentifier	 rc
.	TokenNameDOT	
getAreaOfInterest	TokenNameIdentifier	 get Area Of Interest
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
aoi	TokenNameIdentifier	 aoi
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
aoi	TokenNameIdentifier	 aoi
=	TokenNameEQUAL	
getBounds2D	TokenNameIdentifier	 get Bounds2 D
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Shape	TokenNameIdentifier	 Shape
devShape	TokenNameIdentifier	 dev Shape
=	TokenNameEQUAL	
srcAt	TokenNameIdentifier	 src At
.	TokenNameDOT	
createTransformedShape	TokenNameIdentifier	 create Transformed Shape
(	TokenNameLPAREN	
aoi	TokenNameIdentifier	 aoi
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Rectangle	TokenNameIdentifier	 Rectangle
devRect	TokenNameIdentifier	 dev Rect
=	TokenNameEQUAL	
devShape	TokenNameIdentifier	 dev Shape
.	TokenNameDOT	
getBounds	TokenNameIdentifier	 get Bounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
outsetX	TokenNameIdentifier	 outset X
+=	TokenNamePLUS_EQUAL	
GaussianBlurRed8Bit	TokenNameIdentifier	 Gaussian Blur Red8 Bit
.	TokenNameDOT	
surroundPixels	TokenNameIdentifier	 surround Pixels
(	TokenNameLPAREN	
sdx	TokenNameIdentifier	 sdx
,	TokenNameCOMMA	
rh	TokenNameIdentifier	 rh
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
outsetY	TokenNameIdentifier	 outset Y
+=	TokenNamePLUS_EQUAL	
GaussianBlurRed8Bit	TokenNameIdentifier	 Gaussian Blur Red8 Bit
.	TokenNameDOT	
surroundPixels	TokenNameIdentifier	 surround Pixels
(	TokenNameLPAREN	
sdy	TokenNameIdentifier	 sdy
,	TokenNameCOMMA	
rh	TokenNameIdentifier	 rh
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
devRect	TokenNameIdentifier	 dev Rect
.	TokenNameDOT	
x	TokenNameIdentifier	 x
-=	TokenNameMINUS_EQUAL	
outsetX	TokenNameIdentifier	 outset X
;	TokenNameSEMICOLON	
devRect	TokenNameIdentifier	 dev Rect
.	TokenNameDOT	
y	TokenNameIdentifier	 y
-=	TokenNameMINUS_EQUAL	
outsetY	TokenNameIdentifier	 outset Y
;	TokenNameSEMICOLON	
devRect	TokenNameIdentifier	 dev Rect
.	TokenNameDOT	
width	TokenNameIdentifier	 width
+=	TokenNamePLUS_EQUAL	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
outsetX	TokenNameIdentifier	 outset X
;	TokenNameSEMICOLON	
devRect	TokenNameIdentifier	 dev Rect
.	TokenNameDOT	
height	TokenNameIdentifier	 height
+=	TokenNamePLUS_EQUAL	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
outsetY	TokenNameIdentifier	 outset Y
;	TokenNameSEMICOLON	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
r	TokenNameIdentifier	 r
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
AffineTransform	TokenNameIdentifier	 Affine Transform
invSrcAt	TokenNameIdentifier	 inv Src At
=	TokenNameEQUAL	
srcAt	TokenNameIdentifier	 src At
.	TokenNameDOT	
createInverse	TokenNameIdentifier	 create Inverse
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
invSrcAt	TokenNameIdentifier	 inv Src At
.	TokenNameDOT	
createTransformedShape	TokenNameIdentifier	 create Transformed Shape
(	TokenNameLPAREN	
devRect	TokenNameIdentifier	 dev Rect
)	TokenNameRPAREN	
.	TokenNameDOT	
getBounds2D	TokenNameIdentifier	 get Bounds2 D
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
NoninvertibleTransformException	TokenNameIdentifier	 Noninvertible Transform Exception
nte	TokenNameIdentifier	 nte
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Grow the region in usr space. 	TokenNameCOMMENT_LINE	Grow the region in usr space. 
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
aoi	TokenNameIdentifier	 aoi
.	TokenNameDOT	
getBounds2D	TokenNameIdentifier	 get Bounds2 D
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
new	TokenNamenew	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
.	TokenNameDOT	
Double	TokenNameIdentifier	 Double
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
outsetX	TokenNameIdentifier	 outset X
/	TokenNameDIVIDE	
scaleX	TokenNameIdentifier	 scale X
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
outsetY	TokenNameIdentifier	 outset Y
/	TokenNameDIVIDE	
scaleY	TokenNameIdentifier	 scale Y
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
outsetX	TokenNameIdentifier	 outset X
/	TokenNameDIVIDE	
scaleX	TokenNameIdentifier	 scale X
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
outsetY	TokenNameIdentifier	 outset Y
/	TokenNameDIVIDE	
scaleY	TokenNameIdentifier	 scale Y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
RenderedImage	TokenNameIdentifier	 Rendered Image
ri	TokenNameIdentifier	 ri
;	TokenNameSEMICOLON	
ri	TokenNameIdentifier	 ri
=	TokenNameEQUAL	
getSource	TokenNameIdentifier	 get Source
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
createRendering	TokenNameIdentifier	 create Rendering
(	TokenNameLPAREN	
new	TokenNamenew	
RenderContext	TokenNameIdentifier	 Render Context
(	TokenNameLPAREN	
srcAt	TokenNameIdentifier	 src At
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
rh	TokenNameIdentifier	 rh
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ri	TokenNameIdentifier	 ri
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
CachableRed	TokenNameIdentifier	 Cachable Red
cr	TokenNameIdentifier	 cr
=	TokenNameEQUAL	
convertSourceCS	TokenNameIdentifier	 convert Source CS
(	TokenNameLPAREN	
ri	TokenNameIdentifier	 ri
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// System.out.println("DevRect: " + devRect); 	TokenNameCOMMENT_LINE	System.out.println("DevRect: " + devRect); 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
devRect	TokenNameIdentifier	 dev Rect
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
cr	TokenNameIdentifier	 cr
.	TokenNameDOT	
getBounds	TokenNameIdentifier	 get Bounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// System.out.println("MisMatch Dev:" + devRect); 	TokenNameCOMMENT_LINE	System.out.println("MisMatch Dev:" + devRect); 
// System.out.println(" CR :" + cr.getBounds()); 	TokenNameCOMMENT_LINE	System.out.println(" CR :" + cr.getBounds()); 
cr	TokenNameIdentifier	 cr
=	TokenNameEQUAL	
new	TokenNamenew	
PadRed	TokenNameIdentifier	 Pad Red
(	TokenNameLPAREN	
cr	TokenNameIdentifier	 cr
,	TokenNameCOMMA	
devRect	TokenNameIdentifier	 dev Rect
,	TokenNameCOMMA	
PadMode	TokenNameIdentifier	 Pad Mode
.	TokenNameDOT	
ZERO_PAD	TokenNameIdentifier	 ZERO  PAD
,	TokenNameCOMMA	
rh	TokenNameIdentifier	 rh
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
cr	TokenNameIdentifier	 cr
=	TokenNameEQUAL	
new	TokenNamenew	
GaussianBlurRed8Bit	TokenNameIdentifier	 Gaussian Blur Red8 Bit
(	TokenNameLPAREN	
cr	TokenNameIdentifier	 cr
,	TokenNameCOMMA	
sdx	TokenNameIdentifier	 sdx
,	TokenNameCOMMA	
sdy	TokenNameIdentifier	 sdy
,	TokenNameCOMMA	
rh	TokenNameIdentifier	 rh
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
resAt	TokenNameIdentifier	 res At
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
!	TokenNameNOT	
resAt	TokenNameIdentifier	 res At
.	TokenNameDOT	
isIdentity	TokenNameIdentifier	 is Identity
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
cr	TokenNameIdentifier	 cr
=	TokenNameEQUAL	
new	TokenNamenew	
AffineRed	TokenNameIdentifier	 Affine Red
(	TokenNameLPAREN	
cr	TokenNameIdentifier	 cr
,	TokenNameCOMMA	
resAt	TokenNameIdentifier	 res At
,	TokenNameCOMMA	
rh	TokenNameIdentifier	 rh
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
cr	TokenNameIdentifier	 cr
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the region of input data is is required to generate * outputRgn. * @param srcIndex The source to do the dependency calculation for. * @param outputRgn The region of output you are interested in * generating dependencies for. The is given in the user coordiate * system for this node. * @return The region of input required. This is in the user * coordinate system for the source indicated by srcIndex. */	TokenNameCOMMENT_JAVADOC	 Returns the region of input data is is required to generate outputRgn. @param srcIndex The source to do the dependency calculation for. @param outputRgn The region of output you are interested in generating dependencies for. The is given in the user coordiate system for this node. @return The region of input required. This is in the user coordinate system for the source indicated by srcIndex. 
public	TokenNamepublic	
Shape	TokenNameIdentifier	 Shape
getDependencyRegion	TokenNameIdentifier	 get Dependency Region
(	TokenNameLPAREN	
int	TokenNameint	
srcIndex	TokenNameIdentifier	 src Index
,	TokenNameCOMMA	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
outputRgn	TokenNameIdentifier	 output Rgn
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
srcIndex	TokenNameIdentifier	 src Index
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
outputRgn	TokenNameIdentifier	 output Rgn
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
else	TokenNameelse	
{	TokenNameLBRACE	
// There is only one source in GaussianBlur 	TokenNameCOMMENT_LINE	There is only one source in GaussianBlur 
float	TokenNamefloat	
dX	TokenNameIdentifier	 d X
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
stdDeviationX	TokenNameIdentifier	 std Deviation X
*	TokenNameMULTIPLY	
DSQRT2PI	TokenNameIdentifier	 DSQR T2 PI
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
dY	TokenNameIdentifier	 d Y
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
stdDeviationY	TokenNameIdentifier	 std Deviation Y
*	TokenNameMULTIPLY	
DSQRT2PI	TokenNameIdentifier	 DSQR T2 PI
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
radX	TokenNameIdentifier	 rad X
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
dX	TokenNameIdentifier	 d X
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
radY	TokenNameIdentifier	 rad Y
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
dY	TokenNameIdentifier	 d Y
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
outputRgn	TokenNameIdentifier	 output Rgn
=	TokenNameEQUAL	
new	TokenNamenew	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
(	TokenNameLPAREN	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
outputRgn	TokenNameIdentifier	 output Rgn
.	TokenNameDOT	
getMinX	TokenNameIdentifier	 get Min X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
radX	TokenNameIdentifier	 rad X
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
outputRgn	TokenNameIdentifier	 output Rgn
.	TokenNameDOT	
getMinY	TokenNameIdentifier	 get Min Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
radY	TokenNameIdentifier	 rad Y
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
outputRgn	TokenNameIdentifier	 output Rgn
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
radX	TokenNameIdentifier	 rad X
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
outputRgn	TokenNameIdentifier	 output Rgn
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
radY	TokenNameIdentifier	 rad Y
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
bounds	TokenNameIdentifier	 bounds
=	TokenNameEQUAL	
getBounds2D	TokenNameIdentifier	 get Bounds2 D
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
outputRgn	TokenNameIdentifier	 output Rgn
.	TokenNameDOT	
intersects	TokenNameIdentifier	 intersects
(	TokenNameLPAREN	
bounds	TokenNameIdentifier	 bounds
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
new	TokenNamenew	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Intersect with output region 	TokenNameCOMMENT_LINE	Intersect with output region 
outputRgn	TokenNameIdentifier	 output Rgn
=	TokenNameEQUAL	
outputRgn	TokenNameIdentifier	 output Rgn
.	TokenNameDOT	
createIntersection	TokenNameIdentifier	 create Intersection
(	TokenNameLPAREN	
bounds	TokenNameIdentifier	 bounds
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
outputRgn	TokenNameIdentifier	 output Rgn
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * This calculates the region of output that is affected by a change * in a region of input. * @param srcIndex The input that inputRgn reflects changes in. * @param inputRgn the region of input that has changed, used to * calculate the returned shape. This is given in the user * coordinate system of the source indicated by srcIndex. * @return The region of output that would be invalid given * a change to inputRgn of the source selected by srcIndex. * this is in the user coordinate system of this node. */	TokenNameCOMMENT_JAVADOC	 This calculates the region of output that is affected by a change in a region of input. @param srcIndex The input that inputRgn reflects changes in. @param inputRgn the region of input that has changed, used to calculate the returned shape. This is given in the user coordinate system of the source indicated by srcIndex. @return The region of output that would be invalid given a change to inputRgn of the source selected by srcIndex. this is in the user coordinate system of this node. 
public	TokenNamepublic	
Shape	TokenNameIdentifier	 Shape
getDirtyRegion	TokenNameIdentifier	 get Dirty Region
(	TokenNameLPAREN	
int	TokenNameint	
srcIndex	TokenNameIdentifier	 src Index
,	TokenNameCOMMA	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
inputRgn	TokenNameIdentifier	 input Rgn
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
dirtyRegion	TokenNameIdentifier	 dirty Region
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
srcIndex	TokenNameIdentifier	 src Index
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
float	TokenNamefloat	
dX	TokenNameIdentifier	 d X
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
stdDeviationX	TokenNameIdentifier	 std Deviation X
*	TokenNameMULTIPLY	
DSQRT2PI	TokenNameIdentifier	 DSQR T2 PI
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
dY	TokenNameIdentifier	 d Y
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
stdDeviationY	TokenNameIdentifier	 std Deviation Y
*	TokenNameMULTIPLY	
DSQRT2PI	TokenNameIdentifier	 DSQR T2 PI
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
radX	TokenNameIdentifier	 rad X
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
dX	TokenNameIdentifier	 d X
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
radY	TokenNameIdentifier	 rad Y
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
dY	TokenNameIdentifier	 d Y
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
inputRgn	TokenNameIdentifier	 input Rgn
=	TokenNameEQUAL	
new	TokenNamenew	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
(	TokenNameLPAREN	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
inputRgn	TokenNameIdentifier	 input Rgn
.	TokenNameDOT	
getMinX	TokenNameIdentifier	 get Min X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
radX	TokenNameIdentifier	 rad X
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
inputRgn	TokenNameIdentifier	 input Rgn
.	TokenNameDOT	
getMinY	TokenNameIdentifier	 get Min Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
radY	TokenNameIdentifier	 rad Y
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
inputRgn	TokenNameIdentifier	 input Rgn
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
radX	TokenNameIdentifier	 rad X
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
inputRgn	TokenNameIdentifier	 input Rgn
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
radY	TokenNameIdentifier	 rad Y
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
bounds	TokenNameIdentifier	 bounds
=	TokenNameEQUAL	
getBounds2D	TokenNameIdentifier	 get Bounds2 D
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
inputRgn	TokenNameIdentifier	 input Rgn
.	TokenNameDOT	
intersects	TokenNameIdentifier	 intersects
(	TokenNameLPAREN	
bounds	TokenNameIdentifier	 bounds
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
new	TokenNamenew	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Intersect with input region 	TokenNameCOMMENT_LINE	Intersect with input region 
dirtyRegion	TokenNameIdentifier	 dirty Region
=	TokenNameEQUAL	
inputRgn	TokenNameIdentifier	 input Rgn
.	TokenNameDOT	
createIntersection	TokenNameIdentifier	 create Intersection
(	TokenNameLPAREN	
bounds	TokenNameIdentifier	 bounds
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
dirtyRegion	TokenNameIdentifier	 dirty Region
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
