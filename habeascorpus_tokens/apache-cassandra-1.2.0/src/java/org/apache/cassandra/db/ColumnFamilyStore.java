/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
File	TokenNameIdentifier	 File
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
management	TokenNameIdentifier	 management
.	TokenNameDOT	
ManagementFactory	TokenNameIdentifier	 Management Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
nio	TokenNameIdentifier	 nio
.	TokenNameDOT	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
atomic	TokenNameIdentifier	 atomic
.	TokenNameDOT	
AtomicInteger	TokenNameIdentifier	 Atomic Integer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
atomic	TokenNameIdentifier	 atomic
.	TokenNameDOT	
AtomicLong	TokenNameIdentifier	 Atomic Long
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
regex	TokenNameIdentifier	 regex
.	TokenNameDOT	
Pattern	TokenNameIdentifier	 Pattern
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
management	TokenNameIdentifier	 management
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
collect	TokenNameIdentifier	 collect
.	TokenNameDOT	
AbstractIterator	TokenNameIdentifier	 Abstract Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
collect	TokenNameIdentifier	 collect
.	TokenNameDOT	
ImmutableSet	TokenNameIdentifier	 Immutable Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
collect	TokenNameIdentifier	 collect
.	TokenNameDOT	
Iterables	TokenNameIdentifier	 Iterables
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
collect	TokenNameIdentifier	 collect
.	TokenNameDOT	
Sets	TokenNameIdentifier	 Sets
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
Futures	TokenNameIdentifier	 Futures
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
IDiskAtomFilter	TokenNameIdentifier	 I Disk Atom Filter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
tracing	TokenNameIdentifier	 tracing
.	TokenNameDOT	
TraceState	TokenNameIdentifier	 Trace State
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
tracing	TokenNameIdentifier	 tracing
.	TokenNameDOT	
Tracing	TokenNameIdentifier	 Tracing
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
cliffc	TokenNameIdentifier	 cliffc
.	TokenNameDOT	
high_scale_lib	TokenNameIdentifier	 high scale lib
.	TokenNameDOT	
NonBlockingHashMap	TokenNameIdentifier	 Non Blocking Hash Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
slf4j	TokenNameIdentifier	 slf4j
.	TokenNameDOT	
Logger	TokenNameIdentifier	 Logger
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
slf4j	TokenNameIdentifier	 slf4j
.	TokenNameDOT	
LoggerFactory	TokenNameIdentifier	 Logger Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
cache	TokenNameIdentifier	 cache
.	TokenNameDOT	
IRowCacheEntry	TokenNameIdentifier	 I Row Cache Entry
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
cache	TokenNameIdentifier	 cache
.	TokenNameDOT	
RowCacheKey	TokenNameIdentifier	 Row Cache Key
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
cache	TokenNameIdentifier	 cache
.	TokenNameDOT	
RowCacheSentinel	TokenNameIdentifier	 Row Cache Sentinel
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
JMXEnabledThreadPoolExecutor	TokenNameIdentifier	 JMX Enabled Thread Pool Executor
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
NamedThreadFactory	TokenNameIdentifier	 Named Thread Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
StageManager	TokenNameIdentifier	 Stage Manager
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
columniterator	TokenNameIdentifier	 columniterator
.	TokenNameDOT	
OnDiskAtomIterator	TokenNameIdentifier	 On Disk Atom Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
commitlog	TokenNameIdentifier	 commitlog
.	TokenNameDOT	
CommitLog	TokenNameIdentifier	 Commit Log
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
commitlog	TokenNameIdentifier	 commitlog
.	TokenNameDOT	
ReplayPosition	TokenNameIdentifier	 Replay Position
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
compaction	TokenNameIdentifier	 compaction
.	TokenNameDOT	
AbstractCompactionStrategy	TokenNameIdentifier	 Abstract Compaction Strategy
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
compaction	TokenNameIdentifier	 compaction
.	TokenNameDOT	
CompactionManager	TokenNameIdentifier	 Compaction Manager
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
compaction	TokenNameIdentifier	 compaction
.	TokenNameDOT	
LeveledCompactionStrategy	TokenNameIdentifier	 Leveled Compaction Strategy
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
compaction	TokenNameIdentifier	 compaction
.	TokenNameDOT	
OperationType	TokenNameIdentifier	 Operation Type
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
ExtendedFilter	TokenNameIdentifier	 Extended Filter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
QueryFilter	TokenNameIdentifier	 Query Filter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
QueryPath	TokenNameIdentifier	 Query Path
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
SecondaryIndex	TokenNameIdentifier	 Secondary Index
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
SecondaryIndexManager	TokenNameIdentifier	 Secondary Index Manager
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
marshal	TokenNameIdentifier	 marshal
.	TokenNameDOT	
AbstractType	TokenNameIdentifier	 Abstract Type
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
dht	TokenNameIdentifier	 dht
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
exceptions	TokenNameIdentifier	 exceptions
.	TokenNameDOT	
ConfigurationException	TokenNameIdentifier	 Configuration Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
compress	TokenNameIdentifier	 compress
.	TokenNameDOT	
CompressionParameters	TokenNameIdentifier	 Compression Parameters
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
Descriptor	TokenNameIdentifier	 Descriptor
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
FileUtils	TokenNameIdentifier	 File Utils
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
ColumnFamilyMetrics	TokenNameIdentifier	 Column Family Metrics
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
service	TokenNameIdentifier	 service
.	TokenNameDOT	
CacheService	TokenNameIdentifier	 Cache Service
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
service	TokenNameIdentifier	 service
.	TokenNameDOT	
StorageService	TokenNameIdentifier	 Storage Service
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
thrift	TokenNameIdentifier	 thrift
.	TokenNameDOT	
IndexExpression	TokenNameIdentifier	 Index Expression
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
tracing	TokenNameIdentifier	 tracing
.	TokenNameDOT	
Tracing	TokenNameIdentifier	 Tracing
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
static	TokenNamestatic	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
CFMetaData	TokenNameIdentifier	 CF Meta Data
.	TokenNameDOT	
Caching	TokenNameIdentifier	 Caching
;	TokenNameSEMICOLON	
public	TokenNamepublic	
class	TokenNameclass	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
implements	TokenNameimplements	
ColumnFamilyStoreMBean	TokenNameIdentifier	 Column Family Store M Bean
{	TokenNameLBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Logger	TokenNameIdentifier	 Logger
logger	TokenNameIdentifier	 logger
=	TokenNameEQUAL	
LoggerFactory	TokenNameIdentifier	 Logger Factory
.	TokenNameDOT	
getLogger	TokenNameIdentifier	 get Logger
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* * switchMemtable puts Memtable.getSortedContents on the writer executor. When the write is complete, * we turn the writer into an SSTableReader and add it to ssTables where it is available for reads. * * There are two other things that switchMemtable does. * First, it puts the Memtable into memtablesPendingFlush, where it stays until the flush is complete * and it's been added as an SSTableReader to ssTables_. Second, it adds an entry to commitLogUpdater * that waits for the flush to complete, then calls onMemtableFlush. This allows multiple flushes * to happen simultaneously on multicore systems, while still calling onMF in the correct order, * which is necessary for replay in case of a restart since CommitLog assumes that when onMF is * called, all data up to the given context has been persisted to SSTables. */	TokenNameCOMMENT_BLOCK	 switchMemtable puts Memtable.getSortedContents on the writer executor. When the write is complete, we turn the writer into an SSTableReader and add it to ssTables where it is available for reads. * There are two other things that switchMemtable does. First, it puts the Memtable into memtablesPendingFlush, where it stays until the flush is complete and it's been added as an SSTableReader to ssTables_. Second, it adds an entry to commitLogUpdater that waits for the flush to complete, then calls onMemtableFlush. This allows multiple flushes to happen simultaneously on multicore systems, while still calling onMF in the correct order, which is necessary for replay in case of a restart since CommitLog assumes that when onMF is called, all data up to the given context has been persisted to SSTables. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
ExecutorService	TokenNameIdentifier	 Executor Service
flushWriter	TokenNameIdentifier	 flush Writer
=	TokenNameEQUAL	
new	TokenNamenew	
JMXEnabledThreadPoolExecutor	TokenNameIdentifier	 JMX Enabled Thread Pool Executor
(	TokenNameLPAREN	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getFlushWriters	TokenNameIdentifier	 get Flush Writers
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
StageManager	TokenNameIdentifier	 Stage Manager
.	TokenNameDOT	
KEEPALIVE	TokenNameIdentifier	 KEEPALIVE
,	TokenNameCOMMA	
TimeUnit	TokenNameIdentifier	 Time Unit
.	TokenNameDOT	
SECONDS	TokenNameIdentifier	 SECONDS
,	TokenNameCOMMA	
new	TokenNamenew	
LinkedBlockingQueue	TokenNameIdentifier	 Linked Blocking Queue
<	TokenNameLESS	
Runnable	TokenNameIdentifier	 Runnable
>	TokenNameGREATER	
(	TokenNameLPAREN	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getFlushQueueSize	TokenNameIdentifier	 get Flush Queue Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
NamedThreadFactory	TokenNameIdentifier	 Named Thread Factory
(	TokenNameLPAREN	
"FlushWriter"	TokenNameStringLiteral	FlushWriter
)	TokenNameRPAREN	
,	TokenNameCOMMA	
"internal"	TokenNameStringLiteral	internal
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
ExecutorService	TokenNameIdentifier	 Executor Service
postFlushExecutor	TokenNameIdentifier	 post Flush Executor
=	TokenNameEQUAL	
new	TokenNamenew	
JMXEnabledThreadPoolExecutor	TokenNameIdentifier	 JMX Enabled Thread Pool Executor
(	TokenNameLPAREN	
"MemtablePostFlusher"	TokenNameStringLiteral	MemtablePostFlusher
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
{	TokenNameLBRACE	
// (can block if flush queue fills up, so don't put on scheduledTasks) 	TokenNameCOMMENT_LINE	(can block if flush queue fills up, so don't put on scheduledTasks) 
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
optionalTasks	TokenNameIdentifier	 optional Tasks
.	TokenNameDOT	
scheduleWithFixedDelay	TokenNameIdentifier	 schedule With Fixed Delay
(	TokenNameLPAREN	
new	TokenNamenew	
MeteredFlusher	TokenNameIdentifier	 Metered Flusher
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
1000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
TimeUnit	TokenNameIdentifier	 Time Unit
.	TokenNameDOT	
MILLISECONDS	TokenNameIdentifier	 MILLISECONDS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
final	TokenNamefinal	
Table	TokenNameIdentifier	 Table
table	TokenNameIdentifier	 table
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
columnFamily	TokenNameIdentifier	 column Family
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
CFMetaData	TokenNameIdentifier	 CF Meta Data
metadata	TokenNameIdentifier	 metadata
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
IPartitioner	TokenNameIdentifier	 I Partitioner
partitioner	TokenNameIdentifier	 partitioner
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
mbeanName	TokenNameIdentifier	 mbean Name
;	TokenNameSEMICOLON	
private	TokenNameprivate	
volatile	TokenNamevolatile	
boolean	TokenNameboolean	
valid	TokenNameIdentifier	 valid
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
/* Memtables and SSTables on disk for this column family */	TokenNameCOMMENT_BLOCK	 Memtables and SSTables on disk for this column family 
private	TokenNameprivate	
final	TokenNamefinal	
DataTracker	TokenNameIdentifier	 Data Tracker
data	TokenNameIdentifier	 data
;	TokenNameSEMICOLON	
/* This is used to generate the next index for a SSTable */	TokenNameCOMMENT_BLOCK	 This is used to generate the next index for a SSTable 
private	TokenNameprivate	
final	TokenNamefinal	
AtomicInteger	TokenNameIdentifier	 Atomic Integer
fileIndexGenerator	TokenNameIdentifier	 file Index Generator
=	TokenNameEQUAL	
new	TokenNamenew	
AtomicInteger	TokenNameIdentifier	 Atomic Integer
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
SecondaryIndexManager	TokenNameIdentifier	 Secondary Index Manager
indexManager	TokenNameIdentifier	 index Manager
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
INTERN_CUTOFF	TokenNameIdentifier	 INTERN  CUTOFF
=	TokenNameEQUAL	
256	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
ConcurrentMap	TokenNameIdentifier	 Concurrent Map
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
internedNames	TokenNameIdentifier	 interned Names
=	TokenNameEQUAL	
new	TokenNamenew	
NonBlockingHashMap	TokenNameIdentifier	 Non Blocking Hash Map
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* These are locally held copies to be changed from the config during runtime */	TokenNameCOMMENT_BLOCK	 These are locally held copies to be changed from the config during runtime 
private	TokenNameprivate	
volatile	TokenNamevolatile	
DefaultInteger	TokenNameIdentifier	 Default Integer
minCompactionThreshold	TokenNameIdentifier	 min Compaction Threshold
;	TokenNameSEMICOLON	
private	TokenNameprivate	
volatile	TokenNamevolatile	
DefaultInteger	TokenNameIdentifier	 Default Integer
maxCompactionThreshold	TokenNameIdentifier	 max Compaction Threshold
;	TokenNameSEMICOLON	
private	TokenNameprivate	
volatile	TokenNamevolatile	
AbstractCompactionStrategy	TokenNameIdentifier	 Abstract Compaction Strategy
compactionStrategy	TokenNameIdentifier	 compaction Strategy
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
Directories	TokenNameIdentifier	 Directories
directories	TokenNameIdentifier	 directories
;	TokenNameSEMICOLON	
/** ratio of in-memory memtable size, to serialized size */	TokenNameCOMMENT_JAVADOC	 ratio of in-memory memtable size, to serialized size 
volatile	TokenNamevolatile	
double	TokenNamedouble	
liveRatio	TokenNameIdentifier	 live Ratio
=	TokenNameEQUAL	
1.0	TokenNameDoubleLiteral	
;	TokenNameSEMICOLON	
/** ops count last time we computed liveRatio */	TokenNameCOMMENT_JAVADOC	 ops count last time we computed liveRatio 
private	TokenNameprivate	
final	TokenNamefinal	
AtomicLong	TokenNameIdentifier	 Atomic Long
liveRatioComputedAt	TokenNameIdentifier	 live Ratio Computed At
=	TokenNameEQUAL	
new	TokenNamenew	
AtomicLong	TokenNameIdentifier	 Atomic Long
(	TokenNameLPAREN	
32	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
ColumnFamilyMetrics	TokenNameIdentifier	 Column Family Metrics
metric	TokenNameIdentifier	 metric
;	TokenNameSEMICOLON	
public	TokenNamepublic	
void	TokenNamevoid	
reload	TokenNameIdentifier	 reload
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// metadata object has been mutated directly. make all the members jibe with new settings. 	TokenNameCOMMENT_LINE	metadata object has been mutated directly. make all the members jibe with new settings. 
// only update these runtime-modifiable settings if they have not been modified. 	TokenNameCOMMENT_LINE	only update these runtime-modifiable settings if they have not been modified. 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
minCompactionThreshold	TokenNameIdentifier	 min Compaction Threshold
.	TokenNameDOT	
isModified	TokenNameIdentifier	 is Modified
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
:	TokenNameCOLON	
concatWithIndexes	TokenNameIdentifier	 concat With Indexes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
minCompactionThreshold	TokenNameIdentifier	 min Compaction Threshold
=	TokenNameEQUAL	
new	TokenNamenew	
DefaultInteger	TokenNameIdentifier	 Default Integer
(	TokenNameLPAREN	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
getMinCompactionThreshold	TokenNameIdentifier	 get Min Compaction Threshold
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
maxCompactionThreshold	TokenNameIdentifier	 max Compaction Threshold
.	TokenNameDOT	
isModified	TokenNameIdentifier	 is Modified
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
:	TokenNameCOLON	
concatWithIndexes	TokenNameIdentifier	 concat With Indexes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
maxCompactionThreshold	TokenNameIdentifier	 max Compaction Threshold
=	TokenNameEQUAL	
new	TokenNamenew	
DefaultInteger	TokenNameIdentifier	 Default Integer
(	TokenNameLPAREN	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
getMaxCompactionThreshold	TokenNameIdentifier	 get Max Compaction Threshold
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
maybeReloadCompactionStrategy	TokenNameIdentifier	 maybe Reload Compaction Strategy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
indexManager	TokenNameIdentifier	 index Manager
.	TokenNameDOT	
reload	TokenNameIdentifier	 reload
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// If the CF comparator has changed, we need to change the memtable, 	TokenNameCOMMENT_LINE	If the CF comparator has changed, we need to change the memtable, 
// because the old one still aliases the previous comparator. 	TokenNameCOMMENT_LINE	because the old one still aliases the previous comparator. 
if	TokenNameif	
(	TokenNameLPAREN	
getMemtableThreadSafe	TokenNameIdentifier	 get Memtable Thread Safe
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
initialComparator	TokenNameIdentifier	 initial Comparator
!=	TokenNameNOT_EQUAL	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
comparator	TokenNameIdentifier	 comparator
)	TokenNameRPAREN	
switchMemtable	TokenNameIdentifier	 switch Memtable
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
maybeReloadCompactionStrategy	TokenNameIdentifier	 maybe Reload Compaction Strategy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Check if there is a need for reloading 	TokenNameCOMMENT_LINE	Check if there is a need for reloading 
if	TokenNameif	
(	TokenNameLPAREN	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
compactionStrategyClass	TokenNameIdentifier	 compaction Strategy Class
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
compactionStrategy	TokenNameIdentifier	 compaction Strategy
.	TokenNameDOT	
getClass	TokenNameIdentifier	 get Class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
compactionStrategyOptions	TokenNameIdentifier	 compaction Strategy Options
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
compactionStrategy	TokenNameIdentifier	 compaction Strategy
.	TokenNameDOT	
options	TokenNameIdentifier	 options
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
// TODO is there a way to avoid locking here? 	TokenNameCOMMENT_LINE	TODO is there a way to avoid locking here? 
CompactionManager	TokenNameIdentifier	 Compaction Manager
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getCompactionLock	TokenNameIdentifier	 get Compaction Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
compactionStrategy	TokenNameIdentifier	 compaction Strategy
.	TokenNameDOT	
shutdown	TokenNameIdentifier	 shutdown
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
compactionStrategy	TokenNameIdentifier	 compaction Strategy
=	TokenNameEQUAL	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
createCompactionStrategyInstance	TokenNameIdentifier	 create Compaction Strategy Instance
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
CompactionManager	TokenNameIdentifier	 Compaction Manager
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getCompactionLock	TokenNameIdentifier	 get Compaction Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setCompactionStrategyClass	TokenNameIdentifier	 set Compaction Strategy Class
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
compactionStrategyClass	TokenNameIdentifier	 compaction Strategy Class
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
compactionStrategyClass	TokenNameIdentifier	 compaction Strategy Class
=	TokenNameEQUAL	
CFMetaData	TokenNameIdentifier	 CF Meta Data
.	TokenNameDOT	
createCompactionStrategy	TokenNameIdentifier	 create Compaction Strategy
(	TokenNameLPAREN	
compactionStrategyClass	TokenNameIdentifier	 compaction Strategy Class
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
maybeReloadCompactionStrategy	TokenNameIdentifier	 maybe Reload Compaction Strategy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ConfigurationException	TokenNameIdentifier	 Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getCompactionStrategyClass	TokenNameIdentifier	 get Compaction Strategy Class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
compactionStrategyClass	TokenNameIdentifier	 compaction Strategy Class
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
getCompressionParameters	TokenNameIdentifier	 get Compression Parameters
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
compressionParameters	TokenNameIdentifier	 compression Parameters
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
asThriftOptions	TokenNameIdentifier	 as Thrift Options
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setCompressionParameters	TokenNameIdentifier	 set Compression Parameters
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
opts	TokenNameIdentifier	 opts
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
compressionParameters	TokenNameIdentifier	 compression Parameters
=	TokenNameEQUAL	
CompressionParameters	TokenNameIdentifier	 Compression Parameters
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
opts	TokenNameIdentifier	 opts
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ConfigurationException	TokenNameIdentifier	 Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setCrcCheckChance	TokenNameIdentifier	 set Crc Check Chance
(	TokenNameLPAREN	
double	TokenNamedouble	
crcCheckChance	TokenNameIdentifier	 crc Check Chance
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
:	TokenNameCOLON	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
getAllSSTables	TokenNameIdentifier	 get All SS Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
if	TokenNameif	
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
compression	TokenNameIdentifier	 compression
)	TokenNameRPAREN	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
getCompressionMetadata	TokenNameIdentifier	 get Compression Metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
parameters	TokenNameIdentifier	 parameters
.	TokenNameDOT	
setCrcCheckChance	TokenNameIdentifier	 set Crc Check Chance
(	TokenNameLPAREN	
crcCheckChance	TokenNameIdentifier	 crc Check Chance
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ConfigurationException	TokenNameIdentifier	 Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
(	TokenNameLPAREN	
Table	TokenNameIdentifier	 Table
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
columnFamilyName	TokenNameIdentifier	 column Family Name
,	TokenNameCOMMA	
IPartitioner	TokenNameIdentifier	 I Partitioner
partitioner	TokenNameIdentifier	 partitioner
,	TokenNameCOMMA	
int	TokenNameint	
generation	TokenNameIdentifier	 generation
,	TokenNameCOMMA	
CFMetaData	TokenNameIdentifier	 CF Meta Data
metadata	TokenNameIdentifier	 metadata
,	TokenNameCOMMA	
Directories	TokenNameIdentifier	 Directories
directories	TokenNameIdentifier	 directories
,	TokenNameCOMMA	
boolean	TokenNameboolean	
loadSSTables	TokenNameIdentifier	 load SS Tables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
metadata	TokenNameIdentifier	 metadata
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
:	TokenNameCOLON	
"null metadata for "	TokenNameStringLiteral	null metadata for 
+	TokenNamePLUS	
table	TokenNameIdentifier	 table
+	TokenNamePLUS	
":"	TokenNameStringLiteral	:
+	TokenNamePLUS	
columnFamilyName	TokenNameIdentifier	 column Family Name
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
table	TokenNameIdentifier	 table
=	TokenNameEQUAL	
table	TokenNameIdentifier	 table
;	TokenNameSEMICOLON	
columnFamily	TokenNameIdentifier	 column Family
=	TokenNameEQUAL	
columnFamilyName	TokenNameIdentifier	 column Family Name
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
metadata	TokenNameIdentifier	 metadata
=	TokenNameEQUAL	
metadata	TokenNameIdentifier	 metadata
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
minCompactionThreshold	TokenNameIdentifier	 min Compaction Threshold
=	TokenNameEQUAL	
new	TokenNamenew	
DefaultInteger	TokenNameIdentifier	 Default Integer
(	TokenNameLPAREN	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
getMinCompactionThreshold	TokenNameIdentifier	 get Min Compaction Threshold
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
maxCompactionThreshold	TokenNameIdentifier	 max Compaction Threshold
=	TokenNameEQUAL	
new	TokenNamenew	
DefaultInteger	TokenNameIdentifier	 Default Integer
(	TokenNameLPAREN	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
getMaxCompactionThreshold	TokenNameIdentifier	 get Max Compaction Threshold
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
partitioner	TokenNameIdentifier	 partitioner
=	TokenNameEQUAL	
partitioner	TokenNameIdentifier	 partitioner
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
directories	TokenNameIdentifier	 directories
=	TokenNameEQUAL	
directories	TokenNameIdentifier	 directories
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
indexManager	TokenNameIdentifier	 index Manager
=	TokenNameEQUAL	
new	TokenNamenew	
SecondaryIndexManager	TokenNameIdentifier	 Secondary Index Manager
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
metric	TokenNameIdentifier	 metric
=	TokenNameEQUAL	
new	TokenNamenew	
ColumnFamilyMetrics	TokenNameIdentifier	 Column Family Metrics
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fileIndexGenerator	TokenNameIdentifier	 file Index Generator
.	TokenNameDOT	
set	TokenNameIdentifier	 set
(	TokenNameLPAREN	
generation	TokenNameIdentifier	 generation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Caching	TokenNameIdentifier	 Caching
caching	TokenNameIdentifier	 caching
=	TokenNameEQUAL	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
getCaching	TokenNameIdentifier	 get Caching
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Starting CFS {}"	TokenNameStringLiteral	Starting CFS {}
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// scan for sstables corresponding to this cf and load them 	TokenNameCOMMENT_LINE	scan for sstables corresponding to this cf and load them 
data	TokenNameIdentifier	 data
=	TokenNameEQUAL	
new	TokenNamenew	
DataTracker	TokenNameIdentifier	 Data Tracker
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
loadSSTables	TokenNameIdentifier	 load SS Tables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Directories	TokenNameIdentifier	 Directories
.	TokenNameDOT	
SSTableLister	TokenNameIdentifier	 SS Table Lister
sstableFiles	TokenNameIdentifier	 sstable Files
=	TokenNameEQUAL	
directories	TokenNameIdentifier	 directories
.	TokenNameDOT	
sstableLister	TokenNameIdentifier	 sstable Lister
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
skipTemporary	TokenNameIdentifier	 skip Temporary
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
=	TokenNameEQUAL	
SSTableReader	TokenNameIdentifier	 SS Table Reader
.	TokenNameDOT	
batchOpen	TokenNameIdentifier	 batch Open
(	TokenNameLPAREN	
sstableFiles	TokenNameIdentifier	 sstable Files
.	TokenNameDOT	
list	TokenNameIdentifier	 list
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
metadata	TokenNameIdentifier	 metadata
,	TokenNameCOMMA	
this	TokenNamethis	
.	TokenNameDOT	
partitioner	TokenNameIdentifier	 partitioner
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Filter non-compacted sstables, remove compacted ones 	TokenNameCOMMENT_LINE	Filter non-compacted sstables, remove compacted ones 
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
compactedSSTables	TokenNameIdentifier	 compacted SS Tables
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
:	TokenNameCOLON	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
compactedSSTables	TokenNameIdentifier	 compacted SS Tables
.	TokenNameDOT	
addAll	TokenNameIdentifier	 add All
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
getAncestors	TokenNameIdentifier	 get Ancestors
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
liveSSTables	TokenNameIdentifier	 live SS Tables
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
:	TokenNameCOLON	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
compactedSSTables	TokenNameIdentifier	 compacted SS Tables
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
generation	TokenNameIdentifier	 generation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
releaseReference	TokenNameIdentifier	 release Reference
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// this amount to deleting the sstable 	TokenNameCOMMENT_LINE	this amount to deleting the sstable 
else	TokenNameelse	
liveSSTables	TokenNameIdentifier	 live SS Tables
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
addInitialSSTables	TokenNameIdentifier	 add Initial SS Tables
(	TokenNameLPAREN	
liveSSTables	TokenNameIdentifier	 live SS Tables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
caching	TokenNameIdentifier	 caching
==	TokenNameEQUAL_EQUAL	
Caching	TokenNameIdentifier	 Caching
.	TokenNameDOT	
ALL	TokenNameIdentifier	 ALL
||	TokenNameOR_OR	
caching	TokenNameIdentifier	 caching
==	TokenNameEQUAL_EQUAL	
Caching	TokenNameIdentifier	 Caching
.	TokenNameDOT	
KEYS_ONLY	TokenNameIdentifier	 KEYS  ONLY
)	TokenNameRPAREN	
CacheService	TokenNameIdentifier	 Cache Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
keyCache	TokenNameIdentifier	 key Cache
.	TokenNameDOT	
loadSaved	TokenNameIdentifier	 load Saved
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// compaction strategy should be created after the CFS has been prepared 	TokenNameCOMMENT_LINE	compaction strategy should be created after the CFS has been prepared 
this	TokenNamethis	
.	TokenNameDOT	
compactionStrategy	TokenNameIdentifier	 compaction Strategy
=	TokenNameEQUAL	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
createCompactionStrategyInstance	TokenNameIdentifier	 create Compaction Strategy Instance
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// create the private ColumnFamilyStores for the secondary column indexes 	TokenNameCOMMENT_LINE	create the private ColumnFamilyStores for the secondary column indexes 
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnDefinition	TokenNameIdentifier	 Column Definition
info	TokenNameIdentifier	 info
:	TokenNameCOLON	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
getColumn_metadata	TokenNameIdentifier	 get Column metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
values	TokenNameIdentifier	 values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
getIndexType	TokenNameIdentifier	 get Index Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
indexManager	TokenNameIdentifier	 index Manager
.	TokenNameDOT	
addIndexedColumn	TokenNameIdentifier	 add Indexed Column
(	TokenNameLPAREN	
info	TokenNameIdentifier	 info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// register the mbean 	TokenNameCOMMENT_LINE	register the mbean 
String	TokenNameIdentifier	 String
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
this	TokenNamethis	
.	TokenNameDOT	
partitioner	TokenNameIdentifier	 partitioner
instanceof	TokenNameinstanceof	
LocalPartitioner	TokenNameIdentifier	 Local Partitioner
?	TokenNameQUESTION	
"IndexColumnFamilies"	TokenNameStringLiteral	IndexColumnFamilies
:	TokenNameCOLON	
"ColumnFamilies"	TokenNameStringLiteral	ColumnFamilies
;	TokenNameSEMICOLON	
mbeanName	TokenNameIdentifier	 mbean Name
=	TokenNameEQUAL	
"org.apache.cassandra.db:type="	TokenNameStringLiteral	org.apache.cassandra.db:type=
+	TokenNamePLUS	
type	TokenNameIdentifier	 type
+	TokenNamePLUS	
",keyspace="	TokenNameStringLiteral	,keyspace=
+	TokenNamePLUS	
this	TokenNamethis	
.	TokenNameDOT	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
name	TokenNameIdentifier	 name
+	TokenNamePLUS	
",columnfamily="	TokenNameStringLiteral	,columnfamily=
+	TokenNamePLUS	
columnFamily	TokenNameIdentifier	 column Family
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
MBeanServer	TokenNameIdentifier	 M Bean Server
mbs	TokenNameIdentifier	 mbs
=	TokenNameEQUAL	
ManagementFactory	TokenNameIdentifier	 Management Factory
.	TokenNameDOT	
getPlatformMBeanServer	TokenNameIdentifier	 get Platform M Bean Server
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ObjectName	TokenNameIdentifier	 Object Name
nameObj	TokenNameIdentifier	 name Obj
=	TokenNameEQUAL	
new	TokenNamenew	
ObjectName	TokenNameIdentifier	 Object Name
(	TokenNameLPAREN	
mbeanName	TokenNameIdentifier	 mbean Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
mbs	TokenNameIdentifier	 mbs
.	TokenNameDOT	
registerMBean	TokenNameIdentifier	 register M Bean
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
nameObj	TokenNameIdentifier	 name Obj
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** call when dropping or renaming a CF. Performs mbean housekeeping and invalidates CFS to other operations */	TokenNameCOMMENT_JAVADOC	 call when dropping or renaming a CF. Performs mbean housekeeping and invalidates CFS to other operations 
public	TokenNamepublic	
void	TokenNamevoid	
invalidate	TokenNameIdentifier	 invalidate
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
valid	TokenNameIdentifier	 valid
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
unregisterMBean	TokenNameIdentifier	 unregister M Bean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
unreferenceSSTables	TokenNameIdentifier	 unreference SS Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
indexManager	TokenNameIdentifier	 index Manager
.	TokenNameDOT	
invalidate	TokenNameIdentifier	 invalidate
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// this shouldn't block anything. 	TokenNameCOMMENT_LINE	this shouldn't block anything. 
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
"Failed unregistering mbean: "	TokenNameStringLiteral	Failed unregistering mbean: 
+	TokenNamePLUS	
mbeanName	TokenNameIdentifier	 mbean Name
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Removes every SSTable in the directory from the DataTracker's view. * @param directory the unreadable directory, possibly with SSTables in it, but not necessarily. */	TokenNameCOMMENT_JAVADOC	 Removes every SSTable in the directory from the DataTracker's view. @param directory the unreadable directory, possibly with SSTables in it, but not necessarily. 
void	TokenNamevoid	
maybeRemoveUnreadableSSTables	TokenNameIdentifier	 maybe Remove Unreadable SS Tables
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
directory	TokenNameIdentifier	 directory
)	TokenNameRPAREN	
{	TokenNameLBRACE	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
removeUnreadableSSTables	TokenNameIdentifier	 remove Unreadable SS Tables
(	TokenNameLPAREN	
directory	TokenNameIdentifier	 directory
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
void	TokenNamevoid	
unregisterMBean	TokenNameIdentifier	 unregister M Bean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
MalformedObjectNameException	TokenNameIdentifier	 Malformed Object Name Exception
,	TokenNameCOMMA	
InstanceNotFoundException	TokenNameIdentifier	 Instance Not Found Exception
,	TokenNameCOMMA	
MBeanRegistrationException	TokenNameIdentifier	 M Bean Registration Exception
{	TokenNameLBRACE	
MBeanServer	TokenNameIdentifier	 M Bean Server
mbs	TokenNameIdentifier	 mbs
=	TokenNameEQUAL	
ManagementFactory	TokenNameIdentifier	 Management Factory
.	TokenNameDOT	
getPlatformMBeanServer	TokenNameIdentifier	 get Platform M Bean Server
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ObjectName	TokenNameIdentifier	 Object Name
nameObj	TokenNameIdentifier	 name Obj
=	TokenNameEQUAL	
new	TokenNamenew	
ObjectName	TokenNameIdentifier	 Object Name
(	TokenNameLPAREN	
mbeanName	TokenNameIdentifier	 mbean Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
mbs	TokenNameIdentifier	 mbs
.	TokenNameDOT	
isRegistered	TokenNameIdentifier	 is Registered
(	TokenNameLPAREN	
nameObj	TokenNameIdentifier	 name Obj
)	TokenNameRPAREN	
)	TokenNameRPAREN	
mbs	TokenNameIdentifier	 mbs
.	TokenNameDOT	
unregisterMBean	TokenNameIdentifier	 unregister M Bean
(	TokenNameLPAREN	
nameObj	TokenNameIdentifier	 name Obj
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// unregister metrics 	TokenNameCOMMENT_LINE	unregister metrics 
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
release	TokenNameIdentifier	 release
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getMinRowSize	TokenNameIdentifier	 get Min Row Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
minRowSize	TokenNameIdentifier	 min Row Size
.	TokenNameDOT	
value	TokenNameIdentifier	 value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getMaxRowSize	TokenNameIdentifier	 get Max Row Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
maxRowSize	TokenNameIdentifier	 max Row Size
.	TokenNameDOT	
value	TokenNameIdentifier	 value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getMeanRowSize	TokenNameIdentifier	 get Mean Row Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
meanRowSize	TokenNameIdentifier	 mean Row Size
.	TokenNameDOT	
value	TokenNameIdentifier	 value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getMeanColumns	TokenNameIdentifier	 get Mean Columns
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
getMeanColumns	TokenNameIdentifier	 get Mean Columns
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
createColumnFamilyStore	TokenNameIdentifier	 create Column Family Store
(	TokenNameLPAREN	
Table	TokenNameIdentifier	 Table
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
boolean	TokenNameboolean	
loadSSTables	TokenNameIdentifier	 load SS Tables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
createColumnFamilyStore	TokenNameIdentifier	 create Column Family Store
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getCFMetaData	TokenNameIdentifier	 get CF Meta Data
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
,	TokenNameCOMMA	
loadSSTables	TokenNameIdentifier	 load SS Tables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
createColumnFamilyStore	TokenNameIdentifier	 create Column Family Store
(	TokenNameLPAREN	
Table	TokenNameIdentifier	 Table
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
IPartitioner	TokenNameIdentifier	 I Partitioner
partitioner	TokenNameIdentifier	 partitioner
,	TokenNameCOMMA	
CFMetaData	TokenNameIdentifier	 CF Meta Data
metadata	TokenNameIdentifier	 metadata
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
createColumnFamilyStore	TokenNameIdentifier	 create Column Family Store
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
partitioner	TokenNameIdentifier	 partitioner
,	TokenNameCOMMA	
metadata	TokenNameIdentifier	 metadata
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
synchronized	TokenNamesynchronized	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
createColumnFamilyStore	TokenNameIdentifier	 create Column Family Store
(	TokenNameLPAREN	
Table	TokenNameIdentifier	 Table
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
IPartitioner	TokenNameIdentifier	 I Partitioner
partitioner	TokenNameIdentifier	 partitioner
,	TokenNameCOMMA	
CFMetaData	TokenNameIdentifier	 CF Meta Data
metadata	TokenNameIdentifier	 metadata
,	TokenNameCOMMA	
boolean	TokenNameboolean	
loadSSTables	TokenNameIdentifier	 load SS Tables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// get the max generation number, to prevent generation conflicts 	TokenNameCOMMENT_LINE	get the max generation number, to prevent generation conflicts 
Directories	TokenNameIdentifier	 Directories
directories	TokenNameIdentifier	 directories
=	TokenNameEQUAL	
Directories	TokenNameIdentifier	 Directories
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Directories	TokenNameIdentifier	 Directories
.	TokenNameDOT	
SSTableLister	TokenNameIdentifier	 SS Table Lister
lister	TokenNameIdentifier	 lister
=	TokenNameEQUAL	
directories	TokenNameIdentifier	 directories
.	TokenNameDOT	
sstableLister	TokenNameIdentifier	 sstable Lister
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
includeBackups	TokenNameIdentifier	 include Backups
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
generations	TokenNameIdentifier	 generations
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
Descriptor	TokenNameIdentifier	 Descriptor
,	TokenNameCOMMA	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Component	TokenNameIdentifier	 Component
>>	TokenNameRIGHT_SHIFT	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
lister	TokenNameIdentifier	 lister
.	TokenNameDOT	
list	TokenNameIdentifier	 list
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Descriptor	TokenNameIdentifier	 Descriptor
desc	TokenNameIdentifier	 desc
=	TokenNameEQUAL	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
generations	TokenNameIdentifier	 generations
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
generation	TokenNameIdentifier	 generation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
isCompatible	TokenNameIdentifier	 is Compatible
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Can't open incompatible SSTable! Current version %s, found file: %s"	TokenNameStringLiteral	Can't open incompatible SSTable! Current version %s, found file: %s
,	TokenNameCOMMA	
Descriptor	TokenNameIdentifier	 Descriptor
.	TokenNameDOT	
Version	TokenNameIdentifier	 Version
.	TokenNameDOT	
CURRENT	TokenNameIdentifier	 CURRENT
,	TokenNameCOMMA	
desc	TokenNameIdentifier	 desc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
generations	TokenNameIdentifier	 generations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
(	TokenNameLPAREN	
generations	TokenNameIdentifier	 generations
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
(	TokenNameLPAREN	
generations	TokenNameIdentifier	 generations
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
generations	TokenNameIdentifier	 generations
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
partitioner	TokenNameIdentifier	 partitioner
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
metadata	TokenNameIdentifier	 metadata
,	TokenNameCOMMA	
directories	TokenNameIdentifier	 directories
,	TokenNameCOMMA	
loadSSTables	TokenNameIdentifier	 load SS Tables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Removes unnecessary files from the cf directory at startup: these include temp files, orphans, zero-length files * and compacted sstables. Files that cannot be recognized will be ignored. */	TokenNameCOMMENT_JAVADOC	 Removes unnecessary files from the cf directory at startup: these include temp files, orphans, zero-length files and compacted sstables. Files that cannot be recognized will be ignored. 
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
scrubDataDirectories	TokenNameIdentifier	 scrub Data Directories
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Removing compacted SSTable files from {} (see http://wiki.apache.org/cassandra/MemtableSSTable)"	TokenNameStringLiteral	Removing compacted SSTable files from {} (see http://wiki.apache.org/cassandra/MemtableSSTable)
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Directories	TokenNameIdentifier	 Directories
directories	TokenNameIdentifier	 directories
=	TokenNameEQUAL	
Directories	TokenNameIdentifier	 Directories
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
Descriptor	TokenNameIdentifier	 Descriptor
,	TokenNameCOMMA	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Component	TokenNameIdentifier	 Component
>>	TokenNameRIGHT_SHIFT	
sstableFiles	TokenNameIdentifier	 sstable Files
:	TokenNameCOLON	
directories	TokenNameIdentifier	 directories
.	TokenNameDOT	
sstableLister	TokenNameIdentifier	 sstable Lister
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
list	TokenNameIdentifier	 list
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Descriptor	TokenNameIdentifier	 Descriptor
desc	TokenNameIdentifier	 desc
=	TokenNameEQUAL	
sstableFiles	TokenNameIdentifier	 sstable Files
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Component	TokenNameIdentifier	 Component
>	TokenNameGREATER	
components	TokenNameIdentifier	 components
=	TokenNameEQUAL	
sstableFiles	TokenNameIdentifier	 sstable Files
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
Component	TokenNameIdentifier	 Component
.	TokenNameDOT	
COMPACTED_MARKER	TokenNameIdentifier	 COMPACTED  MARKER
)	TokenNameRPAREN	
||	TokenNameOR_OR	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
temporary	TokenNameIdentifier	 temporary
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SSTable	TokenNameIdentifier	 SS Table
.	TokenNameDOT	
delete	TokenNameIdentifier	 delete
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
components	TokenNameIdentifier	 components
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
File	TokenNameIdentifier	 File
dataFile	TokenNameIdentifier	 data File
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
filenameFor	TokenNameIdentifier	 filename For
(	TokenNameLPAREN	
Component	TokenNameIdentifier	 Component
.	TokenNameDOT	
DATA	TokenNameIdentifier	 DATA
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
Component	TokenNameIdentifier	 Component
.	TokenNameDOT	
DATA	TokenNameIdentifier	 DATA
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
dataFile	TokenNameIdentifier	 data File
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
// everything appears to be in order... moving on. 	TokenNameCOMMENT_LINE	everything appears to be in order... moving on. 
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
// missing the DATA file! all components are orphaned 	TokenNameCOMMENT_LINE	missing the DATA file! all components are orphaned 
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
"Removing orphans for {}: {}"	TokenNameStringLiteral	Removing orphans for {}: {}
,	TokenNameCOMMA	
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
components	TokenNameIdentifier	 components
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Component	TokenNameIdentifier	 Component
component	TokenNameIdentifier	 component
:	TokenNameCOLON	
components	TokenNameIdentifier	 components
)	TokenNameRPAREN	
{	TokenNameLBRACE	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
deleteWithConfirm	TokenNameIdentifier	 delete With Confirm
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
filenameFor	TokenNameIdentifier	 filename For
(	TokenNameLPAREN	
component	TokenNameIdentifier	 component
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// cleanup incomplete saved caches 	TokenNameCOMMENT_LINE	cleanup incomplete saved caches 
Pattern	TokenNameIdentifier	 Pattern
tmpCacheFilePattern	TokenNameIdentifier	 tmp Cache File Pattern
=	TokenNameEQUAL	
Pattern	TokenNameIdentifier	 Pattern
.	TokenNameDOT	
compile	TokenNameIdentifier	 compile
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
+	TokenNamePLUS	
"-"	TokenNameStringLiteral	-
+	TokenNamePLUS	
columnFamily	TokenNameIdentifier	 column Family
+	TokenNamePLUS	
"-(Key|Row)Cache.*\.tmp$"	TokenNameStringLiteral	-(Key|Row)Cache.*\.tmp$
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getSavedCachesLocation	TokenNameIdentifier	 get Saved Caches Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
isDirectory	TokenNameIdentifier	 is Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
file	TokenNameIdentifier	 file
:	TokenNameCOLON	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
listFiles	TokenNameIdentifier	 list Files
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
if	TokenNameif	
(	TokenNameLPAREN	
tmpCacheFilePattern	TokenNameIdentifier	 tmp Cache File Pattern
.	TokenNameDOT	
matcher	TokenNameIdentifier	 matcher
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
matches	TokenNameIdentifier	 matches
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
delete	TokenNameIdentifier	 delete
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
"could not delete "	TokenNameStringLiteral	could not delete 
+	TokenNamePLUS	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// also clean out any index leftovers. 	TokenNameCOMMENT_LINE	also clean out any index leftovers. 
CFMetaData	TokenNameIdentifier	 CF Meta Data
cfm	TokenNameIdentifier	 cfm
=	TokenNameEQUAL	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getCFMetaData	TokenNameIdentifier	 get CF Meta Data
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cfm	TokenNameIdentifier	 cfm
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
// secondary indexes aren't stored in DD. 	TokenNameCOMMENT_LINE	secondary indexes aren't stored in DD. 
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnDefinition	TokenNameIdentifier	 Column Definition
def	TokenNameIdentifier	 def
:	TokenNameCOLON	
cfm	TokenNameIdentifier	 cfm
.	TokenNameDOT	
getColumn_metadata	TokenNameIdentifier	 get Column metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
values	TokenNameIdentifier	 values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
scrubDataDirectories	TokenNameIdentifier	 scrub Data Directories
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
cfm	TokenNameIdentifier	 cfm
.	TokenNameDOT	
indexColumnFamilyName	TokenNameIdentifier	 index Column Family Name
(	TokenNameLPAREN	
def	TokenNameIdentifier	 def
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// must be called after all sstables are loaded since row cache merges all row versions 	TokenNameCOMMENT_LINE	must be called after all sstables are loaded since row cache merges all row versions 
public	TokenNamepublic	
void	TokenNamevoid	
initRowCache	TokenNameIdentifier	 init Row Cache
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isRowCacheEnabled	TokenNameIdentifier	 is Row Cache Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
long	TokenNamelong	
start	TokenNameIdentifier	 start
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
cachedRowsRead	TokenNameIdentifier	 cached Rows Read
=	TokenNameEQUAL	
CacheService	TokenNameIdentifier	 Cache Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
rowCache	TokenNameIdentifier	 row Cache
.	TokenNameDOT	
loadSaved	TokenNameIdentifier	 load Saved
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cachedRowsRead	TokenNameIdentifier	 cached Rows Read
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"completed loading (%d ms; %d keys) row cache for %s.%s"	TokenNameStringLiteral	completed loading (%d ms; %d keys) row cache for %s.%s
,	TokenNameCOMMA	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
start	TokenNameIdentifier	 start
,	TokenNameCOMMA	
cachedRowsRead	TokenNameIdentifier	 cached Rows Read
,	TokenNameCOMMA	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * See #{@code StorageService.loadNewSSTables(String, String)} for more info * * @param ksName The keyspace name * @param cfName The columnFamily name */	TokenNameCOMMENT_JAVADOC	 See #{@code StorageService.loadNewSSTables(String, String)} for more info * @param ksName The keyspace name @param cfName The columnFamily name 
public	TokenNamepublic	
static	TokenNamestatic	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
loadNewSSTables	TokenNameIdentifier	 load New SS Tables
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
ksName	TokenNameIdentifier	 ks Name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
cfName	TokenNameIdentifier	 cf Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
/** ks/cf existence checks will be done by open and getCFS methods for us */	TokenNameCOMMENT_JAVADOC	 ks/cf existence checks will be done by open and getCFS methods for us 
Table	TokenNameIdentifier	 Table
table	TokenNameIdentifier	 table
=	TokenNameEQUAL	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
ksName	TokenNameIdentifier	 ks Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
getColumnFamilyStore	TokenNameIdentifier	 get Column Family Store
(	TokenNameLPAREN	
cfName	TokenNameIdentifier	 cf Name
)	TokenNameRPAREN	
.	TokenNameDOT	
loadNewSSTables	TokenNameIdentifier	 load New SS Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * #{@inheritDoc} */	TokenNameCOMMENT_JAVADOC	 #{@inheritDoc} 
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
loadNewSSTables	TokenNameIdentifier	 load New SS Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Loading new SSTables for "	TokenNameStringLiteral	Loading new SSTables for 
+	TokenNamePLUS	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
name	TokenNameIdentifier	 name
+	TokenNamePLUS	
"/"	TokenNameStringLiteral	/
+	TokenNamePLUS	
columnFamily	TokenNameIdentifier	 column Family
+	TokenNamePLUS	
"..."	TokenNameStringLiteral	...
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Descriptor	TokenNameIdentifier	 Descriptor
>	TokenNameGREATER	
currentDescriptors	TokenNameIdentifier	 current Descriptors
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
Descriptor	TokenNameIdentifier	 Descriptor
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
:	TokenNameCOLON	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
getView	TokenNameIdentifier	 get View
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
currentDescriptors	TokenNameIdentifier	 current Descriptors
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
descriptor	TokenNameIdentifier	 descriptor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
newSSTables	TokenNameIdentifier	 new SS Tables
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Directories	TokenNameIdentifier	 Directories
.	TokenNameDOT	
SSTableLister	TokenNameIdentifier	 SS Table Lister
lister	TokenNameIdentifier	 lister
=	TokenNameEQUAL	
directories	TokenNameIdentifier	 directories
.	TokenNameDOT	
sstableLister	TokenNameIdentifier	 sstable Lister
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
skipTemporary	TokenNameIdentifier	 skip Temporary
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
Descriptor	TokenNameIdentifier	 Descriptor
,	TokenNameCOMMA	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Component	TokenNameIdentifier	 Component
>>	TokenNameRIGHT_SHIFT	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
lister	TokenNameIdentifier	 lister
.	TokenNameDOT	
list	TokenNameIdentifier	 list
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Descriptor	TokenNameIdentifier	 Descriptor
descriptor	TokenNameIdentifier	 descriptor
=	TokenNameEQUAL	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
currentDescriptors	TokenNameIdentifier	 current Descriptors
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
descriptor	TokenNameIdentifier	 descriptor
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
// old (initialized) SSTable found, skipping 	TokenNameCOMMENT_LINE	old (initialized) SSTable found, skipping 
if	TokenNameif	
(	TokenNameLPAREN	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
temporary	TokenNameIdentifier	 temporary
)	TokenNameRPAREN	
// in the process of being written 	TokenNameCOMMENT_LINE	in the process of being written 
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
isCompatible	TokenNameIdentifier	 is Compatible
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Can't open incompatible SSTable! Current version %s, found file: %s"	TokenNameStringLiteral	Can't open incompatible SSTable! Current version %s, found file: %s
,	TokenNameCOMMA	
Descriptor	TokenNameIdentifier	 Descriptor
.	TokenNameDOT	
Version	TokenNameIdentifier	 Version
.	TokenNameDOT	
CURRENT	TokenNameIdentifier	 CURRENT
,	TokenNameCOMMA	
descriptor	TokenNameIdentifier	 descriptor
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Descriptor	TokenNameIdentifier	 Descriptor
newDescriptor	TokenNameIdentifier	 new Descriptor
=	TokenNameEQUAL	
new	TokenNamenew	
Descriptor	TokenNameIdentifier	 Descriptor
(	TokenNameLPAREN	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
version	TokenNameIdentifier	 version
,	TokenNameCOMMA	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
directory	TokenNameIdentifier	 directory
,	TokenNameCOMMA	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
ksname	TokenNameIdentifier	 ksname
,	TokenNameCOMMA	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
cfname	TokenNameIdentifier	 cfname
,	TokenNameCOMMA	
fileIndexGenerator	TokenNameIdentifier	 file Index Generator
.	TokenNameDOT	
incrementAndGet	TokenNameIdentifier	 increment And Get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Renaming new SSTable {} to {}"	TokenNameStringLiteral	Renaming new SSTable {} to {}
,	TokenNameCOMMA	
descriptor	TokenNameIdentifier	 descriptor
,	TokenNameCOMMA	
newDescriptor	TokenNameIdentifier	 new Descriptor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SSTableWriter	TokenNameIdentifier	 SS Table Writer
.	TokenNameDOT	
rename	TokenNameIdentifier	 rename
(	TokenNameLPAREN	
descriptor	TokenNameIdentifier	 descriptor
,	TokenNameCOMMA	
newDescriptor	TokenNameIdentifier	 new Descriptor
,	TokenNameCOMMA	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SSTableReader	TokenNameIdentifier	 SS Table Reader
reader	TokenNameIdentifier	 reader
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
reader	TokenNameIdentifier	 reader
=	TokenNameEQUAL	
SSTableReader	TokenNameIdentifier	 SS Table Reader
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
newDescriptor	TokenNameIdentifier	 new Descriptor
,	TokenNameCOMMA	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
metadata	TokenNameIdentifier	 metadata
,	TokenNameCOMMA	
partitioner	TokenNameIdentifier	 partitioner
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SSTableReader	TokenNameIdentifier	 SS Table Reader
.	TokenNameDOT	
logOpenException	TokenNameIdentifier	 log Open Exception
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
newSSTables	TokenNameIdentifier	 new SS Tables
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
newSSTables	TokenNameIdentifier	 new SS Tables
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"No new SSTables were found for "	TokenNameStringLiteral	No new SSTables were found for 
+	TokenNamePLUS	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
name	TokenNameIdentifier	 name
+	TokenNamePLUS	
"/"	TokenNameStringLiteral	/
+	TokenNamePLUS	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Loading new SSTables and building secondary indexes for "	TokenNameStringLiteral	Loading new SSTables and building secondary indexes for 
+	TokenNamePLUS	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
name	TokenNameIdentifier	 name
+	TokenNamePLUS	
"/"	TokenNameStringLiteral	/
+	TokenNamePLUS	
columnFamily	TokenNameIdentifier	 column Family
+	TokenNamePLUS	
": "	TokenNameStringLiteral	: 
+	TokenNamePLUS	
newSSTables	TokenNameIdentifier	 new SS Tables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SSTableReader	TokenNameIdentifier	 SS Table Reader
.	TokenNameDOT	
acquireReferences	TokenNameIdentifier	 acquire References
(	TokenNameLPAREN	
newSSTables	TokenNameIdentifier	 new SS Tables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
addSSTables	TokenNameIdentifier	 add SS Tables
(	TokenNameLPAREN	
newSSTables	TokenNameIdentifier	 new SS Tables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
indexManager	TokenNameIdentifier	 index Manager
.	TokenNameDOT	
maybeBuildSecondaryIndexes	TokenNameIdentifier	 maybe Build Secondary Indexes
(	TokenNameLPAREN	
newSSTables	TokenNameIdentifier	 new SS Tables
,	TokenNameCOMMA	
indexManager	TokenNameIdentifier	 index Manager
.	TokenNameDOT	
allIndexesNames	TokenNameIdentifier	 all Indexes Names
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
SSTableReader	TokenNameIdentifier	 SS Table Reader
.	TokenNameDOT	
releaseReferences	TokenNameIdentifier	 release References
(	TokenNameLPAREN	
newSSTables	TokenNameIdentifier	 new SS Tables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Done loading load new SSTables for "	TokenNameStringLiteral	Done loading load new SSTables for 
+	TokenNamePLUS	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
name	TokenNameIdentifier	 name
+	TokenNamePLUS	
"/"	TokenNameStringLiteral	/
+	TokenNamePLUS	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
rebuildSecondaryIndex	TokenNameIdentifier	 rebuild Secondary Index
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
ksName	TokenNameIdentifier	 ks Name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
cfName	TokenNameIdentifier	 cf Name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
...	TokenNameELLIPSIS	
idxNames	TokenNameIdentifier	 idx Names
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
=	TokenNameEQUAL	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
ksName	TokenNameIdentifier	 ks Name
)	TokenNameRPAREN	
.	TokenNameDOT	
getColumnFamilyStore	TokenNameIdentifier	 get Column Family Store
(	TokenNameLPAREN	
cfName	TokenNameIdentifier	 cf Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
indexes	TokenNameIdentifier	 indexes
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
asList	TokenNameIdentifier	 as List
(	TokenNameLPAREN	
idxNames	TokenNameIdentifier	 idx Names
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
=	TokenNameEQUAL	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
getSSTables	TokenNameIdentifier	 get SS Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
indexManager	TokenNameIdentifier	 index Manager
.	TokenNameDOT	
setIndexRemoved	TokenNameIdentifier	 set Index Removed
(	TokenNameLPAREN	
indexes	TokenNameIdentifier	 indexes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SSTableReader	TokenNameIdentifier	 SS Table Reader
.	TokenNameDOT	
acquireReferences	TokenNameIdentifier	 acquire References
(	TokenNameLPAREN	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"User Requested secondary index re-build for %s/%s indexes"	TokenNameStringLiteral	User Requested secondary index re-build for %s/%s indexes
,	TokenNameCOMMA	
ksName	TokenNameIdentifier	 ks Name
,	TokenNameCOMMA	
cfName	TokenNameIdentifier	 cf Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
indexManager	TokenNameIdentifier	 index Manager
.	TokenNameDOT	
maybeBuildSecondaryIndexes	TokenNameIdentifier	 maybe Build Secondary Indexes
(	TokenNameLPAREN	
sstables	TokenNameIdentifier	 sstables
,	TokenNameCOMMA	
indexes	TokenNameIdentifier	 indexes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
indexManager	TokenNameIdentifier	 index Manager
.	TokenNameDOT	
setIndexBuilt	TokenNameIdentifier	 set Index Built
(	TokenNameLPAREN	
indexes	TokenNameIdentifier	 indexes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
SSTableReader	TokenNameIdentifier	 SS Table Reader
.	TokenNameDOT	
releaseReferences	TokenNameIdentifier	 release References
(	TokenNameLPAREN	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * @return the name of the column family */	TokenNameCOMMENT_JAVADOC	 @return the name of the column family 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getColumnFamilyName	TokenNameIdentifier	 get Column Family Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
columnFamily	TokenNameIdentifier	 column Family
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getTempSSTablePath	TokenNameIdentifier	 get Temp SS Table Path
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
directory	TokenNameIdentifier	 directory
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getTempSSTablePath	TokenNameIdentifier	 get Temp SS Table Path
(	TokenNameLPAREN	
directory	TokenNameIdentifier	 directory
,	TokenNameCOMMA	
Descriptor	TokenNameIdentifier	 Descriptor
.	TokenNameDOT	
Version	TokenNameIdentifier	 Version
.	TokenNameDOT	
CURRENT	TokenNameIdentifier	 CURRENT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
getTempSSTablePath	TokenNameIdentifier	 get Temp SS Table Path
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
directory	TokenNameIdentifier	 directory
,	TokenNameCOMMA	
Descriptor	TokenNameIdentifier	 Descriptor
.	TokenNameDOT	
Version	TokenNameIdentifier	 Version
version	TokenNameIdentifier	 version
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Descriptor	TokenNameIdentifier	 Descriptor
desc	TokenNameIdentifier	 desc
=	TokenNameEQUAL	
new	TokenNamenew	
Descriptor	TokenNameIdentifier	 Descriptor
(	TokenNameLPAREN	
version	TokenNameIdentifier	 version
,	TokenNameCOMMA	
directory	TokenNameIdentifier	 directory
,	TokenNameCOMMA	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
fileIndexGenerator	TokenNameIdentifier	 file Index Generator
.	TokenNameDOT	
incrementAndGet	TokenNameIdentifier	 increment And Get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
filenameFor	TokenNameIdentifier	 filename For
(	TokenNameLPAREN	
Component	TokenNameIdentifier	 Component
.	TokenNameDOT	
DATA	TokenNameIdentifier	 DATA
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Switch and flush the current memtable, if it was dirty. The forceSwitch * flag allow to force switching the memtable even if it is clean (though * in that case we don't flush, as there is no point). */	TokenNameCOMMENT_JAVADOC	 Switch and flush the current memtable, if it was dirty. The forceSwitch flag allow to force switching the memtable even if it is clean (though in that case we don't flush, as there is no point). 
public	TokenNamepublic	
Future	TokenNameIdentifier	 Future
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
switchMemtable	TokenNameIdentifier	 switch Memtable
(	TokenNameLPAREN	
final	TokenNamefinal	
boolean	TokenNameboolean	
writeCommitLog	TokenNameIdentifier	 write Commit Log
,	TokenNameCOMMA	
boolean	TokenNameboolean	
forceSwitch	TokenNameIdentifier	 force Switch
)	TokenNameRPAREN	
{	TokenNameLBRACE	
/* * If we can get the writelock, that means no new updates can come in and * all ongoing updates to memtables have completed. We can get the tail * of the log and use it as the starting position for log replay on recovery. * * This is why we Table.switchLock needs to be global instead of per-Table: * we need to schedule discardCompletedSegments calls in the same order as their * contexts (commitlog position) were read, even though the flush executor * is multithreaded. */	TokenNameCOMMENT_BLOCK	 If we can get the writelock, that means no new updates can come in and all ongoing updates to memtables have completed. We can get the tail of the log and use it as the starting position for log replay on recovery. * This is why we Table.switchLock needs to be global instead of per-Table: we need to schedule discardCompletedSegments calls in the same order as their contexts (commitlog position) were read, even though the flush executor is multithreaded. 
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
switchLock	TokenNameIdentifier	 switch Lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
final	TokenNamefinal	
Future	TokenNameIdentifier	 Future
<	TokenNameLESS	
ReplayPosition	TokenNameIdentifier	 Replay Position
>	TokenNameGREATER	
ctx	TokenNameIdentifier	 ctx
=	TokenNameEQUAL	
writeCommitLog	TokenNameIdentifier	 write Commit Log
?	TokenNameQUESTION	
CommitLog	TokenNameIdentifier	 Commit Log
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getContext	TokenNameIdentifier	 get Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
Futures	TokenNameIdentifier	 Futures
.	TokenNameDOT	
immediateFuture	TokenNameIdentifier	 immediate Future
(	TokenNameLPAREN	
ReplayPosition	TokenNameIdentifier	 Replay Position
.	TokenNameDOT	
NONE	TokenNameIdentifier	 NONE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// submit the memtable for any indexed sub-cfses, and our own. 	TokenNameCOMMENT_LINE	submit the memtable for any indexed sub-cfses, and our own. 
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
>	TokenNameGREATER	
icc	TokenNameIdentifier	 icc
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// don't assume that this.memtable is dirty; forceFlush can bring us here during index build even if it is not 	TokenNameCOMMENT_LINE	don't assume that this.memtable is dirty; forceFlush can bring us here during index build even if it is not 
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
:	TokenNameCOLON	
concatWithIndexes	TokenNameIdentifier	 concat With Indexes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
forceSwitch	TokenNameIdentifier	 force Switch
||	TokenNameOR_OR	
!	TokenNameNOT	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
getMemtableThreadSafe	TokenNameIdentifier	 get Memtable Thread Safe
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
isClean	TokenNameIdentifier	 is Clean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
icc	TokenNameIdentifier	 icc
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
CountDownLatch	TokenNameIdentifier	 Count Down Latch
latch	TokenNameIdentifier	 latch
=	TokenNameEQUAL	
new	TokenNamenew	
CountDownLatch	TokenNameIdentifier	 Count Down Latch
(	TokenNameLPAREN	
icc	TokenNameIdentifier	 icc
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
:	TokenNameCOLON	
icc	TokenNameIdentifier	 icc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Memtable	TokenNameIdentifier	 Memtable
memtable	TokenNameIdentifier	 memtable
=	TokenNameEQUAL	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
switchMemtable	TokenNameIdentifier	 switch Memtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// With forceSwitch it's possible to get a clean memtable here. 	TokenNameCOMMENT_LINE	With forceSwitch it's possible to get a clean memtable here. 
// In that case, since we've switched it already, just remove 	TokenNameCOMMENT_LINE	In that case, since we've switched it already, just remove 
// it from the memtable pending flush right away. 	TokenNameCOMMENT_LINE	it from the memtable pending flush right away. 
if	TokenNameif	
(	TokenNameLPAREN	
memtable	TokenNameIdentifier	 memtable
.	TokenNameDOT	
isClean	TokenNameIdentifier	 is Clean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
replaceFlushed	TokenNameIdentifier	 replace Flushed
(	TokenNameLPAREN	
memtable	TokenNameIdentifier	 memtable
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
latch	TokenNameIdentifier	 latch
.	TokenNameDOT	
countDown	TokenNameIdentifier	 count Down
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Enqueuing flush of {}"	TokenNameStringLiteral	Enqueuing flush of {}
,	TokenNameCOMMA	
memtable	TokenNameIdentifier	 memtable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
memtable	TokenNameIdentifier	 memtable
.	TokenNameDOT	
flushAndSignal	TokenNameIdentifier	 flush And Signal
(	TokenNameLPAREN	
latch	TokenNameIdentifier	 latch
,	TokenNameCOMMA	
flushWriter	TokenNameIdentifier	 flush Writer
,	TokenNameCOMMA	
ctx	TokenNameIdentifier	 ctx
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
memtableSwitchCount	TokenNameIdentifier	 memtable Switch Count
.	TokenNameDOT	
count	TokenNameIdentifier	 count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
Long	TokenNameIdentifier	 Long
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
)	TokenNameRPAREN	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
memtableSwitchCount	TokenNameIdentifier	 memtable Switch Count
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
memtableSwitchCount	TokenNameIdentifier	 memtable Switch Count
.	TokenNameDOT	
inc	TokenNameIdentifier	 inc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// when all the memtables have been written, including for indexes, mark the flush in the commitlog header. 	TokenNameCOMMENT_LINE	when all the memtables have been written, including for indexes, mark the flush in the commitlog header. 
// a second executor makes sure the onMemtableFlushes get called in the right order, 	TokenNameCOMMENT_LINE	a second executor makes sure the onMemtableFlushes get called in the right order, 
// while keeping the wait-for-flush (future.get) out of anything latency-sensitive. 	TokenNameCOMMENT_LINE	while keeping the wait-for-flush (future.get) out of anything latency-sensitive. 
return	TokenNamereturn	
postFlushExecutor	TokenNameIdentifier	 post Flush Executor
.	TokenNameDOT	
submit	TokenNameIdentifier	 submit
(	TokenNameLPAREN	
new	TokenNamenew	
WrappedRunnable	TokenNameIdentifier	 Wrapped Runnable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
runMayThrow	TokenNameIdentifier	 run May Throw
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
,	TokenNameCOMMA	
ExecutionException	TokenNameIdentifier	 Execution Exception
{	TokenNameLBRACE	
latch	TokenNameIdentifier	 latch
.	TokenNameDOT	
await	TokenNameIdentifier	 await
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
icc	TokenNameIdentifier	 icc
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//only valid when memtables exist 	TokenNameCOMMENT_LINE	only valid when memtables exist 
for	TokenNamefor	
(	TokenNameLPAREN	
SecondaryIndex	TokenNameIdentifier	 Secondary Index
index	TokenNameIdentifier	 index
:	TokenNameCOLON	
indexManager	TokenNameIdentifier	 index Manager
.	TokenNameDOT	
getIndexesNotBackedByCfs	TokenNameIdentifier	 get Indexes Not Backed By Cfs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// flush any non-cfs backed indexes 	TokenNameCOMMENT_LINE	flush any non-cfs backed indexes 
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Flushing SecondaryIndex {}"	TokenNameStringLiteral	Flushing SecondaryIndex {}
,	TokenNameCOMMA	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
forceBlockingFlush	TokenNameIdentifier	 force Blocking Flush
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
writeCommitLog	TokenNameIdentifier	 write Commit Log
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if we're not writing to the commit log, we are replaying the log, so marking 	TokenNameCOMMENT_LINE	if we're not writing to the commit log, we are replaying the log, so marking 
// the log header with "you can discard anything written before the context" is not valid 	TokenNameCOMMENT_LINE	the log header with "you can discard anything written before the context" is not valid 
CommitLog	TokenNameIdentifier	 Commit Log
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
discardCompletedSegments	TokenNameIdentifier	 discard Completed Segments
(	TokenNameLPAREN	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
cfId	TokenNameIdentifier	 cf Id
,	TokenNameCOMMA	
ctx	TokenNameIdentifier	 ctx
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
switchLock	TokenNameIdentifier	 switch Lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
Future	TokenNameIdentifier	 Future
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
forceFlush	TokenNameIdentifier	 force Flush
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// during index build, 2ary index memtables can be dirty even if parent is not. if so, 	TokenNameCOMMENT_LINE	during index build, 2ary index memtables can be dirty even if parent is not. if so, 
// we want flushLargestMemtables to flush the 2ary index ones too. 	TokenNameCOMMENT_LINE	we want flushLargestMemtables to flush the 2ary index ones too. 
boolean	TokenNameboolean	
clean	TokenNameIdentifier	 clean
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
:	TokenNameCOLON	
concatWithIndexes	TokenNameIdentifier	 concat With Indexes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
clean	TokenNameIdentifier	 clean
&=	TokenNameAND_EQUAL	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
getMemtableThreadSafe	TokenNameIdentifier	 get Memtable Thread Safe
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
isClean	TokenNameIdentifier	 is Clean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
clean	TokenNameIdentifier	 clean
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"forceFlush requested but everything is clean in {}"	TokenNameStringLiteral	forceFlush requested but everything is clean in {}
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
Futures	TokenNameIdentifier	 Futures
.	TokenNameDOT	
immediateCheckedFuture	TokenNameIdentifier	 immediate Checked Future
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
switchMemtable	TokenNameIdentifier	 switch Memtable
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
forceBlockingFlush	TokenNameIdentifier	 force Blocking Flush
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
ExecutionException	TokenNameIdentifier	 Execution Exception
,	TokenNameCOMMA	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
{	TokenNameLBRACE	
forceFlush	TokenNameIdentifier	 force Flush
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
maybeUpdateRowCache	TokenNameIdentifier	 maybe Update Row Cache
(	TokenNameLPAREN	
DecoratedKey	TokenNameIdentifier	 Decorated Key
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
ColumnFamily	TokenNameIdentifier	 Column Family
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isRowCacheEnabled	TokenNameIdentifier	 is Row Cache Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
RowCacheKey	TokenNameIdentifier	 Row Cache Key
cacheKey	TokenNameIdentifier	 cache Key
=	TokenNameEQUAL	
new	TokenNamenew	
RowCacheKey	TokenNameIdentifier	 Row Cache Key
(	TokenNameLPAREN	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
cfId	TokenNameIdentifier	 cf Id
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// always invalidate a copying cache value 	TokenNameCOMMENT_LINE	always invalidate a copying cache value 
if	TokenNameif	
(	TokenNameLPAREN	
CacheService	TokenNameIdentifier	 Cache Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
rowCache	TokenNameIdentifier	 row Cache
.	TokenNameDOT	
isPutCopying	TokenNameIdentifier	 is Put Copying
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
invalidateCachedRow	TokenNameIdentifier	 invalidate Cached Row
(	TokenNameLPAREN	
cacheKey	TokenNameIdentifier	 cache Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// invalidate a normal cache value if it's a sentinel, so the read will retry (and include the new update) 	TokenNameCOMMENT_LINE	invalidate a normal cache value if it's a sentinel, so the read will retry (and include the new update) 
IRowCacheEntry	TokenNameIdentifier	 I Row Cache Entry
cachedRow	TokenNameIdentifier	 cached Row
=	TokenNameEQUAL	
getCachedRowInternal	TokenNameIdentifier	 get Cached Row Internal
(	TokenNameLPAREN	
cacheKey	TokenNameIdentifier	 cache Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cachedRow	TokenNameIdentifier	 cached Row
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
cachedRow	TokenNameIdentifier	 cached Row
instanceof	TokenNameinstanceof	
RowCacheSentinel	TokenNameIdentifier	 Row Cache Sentinel
)	TokenNameRPAREN	
invalidateCachedRow	TokenNameIdentifier	 invalidate Cached Row
(	TokenNameLPAREN	
cacheKey	TokenNameIdentifier	 cache Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
// columnFamily is what is written in the commit log. Because of the PeriodicCommitLog, this can be done in concurrency 	TokenNameCOMMENT_LINE	columnFamily is what is written in the commit log. Because of the PeriodicCommitLog, this can be done in concurrency 
// with this. So columnFamily shouldn't be modified and if it contains super columns, neither should they. So for super 	TokenNameCOMMENT_LINE	with this. So columnFamily shouldn't be modified and if it contains super columns, neither should they. So for super 
// columns, we must make sure to clone them when adding to the cache. That's what addAllWithSCCopy does (see #3957) 	TokenNameCOMMENT_LINE	columns, we must make sure to clone them when adding to the cache. That's what addAllWithSCCopy does (see #3957) 
(	TokenNameLPAREN	
(	TokenNameLPAREN	
ColumnFamily	TokenNameIdentifier	 Column Family
)	TokenNameRPAREN	
cachedRow	TokenNameIdentifier	 cached Row
)	TokenNameRPAREN	
.	TokenNameDOT	
addAllWithSCCopy	TokenNameIdentifier	 add All With SC Copy
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
HeapAllocator	TokenNameIdentifier	 Heap Allocator
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Insert/Update the column family for this key. * Caller is responsible for acquiring Table.flusherLock! * param @ lock - lock that needs to be used. * param @ key - key for update/insert * param @ columnFamily - columnFamily changes */	TokenNameCOMMENT_JAVADOC	 Insert/Update the column family for this key. Caller is responsible for acquiring Table.flusherLock! param @ lock - lock that needs to be used. param @ key - key for update/insert param @ columnFamily - columnFamily changes 
public	TokenNamepublic	
void	TokenNamevoid	
apply	TokenNameIdentifier	 apply
(	TokenNameLPAREN	
DecoratedKey	TokenNameIdentifier	 Decorated Key
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
ColumnFamily	TokenNameIdentifier	 Column Family
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
SecondaryIndexManager	TokenNameIdentifier	 Secondary Index Manager
.	TokenNameDOT	
Updater	TokenNameIdentifier	 Updater
indexer	TokenNameIdentifier	 indexer
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
start	TokenNameIdentifier	 start
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
nanoTime	TokenNameIdentifier	 nano Time
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Memtable	TokenNameIdentifier	 Memtable
mt	TokenNameIdentifier	 mt
=	TokenNameEQUAL	
getMemtableThreadSafe	TokenNameIdentifier	 get Memtable Thread Safe
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
mt	TokenNameIdentifier	 mt
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
indexer	TokenNameIdentifier	 indexer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
maybeUpdateRowCache	TokenNameIdentifier	 maybe Update Row Cache
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
writeLatency	TokenNameIdentifier	 write Latency
.	TokenNameDOT	
addNano	TokenNameIdentifier	 add Nano
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
nanoTime	TokenNameIdentifier	 nano Time
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
start	TokenNameIdentifier	 start
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// recompute liveRatio, if we have doubled the number of ops since last calculated 	TokenNameCOMMENT_LINE	recompute liveRatio, if we have doubled the number of ops since last calculated 
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
last	TokenNameIdentifier	 last
=	TokenNameEQUAL	
liveRatioComputedAt	TokenNameIdentifier	 live Ratio Computed At
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
operations	TokenNameIdentifier	 operations
=	TokenNameEQUAL	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
writeLatency	TokenNameIdentifier	 write Latency
.	TokenNameDOT	
latency	TokenNameIdentifier	 latency
.	TokenNameDOT	
count	TokenNameIdentifier	 count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
operations	TokenNameIdentifier	 operations
<	TokenNameLESS	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
last	TokenNameIdentifier	 last
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
liveRatioComputedAt	TokenNameIdentifier	 live Ratio Computed At
.	TokenNameDOT	
compareAndSet	TokenNameIdentifier	 compare And Set
(	TokenNameLPAREN	
last	TokenNameIdentifier	 last
,	TokenNameCOMMA	
operations	TokenNameIdentifier	 operations
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"computing liveRatio of {} at {} ops"	TokenNameStringLiteral	computing liveRatio of {} at {} ops
,	TokenNameCOMMA	
this	TokenNamethis	
,	TokenNameCOMMA	
operations	TokenNameIdentifier	 operations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
mt	TokenNameIdentifier	 mt
.	TokenNameDOT	
updateLiveRatio	TokenNameIdentifier	 update Live Ratio
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
ColumnFamily	TokenNameIdentifier	 Column Family
removeDeletedCF	TokenNameIdentifier	 remove Deleted CF
(	TokenNameLPAREN	
ColumnFamily	TokenNameIdentifier	 Column Family
cf	TokenNameIdentifier	 cf
,	TokenNameCOMMA	
int	TokenNameint	
gcBefore	TokenNameIdentifier	 gc Before
)	TokenNameRPAREN	
{	TokenNameLBRACE	
cf	TokenNameIdentifier	 cf
.	TokenNameDOT	
maybeResetDeletionTimes	TokenNameIdentifier	 maybe Reset Deletion Times
(	TokenNameLPAREN	
gcBefore	TokenNameIdentifier	 gc Before
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
cf	TokenNameIdentifier	 cf
.	TokenNameDOT	
getColumnCount	TokenNameIdentifier	 get Column Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
!	TokenNameNOT	
cf	TokenNameIdentifier	 cf
.	TokenNameDOT	
isMarkedForDelete	TokenNameIdentifier	 is Marked For Delete
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
cf	TokenNameIdentifier	 cf
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
ColumnFamily	TokenNameIdentifier	 Column Family
removeDeleted	TokenNameIdentifier	 remove Deleted
(	TokenNameLPAREN	
ColumnFamily	TokenNameIdentifier	 Column Family
cf	TokenNameIdentifier	 cf
,	TokenNameCOMMA	
int	TokenNameint	
gcBefore	TokenNameIdentifier	 gc Before
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
removeDeleted	TokenNameIdentifier	 remove Deleted
(	TokenNameLPAREN	
cf	TokenNameIdentifier	 cf
,	TokenNameCOMMA	
gcBefore	TokenNameIdentifier	 gc Before
,	TokenNameCOMMA	
SecondaryIndexManager	TokenNameIdentifier	 Secondary Index Manager
.	TokenNameDOT	
nullUpdater	TokenNameIdentifier	 null Updater
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* This is complicated because we need to preserve deleted columns, supercolumns, and columnfamilies until they have been deleted for at least GC_GRACE_IN_SECONDS. But, we do not need to preserve their contents; just the object itself as a "tombstone" that can be used to repair other replicas that do not know about the deletion. */	TokenNameCOMMENT_BLOCK	 This is complicated because we need to preserve deleted columns, supercolumns, and columnfamilies until they have been deleted for at least GC_GRACE_IN_SECONDS. But, we do not need to preserve their contents; just the object itself as a "tombstone" that can be used to repair other replicas that do not know about the deletion. 
public	TokenNamepublic	
static	TokenNamestatic	
ColumnFamily	TokenNameIdentifier	 Column Family
removeDeleted	TokenNameIdentifier	 remove Deleted
(	TokenNameLPAREN	
ColumnFamily	TokenNameIdentifier	 Column Family
cf	TokenNameIdentifier	 cf
,	TokenNameCOMMA	
int	TokenNameint	
gcBefore	TokenNameIdentifier	 gc Before
,	TokenNameCOMMA	
SecondaryIndexManager	TokenNameIdentifier	 Secondary Index Manager
.	TokenNameDOT	
Updater	TokenNameIdentifier	 Updater
indexer	TokenNameIdentifier	 indexer
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
cf	TokenNameIdentifier	 cf
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
removeDeletedColumnsOnly	TokenNameIdentifier	 remove Deleted Columns Only
(	TokenNameLPAREN	
cf	TokenNameIdentifier	 cf
,	TokenNameCOMMA	
gcBefore	TokenNameIdentifier	 gc Before
,	TokenNameCOMMA	
indexer	TokenNameIdentifier	 indexer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
removeDeletedCF	TokenNameIdentifier	 remove Deleted CF
(	TokenNameLPAREN	
cf	TokenNameIdentifier	 cf
,	TokenNameCOMMA	
gcBefore	TokenNameIdentifier	 gc Before
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
removeDeletedColumnsOnly	TokenNameIdentifier	 remove Deleted Columns Only
(	TokenNameLPAREN	
ColumnFamily	TokenNameIdentifier	 Column Family
cf	TokenNameIdentifier	 cf
,	TokenNameCOMMA	
int	TokenNameint	
gcBefore	TokenNameIdentifier	 gc Before
,	TokenNameCOMMA	
SecondaryIndexManager	TokenNameIdentifier	 Secondary Index Manager
.	TokenNameDOT	
Updater	TokenNameIdentifier	 Updater
indexer	TokenNameIdentifier	 indexer
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
cf	TokenNameIdentifier	 cf
.	TokenNameDOT	
isSuper	TokenNameIdentifier	 is Super
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
removeDeletedSuper	TokenNameIdentifier	 remove Deleted Super
(	TokenNameLPAREN	
cf	TokenNameIdentifier	 cf
,	TokenNameCOMMA	
gcBefore	TokenNameIdentifier	 gc Before
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
removeDeletedStandard	TokenNameIdentifier	 remove Deleted Standard
(	TokenNameLPAREN	
cf	TokenNameIdentifier	 cf
,	TokenNameCOMMA	
gcBefore	TokenNameIdentifier	 gc Before
,	TokenNameCOMMA	
indexer	TokenNameIdentifier	 indexer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
removeDeletedColumnsOnly	TokenNameIdentifier	 remove Deleted Columns Only
(	TokenNameLPAREN	
ColumnFamily	TokenNameIdentifier	 Column Family
cf	TokenNameIdentifier	 cf
,	TokenNameCOMMA	
int	TokenNameint	
gcBefore	TokenNameIdentifier	 gc Before
)	TokenNameRPAREN	
{	TokenNameLBRACE	
removeDeletedColumnsOnly	TokenNameIdentifier	 remove Deleted Columns Only
(	TokenNameLPAREN	
cf	TokenNameIdentifier	 cf
,	TokenNameCOMMA	
gcBefore	TokenNameIdentifier	 gc Before
,	TokenNameCOMMA	
SecondaryIndexManager	TokenNameIdentifier	 Secondary Index Manager
.	TokenNameDOT	
nullUpdater	TokenNameIdentifier	 null Updater
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
removeDeletedStandard	TokenNameIdentifier	 remove Deleted Standard
(	TokenNameLPAREN	
ColumnFamily	TokenNameIdentifier	 Column Family
cf	TokenNameIdentifier	 cf
,	TokenNameCOMMA	
int	TokenNameint	
gcBefore	TokenNameIdentifier	 gc Before
,	TokenNameCOMMA	
SecondaryIndexManager	TokenNameIdentifier	 Secondary Index Manager
.	TokenNameDOT	
Updater	TokenNameIdentifier	 Updater
indexer	TokenNameIdentifier	 indexer
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
IColumn	TokenNameIdentifier	 I Column
>	TokenNameGREATER	
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
cf	TokenNameIdentifier	 cf
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
IColumn	TokenNameIdentifier	 I Column
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// remove columns if 	TokenNameCOMMENT_LINE	remove columns if 
// (a) the column itself is gcable or 	TokenNameCOMMENT_LINE	(a) the column itself is gcable or 
// (b) the column is shadowed by a CF tombstone 	TokenNameCOMMENT_LINE	(b) the column is shadowed by a CF tombstone 
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
getLocalDeletionTime	TokenNameIdentifier	 get Local Deletion Time
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<	TokenNameLESS	
gcBefore	TokenNameIdentifier	 gc Before
||	TokenNameOR_OR	
cf	TokenNameIdentifier	 cf
.	TokenNameDOT	
deletionInfo	TokenNameIdentifier	 deletion Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
isDeleted	TokenNameIdentifier	 is Deleted
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
indexer	TokenNameIdentifier	 indexer
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
removeDeletedSuper	TokenNameIdentifier	 remove Deleted Super
(	TokenNameLPAREN	
ColumnFamily	TokenNameIdentifier	 Column Family
cf	TokenNameIdentifier	 cf
,	TokenNameCOMMA	
int	TokenNameint	
gcBefore	TokenNameIdentifier	 gc Before
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// TODO assume deletion means "most are deleted?" and add to clone, instead of remove from original? 	TokenNameCOMMENT_LINE	TODO assume deletion means "most are deleted?" and add to clone, instead of remove from original? 
// this could be improved by having compaction, or possibly even removeDeleted, r/m the tombstone 	TokenNameCOMMENT_LINE	this could be improved by having compaction, or possibly even removeDeleted, r/m the tombstone 
// once gcBefore has passed, so if new stuff is added in it doesn't used the wrong algorithm forever 	TokenNameCOMMENT_LINE	once gcBefore has passed, so if new stuff is added in it doesn't used the wrong algorithm forever 
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
IColumn	TokenNameIdentifier	 I Column
>	TokenNameGREATER	
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
cf	TokenNameIdentifier	 cf
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SuperColumn	TokenNameIdentifier	 Super Column
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
(	TokenNameLPAREN	
SuperColumn	TokenNameIdentifier	 Super Column
)	TokenNameRPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
IColumn	TokenNameIdentifier	 I Column
>	TokenNameGREATER	
subIter	TokenNameIdentifier	 sub Iter
=	TokenNameEQUAL	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
getSubColumns	TokenNameIdentifier	 get Sub Columns
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
subIter	TokenNameIdentifier	 sub Iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
IColumn	TokenNameIdentifier	 I Column
subColumn	TokenNameIdentifier	 sub Column
=	TokenNameEQUAL	
subIter	TokenNameIdentifier	 sub Iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// remove subcolumns if 	TokenNameCOMMENT_LINE	remove subcolumns if 
// (a) the subcolumn itself is gcable or 	TokenNameCOMMENT_LINE	(a) the subcolumn itself is gcable or 
// (b) the supercolumn is shadowed by the CF and the column is not newer 	TokenNameCOMMENT_LINE	(b) the supercolumn is shadowed by the CF and the column is not newer 
// (b) the subcolumn is shadowed by the supercolumn 	TokenNameCOMMENT_LINE	(b) the subcolumn is shadowed by the supercolumn 
if	TokenNameif	
(	TokenNameLPAREN	
subColumn	TokenNameIdentifier	 sub Column
.	TokenNameDOT	
getLocalDeletionTime	TokenNameIdentifier	 get Local Deletion Time
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<	TokenNameLESS	
gcBefore	TokenNameIdentifier	 gc Before
||	TokenNameOR_OR	
cf	TokenNameIdentifier	 cf
.	TokenNameDOT	
deletionInfo	TokenNameIdentifier	 deletion Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
isDeleted	TokenNameIdentifier	 is Deleted
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
name	TokenNameIdentifier	 name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
subColumn	TokenNameIdentifier	 sub Column
.	TokenNameDOT	
timestamp	TokenNameIdentifier	 timestamp
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
deletionInfo	TokenNameIdentifier	 deletion Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
isDeleted	TokenNameIdentifier	 is Deleted
(	TokenNameLPAREN	
subColumn	TokenNameIdentifier	 sub Column
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
subIter	TokenNameIdentifier	 sub Iter
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
maybeResetDeletionTimes	TokenNameIdentifier	 maybe Reset Deletion Times
(	TokenNameLPAREN	
gcBefore	TokenNameIdentifier	 gc Before
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
getSubColumns	TokenNameIdentifier	 get Sub Columns
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
isMarkedForDelete	TokenNameIdentifier	 is Marked For Delete
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * @param sstables * @return sstables whose key range overlaps with that of the given sstables, not including itself. * (The given sstables may or may not overlap with each other.) */	TokenNameCOMMENT_JAVADOC	 @param sstables @return sstables whose key range overlaps with that of the given sstables, not including itself. (The given sstables may or may not overlap with each other.) 
public	TokenNamepublic	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
getOverlappingSSTables	TokenNameIdentifier	 get Overlapping SS Tables
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Checking for sstables overlapping {}"	TokenNameStringLiteral	Checking for sstables overlapping {}
,	TokenNameCOMMA	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// a normal compaction won't ever have an empty sstables list, but we create a skeleton 	TokenNameCOMMENT_LINE	a normal compaction won't ever have an empty sstables list, but we create a skeleton 
// compaction controller for streaming, and that passes an empty list. 	TokenNameCOMMENT_LINE	compaction controller for streaming, and that passes an empty list. 
if	TokenNameif	
(	TokenNameLPAREN	
sstables	TokenNameIdentifier	 sstables
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
ImmutableSet	TokenNameIdentifier	 Immutable Set
.	TokenNameDOT	
of	TokenNameIdentifier	 of
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DataTracker	TokenNameIdentifier	 Data Tracker
.	TokenNameDOT	
SSTableIntervalTree	TokenNameIdentifier	 SS Table Interval Tree
tree	TokenNameIdentifier	 tree
=	TokenNameEQUAL	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
getView	TokenNameIdentifier	 get View
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
intervalTree	TokenNameIdentifier	 interval Tree
;	TokenNameSEMICOLON	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
results	TokenNameIdentifier	 results
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
:	TokenNameCOLON	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
overlaps	TokenNameIdentifier	 overlaps
=	TokenNameEQUAL	
ImmutableSet	TokenNameIdentifier	 Immutable Set
.	TokenNameDOT	
copyOf	TokenNameIdentifier	 copy Of
(	TokenNameLPAREN	
tree	TokenNameIdentifier	 tree
.	TokenNameDOT	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
Interval	TokenNameIdentifier	 Interval
.	TokenNameDOT	
<	TokenNameLESS	
RowPosition	TokenNameIdentifier	 Row Position
,	TokenNameCOMMA	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
first	TokenNameIdentifier	 first
,	TokenNameCOMMA	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
last	TokenNameIdentifier	 last
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
overlaps	TokenNameIdentifier	 overlaps
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
results	TokenNameIdentifier	 results
=	TokenNameEQUAL	
results	TokenNameIdentifier	 results
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
overlaps	TokenNameIdentifier	 overlaps
:	TokenNameCOLON	
Sets	TokenNameIdentifier	 Sets
.	TokenNameDOT	
union	TokenNameIdentifier	 union
(	TokenNameLPAREN	
results	TokenNameIdentifier	 results
,	TokenNameCOMMA	
overlaps	TokenNameIdentifier	 overlaps
)	TokenNameRPAREN	
.	TokenNameDOT	
immutableCopy	TokenNameIdentifier	 immutable Copy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
results	TokenNameIdentifier	 results
=	TokenNameEQUAL	
Sets	TokenNameIdentifier	 Sets
.	TokenNameDOT	
difference	TokenNameIdentifier	 difference
(	TokenNameLPAREN	
results	TokenNameIdentifier	 results
,	TokenNameCOMMA	
ImmutableSet	TokenNameIdentifier	 Immutable Set
.	TokenNameDOT	
copyOf	TokenNameIdentifier	 copy Of
(	TokenNameLPAREN	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
results	TokenNameIdentifier	 results
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * like getOverlappingSSTables, but acquires references before returning */	TokenNameCOMMENT_JAVADOC	 like getOverlappingSSTables, but acquires references before returning 
public	TokenNamepublic	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
getAndReferenceOverlappingSSTables	TokenNameIdentifier	 get And Reference Overlapping SS Tables
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
overlapped	TokenNameIdentifier	 overlapped
=	TokenNameEQUAL	
getOverlappingSSTables	TokenNameIdentifier	 get Overlapping SS Tables
(	TokenNameLPAREN	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
.	TokenNameDOT	
acquireReferences	TokenNameIdentifier	 acquire References
(	TokenNameLPAREN	
overlapped	TokenNameIdentifier	 overlapped
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
overlapped	TokenNameIdentifier	 overlapped
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* * Called after a BinaryMemtable flushes its in-memory data, or we add a file * via bootstrap. This information is cached in the ColumnFamilyStore. * This is useful for reads because the ColumnFamilyStore first looks in * the in-memory store and the into the disk to find the key. If invoked * during recoveryMode the onMemtableFlush() need not be invoked. * * param @ filename - filename just flushed to disk */	TokenNameCOMMENT_BLOCK	 Called after a BinaryMemtable flushes its in-memory data, or we add a file via bootstrap. This information is cached in the ColumnFamilyStore. This is useful for reads because the ColumnFamilyStore first looks in the in-memory store and the into the disk to find the key. If invoked during recoveryMode the onMemtableFlush() need not be invoked. * param @ filename - filename just flushed to disk 
public	TokenNamepublic	
void	TokenNamevoid	
addSSTable	TokenNameIdentifier	 add SS Table
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
getColumnFamilyName	TokenNameIdentifier	 get Column Family Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
addSSTables	TokenNameIdentifier	 add SS Tables
(	TokenNameLPAREN	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
asList	TokenNameIdentifier	 as List
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
addSSTables	TokenNameIdentifier	 add SS Tables
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
addSSTables	TokenNameIdentifier	 add SS Tables
(	TokenNameLPAREN	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CompactionManager	TokenNameIdentifier	 Compaction Manager
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
submitBackground	TokenNameIdentifier	 submit Background
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Calculate expected file size of SSTable after compaction. * * If operation type is {@code CLEANUP} and we're not dealing with an index sstable, * then we calculate expected file size with checking token range to be eliminated. * * Otherwise, we just add up all the files' size, which is the worst case file * size for compaction of all the list of files given. * * @param sstables SSTables to calculate expected compacted file size * @param operation Operation type * @return Expected file size of SSTable after compaction */	TokenNameCOMMENT_JAVADOC	 Calculate expected file size of SSTable after compaction. * If operation type is {@code CLEANUP} and we're not dealing with an index sstable, then we calculate expected file size with checking token range to be eliminated. * Otherwise, we just add up all the files' size, which is the worst case file size for compaction of all the list of files given. * @param sstables SSTables to calculate expected compacted file size @param operation Operation type @return Expected file size of SSTable after compaction 
public	TokenNamepublic	
long	TokenNamelong	
getExpectedCompactedFileSize	TokenNameIdentifier	 get Expected Compacted File Size
(	TokenNameLPAREN	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
,	TokenNameCOMMA	
OperationType	TokenNameIdentifier	 Operation Type
operation	TokenNameIdentifier	 operation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
operation	TokenNameIdentifier	 operation
!=	TokenNameNOT_EQUAL	
OperationType	TokenNameIdentifier	 Operation Type
.	TokenNameDOT	
CLEANUP	TokenNameIdentifier	 CLEANUP
||	TokenNameOR_OR	
isIndex	TokenNameIdentifier	 is Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
SSTable	TokenNameIdentifier	 SS Table
.	TokenNameDOT	
getTotalBytes	TokenNameIdentifier	 get Total Bytes
(	TokenNameLPAREN	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// cleanup size estimation only counts bytes for keys local to this node 	TokenNameCOMMENT_LINE	cleanup size estimation only counts bytes for keys local to this node 
long	TokenNamelong	
expectedFileSize	TokenNameIdentifier	 expected File Size
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
ranges	TokenNameIdentifier	 ranges
=	TokenNameEQUAL	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getLocalRanges	TokenNameIdentifier	 get Local Ranges
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
:	TokenNameCOLON	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
positions	TokenNameIdentifier	 positions
=	TokenNameEQUAL	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
getPositionsForRanges	TokenNameIdentifier	 get Positions For Ranges
(	TokenNameLPAREN	
ranges	TokenNameIdentifier	 ranges
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
position	TokenNameIdentifier	 position
:	TokenNameCOLON	
positions	TokenNameIdentifier	 positions
)	TokenNameRPAREN	
expectedFileSize	TokenNameIdentifier	 expected File Size
+=	TokenNamePLUS_EQUAL	
position	TokenNameIdentifier	 position
.	TokenNameDOT	
right	TokenNameIdentifier	 right
-	TokenNameMINUS	
position	TokenNameIdentifier	 position
.	TokenNameDOT	
left	TokenNameIdentifier	 left
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
expectedFileSize	TokenNameIdentifier	 expected File Size
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* * Find the maximum size file in the list . */	TokenNameCOMMENT_BLOCK	 Find the maximum size file in the list . 
public	TokenNamepublic	
SSTableReader	TokenNameIdentifier	 SS Table Reader
getMaxSizeFile	TokenNameIdentifier	 get Max Size File
(	TokenNameLPAREN	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
maxSize	TokenNameIdentifier	 max Size
=	TokenNameEQUAL	
0L	TokenNameLongLiteral	
;	TokenNameSEMICOLON	
SSTableReader	TokenNameIdentifier	 SS Table Reader
maxFile	TokenNameIdentifier	 max File
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
:	TokenNameCOLON	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
onDiskLength	TokenNameIdentifier	 on Disk Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
maxSize	TokenNameIdentifier	 max Size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
maxSize	TokenNameIdentifier	 max Size
=	TokenNameEQUAL	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
onDiskLength	TokenNameIdentifier	 on Disk Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
maxFile	TokenNameIdentifier	 max File
=	TokenNameEQUAL	
sstable	TokenNameIdentifier	 sstable
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
maxFile	TokenNameIdentifier	 max File
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
forceCleanup	TokenNameIdentifier	 force Cleanup
(	TokenNameLPAREN	
CounterId	TokenNameIdentifier	 Counter Id
.	TokenNameDOT	
OneShotRenewer	TokenNameIdentifier	 One Shot Renewer
renewer	TokenNameIdentifier	 renewer
)	TokenNameRPAREN	
throws	TokenNamethrows	
ExecutionException	TokenNameIdentifier	 Execution Exception
,	TokenNameCOMMA	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
{	TokenNameLBRACE	
CompactionManager	TokenNameIdentifier	 Compaction Manager
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
performCleanup	TokenNameIdentifier	 perform Cleanup
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
.	TokenNameDOT	
this	TokenNamethis	
,	TokenNameCOMMA	
renewer	TokenNameIdentifier	 renewer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
scrub	TokenNameIdentifier	 scrub
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
ExecutionException	TokenNameIdentifier	 Execution Exception
,	TokenNameCOMMA	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
{	TokenNameLBRACE	
snapshotWithoutFlush	TokenNameIdentifier	 snapshot Without Flush
(	TokenNameLPAREN	
"pre-scrub-"	TokenNameStringLiteral	pre-scrub-
+	TokenNamePLUS	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CompactionManager	TokenNameIdentifier	 Compaction Manager
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
performScrub	TokenNameIdentifier	 perform Scrub
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
.	TokenNameDOT	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
sstablesRewrite	TokenNameIdentifier	 sstables Rewrite
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
ExecutionException	TokenNameIdentifier	 Execution Exception
,	TokenNameCOMMA	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
{	TokenNameLBRACE	
CompactionManager	TokenNameIdentifier	 Compaction Manager
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
performSSTableRewrite	TokenNameIdentifier	 perform SS Table Rewrite
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
.	TokenNameDOT	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
markCompacted	TokenNameIdentifier	 mark Compacted
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
,	TokenNameCOMMA	
OperationType	TokenNameIdentifier	 Operation Type
compactionType	TokenNameIdentifier	 compaction Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
!	TokenNameNOT	
sstables	TokenNameIdentifier	 sstables
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
markCompacted	TokenNameIdentifier	 mark Compacted
(	TokenNameLPAREN	
sstables	TokenNameIdentifier	 sstables
,	TokenNameCOMMA	
compactionType	TokenNameIdentifier	 compaction Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
replaceCompactedSSTables	TokenNameIdentifier	 replace Compacted SS Tables
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
,	TokenNameCOMMA	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
replacements	TokenNameIdentifier	 replacements
,	TokenNameCOMMA	
OperationType	TokenNameIdentifier	 Operation Type
compactionType	TokenNameIdentifier	 compaction Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
replaceCompactedSSTables	TokenNameIdentifier	 replace Compacted SS Tables
(	TokenNameLPAREN	
sstables	TokenNameIdentifier	 sstables
,	TokenNameCOMMA	
replacements	TokenNameIdentifier	 replacements
,	TokenNameCOMMA	
compactionType	TokenNameIdentifier	 compaction Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
void	TokenNamevoid	
replaceFlushed	TokenNameIdentifier	 replace Flushed
(	TokenNameLPAREN	
Memtable	TokenNameIdentifier	 Memtable
memtable	TokenNameIdentifier	 memtable
,	TokenNameCOMMA	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
{	TokenNameLBRACE	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
replaceFlushed	TokenNameIdentifier	 replace Flushed
(	TokenNameLPAREN	
memtable	TokenNameIdentifier	 memtable
,	TokenNameCOMMA	
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
CompactionManager	TokenNameIdentifier	 Compaction Manager
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
submitBackground	TokenNameIdentifier	 submit Background
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isValid	TokenNameIdentifier	 is Valid
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
valid	TokenNameIdentifier	 valid
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getMemtableColumnsCount	TokenNameIdentifier	 get Memtable Columns Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
memtableColumnsCount	TokenNameIdentifier	 memtable Columns Count
.	TokenNameDOT	
value	TokenNameIdentifier	 value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getMemtableDataSize	TokenNameIdentifier	 get Memtable Data Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
memtableDataSize	TokenNameIdentifier	 memtable Data Size
.	TokenNameDOT	
value	TokenNameIdentifier	 value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getTotalMemtableLiveSize	TokenNameIdentifier	 get Total Memtable Live Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getMemtableDataSize	TokenNameIdentifier	 get Memtable Data Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
indexManager	TokenNameIdentifier	 index Manager
.	TokenNameDOT	
getTotalLiveSize	TokenNameIdentifier	 get Total Live Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getMemtableSwitchCount	TokenNameIdentifier	 get Memtable Switch Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
memtableSwitchCount	TokenNameIdentifier	 memtable Switch Count
.	TokenNameDOT	
count	TokenNameIdentifier	 count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
Memtable	TokenNameIdentifier	 Memtable
getMemtableThreadSafe	TokenNameIdentifier	 get Memtable Thread Safe
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
getMemtable	TokenNameIdentifier	 get Memtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Package protected for access from the CompactionManager. */	TokenNameCOMMENT_JAVADOC	 Package protected for access from the CompactionManager. 
public	TokenNamepublic	
DataTracker	TokenNameIdentifier	 Data Tracker
getDataTracker	TokenNameIdentifier	 get Data Tracker
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
data	TokenNameIdentifier	 data
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
getSSTables	TokenNameIdentifier	 get SS Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
getSSTables	TokenNameIdentifier	 get SS Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
getUncompactingSSTables	TokenNameIdentifier	 get Uncompacting SS Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
getUncompactingSSTables	TokenNameIdentifier	 get Uncompacting SS Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getRecentSSTablesPerReadHistogram	TokenNameIdentifier	 get Recent SS Tables Per Read Histogram
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
recentSSTablesPerRead	TokenNameIdentifier	 recent SS Tables Per Read
.	TokenNameDOT	
getBuckets	TokenNameIdentifier	 get Buckets
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getSSTablesPerReadHistogram	TokenNameIdentifier	 get SS Tables Per Read Histogram
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
sstablesPerRead	TokenNameIdentifier	 sstables Per Read
.	TokenNameDOT	
getBuckets	TokenNameIdentifier	 get Buckets
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getReadCount	TokenNameIdentifier	 get Read Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
readLatency	TokenNameIdentifier	 read Latency
.	TokenNameDOT	
latency	TokenNameIdentifier	 latency
.	TokenNameDOT	
count	TokenNameIdentifier	 count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
double	TokenNamedouble	
getRecentReadLatencyMicros	TokenNameIdentifier	 get Recent Read Latency Micros
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
readLatency	TokenNameIdentifier	 read Latency
.	TokenNameDOT	
getRecentLatency	TokenNameIdentifier	 get Recent Latency
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getLifetimeReadLatencyHistogramMicros	TokenNameIdentifier	 get Lifetime Read Latency Histogram Micros
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
readLatency	TokenNameIdentifier	 read Latency
.	TokenNameDOT	
totalLatencyHistogram	TokenNameIdentifier	 total Latency Histogram
.	TokenNameDOT	
getBuckets	TokenNameIdentifier	 get Buckets
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getRecentReadLatencyHistogramMicros	TokenNameIdentifier	 get Recent Read Latency Histogram Micros
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
readLatency	TokenNameIdentifier	 read Latency
.	TokenNameDOT	
recentLatencyHistogram	TokenNameIdentifier	 recent Latency Histogram
.	TokenNameDOT	
getBuckets	TokenNameIdentifier	 get Buckets
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getTotalReadLatencyMicros	TokenNameIdentifier	 get Total Read Latency Micros
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
readLatency	TokenNameIdentifier	 read Latency
.	TokenNameDOT	
totalLatency	TokenNameIdentifier	 total Latency
.	TokenNameDOT	
count	TokenNameIdentifier	 count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getPendingTasks	TokenNameIdentifier	 get Pending Tasks
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
pendingTasks	TokenNameIdentifier	 pending Tasks
.	TokenNameDOT	
value	TokenNameIdentifier	 value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getWriteCount	TokenNameIdentifier	 get Write Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
writeLatency	TokenNameIdentifier	 write Latency
.	TokenNameDOT	
latency	TokenNameIdentifier	 latency
.	TokenNameDOT	
count	TokenNameIdentifier	 count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getTotalWriteLatencyMicros	TokenNameIdentifier	 get Total Write Latency Micros
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
writeLatency	TokenNameIdentifier	 write Latency
.	TokenNameDOT	
totalLatency	TokenNameIdentifier	 total Latency
.	TokenNameDOT	
count	TokenNameIdentifier	 count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
double	TokenNamedouble	
getRecentWriteLatencyMicros	TokenNameIdentifier	 get Recent Write Latency Micros
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
writeLatency	TokenNameIdentifier	 write Latency
.	TokenNameDOT	
getRecentLatency	TokenNameIdentifier	 get Recent Latency
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getLifetimeWriteLatencyHistogramMicros	TokenNameIdentifier	 get Lifetime Write Latency Histogram Micros
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
writeLatency	TokenNameIdentifier	 write Latency
.	TokenNameDOT	
totalLatencyHistogram	TokenNameIdentifier	 total Latency Histogram
.	TokenNameDOT	
getBuckets	TokenNameIdentifier	 get Buckets
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getRecentWriteLatencyHistogramMicros	TokenNameIdentifier	 get Recent Write Latency Histogram Micros
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
writeLatency	TokenNameIdentifier	 write Latency
.	TokenNameDOT	
recentLatencyHistogram	TokenNameIdentifier	 recent Latency Histogram
.	TokenNameDOT	
getBuckets	TokenNameIdentifier	 get Buckets
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
ColumnFamily	TokenNameIdentifier	 Column Family
getColumnFamily	TokenNameIdentifier	 get Column Family
(	TokenNameLPAREN	
DecoratedKey	TokenNameIdentifier	 Decorated Key
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
QueryPath	TokenNameIdentifier	 Query Path
path	TokenNameIdentifier	 path
,	TokenNameCOMMA	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
start	TokenNameIdentifier	 start
,	TokenNameCOMMA	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
finish	TokenNameIdentifier	 finish
,	TokenNameCOMMA	
boolean	TokenNameboolean	
reversed	TokenNameIdentifier	 reversed
,	TokenNameCOMMA	
int	TokenNameint	
limit	TokenNameIdentifier	 limit
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getColumnFamily	TokenNameIdentifier	 get Column Family
(	TokenNameLPAREN	
QueryFilter	TokenNameIdentifier	 Query Filter
.	TokenNameDOT	
getSliceFilter	TokenNameIdentifier	 get Slice Filter
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
path	TokenNameIdentifier	 path
,	TokenNameCOMMA	
start	TokenNameIdentifier	 start
,	TokenNameCOMMA	
finish	TokenNameIdentifier	 finish
,	TokenNameCOMMA	
reversed	TokenNameIdentifier	 reversed
,	TokenNameCOMMA	
limit	TokenNameIdentifier	 limit
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * get a list of columns starting from a given column, in a specified order. * only the latest version of a column is returned. * @return null if there is no data and no tombstones; otherwise a ColumnFamily */	TokenNameCOMMENT_JAVADOC	 get a list of columns starting from a given column, in a specified order. only the latest version of a column is returned. @return null if there is no data and no tombstones; otherwise a ColumnFamily 
public	TokenNamepublic	
ColumnFamily	TokenNameIdentifier	 Column Family
getColumnFamily	TokenNameIdentifier	 get Column Family
(	TokenNameLPAREN	
QueryFilter	TokenNameIdentifier	 Query Filter
filter	TokenNameIdentifier	 filter
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getColumnFamily	TokenNameIdentifier	 get Column Family
(	TokenNameLPAREN	
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
gcBefore	TokenNameIdentifier	 gc Before
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
gcBefore	TokenNameIdentifier	 gc Before
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
1000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
-	TokenNameMINUS	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
getGcGraceSeconds	TokenNameIdentifier	 get Gc Grace Seconds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * fetch the row given by filter.key if it is in the cache; if not, read it from disk and cache it * @param cfId the column family to read the row from * @param filter the columns being queried. Note that we still cache entire rows, but if a row is uncached * and we race to cache it, only the winner will read the entire row * @return the entire row for filter.key, if present in the cache (or we can cache it), or just the column * specified by filter otherwise */	TokenNameCOMMENT_JAVADOC	 fetch the row given by filter.key if it is in the cache; if not, read it from disk and cache it @param cfId the column family to read the row from @param filter the columns being queried. Note that we still cache entire rows, but if a row is uncached and we race to cache it, only the winner will read the entire row @return the entire row for filter.key, if present in the cache (or we can cache it), or just the column specified by filter otherwise 
private	TokenNameprivate	
ColumnFamily	TokenNameIdentifier	 Column Family
getThroughCache	TokenNameIdentifier	 get Through Cache
(	TokenNameLPAREN	
UUID	TokenNameIdentifier	 UUID
cfId	TokenNameIdentifier	 cf Id
,	TokenNameCOMMA	
QueryFilter	TokenNameIdentifier	 Query Filter
filter	TokenNameIdentifier	 filter
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
isRowCacheEnabled	TokenNameIdentifier	 is Row Cache Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Row cache is not enabled on column family ["	TokenNameStringLiteral	Row cache is not enabled on column family [
+	TokenNamePLUS	
getColumnFamilyName	TokenNameIdentifier	 get Column Family Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"]"	TokenNameStringLiteral	]
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
RowCacheKey	TokenNameIdentifier	 Row Cache Key
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
new	TokenNamenew	
RowCacheKey	TokenNameIdentifier	 Row Cache Key
(	TokenNameLPAREN	
cfId	TokenNameIdentifier	 cf Id
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// attempt a sentinel-read-cache sequence. if a write invalidates our sentinel, we'll return our 	TokenNameCOMMENT_LINE	attempt a sentinel-read-cache sequence. if a write invalidates our sentinel, we'll return our 
// (now potentially obsolete) data, but won't cache it. see CASSANDRA-3862 	TokenNameCOMMENT_LINE	(now potentially obsolete) data, but won't cache it. see CASSANDRA-3862 
IRowCacheEntry	TokenNameIdentifier	 I Row Cache Entry
cached	TokenNameIdentifier	 cached
=	TokenNameEQUAL	
CacheService	TokenNameIdentifier	 Cache Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
rowCache	TokenNameIdentifier	 row Cache
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cached	TokenNameIdentifier	 cached
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
cached	TokenNameIdentifier	 cached
instanceof	TokenNameinstanceof	
RowCacheSentinel	TokenNameIdentifier	 Row Cache Sentinel
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Some other read is trying to cache the value, just do a normal non-caching read 	TokenNameCOMMENT_LINE	Some other read is trying to cache the value, just do a normal non-caching read 
Tracing	TokenNameIdentifier	 Tracing
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Row cache miss (race)"	TokenNameStringLiteral	Row cache miss (race)
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
getTopLevelColumns	TokenNameIdentifier	 get Top Level Columns
(	TokenNameLPAREN	
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MIN_VALUE	TokenNameIdentifier	 MIN  VALUE
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Tracing	TokenNameIdentifier	 Tracing
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Row cache hit"	TokenNameStringLiteral	Row cache hit
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
ColumnFamily	TokenNameIdentifier	 Column Family
)	TokenNameRPAREN	
cached	TokenNameIdentifier	 cached
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Tracing	TokenNameIdentifier	 Tracing
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Row cache miss"	TokenNameStringLiteral	Row cache miss
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
RowCacheSentinel	TokenNameIdentifier	 Row Cache Sentinel
sentinel	TokenNameIdentifier	 sentinel
=	TokenNameEQUAL	
new	TokenNamenew	
RowCacheSentinel	TokenNameIdentifier	 Row Cache Sentinel
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
sentinelSuccess	TokenNameIdentifier	 sentinel Success
=	TokenNameEQUAL	
CacheService	TokenNameIdentifier	 Cache Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
rowCache	TokenNameIdentifier	 row Cache
.	TokenNameDOT	
putIfAbsent	TokenNameIdentifier	 put If Absent
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
sentinel	TokenNameIdentifier	 sentinel
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
ColumnFamily	TokenNameIdentifier	 Column Family
data	TokenNameIdentifier	 data
=	TokenNameEQUAL	
getTopLevelColumns	TokenNameIdentifier	 get Top Level Columns
(	TokenNameLPAREN	
QueryFilter	TokenNameIdentifier	 Query Filter
.	TokenNameDOT	
getIdentityFilter	TokenNameIdentifier	 get Identity Filter
(	TokenNameLPAREN	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
new	TokenNamenew	
QueryPath	TokenNameIdentifier	 Query Path
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MIN_VALUE	TokenNameIdentifier	 MIN  VALUE
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sentinelSuccess	TokenNameIdentifier	 sentinel Success
&&	TokenNameAND_AND	
data	TokenNameIdentifier	 data
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
CacheService	TokenNameIdentifier	 Cache Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
rowCache	TokenNameIdentifier	 row Cache
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
sentinel	TokenNameIdentifier	 sentinel
,	TokenNameCOMMA	
data	TokenNameIdentifier	 data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
data	TokenNameIdentifier	 data
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
sentinelSuccess	TokenNameIdentifier	 sentinel Success
&&	TokenNameAND_AND	
data	TokenNameIdentifier	 data
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
CacheService	TokenNameIdentifier	 Cache Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
rowCache	TokenNameIdentifier	 row Cache
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
ColumnFamily	TokenNameIdentifier	 Column Family
getColumnFamily	TokenNameIdentifier	 get Column Family
(	TokenNameLPAREN	
QueryFilter	TokenNameIdentifier	 Query Filter
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
int	TokenNameint	
gcBefore	TokenNameIdentifier	 gc Before
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
columnFamily	TokenNameIdentifier	 column Family
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
getColumnFamilyName	TokenNameIdentifier	 get Column Family Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
getColumnFamilyName	TokenNameIdentifier	 get Column Family Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ColumnFamily	TokenNameIdentifier	 Column Family
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
long	TokenNamelong	
start	TokenNameIdentifier	 start
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
nanoTime	TokenNameIdentifier	 nano Time
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isRowCacheEnabled	TokenNameIdentifier	 is Row Cache Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
UUID	TokenNameIdentifier	 UUID
cfId	TokenNameIdentifier	 cf Id
=	TokenNameEQUAL	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getId	TokenNameIdentifier	 get Id
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cfId	TokenNameIdentifier	 cf Id
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"no id found for {}.{}"	TokenNameStringLiteral	no id found for {}.{}
,	TokenNameCOMMA	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ColumnFamily	TokenNameIdentifier	 Column Family
cached	TokenNameIdentifier	 cached
=	TokenNameEQUAL	
getThroughCache	TokenNameIdentifier	 get Through Cache
(	TokenNameLPAREN	
cfId	TokenNameIdentifier	 cf Id
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cached	TokenNameIdentifier	 cached
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"cached row is empty"	TokenNameStringLiteral	cached row is empty
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
filterColumnFamily	TokenNameIdentifier	 filter Column Family
(	TokenNameLPAREN	
cached	TokenNameIdentifier	 cached
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
gcBefore	TokenNameIdentifier	 gc Before
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
ColumnFamily	TokenNameIdentifier	 Column Family
cf	TokenNameIdentifier	 cf
=	TokenNameEQUAL	
getTopLevelColumns	TokenNameIdentifier	 get Top Level Columns
(	TokenNameLPAREN	
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
gcBefore	TokenNameIdentifier	 gc Before
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cf	TokenNameIdentifier	 cf
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// TODO this is necessary because when we collate supercolumns together, we don't check 	TokenNameCOMMENT_LINE	TODO this is necessary because when we collate supercolumns together, we don't check 
// their subcolumns for relevance, so we need to do a second prune post facto here. 	TokenNameCOMMENT_LINE	their subcolumns for relevance, so we need to do a second prune post facto here. 
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
cf	TokenNameIdentifier	 cf
.	TokenNameDOT	
isSuper	TokenNameIdentifier	 is Super
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
removeDeleted	TokenNameIdentifier	 remove Deleted
(	TokenNameLPAREN	
cf	TokenNameIdentifier	 cf
,	TokenNameCOMMA	
gcBefore	TokenNameIdentifier	 gc Before
)	TokenNameRPAREN	
:	TokenNameCOLON	
removeDeletedCF	TokenNameIdentifier	 remove Deleted CF
(	TokenNameLPAREN	
cf	TokenNameIdentifier	 cf
,	TokenNameCOMMA	
gcBefore	TokenNameIdentifier	 gc Before
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
readLatency	TokenNameIdentifier	 read Latency
.	TokenNameDOT	
addNano	TokenNameIdentifier	 add Nano
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
nanoTime	TokenNameIdentifier	 nano Time
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
start	TokenNameIdentifier	 start
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
result	TokenNameIdentifier	 result
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Filter a cached row, which will not be modified by the filter, but may be modified by throwing out * tombstones that are no longer relevant. * The returned column family won't be thread safe. */	TokenNameCOMMENT_JAVADOC	 Filter a cached row, which will not be modified by the filter, but may be modified by throwing out tombstones that are no longer relevant. The returned column family won't be thread safe. 
ColumnFamily	TokenNameIdentifier	 Column Family
filterColumnFamily	TokenNameIdentifier	 filter Column Family
(	TokenNameLPAREN	
ColumnFamily	TokenNameIdentifier	 Column Family
cached	TokenNameIdentifier	 cached
,	TokenNameCOMMA	
QueryFilter	TokenNameIdentifier	 Query Filter
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
int	TokenNameint	
gcBefore	TokenNameIdentifier	 gc Before
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ColumnFamily	TokenNameIdentifier	 Column Family
cf	TokenNameIdentifier	 cf
=	TokenNameEQUAL	
cached	TokenNameIdentifier	 cached
.	TokenNameDOT	
cloneMeShallow	TokenNameIdentifier	 clone Me Shallow
(	TokenNameLPAREN	
ArrayBackedSortedColumns	TokenNameIdentifier	 Array Backed Sorted Columns
.	TokenNameDOT	
factory	TokenNameIdentifier	 factory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
isReversed	TokenNameIdentifier	 is Reversed
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
OnDiskAtomIterator	TokenNameIdentifier	 On Disk Atom Iterator
ci	TokenNameIdentifier	 ci
=	TokenNameEQUAL	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
getMemtableColumnIterator	TokenNameIdentifier	 get Memtable Column Iterator
(	TokenNameLPAREN	
cached	TokenNameIdentifier	 cached
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
collateOnDiskAtom	TokenNameIdentifier	 collate On Disk Atom
(	TokenNameLPAREN	
cf	TokenNameIdentifier	 cf
,	TokenNameCOMMA	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
singletonList	TokenNameIdentifier	 singleton List
(	TokenNameLPAREN	
ci	TokenNameIdentifier	 ci
)	TokenNameRPAREN	
,	TokenNameCOMMA	
gcBefore	TokenNameIdentifier	 gc Before
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// TODO this is necessary because when we collate supercolumns together, we don't check 	TokenNameCOMMENT_LINE	TODO this is necessary because when we collate supercolumns together, we don't check 
// their subcolumns for relevance, so we need to do a second prune post facto here. 	TokenNameCOMMENT_LINE	their subcolumns for relevance, so we need to do a second prune post facto here. 
return	TokenNamereturn	
cf	TokenNameIdentifier	 cf
.	TokenNameDOT	
isSuper	TokenNameIdentifier	 is Super
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
removeDeleted	TokenNameIdentifier	 remove Deleted
(	TokenNameLPAREN	
cf	TokenNameIdentifier	 cf
,	TokenNameCOMMA	
gcBefore	TokenNameIdentifier	 gc Before
)	TokenNameRPAREN	
:	TokenNameCOLON	
removeDeletedCF	TokenNameIdentifier	 remove Deleted CF
(	TokenNameLPAREN	
cf	TokenNameIdentifier	 cf
,	TokenNameCOMMA	
gcBefore	TokenNameIdentifier	 gc Before
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the current view and acquires references on all its sstables. * This is a bit tricky because we must ensure that between the time we * get the current view and the time we acquire the references the set of * sstables hasn't changed. Otherwise we could get a view for which an * sstable have been deleted in the meantime. * * At the end of this method, a reference on all the sstables of the * returned view will have been acquired and must thus be released when * appropriate. */	TokenNameCOMMENT_JAVADOC	 Get the current view and acquires references on all its sstables. This is a bit tricky because we must ensure that between the time we get the current view and the time we acquire the references the set of sstables hasn't changed. Otherwise we could get a view for which an sstable have been deleted in the meantime. * At the end of this method, a reference on all the sstables of the returned view will have been acquired and must thus be released when appropriate. 
private	TokenNameprivate	
DataTracker	TokenNameIdentifier	 Data Tracker
.	TokenNameDOT	
View	TokenNameIdentifier	 View
markCurrentViewReferenced	TokenNameIdentifier	 mark Current View Referenced
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DataTracker	TokenNameIdentifier	 Data Tracker
.	TokenNameDOT	
View	TokenNameIdentifier	 View
currentView	TokenNameIdentifier	 current View
=	TokenNameEQUAL	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
getView	TokenNameIdentifier	 get View
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
.	TokenNameDOT	
acquireReferences	TokenNameIdentifier	 acquire References
(	TokenNameLPAREN	
currentView	TokenNameIdentifier	 current View
.	TokenNameDOT	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
currentView	TokenNameIdentifier	 current View
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Get the current sstables, acquiring references on all of them. * The caller is in charge of releasing the references on the sstables. * * See markCurrentViewReferenced() above. */	TokenNameCOMMENT_JAVADOC	 Get the current sstables, acquiring references on all of them. The caller is in charge of releasing the references on the sstables. * See markCurrentViewReferenced() above. 
public	TokenNamepublic	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
markCurrentSSTablesReferenced	TokenNameIdentifier	 mark Current SS Tables Referenced
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
markCurrentViewReferenced	TokenNameIdentifier	 mark Current View Referenced
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
sstables	TokenNameIdentifier	 sstables
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @return a ViewFragment containing the sstables and memtables that may need to be merged * for the given @param key, according to the interval tree */	TokenNameCOMMENT_JAVADOC	 @return a ViewFragment containing the sstables and memtables that may need to be merged for the given @param key, according to the interval tree 
public	TokenNamepublic	
ViewFragment	TokenNameIdentifier	 View Fragment
markReferenced	TokenNameIdentifier	 mark Referenced
(	TokenNameLPAREN	
DecoratedKey	TokenNameIdentifier	 Decorated Key
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
!	TokenNameNOT	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
isMinimum	TokenNameIdentifier	 is Minimum
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DataTracker	TokenNameIdentifier	 Data Tracker
.	TokenNameDOT	
View	TokenNameIdentifier	 View
view	TokenNameIdentifier	 view
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
view	TokenNameIdentifier	 view
=	TokenNameEQUAL	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
getView	TokenNameIdentifier	 get View
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sstables	TokenNameIdentifier	 sstables
=	TokenNameEQUAL	
view	TokenNameIdentifier	 view
.	TokenNameDOT	
intervalTree	TokenNameIdentifier	 interval Tree
.	TokenNameDOT	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
.	TokenNameDOT	
acquireReferences	TokenNameIdentifier	 acquire References
(	TokenNameLPAREN	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
// retry w/ new view 	TokenNameCOMMENT_LINE	retry w/ new view 
}	TokenNameRBRACE	
return	TokenNamereturn	
new	TokenNamenew	
ViewFragment	TokenNameIdentifier	 View Fragment
(	TokenNameLPAREN	
sstables	TokenNameIdentifier	 sstables
,	TokenNameCOMMA	
Iterables	TokenNameIdentifier	 Iterables
.	TokenNameDOT	
concat	TokenNameIdentifier	 concat
(	TokenNameLPAREN	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
singleton	TokenNameIdentifier	 singleton
(	TokenNameLPAREN	
view	TokenNameIdentifier	 view
.	TokenNameDOT	
memtable	TokenNameIdentifier	 memtable
)	TokenNameRPAREN	
,	TokenNameCOMMA	
view	TokenNameIdentifier	 view
.	TokenNameDOT	
memtablesPendingFlush	TokenNameIdentifier	 memtables Pending Flush
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @return a ViewFragment containing the sstables and memtables that may need to be merged * for rows between @param startWith and @param stopAt, inclusive, according to the interval tree */	TokenNameCOMMENT_JAVADOC	 @return a ViewFragment containing the sstables and memtables that may need to be merged for rows between @param startWith and @param stopAt, inclusive, according to the interval tree 
public	TokenNamepublic	
ViewFragment	TokenNameIdentifier	 View Fragment
markReferenced	TokenNameIdentifier	 mark Referenced
(	TokenNameLPAREN	
RowPosition	TokenNameIdentifier	 Row Position
startWith	TokenNameIdentifier	 start With
,	TokenNameCOMMA	
RowPosition	TokenNameIdentifier	 Row Position
stopAt	TokenNameIdentifier	 stop At
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DataTracker	TokenNameIdentifier	 Data Tracker
.	TokenNameDOT	
View	TokenNameIdentifier	 View
view	TokenNameIdentifier	 view
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
view	TokenNameIdentifier	 view
=	TokenNameEQUAL	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
getView	TokenNameIdentifier	 get View
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// startAt == minimum is ok, but stopAt == minimum is confusing because all IntervalTree deals with 	TokenNameCOMMENT_LINE	startAt == minimum is ok, but stopAt == minimum is confusing because all IntervalTree deals with 
// is Comparable, so it won't know to special-case that. However max() should not be call if the 	TokenNameCOMMENT_LINE	is Comparable, so it won't know to special-case that. However max() should not be call if the 
// intervalTree is empty sochecking that first 	TokenNameCOMMENT_LINE	intervalTree is empty sochecking that first 
// 	TokenNameCOMMENT_LINE	 
if	TokenNameif	
(	TokenNameLPAREN	
view	TokenNameIdentifier	 view
.	TokenNameDOT	
intervalTree	TokenNameIdentifier	 interval Tree
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sstables	TokenNameIdentifier	 sstables
=	TokenNameEQUAL	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
emptyList	TokenNameIdentifier	 empty List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
RowPosition	TokenNameIdentifier	 Row Position
stopInTree	TokenNameIdentifier	 stop In Tree
=	TokenNameEQUAL	
stopAt	TokenNameIdentifier	 stop At
.	TokenNameDOT	
isMinimum	TokenNameIdentifier	 is Minimum
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
view	TokenNameIdentifier	 view
.	TokenNameDOT	
intervalTree	TokenNameIdentifier	 interval Tree
.	TokenNameDOT	
max	TokenNameIdentifier	 max
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
stopAt	TokenNameIdentifier	 stop At
;	TokenNameSEMICOLON	
sstables	TokenNameIdentifier	 sstables
=	TokenNameEQUAL	
view	TokenNameIdentifier	 view
.	TokenNameDOT	
intervalTree	TokenNameIdentifier	 interval Tree
.	TokenNameDOT	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
Interval	TokenNameIdentifier	 Interval
.	TokenNameDOT	
<	TokenNameLESS	
RowPosition	TokenNameIdentifier	 Row Position
,	TokenNameCOMMA	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
startWith	TokenNameIdentifier	 start With
,	TokenNameCOMMA	
stopInTree	TokenNameIdentifier	 stop In Tree
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
.	TokenNameDOT	
acquireReferences	TokenNameIdentifier	 acquire References
(	TokenNameLPAREN	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
// retry w/ new view 	TokenNameCOMMENT_LINE	retry w/ new view 
}	TokenNameRBRACE	
return	TokenNamereturn	
new	TokenNamenew	
ViewFragment	TokenNameIdentifier	 View Fragment
(	TokenNameLPAREN	
sstables	TokenNameIdentifier	 sstables
,	TokenNameCOMMA	
Iterables	TokenNameIdentifier	 Iterables
.	TokenNameDOT	
concat	TokenNameIdentifier	 concat
(	TokenNameLPAREN	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
singleton	TokenNameIdentifier	 singleton
(	TokenNameLPAREN	
view	TokenNameIdentifier	 view
.	TokenNameDOT	
memtable	TokenNameIdentifier	 memtable
)	TokenNameRPAREN	
,	TokenNameCOMMA	
view	TokenNameIdentifier	 view
.	TokenNameDOT	
memtablesPendingFlush	TokenNameIdentifier	 memtables Pending Flush
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
getSSTablesForKey	TokenNameIdentifier	 get SS Tables For Key
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DecoratedKey	TokenNameIdentifier	 Decorated Key
dk	TokenNameIdentifier	 dk
=	TokenNameEQUAL	
new	TokenNamenew	
DecoratedKey	TokenNameIdentifier	 Decorated Key
(	TokenNameLPAREN	
partitioner	TokenNameIdentifier	 partitioner
.	TokenNameDOT	
getToken	TokenNameIdentifier	 get Token
(	TokenNameLPAREN	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
.	TokenNameDOT	
wrap	TokenNameIdentifier	 wrap
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
getBytes	TokenNameIdentifier	 get Bytes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
.	TokenNameDOT	
wrap	TokenNameIdentifier	 wrap
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
getBytes	TokenNameIdentifier	 get Bytes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ViewFragment	TokenNameIdentifier	 View Fragment
view	TokenNameIdentifier	 view
=	TokenNameEQUAL	
markReferenced	TokenNameIdentifier	 mark Referenced
(	TokenNameLPAREN	
dk	TokenNameIdentifier	 dk
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
files	TokenNameIdentifier	 files
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstr	TokenNameIdentifier	 sstr
:	TokenNameCOLON	
view	TokenNameIdentifier	 view
.	TokenNameDOT	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// check if the key actually exists in this sstable, without updating cache and stats 	TokenNameCOMMENT_LINE	check if the key actually exists in this sstable, without updating cache and stats 
if	TokenNameif	
(	TokenNameLPAREN	
sstr	TokenNameIdentifier	 sstr
.	TokenNameDOT	
getPosition	TokenNameIdentifier	 get Position
(	TokenNameLPAREN	
dk	TokenNameIdentifier	 dk
,	TokenNameCOMMA	
SSTableReader	TokenNameIdentifier	 SS Table Reader
.	TokenNameDOT	
Operator	TokenNameIdentifier	 Operator
.	TokenNameDOT	
EQ	TokenNameIdentifier	 EQ
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
files	TokenNameIdentifier	 files
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
sstr	TokenNameIdentifier	 sstr
.	TokenNameDOT	
getFilename	TokenNameIdentifier	 get Filename
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
files	TokenNameIdentifier	 files
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
SSTableReader	TokenNameIdentifier	 SS Table Reader
.	TokenNameDOT	
releaseReferences	TokenNameIdentifier	 release References
(	TokenNameLPAREN	
view	TokenNameIdentifier	 view
.	TokenNameDOT	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
ColumnFamily	TokenNameIdentifier	 Column Family
getTopLevelColumns	TokenNameIdentifier	 get Top Level Columns
(	TokenNameLPAREN	
QueryFilter	TokenNameIdentifier	 Query Filter
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
int	TokenNameint	
gcBefore	TokenNameIdentifier	 gc Before
,	TokenNameCOMMA	
boolean	TokenNameboolean	
forCache	TokenNameIdentifier	 for Cache
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Tracing	TokenNameIdentifier	 Tracing
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Executing single-partition query on {}"	TokenNameStringLiteral	Executing single-partition query on {}
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CollationController	TokenNameIdentifier	 Collation Controller
controller	TokenNameIdentifier	 controller
=	TokenNameEQUAL	
new	TokenNamenew	
CollationController	TokenNameIdentifier	 Collation Controller
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
forCache	TokenNameIdentifier	 for Cache
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
gcBefore	TokenNameIdentifier	 gc Before
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ColumnFamily	TokenNameIdentifier	 Column Family
columns	TokenNameIdentifier	 columns
=	TokenNameEQUAL	
controller	TokenNameIdentifier	 controller
.	TokenNameDOT	
getTopLevelColumns	TokenNameIdentifier	 get Top Level Columns
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
updateSSTableIterated	TokenNameIdentifier	 update SS Table Iterated
(	TokenNameLPAREN	
controller	TokenNameIdentifier	 controller
.	TokenNameDOT	
getSstablesIterated	TokenNameIdentifier	 get Sstables Iterated
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
columns	TokenNameIdentifier	 columns
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
abstract	TokenNameabstract	
class	TokenNameclass	
AbstractScanIterator	TokenNameIdentifier	 Abstract Scan Iterator
extends	TokenNameextends	
AbstractIterator	TokenNameIdentifier	 Abstract Iterator
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
implements	TokenNameimplements	
CloseableIterator	TokenNameIdentifier	 Closeable Iterator
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
{	TokenNameLBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
needsFiltering	TokenNameIdentifier	 needs Filtering
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Iterate over a range of rows and columns from memtables/sstables. * * @param superColumn optional SuperColumn to slice subcolumns of; null to slice top-level columns * @param range Either a Bounds, which includes start key, or a Range, which does not. * @param columnFilter description of the columns we're interested in for each row */	TokenNameCOMMENT_JAVADOC	 Iterate over a range of rows and columns from memtables/sstables. * @param superColumn optional SuperColumn to slice subcolumns of; null to slice top-level columns @param range Either a Bounds, which includes start key, or a Range, which does not. @param columnFilter description of the columns we're interested in for each row 
public	TokenNamepublic	
AbstractScanIterator	TokenNameIdentifier	 Abstract Scan Iterator
getSequentialIterator	TokenNameIdentifier	 get Sequential Iterator
(	TokenNameLPAREN	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
superColumn	TokenNameIdentifier	 super Column
,	TokenNameCOMMA	
final	TokenNamefinal	
AbstractBounds	TokenNameIdentifier	 Abstract Bounds
<	TokenNameLESS	
RowPosition	TokenNameIdentifier	 Row Position
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
IDiskAtomFilter	TokenNameIdentifier	 I Disk Atom Filter
columnFilter	TokenNameIdentifier	 column Filter
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
!	TokenNameNOT	
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
instanceof	TokenNameinstanceof	
Range	TokenNameIdentifier	 Range
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Range	TokenNameIdentifier	 Range
)	TokenNameRPAREN	
range	TokenNameIdentifier	 range
)	TokenNameRPAREN	
.	TokenNameDOT	
isWrapAround	TokenNameIdentifier	 is Wrap Around
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
right	TokenNameIdentifier	 right
.	TokenNameDOT	
isMinimum	TokenNameIdentifier	 is Minimum
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
range	TokenNameIdentifier	 range
;	TokenNameSEMICOLON	
final	TokenNamefinal	
RowPosition	TokenNameIdentifier	 Row Position
startWith	TokenNameIdentifier	 start With
=	TokenNameEQUAL	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
left	TokenNameIdentifier	 left
;	TokenNameSEMICOLON	
final	TokenNamefinal	
RowPosition	TokenNameIdentifier	 Row Position
stopAt	TokenNameIdentifier	 stop At
=	TokenNameEQUAL	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
right	TokenNameIdentifier	 right
;	TokenNameSEMICOLON	
QueryFilter	TokenNameIdentifier	 Query Filter
filter	TokenNameIdentifier	 filter
=	TokenNameEQUAL	
new	TokenNamenew	
QueryFilter	TokenNameIdentifier	 Query Filter
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
new	TokenNamenew	
QueryPath	TokenNameIdentifier	 Query Path
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
superColumn	TokenNameIdentifier	 super Column
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
columnFilter	TokenNameIdentifier	 column Filter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
ViewFragment	TokenNameIdentifier	 View Fragment
view	TokenNameIdentifier	 view
=	TokenNameEQUAL	
markReferenced	TokenNameIdentifier	 mark Referenced
(	TokenNameLPAREN	
startWith	TokenNameIdentifier	 start With
,	TokenNameCOMMA	
stopAt	TokenNameIdentifier	 stop At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Tracing	TokenNameIdentifier	 Tracing
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Executing seq scan across {} sstables for {}"	TokenNameStringLiteral	Executing seq scan across {} sstables for {}
,	TokenNameCOMMA	
view	TokenNameIdentifier	 view
.	TokenNameDOT	
sstables	TokenNameIdentifier	 sstables
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
getString	TokenNameIdentifier	 get String
(	TokenNameLPAREN	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
getKeyValidator	TokenNameIdentifier	 get Key Validator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
final	TokenNamefinal	
CloseableIterator	TokenNameIdentifier	 Closeable Iterator
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
iterator	TokenNameIdentifier	 iterator
=	TokenNameEQUAL	
RowIteratorFactory	TokenNameIdentifier	 Row Iterator Factory
.	TokenNameDOT	
getIterator	TokenNameIdentifier	 get Iterator
(	TokenNameLPAREN	
view	TokenNameIdentifier	 view
.	TokenNameDOT	
memtables	TokenNameIdentifier	 memtables
,	TokenNameCOMMA	
view	TokenNameIdentifier	 view
.	TokenNameDOT	
sstables	TokenNameIdentifier	 sstables
,	TokenNameCOMMA	
startWith	TokenNameIdentifier	 start With
,	TokenNameCOMMA	
stopAt	TokenNameIdentifier	 stop At
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
gcBefore	TokenNameIdentifier	 gc Before
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
1000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
-	TokenNameMINUS	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
getGcGraceSeconds	TokenNameIdentifier	 get Gc Grace Seconds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
AbstractScanIterator	TokenNameIdentifier	 Abstract Scan Iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
protected	TokenNameprotected	
Row	TokenNameIdentifier	 Row
computeNext	TokenNameIdentifier	 compute Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// pull a row out of the iterator 	TokenNameCOMMENT_LINE	pull a row out of the iterator 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
iterator	TokenNameIdentifier	 iterator
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
endOfData	TokenNameIdentifier	 end Of Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Row	TokenNameIdentifier	 Row
current	TokenNameIdentifier	 current
=	TokenNameEQUAL	
iterator	TokenNameIdentifier	 iterator
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DecoratedKey	TokenNameIdentifier	 Decorated Key
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
current	TokenNameIdentifier	 current
.	TokenNameDOT	
key	TokenNameIdentifier	 key
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
stopAt	TokenNameIdentifier	 stop At
.	TokenNameDOT	
isMinimum	TokenNameIdentifier	 is Minimum
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
stopAt	TokenNameIdentifier	 stop At
.	TokenNameDOT	
compareTo	TokenNameIdentifier	 compare To
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
endOfData	TokenNameIdentifier	 end Of Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// skipping outside of assigned range 	TokenNameCOMMENT_LINE	skipping outside of assigned range 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
computeNext	TokenNameIdentifier	 compute Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"scanned {}"	TokenNameStringLiteral	scanned {}
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// TODO this is necessary because when we collate supercolumns together, we don't check 	TokenNameCOMMENT_LINE	TODO this is necessary because when we collate supercolumns together, we don't check 
// their subcolumns for relevance, so we need to do a second prune post facto here. 	TokenNameCOMMENT_LINE	their subcolumns for relevance, so we need to do a second prune post facto here. 
return	TokenNamereturn	
current	TokenNameIdentifier	 current
.	TokenNameDOT	
cf	TokenNameIdentifier	 cf
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
current	TokenNameIdentifier	 current
.	TokenNameDOT	
cf	TokenNameIdentifier	 cf
.	TokenNameDOT	
isSuper	TokenNameIdentifier	 is Super
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
new	TokenNamenew	
Row	TokenNameIdentifier	 Row
(	TokenNameLPAREN	
current	TokenNameIdentifier	 current
.	TokenNameDOT	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
removeDeleted	TokenNameIdentifier	 remove Deleted
(	TokenNameLPAREN	
current	TokenNameIdentifier	 current
.	TokenNameDOT	
cf	TokenNameIdentifier	 cf
,	TokenNameCOMMA	
gcBefore	TokenNameIdentifier	 gc Before
)	TokenNameRPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
current	TokenNameIdentifier	 current
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
SSTableReader	TokenNameIdentifier	 SS Table Reader
.	TokenNameDOT	
releaseReferences	TokenNameIdentifier	 release References
(	TokenNameLPAREN	
view	TokenNameIdentifier	 view
.	TokenNameDOT	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
iterator	TokenNameIdentifier	 iterator
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
RuntimeException	TokenNameIdentifier	 Runtime Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// In case getIterator() throws, otherwise the iteror close method releases the references. 	TokenNameCOMMENT_LINE	In case getIterator() throws, otherwise the iteror close method releases the references. 
SSTableReader	TokenNameIdentifier	 SS Table Reader
.	TokenNameDOT	
releaseReferences	TokenNameIdentifier	 release References
(	TokenNameLPAREN	
view	TokenNameIdentifier	 view
.	TokenNameDOT	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
getRangeSlice	TokenNameIdentifier	 get Range Slice
(	TokenNameLPAREN	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
superColumn	TokenNameIdentifier	 super Column
,	TokenNameCOMMA	
final	TokenNamefinal	
AbstractBounds	TokenNameIdentifier	 Abstract Bounds
<	TokenNameLESS	
RowPosition	TokenNameIdentifier	 Row Position
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
int	TokenNameint	
maxResults	TokenNameIdentifier	 max Results
,	TokenNameCOMMA	
IDiskAtomFilter	TokenNameIdentifier	 I Disk Atom Filter
columnFilter	TokenNameIdentifier	 column Filter
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
IndexExpression	TokenNameIdentifier	 Index Expression
>	TokenNameGREATER	
rowFilter	TokenNameIdentifier	 row Filter
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getRangeSlice	TokenNameIdentifier	 get Range Slice
(	TokenNameLPAREN	
superColumn	TokenNameIdentifier	 super Column
,	TokenNameCOMMA	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
maxResults	TokenNameIdentifier	 max Results
,	TokenNameCOMMA	
columnFilter	TokenNameIdentifier	 column Filter
,	TokenNameCOMMA	
rowFilter	TokenNameIdentifier	 row Filter
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
getRangeSlice	TokenNameIdentifier	 get Range Slice
(	TokenNameLPAREN	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
superColumn	TokenNameIdentifier	 super Column
,	TokenNameCOMMA	
final	TokenNamefinal	
AbstractBounds	TokenNameIdentifier	 Abstract Bounds
<	TokenNameLESS	
RowPosition	TokenNameIdentifier	 Row Position
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
int	TokenNameint	
maxResults	TokenNameIdentifier	 max Results
,	TokenNameCOMMA	
IDiskAtomFilter	TokenNameIdentifier	 I Disk Atom Filter
columnFilter	TokenNameIdentifier	 column Filter
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
IndexExpression	TokenNameIdentifier	 Index Expression
>	TokenNameGREATER	
rowFilter	TokenNameIdentifier	 row Filter
,	TokenNameCOMMA	
boolean	TokenNameboolean	
countCQL3Rows	TokenNameIdentifier	 count CQ L3 Rows
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isPaging	TokenNameIdentifier	 is Paging
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
filter	TokenNameIdentifier	 filter
(	TokenNameLPAREN	
getSequentialIterator	TokenNameIdentifier	 get Sequential Iterator
(	TokenNameLPAREN	
superColumn	TokenNameIdentifier	 super Column
,	TokenNameCOMMA	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
columnFilter	TokenNameIdentifier	 column Filter
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ExtendedFilter	TokenNameIdentifier	 Extended Filter
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
columnFilter	TokenNameIdentifier	 column Filter
,	TokenNameCOMMA	
rowFilter	TokenNameIdentifier	 row Filter
,	TokenNameCOMMA	
maxResults	TokenNameIdentifier	 max Results
,	TokenNameCOMMA	
countCQL3Rows	TokenNameIdentifier	 count CQ L3 Rows
,	TokenNameCOMMA	
isPaging	TokenNameIdentifier	 is Paging
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
IndexExpression	TokenNameIdentifier	 Index Expression
>	TokenNameGREATER	
clause	TokenNameIdentifier	 clause
,	TokenNameCOMMA	
AbstractBounds	TokenNameIdentifier	 Abstract Bounds
<	TokenNameLESS	
RowPosition	TokenNameIdentifier	 Row Position
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
int	TokenNameint	
maxResults	TokenNameIdentifier	 max Results
,	TokenNameCOMMA	
IDiskAtomFilter	TokenNameIdentifier	 I Disk Atom Filter
dataFilter	TokenNameIdentifier	 data Filter
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
clause	TokenNameIdentifier	 clause
,	TokenNameCOMMA	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
maxResults	TokenNameIdentifier	 max Results
,	TokenNameCOMMA	
dataFilter	TokenNameIdentifier	 data Filter
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
IndexExpression	TokenNameIdentifier	 Index Expression
>	TokenNameGREATER	
clause	TokenNameIdentifier	 clause
,	TokenNameCOMMA	
AbstractBounds	TokenNameIdentifier	 Abstract Bounds
<	TokenNameLESS	
RowPosition	TokenNameIdentifier	 Row Position
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
int	TokenNameint	
maxResults	TokenNameIdentifier	 max Results
,	TokenNameCOMMA	
IDiskAtomFilter	TokenNameIdentifier	 I Disk Atom Filter
dataFilter	TokenNameIdentifier	 data Filter
,	TokenNameCOMMA	
boolean	TokenNameboolean	
countCQL3Rows	TokenNameIdentifier	 count CQ L3 Rows
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Tracing	TokenNameIdentifier	 Tracing
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Executing indexed scan for {}"	TokenNameStringLiteral	Executing indexed scan for {}
,	TokenNameCOMMA	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
getString	TokenNameIdentifier	 get String
(	TokenNameLPAREN	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
getKeyValidator	TokenNameIdentifier	 get Key Validator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
indexManager	TokenNameIdentifier	 index Manager
.	TokenNameDOT	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
clause	TokenNameIdentifier	 clause
,	TokenNameCOMMA	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
maxResults	TokenNameIdentifier	 max Results
,	TokenNameCOMMA	
dataFilter	TokenNameIdentifier	 data Filter
,	TokenNameCOMMA	
countCQL3Rows	TokenNameIdentifier	 count CQ L3 Rows
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
filter	TokenNameIdentifier	 filter
(	TokenNameLPAREN	
AbstractScanIterator	TokenNameIdentifier	 Abstract Scan Iterator
rowIterator	TokenNameIdentifier	 row Iterator
,	TokenNameCOMMA	
ExtendedFilter	TokenNameIdentifier	 Extended Filter
filter	TokenNameIdentifier	 filter
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Filtering {} for rows matching {}"	TokenNameStringLiteral	Filtering {} for rows matching {}
,	TokenNameCOMMA	
rowIterator	TokenNameIdentifier	 row Iterator
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
rows	TokenNameIdentifier	 rows
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
columnsCount	TokenNameIdentifier	 columns Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
total	TokenNameIdentifier	 total
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
matched	TokenNameIdentifier	 matched
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
rowIterator	TokenNameIdentifier	 row Iterator
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
rows	TokenNameIdentifier	 rows
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<	TokenNameLESS	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
maxRows	TokenNameIdentifier	 max Rows
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
columnsCount	TokenNameIdentifier	 columns Count
<	TokenNameLESS	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
maxColumns	TokenNameIdentifier	 max Columns
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// get the raw columns requested, and additional columns for the expressions if necessary 	TokenNameCOMMENT_LINE	get the raw columns requested, and additional columns for the expressions if necessary 
Row	TokenNameIdentifier	 Row
rawRow	TokenNameIdentifier	 raw Row
=	TokenNameEQUAL	
rowIterator	TokenNameIdentifier	 row Iterator
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
total	TokenNameIdentifier	 total
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
ColumnFamily	TokenNameIdentifier	 Column Family
data	TokenNameIdentifier	 data
=	TokenNameEQUAL	
rawRow	TokenNameIdentifier	 raw Row
.	TokenNameDOT	
cf	TokenNameIdentifier	 cf
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
rowIterator	TokenNameIdentifier	 row Iterator
.	TokenNameDOT	
needsFiltering	TokenNameIdentifier	 needs Filtering
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
IDiskAtomFilter	TokenNameIdentifier	 I Disk Atom Filter
extraFilter	TokenNameIdentifier	 extra Filter
=	TokenNameEQUAL	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
getExtraFilter	TokenNameIdentifier	 get Extra Filter
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
extraFilter	TokenNameIdentifier	 extra Filter
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
QueryPath	TokenNameIdentifier	 Query Path
path	TokenNameIdentifier	 path
=	TokenNameEQUAL	
new	TokenNamenew	
QueryPath	TokenNameIdentifier	 Query Path
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ColumnFamily	TokenNameIdentifier	 Column Family
cf	TokenNameIdentifier	 cf
=	TokenNameEQUAL	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
getColumnFamily	TokenNameIdentifier	 get Column Family
(	TokenNameLPAREN	
new	TokenNamenew	
QueryFilter	TokenNameIdentifier	 Query Filter
(	TokenNameLPAREN	
rawRow	TokenNameIdentifier	 raw Row
.	TokenNameDOT	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
path	TokenNameIdentifier	 path
,	TokenNameCOMMA	
extraFilter	TokenNameIdentifier	 extra Filter
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cf	TokenNameIdentifier	 cf
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
addAll	TokenNameIdentifier	 add All
(	TokenNameLPAREN	
cf	TokenNameIdentifier	 cf
,	TokenNameCOMMA	
HeapAllocator	TokenNameIdentifier	 Heap Allocator
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
isSatisfiedBy	TokenNameIdentifier	 is Satisfied By
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"{} satisfies all filter expressions"	TokenNameStringLiteral	{} satisfies all filter expressions
,	TokenNameCOMMA	
data	TokenNameIdentifier	 data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// cut the resultset back to what was requested, if necessary 	TokenNameCOMMENT_LINE	cut the resultset back to what was requested, if necessary 
data	TokenNameIdentifier	 data
=	TokenNameEQUAL	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
prune	TokenNameIdentifier	 prune
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
rows	TokenNameIdentifier	 rows
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
Row	TokenNameIdentifier	 Row
(	TokenNameLPAREN	
rawRow	TokenNameIdentifier	 raw Row
.	TokenNameDOT	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
data	TokenNameIdentifier	 data
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
matched	TokenNameIdentifier	 matched
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
columnsCount	TokenNameIdentifier	 columns Count
+=	TokenNamePLUS_EQUAL	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
lastCounted	TokenNameIdentifier	 last Counted
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Update the underlying filter to avoid querying more columns per slice than necessary and to handle paging 	TokenNameCOMMENT_LINE	Update the underlying filter to avoid querying more columns per slice than necessary and to handle paging 
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
updateFilter	TokenNameIdentifier	 update Filter
(	TokenNameLPAREN	
columnsCount	TokenNameIdentifier	 columns Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
rows	TokenNameIdentifier	 rows
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
rowIterator	TokenNameIdentifier	 row Iterator
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Tracing	TokenNameIdentifier	 Tracing
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Scanned {} rows and matched {}"	TokenNameStringLiteral	Scanned {} rows and matched {}
,	TokenNameCOMMA	
total	TokenNameIdentifier	 total
,	TokenNameCOMMA	
matched	TokenNameIdentifier	 matched
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
getComparator	TokenNameIdentifier	 get Comparator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
comparator	TokenNameIdentifier	 comparator
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
snapshotWithoutFlush	TokenNameIdentifier	 snapshot Without Flush
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
snapshotName	TokenNameIdentifier	 snapshot Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
:	TokenNameCOLON	
concatWithIndexes	TokenNameIdentifier	 concat With Indexes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DataTracker	TokenNameIdentifier	 Data Tracker
.	TokenNameDOT	
View	TokenNameIdentifier	 View
currentView	TokenNameIdentifier	 current View
=	TokenNameEQUAL	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
markCurrentViewReferenced	TokenNameIdentifier	 mark Current View Referenced
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
ssTable	TokenNameIdentifier	 ss Table
:	TokenNameCOLON	
currentView	TokenNameIdentifier	 current View
.	TokenNameDOT	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
snapshotDirectory	TokenNameIdentifier	 snapshot Directory
=	TokenNameEQUAL	
Directories	TokenNameIdentifier	 Directories
.	TokenNameDOT	
getSnapshotDirectory	TokenNameIdentifier	 get Snapshot Directory
(	TokenNameLPAREN	
ssTable	TokenNameIdentifier	 ss Table
.	TokenNameDOT	
descriptor	TokenNameIdentifier	 descriptor
,	TokenNameCOMMA	
snapshotName	TokenNameIdentifier	 snapshot Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ssTable	TokenNameIdentifier	 ss Table
.	TokenNameDOT	
createLinks	TokenNameIdentifier	 create Links
(	TokenNameLPAREN	
snapshotDirectory	TokenNameIdentifier	 snapshot Directory
.	TokenNameDOT	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// hard links 	TokenNameCOMMENT_LINE	hard links 
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Snapshot for "	TokenNameStringLiteral	Snapshot for 
+	TokenNamePLUS	
table	TokenNameIdentifier	 table
+	TokenNamePLUS	
" keyspace data file "	TokenNameStringLiteral	 keyspace data file 
+	TokenNamePLUS	
ssTable	TokenNameIdentifier	 ss Table
.	TokenNameDOT	
getFilename	TokenNameIdentifier	 get Filename
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" created in "	TokenNameStringLiteral	 created in 
+	TokenNamePLUS	
snapshotDirectory	TokenNameIdentifier	 snapshot Directory
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
compactionStrategy	TokenNameIdentifier	 compaction Strategy
instanceof	TokenNameinstanceof	
LeveledCompactionStrategy	TokenNameIdentifier	 Leveled Compaction Strategy
)	TokenNameRPAREN	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
directories	TokenNameIdentifier	 directories
.	TokenNameDOT	
snapshotLeveledManifest	TokenNameIdentifier	 snapshot Leveled Manifest
(	TokenNameLPAREN	
snapshotName	TokenNameIdentifier	 snapshot Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
SSTableReader	TokenNameIdentifier	 SS Table Reader
.	TokenNameDOT	
releaseReferences	TokenNameIdentifier	 release References
(	TokenNameLPAREN	
currentView	TokenNameIdentifier	 current View
.	TokenNameDOT	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
getSnapshotSSTableReader	TokenNameIdentifier	 get Snapshot SS Table Reader
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
tag	TokenNameIdentifier	 tag
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
Descriptor	TokenNameIdentifier	 Descriptor
,	TokenNameCOMMA	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Component	TokenNameIdentifier	 Component
>>	TokenNameRIGHT_SHIFT	
snapshots	TokenNameIdentifier	 snapshots
=	TokenNameEQUAL	
directories	TokenNameIdentifier	 directories
.	TokenNameDOT	
sstableLister	TokenNameIdentifier	 sstable Lister
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
snapshots	TokenNameIdentifier	 snapshots
(	TokenNameLPAREN	
tag	TokenNameIdentifier	 tag
)	TokenNameRPAREN	
.	TokenNameDOT	
list	TokenNameIdentifier	 list
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
readers	TokenNameIdentifier	 readers
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
(	TokenNameLPAREN	
snapshots	TokenNameIdentifier	 snapshots
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
Descriptor	TokenNameIdentifier	 Descriptor
,	TokenNameCOMMA	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Component	TokenNameIdentifier	 Component
>>	TokenNameRIGHT_SHIFT	
entries	TokenNameIdentifier	 entries
:	TokenNameCOLON	
snapshots	TokenNameIdentifier	 snapshots
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
readers	TokenNameIdentifier	 readers
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
entries	TokenNameIdentifier	 entries
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
entries	TokenNameIdentifier	 entries
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
metadata	TokenNameIdentifier	 metadata
,	TokenNameCOMMA	
partitioner	TokenNameIdentifier	 partitioner
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
readers	TokenNameIdentifier	 readers
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Take a snap shot of this columnfamily store. * * @param snapshotName the name of the associated with the snapshot */	TokenNameCOMMENT_JAVADOC	 Take a snap shot of this columnfamily store. * @param snapshotName the name of the associated with the snapshot 
public	TokenNamepublic	
void	TokenNamevoid	
snapshot	TokenNameIdentifier	 snapshot
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
snapshotName	TokenNameIdentifier	 snapshot Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
forceBlockingFlush	TokenNameIdentifier	 force Blocking Flush
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ExecutionException	TokenNameIdentifier	 Execution Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
AssertionError	TokenNameIdentifier	 Assertion Error
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
snapshotWithoutFlush	TokenNameIdentifier	 snapshot Without Flush
(	TokenNameLPAREN	
snapshotName	TokenNameIdentifier	 snapshot Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
snapshotExists	TokenNameIdentifier	 snapshot Exists
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
snapshotName	TokenNameIdentifier	 snapshot Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
directories	TokenNameIdentifier	 directories
.	TokenNameDOT	
snapshotExists	TokenNameIdentifier	 snapshot Exists
(	TokenNameLPAREN	
snapshotName	TokenNameIdentifier	 snapshot Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getSnapshotCreationTime	TokenNameIdentifier	 get Snapshot Creation Time
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
snapshotName	TokenNameIdentifier	 snapshot Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
directories	TokenNameIdentifier	 directories
.	TokenNameDOT	
snapshotCreationTime	TokenNameIdentifier	 snapshot Creation Time
(	TokenNameLPAREN	
snapshotName	TokenNameIdentifier	 snapshot Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
clearSnapshot	TokenNameIdentifier	 clear Snapshot
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
snapshotName	TokenNameIdentifier	 snapshot Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
directories	TokenNameIdentifier	 directories
.	TokenNameDOT	
clearSnapshot	TokenNameIdentifier	 clear Snapshot
(	TokenNameLPAREN	
snapshotName	TokenNameIdentifier	 snapshot Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
hasUnreclaimedSpace	TokenNameIdentifier	 has Unreclaimed Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getLiveDiskSpaceUsed	TokenNameIdentifier	 get Live Disk Space Used
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<	TokenNameLESS	
getTotalDiskSpaceUsed	TokenNameIdentifier	 get Total Disk Space Used
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getTotalDiskSpaceUsed	TokenNameIdentifier	 get Total Disk Space Used
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
totalDiskSpaceUsed	TokenNameIdentifier	 total Disk Space Used
.	TokenNameDOT	
count	TokenNameIdentifier	 count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getLiveDiskSpaceUsed	TokenNameIdentifier	 get Live Disk Space Used
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
liveDiskSpaceUsed	TokenNameIdentifier	 live Disk Space Used
.	TokenNameDOT	
count	TokenNameIdentifier	 count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getLiveSSTableCount	TokenNameIdentifier	 get Live SS Table Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
liveSSTableCount	TokenNameIdentifier	 live SS Table Count
.	TokenNameDOT	
value	TokenNameIdentifier	 value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @return the cached row for @param key if it is already present in the cache. * That is, unlike getThroughCache, it will not readAndCache the row if it is not present, nor * are these calls counted in cache statistics. * * Note that this WILL cause deserialization of a SerializingCache row, so if all you * need to know is whether a row is present or not, use containsCachedRow instead. */	TokenNameCOMMENT_JAVADOC	 @return the cached row for @param key if it is already present in the cache. That is, unlike getThroughCache, it will not readAndCache the row if it is not present, nor are these calls counted in cache statistics. * Note that this WILL cause deserialization of a SerializingCache row, so if all you need to know is whether a row is present or not, use containsCachedRow instead. 
public	TokenNamepublic	
ColumnFamily	TokenNameIdentifier	 Column Family
getRawCachedRow	TokenNameIdentifier	 get Raw Cached Row
(	TokenNameLPAREN	
DecoratedKey	TokenNameIdentifier	 Decorated Key
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
cfId	TokenNameIdentifier	 cf Id
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// secondary index 	TokenNameCOMMENT_LINE	secondary index 
IRowCacheEntry	TokenNameIdentifier	 I Row Cache Entry
cached	TokenNameIdentifier	 cached
=	TokenNameEQUAL	
getCachedRowInternal	TokenNameIdentifier	 get Cached Row Internal
(	TokenNameLPAREN	
new	TokenNamenew	
RowCacheKey	TokenNameIdentifier	 Row Cache Key
(	TokenNameLPAREN	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
cfId	TokenNameIdentifier	 cf Id
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
cached	TokenNameIdentifier	 cached
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
cached	TokenNameIdentifier	 cached
instanceof	TokenNameinstanceof	
RowCacheSentinel	TokenNameIdentifier	 Row Cache Sentinel
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
(	TokenNameLPAREN	
ColumnFamily	TokenNameIdentifier	 Column Family
)	TokenNameRPAREN	
cached	TokenNameIdentifier	 cached
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
IRowCacheEntry	TokenNameIdentifier	 I Row Cache Entry
getCachedRowInternal	TokenNameIdentifier	 get Cached Row Internal
(	TokenNameLPAREN	
RowCacheKey	TokenNameIdentifier	 Row Cache Key
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
CacheService	TokenNameIdentifier	 Cache Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
rowCache	TokenNameIdentifier	 row Cache
.	TokenNameDOT	
getCapacity	TokenNameIdentifier	 get Capacity
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
CacheService	TokenNameIdentifier	 Cache Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
rowCache	TokenNameIdentifier	 row Cache
.	TokenNameDOT	
getInternal	TokenNameIdentifier	 get Internal
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @return true if @param key is contained in the row cache */	TokenNameCOMMENT_JAVADOC	 @return true if @param key is contained in the row cache 
public	TokenNamepublic	
boolean	TokenNameboolean	
containsCachedRow	TokenNameIdentifier	 contains Cached Row
(	TokenNameLPAREN	
DecoratedKey	TokenNameIdentifier	 Decorated Key
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
CacheService	TokenNameIdentifier	 Cache Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
rowCache	TokenNameIdentifier	 row Cache
.	TokenNameDOT	
getCapacity	TokenNameIdentifier	 get Capacity
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
CacheService	TokenNameIdentifier	 Cache Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
rowCache	TokenNameIdentifier	 row Cache
.	TokenNameDOT	
containsKey	TokenNameIdentifier	 contains Key
(	TokenNameLPAREN	
new	TokenNamenew	
RowCacheKey	TokenNameIdentifier	 Row Cache Key
(	TokenNameLPAREN	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
cfId	TokenNameIdentifier	 cf Id
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
invalidateCachedRow	TokenNameIdentifier	 invalidate Cached Row
(	TokenNameLPAREN	
RowCacheKey	TokenNameIdentifier	 Row Cache Key
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CacheService	TokenNameIdentifier	 Cache Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
rowCache	TokenNameIdentifier	 row Cache
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
invalidateCachedRow	TokenNameIdentifier	 invalidate Cached Row
(	TokenNameLPAREN	
DecoratedKey	TokenNameIdentifier	 Decorated Key
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
UUID	TokenNameIdentifier	 UUID
cfId	TokenNameIdentifier	 cf Id
=	TokenNameEQUAL	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getId	TokenNameIdentifier	 get Id
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
this	TokenNamethis	
.	TokenNameDOT	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cfId	TokenNameIdentifier	 cf Id
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
// secondary index 	TokenNameCOMMENT_LINE	secondary index 
invalidateCachedRow	TokenNameIdentifier	 invalidate Cached Row
(	TokenNameLPAREN	
new	TokenNamenew	
RowCacheKey	TokenNameIdentifier	 Row Cache Key
(	TokenNameLPAREN	
cfId	TokenNameIdentifier	 cf Id
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
forceMajorCompaction	TokenNameIdentifier	 force Major Compaction
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
,	TokenNameCOMMA	
ExecutionException	TokenNameIdentifier	 Execution Exception
{	TokenNameLBRACE	
CompactionManager	TokenNameIdentifier	 Compaction Manager
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
performMaximal	TokenNameIdentifier	 perform Maximal
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
>	TokenNameGREATER	
all	TokenNameIdentifier	 all
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
>>	TokenNameRIGHT_SHIFT	
stores	TokenNameIdentifier	 stores
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getTables	TokenNameIdentifier	 get Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Table	TokenNameIdentifier	 Table
table	TokenNameIdentifier	 table
:	TokenNameCOLON	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
all	TokenNameIdentifier	 all
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stores	TokenNameIdentifier	 stores
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
getColumnFamilyStores	TokenNameIdentifier	 get Column Family Stores
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
Iterables	TokenNameIdentifier	 Iterables
.	TokenNameDOT	
concat	TokenNameIdentifier	 concat
(	TokenNameLPAREN	
stores	TokenNameIdentifier	 stores
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
>	TokenNameGREATER	
allUserDefined	TokenNameIdentifier	 all User Defined
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
>	TokenNameGREATER	
cfses	TokenNameIdentifier	 cfses
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Table	TokenNameIdentifier	 Table
table	TokenNameIdentifier	 table
:	TokenNameCOLON	
Sets	TokenNameIdentifier	 Sets
.	TokenNameDOT	
difference	TokenNameIdentifier	 difference
(	TokenNameLPAREN	
ImmutableSet	TokenNameIdentifier	 Immutable Set
.	TokenNameDOT	
copyOf	TokenNameIdentifier	 copy Of
(	TokenNameLPAREN	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
all	TokenNameIdentifier	 all
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ImmutableSet	TokenNameIdentifier	 Immutable Set
.	TokenNameDOT	
of	TokenNameIdentifier	 of
(	TokenNameLPAREN	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
SYSTEM_KS	TokenNameIdentifier	 SYSTEM  KS
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
cfses	TokenNameIdentifier	 cfses
.	TokenNameDOT	
addAll	TokenNameIdentifier	 add All
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
getColumnFamilyStores	TokenNameIdentifier	 get Column Family Stores
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
cfses	TokenNameIdentifier	 cfses
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
DecoratedKey	TokenNameIdentifier	 Decorated Key
>	TokenNameGREATER	
keySamples	TokenNameIdentifier	 key Samples
(	TokenNameLPAREN	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
=	TokenNameEQUAL	
getSSTables	TokenNameIdentifier	 get SS Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
DecoratedKey	TokenNameIdentifier	 Decorated Key
>	TokenNameGREATER	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
samples	TokenNameIdentifier	 samples
=	TokenNameEQUAL	
new	TokenNamenew	
Iterable	TokenNameIdentifier	 Iterable
[	TokenNameLBRACKET	
sstables	TokenNameIdentifier	 sstables
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
:	TokenNameCOLON	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
samples	TokenNameIdentifier	 samples
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
getKeySamples	TokenNameIdentifier	 get Key Samples
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
Iterables	TokenNameIdentifier	 Iterables
.	TokenNameDOT	
concat	TokenNameIdentifier	 concat
(	TokenNameLPAREN	
samples	TokenNameIdentifier	 samples
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * For testing. No effort is made to clear historical or even the current memtables, nor for * thread safety. All we do is wipe the sstable containers clean, while leaving the actual * data files present on disk. (This allows tests to easily call loadNewSSTables on them.) */	TokenNameCOMMENT_JAVADOC	 For testing. No effort is made to clear historical or even the current memtables, nor for thread safety. All we do is wipe the sstable containers clean, while leaving the actual data files present on disk. (This allows tests to easily call loadNewSSTables on them.) 
public	TokenNamepublic	
void	TokenNamevoid	
clearUnsafe	TokenNameIdentifier	 clear Unsafe
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
:	TokenNameCOLON	
concatWithIndexes	TokenNameIdentifier	 concat With Indexes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
init	TokenNameIdentifier	 init
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Truncate deletes the entire column family's data with no expensive tombstone creation * @return a Future to the delete operation. Call the future's get() to make * sure the column family has been deleted */	TokenNameCOMMENT_JAVADOC	 Truncate deletes the entire column family's data with no expensive tombstone creation @return a Future to the delete operation. Call the future's get() to make sure the column family has been deleted 
public	TokenNamepublic	
Future	TokenNameIdentifier	 Future
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
truncate	TokenNameIdentifier	 truncate
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
ExecutionException	TokenNameIdentifier	 Execution Exception
,	TokenNameCOMMA	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
{	TokenNameLBRACE	
// We have two goals here: 	TokenNameCOMMENT_LINE	We have two goals here: 
// - truncate should delete everything written before truncate was invoked 	TokenNameCOMMENT_LINE	- truncate should delete everything written before truncate was invoked 
// - but not delete anything that isn't part of the snapshot we create. 	TokenNameCOMMENT_LINE	- but not delete anything that isn't part of the snapshot we create. 
// We accomplish this by first flushing manually, then snapshotting, and 	TokenNameCOMMENT_LINE	We accomplish this by first flushing manually, then snapshotting, and 
// recording the timestamp IN BETWEEN those actions. Any sstables created 	TokenNameCOMMENT_LINE	recording the timestamp IN BETWEEN those actions. Any sstables created 
// with this timestamp or greater time, will not be marked for delete. 	TokenNameCOMMENT_LINE	with this timestamp or greater time, will not be marked for delete. 
// 	TokenNameCOMMENT_LINE	 
// Bonus complication: since we store replay position in sstable metadata, 	TokenNameCOMMENT_LINE	Bonus complication: since we store replay position in sstable metadata, 
// truncating those sstables means we will replay any CL segments from the 	TokenNameCOMMENT_LINE	truncating those sstables means we will replay any CL segments from the 
// beginning if we restart before they are discarded for normal reasons 	TokenNameCOMMENT_LINE	beginning if we restart before they are discarded for normal reasons 
// post-truncate. So we need to create a "dummy" sstable containing 	TokenNameCOMMENT_LINE	post-truncate. So we need to create a "dummy" sstable containing 
// only the replay position. This is done by CompactionManager.submitTruncate. 	TokenNameCOMMENT_LINE	only the replay position. This is done by CompactionManager.submitTruncate. 
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"truncating {}"	TokenNameStringLiteral	truncating {}
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
isAutoSnapshot	TokenNameIdentifier	 is Auto Snapshot
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// flush the CF being truncated before forcing the new segment 	TokenNameCOMMENT_LINE	flush the CF being truncated before forcing the new segment 
forceBlockingFlush	TokenNameIdentifier	 force Blocking Flush
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// sleep a little to make sure that our truncatedAt comes after any sstable 	TokenNameCOMMENT_LINE	sleep a little to make sure that our truncatedAt comes after any sstable 
// that was part of the flushed we forced; otherwise on a tie, it won't get deleted. 	TokenNameCOMMENT_LINE	that was part of the flushed we forced; otherwise on a tie, it won't get deleted. 
try	TokenNametry	
{	TokenNameLBRACE	
long	TokenNamelong	
starttime	TokenNameIdentifier	 starttime
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
starttime	TokenNameIdentifier	 starttime
)	TokenNameRPAREN	
<	TokenNameLESS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
sleep	TokenNameIdentifier	 sleep
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
AssertionError	TokenNameIdentifier	 Assertion Error
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// just nuke the memtable data w/o writing to disk first 	TokenNameCOMMENT_LINE	just nuke the memtable data w/o writing to disk first 
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
switchLock	TokenNameIdentifier	 switch Lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
:	TokenNameCOLON	
concatWithIndexes	TokenNameIdentifier	 concat With Indexes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Memtable	TokenNameIdentifier	 Memtable
mt	TokenNameIdentifier	 mt
=	TokenNameEQUAL	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
getMemtableThreadSafe	TokenNameIdentifier	 get Memtable Thread Safe
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
mt	TokenNameIdentifier	 mt
.	TokenNameDOT	
isClean	TokenNameIdentifier	 is Clean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
mt	TokenNameIdentifier	 mt
.	TokenNameDOT	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
renewMemtable	TokenNameIdentifier	 renew Memtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
switchLock	TokenNameIdentifier	 switch Lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
long	TokenNamelong	
truncatedAt	TokenNameIdentifier	 truncated At
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
isAutoSnapshot	TokenNameIdentifier	 is Auto Snapshot
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
snapshot	TokenNameIdentifier	 snapshot
(	TokenNameLPAREN	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
getTimestampedSnapshotName	TokenNameIdentifier	 get Timestamped Snapshot Name
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
CompactionManager	TokenNameIdentifier	 Compaction Manager
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
submitTruncate	TokenNameIdentifier	 submit Truncate
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
truncatedAt	TokenNameIdentifier	 truncated At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getBloomFilterFalsePositives	TokenNameIdentifier	 get Bloom Filter False Positives
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
bloomFilterFalsePositives	TokenNameIdentifier	 bloom Filter False Positives
.	TokenNameDOT	
value	TokenNameIdentifier	 value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getRecentBloomFilterFalsePositives	TokenNameIdentifier	 get Recent Bloom Filter False Positives
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
recentBloomFilterFalsePositives	TokenNameIdentifier	 recent Bloom Filter False Positives
.	TokenNameDOT	
value	TokenNameIdentifier	 value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
double	TokenNamedouble	
getBloomFilterFalseRatio	TokenNameIdentifier	 get Bloom Filter False Ratio
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
bloomFilterFalseRatio	TokenNameIdentifier	 bloom Filter False Ratio
.	TokenNameDOT	
value	TokenNameIdentifier	 value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
double	TokenNamedouble	
getRecentBloomFilterFalseRatio	TokenNameIdentifier	 get Recent Bloom Filter False Ratio
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
recentBloomFilterFalseRatio	TokenNameIdentifier	 recent Bloom Filter False Ratio
.	TokenNameDOT	
value	TokenNameIdentifier	 value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getBloomFilterDiskSpaceUsed	TokenNameIdentifier	 get Bloom Filter Disk Space Used
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
bloomFilterDiskSpaceUsed	TokenNameIdentifier	 bloom Filter Disk Space Used
.	TokenNameDOT	
value	TokenNameIdentifier	 value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
String	TokenNameIdentifier	 String
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
"CFS("	TokenNameStringLiteral	CFS(
+	TokenNamePLUS	
"Keyspace='"	TokenNameStringLiteral	Keyspace='
+	TokenNamePLUS	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
name	TokenNameIdentifier	 name
+	TokenNamePLUS	
'\''	TokenNameCharacterLiteral	
+	TokenNamePLUS	
", ColumnFamily='"	TokenNameStringLiteral	, ColumnFamily='
+	TokenNamePLUS	
columnFamily	TokenNameIdentifier	 column Family
+	TokenNamePLUS	
'\''	TokenNameCharacterLiteral	
+	TokenNamePLUS	
')'	TokenNameCharacterLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
disableAutoCompaction	TokenNameIdentifier	 disable Auto Compaction
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
minCompactionThreshold	TokenNameIdentifier	 min Compaction Threshold
.	TokenNameDOT	
set	TokenNameIdentifier	 set
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
maxCompactionThreshold	TokenNameIdentifier	 max Compaction Threshold
.	TokenNameDOT	
set	TokenNameIdentifier	 set
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
enableAutoCompaction	TokenNameIdentifier	 enable Auto Compaction
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
minCompactionThreshold	TokenNameIdentifier	 min Compaction Threshold
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
maxCompactionThreshold	TokenNameIdentifier	 max Compaction Threshold
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* JMX getters and setters for the Default<T>s. - get/set minCompactionThreshold - get/set maxCompactionThreshold - get memsize - get memops - get/set memtime */	TokenNameCOMMENT_BLOCK	 JMX getters and setters for the Default<T>s. - get/set minCompactionThreshold - get/set maxCompactionThreshold - get memsize - get memops - get/set memtime 
public	TokenNamepublic	
AbstractCompactionStrategy	TokenNameIdentifier	 Abstract Compaction Strategy
getCompactionStrategy	TokenNameIdentifier	 get Compaction Strategy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
compactionStrategy	TokenNameIdentifier	 compaction Strategy
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setCompactionThresholds	TokenNameIdentifier	 set Compaction Thresholds
(	TokenNameLPAREN	
int	TokenNameint	
minThreshold	TokenNameIdentifier	 min Threshold
,	TokenNameCOMMA	
int	TokenNameint	
maxThreshold	TokenNameIdentifier	 max Threshold
)	TokenNameRPAREN	
{	TokenNameLBRACE	
validateCompactionThresholds	TokenNameIdentifier	 validate Compaction Thresholds
(	TokenNameLPAREN	
minThreshold	TokenNameIdentifier	 min Threshold
,	TokenNameCOMMA	
maxThreshold	TokenNameIdentifier	 max Threshold
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
minCompactionThreshold	TokenNameIdentifier	 min Compaction Threshold
.	TokenNameDOT	
set	TokenNameIdentifier	 set
(	TokenNameLPAREN	
minThreshold	TokenNameIdentifier	 min Threshold
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
maxCompactionThreshold	TokenNameIdentifier	 max Compaction Threshold
.	TokenNameDOT	
set	TokenNameIdentifier	 set
(	TokenNameLPAREN	
maxThreshold	TokenNameIdentifier	 max Threshold
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// this is called as part of CompactionStrategy constructor; avoid circular dependency by checking for null 	TokenNameCOMMENT_LINE	this is called as part of CompactionStrategy constructor; avoid circular dependency by checking for null 
if	TokenNameif	
(	TokenNameLPAREN	
compactionStrategy	TokenNameIdentifier	 compaction Strategy
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
CompactionManager	TokenNameIdentifier	 Compaction Manager
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
submitBackground	TokenNameIdentifier	 submit Background
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getMinimumCompactionThreshold	TokenNameIdentifier	 get Minimum Compaction Threshold
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
minCompactionThreshold	TokenNameIdentifier	 min Compaction Threshold
.	TokenNameDOT	
value	TokenNameIdentifier	 value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setMinimumCompactionThreshold	TokenNameIdentifier	 set Minimum Compaction Threshold
(	TokenNameLPAREN	
int	TokenNameint	
minCompactionThreshold	TokenNameIdentifier	 min Compaction Threshold
)	TokenNameRPAREN	
{	TokenNameLBRACE	
validateCompactionThresholds	TokenNameIdentifier	 validate Compaction Thresholds
(	TokenNameLPAREN	
minCompactionThreshold	TokenNameIdentifier	 min Compaction Threshold
,	TokenNameCOMMA	
maxCompactionThreshold	TokenNameIdentifier	 max Compaction Threshold
.	TokenNameDOT	
value	TokenNameIdentifier	 value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
minCompactionThreshold	TokenNameIdentifier	 min Compaction Threshold
.	TokenNameDOT	
set	TokenNameIdentifier	 set
(	TokenNameLPAREN	
minCompactionThreshold	TokenNameIdentifier	 min Compaction Threshold
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getMaximumCompactionThreshold	TokenNameIdentifier	 get Maximum Compaction Threshold
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
maxCompactionThreshold	TokenNameIdentifier	 max Compaction Threshold
.	TokenNameDOT	
value	TokenNameIdentifier	 value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setMaximumCompactionThreshold	TokenNameIdentifier	 set Maximum Compaction Threshold
(	TokenNameLPAREN	
int	TokenNameint	
maxCompactionThreshold	TokenNameIdentifier	 max Compaction Threshold
)	TokenNameRPAREN	
{	TokenNameLBRACE	
validateCompactionThresholds	TokenNameIdentifier	 validate Compaction Thresholds
(	TokenNameLPAREN	
minCompactionThreshold	TokenNameIdentifier	 min Compaction Threshold
.	TokenNameDOT	
value	TokenNameIdentifier	 value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
maxCompactionThreshold	TokenNameIdentifier	 max Compaction Threshold
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
maxCompactionThreshold	TokenNameIdentifier	 max Compaction Threshold
.	TokenNameDOT	
set	TokenNameIdentifier	 set
(	TokenNameLPAREN	
maxCompactionThreshold	TokenNameIdentifier	 max Compaction Threshold
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
validateCompactionThresholds	TokenNameIdentifier	 validate Compaction Thresholds
(	TokenNameLPAREN	
int	TokenNameint	
minThreshold	TokenNameIdentifier	 min Threshold
,	TokenNameCOMMA	
int	TokenNameint	
maxThreshold	TokenNameIdentifier	 max Threshold
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
minThreshold	TokenNameIdentifier	 min Threshold
>	TokenNameGREATER	
maxThreshold	TokenNameIdentifier	 max Threshold
&&	TokenNameAND_AND	
maxThreshold	TokenNameIdentifier	 max Threshold
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"The min_compaction_threshold cannot be larger than the max_compaction_threshold. "	TokenNameStringLiteral	The min_compaction_threshold cannot be larger than the max_compaction_threshold. 
+	TokenNamePLUS	
"Min is '%d', Max is '%d'."	TokenNameStringLiteral	Min is '%d', Max is '%d'.
,	TokenNameCOMMA	
minThreshold	TokenNameIdentifier	 min Threshold
,	TokenNameCOMMA	
maxThreshold	TokenNameIdentifier	 max Threshold
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isCompactionDisabled	TokenNameIdentifier	 is Compaction Disabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getMinimumCompactionThreshold	TokenNameIdentifier	 get Minimum Compaction Threshold
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
getMaximumCompactionThreshold	TokenNameIdentifier	 get Maximum Compaction Threshold
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// End JMX get/set. 	TokenNameCOMMENT_LINE	End JMX get/set. 
public	TokenNamepublic	
long	TokenNamelong	
estimateKeys	TokenNameIdentifier	 estimate Keys
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
estimatedKeys	TokenNameIdentifier	 estimated Keys
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getEstimatedRowSizeHistogram	TokenNameIdentifier	 get Estimated Row Size Histogram
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
estimatedRowSizeHistogram	TokenNameIdentifier	 estimated Row Size Histogram
.	TokenNameDOT	
value	TokenNameIdentifier	 value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getEstimatedColumnCountHistogram	TokenNameIdentifier	 get Estimated Column Count Histogram
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
estimatedColumnCountHistogram	TokenNameIdentifier	 estimated Column Count Histogram
.	TokenNameDOT	
value	TokenNameIdentifier	 value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
double	TokenNamedouble	
getCompressionRatio	TokenNameIdentifier	 get Compression Ratio
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metric	TokenNameIdentifier	 metric
.	TokenNameDOT	
compressionRatio	TokenNameIdentifier	 compression Ratio
.	TokenNameDOT	
value	TokenNameIdentifier	 value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** true if this CFS contains secondary index data */	TokenNameCOMMENT_JAVADOC	 true if this CFS contains secondary index data 
public	TokenNamepublic	
boolean	TokenNameboolean	
isIndex	TokenNameIdentifier	 is Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
partitioner	TokenNameIdentifier	 partitioner
instanceof	TokenNameinstanceof	
LocalPartitioner	TokenNameIdentifier	 Local Partitioner
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
intern	TokenNameIdentifier	 intern
(	TokenNameLPAREN	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
internedName	TokenNameIdentifier	 interned Name
=	TokenNameEQUAL	
internedNames	TokenNameIdentifier	 interned Names
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
internedName	TokenNameIdentifier	 interned Name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
internedName	TokenNameIdentifier	 interned Name
=	TokenNameEQUAL	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
concurrentName	TokenNameIdentifier	 concurrent Name
=	TokenNameEQUAL	
internedNames	TokenNameIdentifier	 interned Names
.	TokenNameDOT	
putIfAbsent	TokenNameIdentifier	 put If Absent
(	TokenNameLPAREN	
internedName	TokenNameIdentifier	 interned Name
,	TokenNameCOMMA	
internedName	TokenNameIdentifier	 interned Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
concurrentName	TokenNameIdentifier	 concurrent Name
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
internedName	TokenNameIdentifier	 interned Name
=	TokenNameEQUAL	
concurrentName	TokenNameIdentifier	 concurrent Name
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
internedName	TokenNameIdentifier	 interned Name
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
internOrCopy	TokenNameIdentifier	 intern Or Copy
(	TokenNameLPAREN	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
Allocator	TokenNameIdentifier	 Allocator
allocator	TokenNameIdentifier	 allocator
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
internedNames	TokenNameIdentifier	 interned Names
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>=	TokenNameGREATER_EQUAL	
INTERN_CUTOFF	TokenNameIdentifier	 INTERN  CUTOFF
)	TokenNameRPAREN	
return	TokenNamereturn	
allocator	TokenNameIdentifier	 allocator
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
intern	TokenNameIdentifier	 intern
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
maybeIntern	TokenNameIdentifier	 maybe Intern
(	TokenNameLPAREN	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
internedNames	TokenNameIdentifier	 interned Names
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>=	TokenNameGREATER_EQUAL	
INTERN_CUTOFF	TokenNameIdentifier	 INTERN  CUTOFF
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
intern	TokenNameIdentifier	 intern
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
SSTableWriter	TokenNameIdentifier	 SS Table Writer
createCompactionWriter	TokenNameIdentifier	 create Compaction Writer
(	TokenNameLPAREN	
long	TokenNamelong	
estimatedRows	TokenNameIdentifier	 estimated Rows
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
location	TokenNameIdentifier	 location
,	TokenNameCOMMA	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ReplayPosition	TokenNameIdentifier	 Replay Position
rp	TokenNameIdentifier	 rp
=	TokenNameEQUAL	
ReplayPosition	TokenNameIdentifier	 Replay Position
.	TokenNameDOT	
getReplayPosition	TokenNameIdentifier	 get Replay Position
(	TokenNameLPAREN	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SSTableMetadata	TokenNameIdentifier	 SS Table Metadata
.	TokenNameDOT	
Collector	TokenNameIdentifier	 Collector
sstableMetadataCollector	TokenNameIdentifier	 sstable Metadata Collector
=	TokenNameEQUAL	
SSTableMetadata	TokenNameIdentifier	 SS Table Metadata
.	TokenNameDOT	
createCollector	TokenNameIdentifier	 create Collector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
replayPosition	TokenNameIdentifier	 replay Position
(	TokenNameLPAREN	
rp	TokenNameIdentifier	 rp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Get the max timestamp of the precompacted sstables 	TokenNameCOMMENT_LINE	Get the max timestamp of the precompacted sstables 
// and adds generation of live ancestors 	TokenNameCOMMENT_LINE	and adds generation of live ancestors 
for	TokenNamefor	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
:	TokenNameCOLON	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sstableMetadataCollector	TokenNameIdentifier	 sstable Metadata Collector
.	TokenNameDOT	
updateMaxTimestamp	TokenNameIdentifier	 update Max Timestamp
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
getMaxTimestamp	TokenNameIdentifier	 get Max Timestamp
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sstableMetadataCollector	TokenNameIdentifier	 sstable Metadata Collector
.	TokenNameDOT	
addAncestor	TokenNameIdentifier	 add Ancestor
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
generation	TokenNameIdentifier	 generation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Integer	TokenNameIdentifier	 Integer
i	TokenNameIdentifier	 i
:	TokenNameCOLON	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
getAncestors	TokenNameIdentifier	 get Ancestors
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
withGeneration	TokenNameIdentifier	 with Generation
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
.	TokenNameDOT	
filenameFor	TokenNameIdentifier	 filename For
(	TokenNameLPAREN	
Component	TokenNameIdentifier	 Component
.	TokenNameDOT	
DATA	TokenNameIdentifier	 DATA
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
sstableMetadataCollector	TokenNameIdentifier	 sstable Metadata Collector
.	TokenNameDOT	
addAncestor	TokenNameIdentifier	 add Ancestor
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
new	TokenNamenew	
SSTableWriter	TokenNameIdentifier	 SS Table Writer
(	TokenNameLPAREN	
getTempSSTablePath	TokenNameIdentifier	 get Temp SS Table Path
(	TokenNameLPAREN	
location	TokenNameIdentifier	 location
)	TokenNameRPAREN	
,	TokenNameCOMMA	
estimatedRows	TokenNameIdentifier	 estimated Rows
,	TokenNameCOMMA	
metadata	TokenNameIdentifier	 metadata
,	TokenNameCOMMA	
partitioner	TokenNameIdentifier	 partitioner
,	TokenNameCOMMA	
sstableMetadataCollector	TokenNameIdentifier	 sstable Metadata Collector
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
>	TokenNameGREATER	
concatWithIndexes	TokenNameIdentifier	 concat With Indexes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
Iterables	TokenNameIdentifier	 Iterables
.	TokenNameDOT	
concat	TokenNameIdentifier	 concat
(	TokenNameLPAREN	
indexManager	TokenNameIdentifier	 index Manager
.	TokenNameDOT	
getIndexesBackedByCfs	TokenNameIdentifier	 get Indexes Backed By Cfs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
singleton	TokenNameIdentifier	 singleton
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Memtable	TokenNameIdentifier	 Memtable
>	TokenNameGREATER	
getMemtablesPendingFlush	TokenNameIdentifier	 get Memtables Pending Flush
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
getMemtablesPendingFlush	TokenNameIdentifier	 get Memtables Pending Flush
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
getBuiltIndexes	TokenNameIdentifier	 get Built Indexes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
indexManager	TokenNameIdentifier	 index Manager
.	TokenNameDOT	
getBuiltIndexes	TokenNameIdentifier	 get Built Indexes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getUnleveledSSTables	TokenNameIdentifier	 get Unleveled SS Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
this	TokenNamethis	
.	TokenNameDOT	
compactionStrategy	TokenNameIdentifier	 compaction Strategy
instanceof	TokenNameinstanceof	
LeveledCompactionStrategy	TokenNameIdentifier	 Leveled Compaction Strategy
?	TokenNameQUESTION	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
LeveledCompactionStrategy	TokenNameIdentifier	 Leveled Compaction Strategy
)	TokenNameRPAREN	
this	TokenNamethis	
.	TokenNameDOT	
compactionStrategy	TokenNameIdentifier	 compaction Strategy
)	TokenNameRPAREN	
.	TokenNameDOT	
getLevelSize	TokenNameIdentifier	 get Level Size
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
:	TokenNameCOLON	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getSSTableCountPerLevel	TokenNameIdentifier	 get SS Table Count Per Level
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
compactionStrategy	TokenNameIdentifier	 compaction Strategy
instanceof	TokenNameinstanceof	
LeveledCompactionStrategy	TokenNameIdentifier	 Leveled Compaction Strategy
?	TokenNameQUESTION	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
LeveledCompactionStrategy	TokenNameIdentifier	 Leveled Compaction Strategy
)	TokenNameRPAREN	
compactionStrategy	TokenNameIdentifier	 compaction Strategy
)	TokenNameRPAREN	
.	TokenNameDOT	
getAllLevelSize	TokenNameIdentifier	 get All Level Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
class	TokenNameclass	
ViewFragment	TokenNameIdentifier	 View Fragment
{	TokenNameLBRACE	
public	TokenNamepublic	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
Memtable	TokenNameIdentifier	 Memtable
>	TokenNameGREATER	
memtables	TokenNameIdentifier	 memtables
;	TokenNameSEMICOLON	
public	TokenNamepublic	
ViewFragment	TokenNameIdentifier	 View Fragment
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
,	TokenNameCOMMA	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
Memtable	TokenNameIdentifier	 Memtable
>	TokenNameGREATER	
memtables	TokenNameIdentifier	 memtables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
sstables	TokenNameIdentifier	 sstables
=	TokenNameEQUAL	
sstables	TokenNameIdentifier	 sstables
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
memtables	TokenNameIdentifier	 memtables
=	TokenNameEQUAL	
memtables	TokenNameIdentifier	 memtables
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Returns the creation time of the oldest memtable not fully flushed yet. */	TokenNameCOMMENT_JAVADOC	 Returns the creation time of the oldest memtable not fully flushed yet. 
public	TokenNamepublic	
long	TokenNamelong	
oldestUnflushedMemtable	TokenNameIdentifier	 oldest Unflushed Memtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DataTracker	TokenNameIdentifier	 Data Tracker
.	TokenNameDOT	
View	TokenNameIdentifier	 View
view	TokenNameIdentifier	 view
=	TokenNameEQUAL	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
getView	TokenNameIdentifier	 get View
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
oldest	TokenNameIdentifier	 oldest
=	TokenNameEQUAL	
view	TokenNameIdentifier	 view
.	TokenNameDOT	
memtable	TokenNameIdentifier	 memtable
.	TokenNameDOT	
creationTime	TokenNameIdentifier	 creation Time
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Memtable	TokenNameIdentifier	 Memtable
memtable	TokenNameIdentifier	 memtable
:	TokenNameCOLON	
view	TokenNameIdentifier	 view
.	TokenNameDOT	
memtablesPendingFlush	TokenNameIdentifier	 memtables Pending Flush
)	TokenNameRPAREN	
oldest	TokenNameIdentifier	 oldest
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
min	TokenNameIdentifier	 min
(	TokenNameLPAREN	
oldest	TokenNameIdentifier	 oldest
,	TokenNameCOMMA	
memtable	TokenNameIdentifier	 memtable
.	TokenNameDOT	
creationTime	TokenNameIdentifier	 creation Time
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
oldest	TokenNameIdentifier	 oldest
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DataTracker	TokenNameIdentifier	 Data Tracker
.	TokenNameDOT	
View	TokenNameIdentifier	 View
view	TokenNameIdentifier	 view
=	TokenNameEQUAL	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
getView	TokenNameIdentifier	 get View
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
view	TokenNameIdentifier	 view
.	TokenNameDOT	
sstables	TokenNameIdentifier	 sstables
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
view	TokenNameIdentifier	 view
.	TokenNameDOT	
memtable	TokenNameIdentifier	 memtable
.	TokenNameDOT	
getOperations	TokenNameIdentifier	 get Operations
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
view	TokenNameIdentifier	 view
.	TokenNameDOT	
memtablesPendingFlush	TokenNameIdentifier	 memtables Pending Flush
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
isRowCacheEnabled	TokenNameIdentifier	 is Row Cache Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
!	TokenNameNOT	
(	TokenNameLPAREN	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
getCaching	TokenNameIdentifier	 get Caching
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
Caching	TokenNameIdentifier	 Caching
.	TokenNameDOT	
NONE	TokenNameIdentifier	 NONE
||	TokenNameOR_OR	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
getCaching	TokenNameIdentifier	 get Caching
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
Caching	TokenNameIdentifier	 Caching
.	TokenNameDOT	
KEYS_ONLY	TokenNameIdentifier	 KEYS  ONLY
||	TokenNameOR_OR	
CacheService	TokenNameIdentifier	 Cache Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
rowCache	TokenNameIdentifier	 row Cache
.	TokenNameDOT	
getCapacity	TokenNameIdentifier	 get Capacity
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Discard all SSTables that were created before given timestamp. Caller is responsible to obtain compactionLock. * * @param truncatedAt The timestamp of the truncation * (all SSTables before that timestamp are going be marked as compacted) * * @return the most recent replay position of the truncated data */	TokenNameCOMMENT_JAVADOC	 Discard all SSTables that were created before given timestamp. Caller is responsible to obtain compactionLock. * @param truncatedAt The timestamp of the truncation (all SSTables before that timestamp are going be marked as compacted) * @return the most recent replay position of the truncated data 
public	TokenNamepublic	
ReplayPosition	TokenNameIdentifier	 Replay Position
discardSSTables	TokenNameIdentifier	 discard SS Tables
(	TokenNameLPAREN	
long	TokenNamelong	
truncatedAt	TokenNameIdentifier	 truncated At
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
truncatedSSTables	TokenNameIdentifier	 truncated SS Tables
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
:	TokenNameCOLON	
getSSTables	TokenNameIdentifier	 get SS Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
newSince	TokenNameIdentifier	 new Since
(	TokenNameLPAREN	
truncatedAt	TokenNameIdentifier	 truncated At
)	TokenNameRPAREN	
)	TokenNameRPAREN	
truncatedSSTables	TokenNameIdentifier	 truncated SS Tables
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
truncatedSSTables	TokenNameIdentifier	 truncated SS Tables
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
ReplayPosition	TokenNameIdentifier	 Replay Position
.	TokenNameDOT	
NONE	TokenNameIdentifier	 NONE
;	TokenNameSEMICOLON	
markCompacted	TokenNameIdentifier	 mark Compacted
(	TokenNameLPAREN	
truncatedSSTables	TokenNameIdentifier	 truncated SS Tables
,	TokenNameCOMMA	
OperationType	TokenNameIdentifier	 Operation Type
.	TokenNameDOT	
UNKNOWN	TokenNameIdentifier	 UNKNOWN
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
ReplayPosition	TokenNameIdentifier	 Replay Position
.	TokenNameDOT	
getReplayPosition	TokenNameIdentifier	 get Replay Position
(	TokenNameLPAREN	
truncatedSSTables	TokenNameIdentifier	 truncated SS Tables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
