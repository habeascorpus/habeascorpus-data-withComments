/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
taskdefs	TokenNameIdentifier	 taskdefs
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
ByteArrayInputStream	TokenNameIdentifier	 Byte Array Input Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
ByteArrayOutputStream	TokenNameIdentifier	 Byte Array Output Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
File	TokenNameIdentifier	 File
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
FileInputStream	TokenNameIdentifier	 File Input Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
FileOutputStream	TokenNameIdentifier	 File Output Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
InputStream	TokenNameIdentifier	 Input Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
OutputStream	TokenNameIdentifier	 Output Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Arrays	TokenNameIdentifier	 Arrays
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Collections	TokenNameIdentifier	 Collections
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Comparator	TokenNameIdentifier	 Comparator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Enumeration	TokenNameIdentifier	 Enumeration
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
HashMap	TokenNameIdentifier	 Hash Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Hashtable	TokenNameIdentifier	 Hashtable
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Iterator	TokenNameIdentifier	 Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Map	TokenNameIdentifier	 Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Stack	TokenNameIdentifier	 Stack
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Vector	TokenNameIdentifier	 Vector
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
zip	TokenNameIdentifier	 zip
.	TokenNameDOT	
CRC32	TokenNameIdentifier	 CR C32
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
BuildException	TokenNameIdentifier	 Build Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
DirectoryScanner	TokenNameIdentifier	 Directory Scanner
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
FileScanner	TokenNameIdentifier	 File Scanner
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
Project	TokenNameIdentifier	 Project
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
ArchiveFileSet	TokenNameIdentifier	 Archive File Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
EnumeratedAttribute	TokenNameIdentifier	 Enumerated Attribute
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
FileSet	TokenNameIdentifier	 File Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
PatternSet	TokenNameIdentifier	 Pattern Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
Resource	TokenNameIdentifier	 Resource
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
ResourceCollection	TokenNameIdentifier	 Resource Collection
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
ZipFileSet	TokenNameIdentifier	 Zip File Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
ZipScanner	TokenNameIdentifier	 Zip Scanner
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
ArchiveResource	TokenNameIdentifier	 Archive Resource
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
FileProvider	TokenNameIdentifier	 File Provider
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
FileResource	TokenNameIdentifier	 File Resource
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
Union	TokenNameIdentifier	 Union
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
ZipResource	TokenNameIdentifier	 Zip Resource
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
selectors	TokenNameIdentifier	 selectors
.	TokenNameDOT	
ResourceSelector	TokenNameIdentifier	 Resource Selector
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
FileNameMapper	TokenNameIdentifier	 File Name Mapper
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
FileUtils	TokenNameIdentifier	 File Utils
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
GlobPatternMapper	TokenNameIdentifier	 Glob Pattern Mapper
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
IdentityMapper	TokenNameIdentifier	 Identity Mapper
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
MergingMapper	TokenNameIdentifier	 Merging Mapper
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ResourceUtils	TokenNameIdentifier	 Resource Utils
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
zip	TokenNameIdentifier	 zip
.	TokenNameDOT	
UnixStat	TokenNameIdentifier	 Unix Stat
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
zip	TokenNameIdentifier	 zip
.	TokenNameDOT	
ZipEntry	TokenNameIdentifier	 Zip Entry
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
zip	TokenNameIdentifier	 zip
.	TokenNameDOT	
ZipExtraField	TokenNameIdentifier	 Zip Extra Field
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
zip	TokenNameIdentifier	 zip
.	TokenNameDOT	
ZipFile	TokenNameIdentifier	 Zip File
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
zip	TokenNameIdentifier	 zip
.	TokenNameDOT	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
;	TokenNameSEMICOLON	
/** * Create a Zip file. * * @since Ant 1.1 * * @ant.task category="packaging" */	TokenNameCOMMENT_JAVADOC	 Create a Zip file. * @since Ant 1.1 * @ant.task category="packaging" 
public	TokenNamepublic	
class	TokenNameclass	
Zip	TokenNameIdentifier	 Zip
extends	TokenNameextends	
MatchingTask	TokenNameIdentifier	 Matching Task
{	TokenNameLBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
BUFFER_SIZE	TokenNameIdentifier	 BUFFER  SIZE
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
1024	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
ROUNDUP_MILLIS	TokenNameIdentifier	 ROUNDUP  MILLIS
=	TokenNameEQUAL	
1999	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// 2 seconds - 1 	TokenNameCOMMENT_LINE	2 seconds - 1 
// CheckStyle:VisibilityModifier OFF - bc 	TokenNameCOMMENT_LINE	CheckStyle:VisibilityModifier OFF - bc 
protected	TokenNameprotected	
File	TokenNameIdentifier	 File
zipFile	TokenNameIdentifier	 zip File
;	TokenNameSEMICOLON	
// use to scan own archive 	TokenNameCOMMENT_LINE	use to scan own archive 
private	TokenNameprivate	
ZipScanner	TokenNameIdentifier	 Zip Scanner
zs	TokenNameIdentifier	 zs
;	TokenNameSEMICOLON	
private	TokenNameprivate	
File	TokenNameIdentifier	 File
baseDir	TokenNameIdentifier	 base Dir
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
Hashtable	TokenNameIdentifier	 Hashtable
entries	TokenNameIdentifier	 entries
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Vector	TokenNameIdentifier	 Vector
groupfilesets	TokenNameIdentifier	 groupfilesets
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Vector	TokenNameIdentifier	 Vector
filesetsFromGroupfilesets	TokenNameIdentifier	 filesets From Groupfilesets
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
String	TokenNameIdentifier	 String
duplicate	TokenNameIdentifier	 duplicate
=	TokenNameEQUAL	
"add"	TokenNameStringLiteral	add
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
doCompress	TokenNameIdentifier	 do Compress
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
doUpdate	TokenNameIdentifier	 do Update
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// shadow of the above if the value is altered in execute 	TokenNameCOMMENT_LINE	shadow of the above if the value is altered in execute 
private	TokenNameprivate	
boolean	TokenNameboolean	
savedDoUpdate	TokenNameIdentifier	 saved Do Update
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
doFilesonly	TokenNameIdentifier	 do Filesonly
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
String	TokenNameIdentifier	 String
archiveType	TokenNameIdentifier	 archive Type
=	TokenNameEQUAL	
"zip"	TokenNameStringLiteral	zip
;	TokenNameSEMICOLON	
// For directories: 	TokenNameCOMMENT_LINE	For directories: 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
long	TokenNamelong	
EMPTY_CRC	TokenNameIdentifier	 EMPTY  CRC
=	TokenNameEQUAL	
new	TokenNamenew	
CRC32	TokenNameIdentifier	 CR C32
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
String	TokenNameIdentifier	 String
emptyBehavior	TokenNameIdentifier	 empty Behavior
=	TokenNameEQUAL	
"skip"	TokenNameStringLiteral	skip
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Vector	TokenNameIdentifier	 Vector
resources	TokenNameIdentifier	 resources
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
Hashtable	TokenNameIdentifier	 Hashtable
addedDirs	TokenNameIdentifier	 added Dirs
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Vector	TokenNameIdentifier	 Vector
addedFiles	TokenNameIdentifier	 added Files
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
ResourceSelector	TokenNameIdentifier	 Resource Selector
MISSING_SELECTOR	TokenNameIdentifier	 MISSING  SELECTOR
=	TokenNameEQUAL	
new	TokenNamenew	
ResourceSelector	TokenNameIdentifier	 Resource Selector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isSelected	TokenNameIdentifier	 is Selected
(	TokenNameLPAREN	
Resource	TokenNameIdentifier	 Resource
target	TokenNameIdentifier	 target
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
!	TokenNameNOT	
target	TokenNameIdentifier	 target
.	TokenNameDOT	
isExists	TokenNameIdentifier	 is Exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
ResourceUtils	TokenNameIdentifier	 Resource Utils
.	TokenNameDOT	
ResourceSelectorProvider	TokenNameIdentifier	 Resource Selector Provider
MISSING_DIR_PROVIDER	TokenNameIdentifier	 MISSING  DIR  PROVIDER
=	TokenNameEQUAL	
new	TokenNamenew	
ResourceUtils	TokenNameIdentifier	 Resource Utils
.	TokenNameDOT	
ResourceSelectorProvider	TokenNameIdentifier	 Resource Selector Provider
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
ResourceSelector	TokenNameIdentifier	 Resource Selector
getTargetSelectorForSource	TokenNameIdentifier	 get Target Selector For Source
(	TokenNameLPAREN	
Resource	TokenNameIdentifier	 Resource
sr	TokenNameIdentifier	 sr
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
MISSING_SELECTOR	TokenNameIdentifier	 MISSING  SELECTOR
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** * If this flag is true, execute() will run most operations twice, * the first time with {@link #skipWriting skipWriting} set to * true and the second time with setting it to false. * * <p>The only situation in Ant's current code base where this is * ever going to be true is if the jar task has been configured * with a filesetmanifest other than "skip".</p> */	TokenNameCOMMENT_JAVADOC	 If this flag is true, execute() will run most operations twice, the first time with {@link #skipWriting skipWriting} set to true and the second time with setting it to false. * <p>The only situation in Ant's current code base where this is ever going to be true is if the jar task has been configured with a filesetmanifest other than "skip".</p> 
protected	TokenNameprotected	
boolean	TokenNameboolean	
doubleFilePass	TokenNameIdentifier	 double File Pass
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** * whether the methods should just perform some sort of dry-run. * * <p>Will only ever be true in the first pass if the task * performs two passes because {@link #doubleFilePass * doubleFilePass} is true.</p> */	TokenNameCOMMENT_JAVADOC	 whether the methods should just perform some sort of dry-run. * <p>Will only ever be true in the first pass if the task performs two passes because {@link #doubleFilePass doubleFilePass} is true.</p> 
protected	TokenNameprotected	
boolean	TokenNameboolean	
skipWriting	TokenNameIdentifier	 skip Writing
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** * Whether this is the first time the archive building methods are invoked. * * @return true if either {@link #doubleFilePass doubleFilePass} * is false or {@link #skipWriting skipWriting} is true. * * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Whether this is the first time the archive building methods are invoked. * @return true if either {@link #doubleFilePass doubleFilePass} is false or {@link #skipWriting skipWriting} is true. * @since Ant 1.8.0 
protected	TokenNameprotected	
final	TokenNamefinal	
boolean	TokenNameboolean	
isFirstPass	TokenNameIdentifier	 is First Pass
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
!	TokenNameNOT	
doubleFilePass	TokenNameIdentifier	 double File Pass
||	TokenNameOR_OR	
skipWriting	TokenNameIdentifier	 skip Writing
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
FileUtils	TokenNameIdentifier	 File Utils
FILE_UTILS	TokenNameIdentifier	 FILE  UTILS
=	TokenNameEQUAL	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
getFileUtils	TokenNameIdentifier	 get File Utils
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// CheckStyle:VisibilityModifier ON 	TokenNameCOMMENT_LINE	CheckStyle:VisibilityModifier ON 
// This boolean is set if the task detects that the 	TokenNameCOMMENT_LINE	This boolean is set if the task detects that the 
// target is outofdate and has written to the target file. 	TokenNameCOMMENT_LINE	target is outofdate and has written to the target file. 
private	TokenNameprivate	
boolean	TokenNameboolean	
updatedFile	TokenNameIdentifier	 updated File
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** * true when we are adding new files into the Zip file, as opposed * to adding back the unchanged files */	TokenNameCOMMENT_JAVADOC	 true when we are adding new files into the Zip file, as opposed to adding back the unchanged files 
private	TokenNameprivate	
boolean	TokenNameboolean	
addingNewFiles	TokenNameIdentifier	 adding New Files
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** * Encoding to use for filenames, defaults to the platform's * default encoding. */	TokenNameCOMMENT_JAVADOC	 Encoding to use for filenames, defaults to the platform's default encoding. 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
;	TokenNameSEMICOLON	
/** * Whether the original compression of entries coming from a ZIP * archive should be kept (for example when updating an archive). * * @since Ant 1.6 */	TokenNameCOMMENT_JAVADOC	 Whether the original compression of entries coming from a ZIP archive should be kept (for example when updating an archive). * @since Ant 1.6 
private	TokenNameprivate	
boolean	TokenNameboolean	
keepCompression	TokenNameIdentifier	 keep Compression
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** * Whether the file modification times will be rounded up to the * next even number of seconds. * * @since Ant 1.6.2 */	TokenNameCOMMENT_JAVADOC	 Whether the file modification times will be rounded up to the next even number of seconds. * @since Ant 1.6.2 
private	TokenNameprivate	
boolean	TokenNameboolean	
roundUp	TokenNameIdentifier	 round Up
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
/** * Comment for the archive. * @since Ant 1.6.3 */	TokenNameCOMMENT_JAVADOC	 Comment for the archive. @since Ant 1.6.3 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
comment	TokenNameIdentifier	 comment
=	TokenNameEQUAL	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
level	TokenNameIdentifier	 level
=	TokenNameEQUAL	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
.	TokenNameDOT	
DEFAULT_COMPRESSION	TokenNameIdentifier	 DEFAULT  COMPRESSION
;	TokenNameSEMICOLON	
/** * Assume 0 Unix mode is intentional. * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Assume 0 Unix mode is intentional. @since Ant 1.8.0 
private	TokenNameprivate	
boolean	TokenNameboolean	
preserve0Permissions	TokenNameIdentifier	 preserve0 Permissions
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** * Whether to set the language encoding flag when creating the archive. * * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Whether to set the language encoding flag when creating the archive. * @since Ant 1.8.0 
private	TokenNameprivate	
boolean	TokenNameboolean	
useLanguageEncodingFlag	TokenNameIdentifier	 use Language Encoding Flag
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
/** * Whether to add unicode extra fields. * * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Whether to add unicode extra fields. * @since Ant 1.8.0 
private	TokenNameprivate	
UnicodeExtraField	TokenNameIdentifier	 Unicode Extra Field
createUnicodeExtraFields	TokenNameIdentifier	 create Unicode Extra Fields
=	TokenNameEQUAL	
UnicodeExtraField	TokenNameIdentifier	 Unicode Extra Field
.	TokenNameDOT	
NEVER	TokenNameIdentifier	 NEVER
;	TokenNameSEMICOLON	
/** * Whether to fall back to UTF-8 if a name cannot be enoded using * the specified encoding. * * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Whether to fall back to UTF-8 if a name cannot be enoded using the specified encoding. * @since Ant 1.8.0 
private	TokenNameprivate	
boolean	TokenNameboolean	
fallBackToUTF8	TokenNameIdentifier	 fall Back To UT F8
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** * This is the name/location of where to * create the .zip file. * @param zipFile the path of the zipFile * @deprecated since 1.5.x. * Use setDestFile(File) instead. * @ant.attribute ignore="true" */	TokenNameCOMMENT_JAVADOC	 This is the name/location of where to create the .zip file. @param zipFile the path of the zipFile @deprecated since 1.5.x. Use setDestFile(File) instead. @ant.attribute ignore="true" 
public	TokenNamepublic	
void	TokenNamevoid	
setZipfile	TokenNameIdentifier	 set Zipfile
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
zipFile	TokenNameIdentifier	 zip File
)	TokenNameRPAREN	
{	TokenNameLBRACE	
setDestFile	TokenNameIdentifier	 set Dest File
(	TokenNameLPAREN	
zipFile	TokenNameIdentifier	 zip File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * This is the name/location of where to * create the file. * @param file the path of the zipFile * @since Ant 1.5 * @deprecated since 1.5.x. * Use setDestFile(File) instead. * @ant.attribute ignore="true" */	TokenNameCOMMENT_JAVADOC	 This is the name/location of where to create the file. @param file the path of the zipFile @since Ant 1.5 @deprecated since 1.5.x. Use setDestFile(File) instead. @ant.attribute ignore="true" 
public	TokenNamepublic	
void	TokenNamevoid	
setFile	TokenNameIdentifier	 set File
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
{	TokenNameLBRACE	
setDestFile	TokenNameIdentifier	 set Dest File
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The file to create; required. * @since Ant 1.5 * @param destFile The new destination File */	TokenNameCOMMENT_JAVADOC	 The file to create; required. @since Ant 1.5 @param destFile The new destination File 
public	TokenNamepublic	
void	TokenNamevoid	
setDestFile	TokenNameIdentifier	 set Dest File
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
destFile	TokenNameIdentifier	 dest File
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
zipFile	TokenNameIdentifier	 zip File
=	TokenNameEQUAL	
destFile	TokenNameIdentifier	 dest File
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The file to create. * @return the destination file * @since Ant 1.5.2 */	TokenNameCOMMENT_JAVADOC	 The file to create. @return the destination file @since Ant 1.5.2 
public	TokenNamepublic	
File	TokenNameIdentifier	 File
getDestFile	TokenNameIdentifier	 get Dest File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
zipFile	TokenNameIdentifier	 zip File
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Directory from which to archive files; optional. * @param baseDir the base directory */	TokenNameCOMMENT_JAVADOC	 Directory from which to archive files; optional. @param baseDir the base directory 
public	TokenNamepublic	
void	TokenNamevoid	
setBasedir	TokenNameIdentifier	 set Basedir
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
baseDir	TokenNameIdentifier	 base Dir
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
baseDir	TokenNameIdentifier	 base Dir
=	TokenNameEQUAL	
baseDir	TokenNameIdentifier	 base Dir
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Whether we want to compress the files or only store them; * optional, default=true; * @param c if true, compress the files */	TokenNameCOMMENT_JAVADOC	 Whether we want to compress the files or only store them; optional, default=true; @param c if true, compress the files 
public	TokenNamepublic	
void	TokenNamevoid	
setCompress	TokenNameIdentifier	 set Compress
(	TokenNameLPAREN	
boolean	TokenNameboolean	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
{	TokenNameLBRACE	
doCompress	TokenNameIdentifier	 do Compress
=	TokenNameEQUAL	
c	TokenNameIdentifier	 c
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Whether we want to compress the files or only store them; * @return true if the files are to be compressed * @since Ant 1.5.2 */	TokenNameCOMMENT_JAVADOC	 Whether we want to compress the files or only store them; @return true if the files are to be compressed @since Ant 1.5.2 
public	TokenNamepublic	
boolean	TokenNameboolean	
isCompress	TokenNameIdentifier	 is Compress
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
doCompress	TokenNameIdentifier	 do Compress
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * If true, emulate Sun's jar utility by not adding parent directories; * optional, defaults to false. * @param f if true, emulate sun's jar by not adding parent directories */	TokenNameCOMMENT_JAVADOC	 If true, emulate Sun's jar utility by not adding parent directories; optional, defaults to false. @param f if true, emulate sun's jar by not adding parent directories 
public	TokenNamepublic	
void	TokenNamevoid	
setFilesonly	TokenNameIdentifier	 set Filesonly
(	TokenNameLPAREN	
boolean	TokenNameboolean	
f	TokenNameIdentifier	 f
)	TokenNameRPAREN	
{	TokenNameLBRACE	
doFilesonly	TokenNameIdentifier	 do Filesonly
=	TokenNameEQUAL	
f	TokenNameIdentifier	 f
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * If true, updates an existing file, otherwise overwrite * any existing one; optional defaults to false. * @param c if true, updates an existing zip file */	TokenNameCOMMENT_JAVADOC	 If true, updates an existing file, otherwise overwrite any existing one; optional defaults to false. @param c if true, updates an existing zip file 
public	TokenNamepublic	
void	TokenNamevoid	
setUpdate	TokenNameIdentifier	 set Update
(	TokenNameLPAREN	
boolean	TokenNameboolean	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
{	TokenNameLBRACE	
doUpdate	TokenNameIdentifier	 do Update
=	TokenNameEQUAL	
c	TokenNameIdentifier	 c
;	TokenNameSEMICOLON	
savedDoUpdate	TokenNameIdentifier	 saved Do Update
=	TokenNameEQUAL	
c	TokenNameIdentifier	 c
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Are we updating an existing archive? * @return true if updating an existing archive */	TokenNameCOMMENT_JAVADOC	 Are we updating an existing archive? @return true if updating an existing archive 
public	TokenNamepublic	
boolean	TokenNameboolean	
isInUpdateMode	TokenNameIdentifier	 is In Update Mode
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
doUpdate	TokenNameIdentifier	 do Update
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Adds a set of files. * @param set the fileset to add */	TokenNameCOMMENT_JAVADOC	 Adds a set of files. @param set the fileset to add 
public	TokenNamepublic	
void	TokenNamevoid	
addFileset	TokenNameIdentifier	 add Fileset
(	TokenNameLPAREN	
FileSet	TokenNameIdentifier	 File Set
set	TokenNameIdentifier	 set
)	TokenNameRPAREN	
{	TokenNameLBRACE	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
set	TokenNameIdentifier	 set
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Adds a set of files that can be * read from an archive and be given a prefix/fullpath. * @param set the zipfileset to add */	TokenNameCOMMENT_JAVADOC	 Adds a set of files that can be read from an archive and be given a prefix/fullpath. @param set the zipfileset to add 
public	TokenNamepublic	
void	TokenNamevoid	
addZipfileset	TokenNameIdentifier	 add Zipfileset
(	TokenNameLPAREN	
ZipFileSet	TokenNameIdentifier	 Zip File Set
set	TokenNameIdentifier	 set
)	TokenNameRPAREN	
{	TokenNameLBRACE	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
set	TokenNameIdentifier	 set
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Add a collection of resources to be archived. * @param a the resources to archive * @since Ant 1.7 */	TokenNameCOMMENT_JAVADOC	 Add a collection of resources to be archived. @param a the resources to archive @since Ant 1.7 
public	TokenNamepublic	
void	TokenNamevoid	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
ResourceCollection	TokenNameIdentifier	 Resource Collection
a	TokenNameIdentifier	 a
)	TokenNameRPAREN	
{	TokenNameLBRACE	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
a	TokenNameIdentifier	 a
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Adds a group of zip files. * @param set the group (a fileset) to add */	TokenNameCOMMENT_JAVADOC	 Adds a group of zip files. @param set the group (a fileset) to add 
public	TokenNamepublic	
void	TokenNamevoid	
addZipGroupFileset	TokenNameIdentifier	 add Zip Group Fileset
(	TokenNameLPAREN	
FileSet	TokenNameIdentifier	 File Set
set	TokenNameIdentifier	 set
)	TokenNameRPAREN	
{	TokenNameLBRACE	
groupfilesets	TokenNameIdentifier	 groupfilesets
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
set	TokenNameIdentifier	 set
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets behavior for when a duplicate file is about to be added - * one of <code>add</code>, <code>preserve</code> or <code>fail</code>. * Possible values are: <code>add</code> (keep both * of the files); <code>preserve</code> (keep the first version * of the file found); <code>fail</code> halt a problem * Default for zip tasks is <code>add</code> * @param df a <code>Duplicate</code> enumerated value */	TokenNameCOMMENT_JAVADOC	 Sets behavior for when a duplicate file is about to be added - one of <code>add</code>, <code>preserve</code> or <code>fail</code>. Possible values are: <code>add</code> (keep both of the files); <code>preserve</code> (keep the first version of the file found); <code>fail</code> halt a problem Default for zip tasks is <code>add</code> @param df a <code>Duplicate</code> enumerated value 
public	TokenNamepublic	
void	TokenNamevoid	
setDuplicate	TokenNameIdentifier	 set Duplicate
(	TokenNameLPAREN	
Duplicate	TokenNameIdentifier	 Duplicate
df	TokenNameIdentifier	 df
)	TokenNameRPAREN	
{	TokenNameLBRACE	
duplicate	TokenNameIdentifier	 duplicate
=	TokenNameEQUAL	
df	TokenNameIdentifier	 df
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Possible behaviors when there are no matching files for the task: * "fail", "skip", or "create". */	TokenNameCOMMENT_JAVADOC	 Possible behaviors when there are no matching files for the task: "fail", "skip", or "create". 
public	TokenNamepublic	
static	TokenNamestatic	
class	TokenNameclass	
WhenEmpty	TokenNameIdentifier	 When Empty
extends	TokenNameextends	
EnumeratedAttribute	TokenNameIdentifier	 Enumerated Attribute
{	TokenNameLBRACE	
/** * The string values for the enumerated value * @return the values */	TokenNameCOMMENT_JAVADOC	 The string values for the enumerated value @return the values 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getValues	TokenNameIdentifier	 get Values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"fail"	TokenNameStringLiteral	fail
,	TokenNameCOMMA	
"skip"	TokenNameStringLiteral	skip
,	TokenNameCOMMA	
"create"	TokenNameStringLiteral	create
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Sets behavior of the task when no files match. * Possible values are: <code>fail</code> (throw an exception * and halt the build); <code>skip</code> (do not create * any archive, but issue a warning); <code>create</code> * (make an archive with no entries). * Default for zip tasks is <code>skip</code>; * for jar tasks, <code>create</code>. * @param we a <code>WhenEmpty</code> enumerated value */	TokenNameCOMMENT_JAVADOC	 Sets behavior of the task when no files match. Possible values are: <code>fail</code> (throw an exception and halt the build); <code>skip</code> (do not create any archive, but issue a warning); <code>create</code> (make an archive with no entries). Default for zip tasks is <code>skip</code>; for jar tasks, <code>create</code>. @param we a <code>WhenEmpty</code> enumerated value 
public	TokenNamepublic	
void	TokenNamevoid	
setWhenempty	TokenNameIdentifier	 set Whenempty
(	TokenNameLPAREN	
WhenEmpty	TokenNameIdentifier	 When Empty
we	TokenNameIdentifier	 we
)	TokenNameRPAREN	
{	TokenNameLBRACE	
emptyBehavior	TokenNameIdentifier	 empty Behavior
=	TokenNameEQUAL	
we	TokenNameIdentifier	 we
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Encoding to use for filenames, defaults to the platform's * default encoding. * * <p>For a list of possible values see <a * href="http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html">http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html</a>.</p> * @param encoding the encoding name */	TokenNameCOMMENT_JAVADOC	 Encoding to use for filenames, defaults to the platform's default encoding. * <p>For a list of possible values see <a href="http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html">http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html</a>.</p> @param encoding the encoding name 
public	TokenNamepublic	
void	TokenNamevoid	
setEncoding	TokenNameIdentifier	 set Encoding
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
encoding	TokenNameIdentifier	 encoding
=	TokenNameEQUAL	
encoding	TokenNameIdentifier	 encoding
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Encoding to use for filenames. * @return the name of the encoding to use * @since Ant 1.5.2 */	TokenNameCOMMENT_JAVADOC	 Encoding to use for filenames. @return the name of the encoding to use @since Ant 1.5.2 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getEncoding	TokenNameIdentifier	 get Encoding
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
encoding	TokenNameIdentifier	 encoding
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Whether the original compression of entries coming from a ZIP * archive should be kept (for example when updating an archive). * Default is false. * @param keep if true, keep the original compression * @since Ant 1.6 */	TokenNameCOMMENT_JAVADOC	 Whether the original compression of entries coming from a ZIP archive should be kept (for example when updating an archive). Default is false. @param keep if true, keep the original compression @since Ant 1.6 
public	TokenNamepublic	
void	TokenNamevoid	
setKeepCompression	TokenNameIdentifier	 set Keep Compression
(	TokenNameLPAREN	
boolean	TokenNameboolean	
keep	TokenNameIdentifier	 keep
)	TokenNameRPAREN	
{	TokenNameLBRACE	
keepCompression	TokenNameIdentifier	 keep Compression
=	TokenNameEQUAL	
keep	TokenNameIdentifier	 keep
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Comment to use for archive. * * @param comment The content of the comment. * @since Ant 1.6.3 */	TokenNameCOMMENT_JAVADOC	 Comment to use for archive. * @param comment The content of the comment. @since Ant 1.6.3 
public	TokenNamepublic	
void	TokenNamevoid	
setComment	TokenNameIdentifier	 set Comment
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
comment	TokenNameIdentifier	 comment
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
comment	TokenNameIdentifier	 comment
=	TokenNameEQUAL	
comment	TokenNameIdentifier	 comment
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Comment of the archive * * @return Comment of the archive. * @since Ant 1.6.3 */	TokenNameCOMMENT_JAVADOC	 Comment of the archive * @return Comment of the archive. @since Ant 1.6.3 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getComment	TokenNameIdentifier	 get Comment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
comment	TokenNameIdentifier	 comment
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set the compression level to use. Default is * ZipOutputStream.DEFAULT_COMPRESSION. * @param level compression level. * @since Ant 1.7 */	TokenNameCOMMENT_JAVADOC	 Set the compression level to use. Default is ZipOutputStream.DEFAULT_COMPRESSION. @param level compression level. @since Ant 1.7 
public	TokenNamepublic	
void	TokenNamevoid	
setLevel	TokenNameIdentifier	 set Level
(	TokenNameLPAREN	
int	TokenNameint	
level	TokenNameIdentifier	 level
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
level	TokenNameIdentifier	 level
=	TokenNameEQUAL	
level	TokenNameIdentifier	 level
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the compression level. * @return compression level. * @since Ant 1.7 */	TokenNameCOMMENT_JAVADOC	 Get the compression level. @return compression level. @since Ant 1.7 
public	TokenNamepublic	
int	TokenNameint	
getLevel	TokenNameIdentifier	 get Level
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
level	TokenNameIdentifier	 level
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Whether the file modification times will be rounded up to the * next even number of seconds. * * <p>Zip archives store file modification times with a * granularity of two seconds, so the times will either be rounded * up or down. If you round down, the archive will always seem * out-of-date when you rerun the task, so the default is to round * up. Rounding up may lead to a different type of problems like * JSPs inside a web archive that seem to be slightly more recent * than precompiled pages, rendering precompilation useless.</p> * @param r a <code>boolean</code> value * @since Ant 1.6.2 */	TokenNameCOMMENT_JAVADOC	 Whether the file modification times will be rounded up to the next even number of seconds. * <p>Zip archives store file modification times with a granularity of two seconds, so the times will either be rounded up or down. If you round down, the archive will always seem out-of-date when you rerun the task, so the default is to round up. Rounding up may lead to a different type of problems like JSPs inside a web archive that seem to be slightly more recent than precompiled pages, rendering precompilation useless.</p> @param r a <code>boolean</code> value @since Ant 1.6.2 
public	TokenNamepublic	
void	TokenNamevoid	
setRoundUp	TokenNameIdentifier	 set Round Up
(	TokenNameLPAREN	
boolean	TokenNameboolean	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
{	TokenNameLBRACE	
roundUp	TokenNameIdentifier	 round Up
=	TokenNameEQUAL	
r	TokenNameIdentifier	 r
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Assume 0 Unix mode is intentional. * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Assume 0 Unix mode is intentional. @since Ant 1.8.0 
public	TokenNamepublic	
void	TokenNamevoid	
setPreserve0Permissions	TokenNameIdentifier	 set Preserve0 Permissions
(	TokenNameLPAREN	
boolean	TokenNameboolean	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
{	TokenNameLBRACE	
preserve0Permissions	TokenNameIdentifier	 preserve0 Permissions
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Assume 0 Unix mode is intentional. * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Assume 0 Unix mode is intentional. @since Ant 1.8.0 
public	TokenNamepublic	
boolean	TokenNameboolean	
getPreserve0Permissions	TokenNameIdentifier	 get Preserve0 Permissions
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
preserve0Permissions	TokenNameIdentifier	 preserve0 Permissions
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Whether to set the language encoding flag. * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Whether to set the language encoding flag. @since Ant 1.8.0 
public	TokenNamepublic	
void	TokenNamevoid	
setUseLanguageEncodingFlag	TokenNameIdentifier	 set Use Language Encoding Flag
(	TokenNameLPAREN	
boolean	TokenNameboolean	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
{	TokenNameLBRACE	
useLanguageEncodingFlag	TokenNameIdentifier	 use Language Encoding Flag
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Whether the language encoding flag will be used. * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Whether the language encoding flag will be used. @since Ant 1.8.0 
public	TokenNamepublic	
boolean	TokenNameboolean	
getUseLanguageEnodingFlag	TokenNameIdentifier	 get Use Language Enoding Flag
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
useLanguageEncodingFlag	TokenNameIdentifier	 use Language Encoding Flag
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Whether Unicode extra fields will be created. * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Whether Unicode extra fields will be created. @since Ant 1.8.0 
public	TokenNamepublic	
void	TokenNamevoid	
setCreateUnicodeExtraFields	TokenNameIdentifier	 set Create Unicode Extra Fields
(	TokenNameLPAREN	
UnicodeExtraField	TokenNameIdentifier	 Unicode Extra Field
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
{	TokenNameLBRACE	
createUnicodeExtraFields	TokenNameIdentifier	 create Unicode Extra Fields
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Whether Unicode extra fields will be created. * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Whether Unicode extra fields will be created. @since Ant 1.8.0 
public	TokenNamepublic	
UnicodeExtraField	TokenNameIdentifier	 Unicode Extra Field
getCreateUnicodeExtraFields	TokenNameIdentifier	 get Create Unicode Extra Fields
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
createUnicodeExtraFields	TokenNameIdentifier	 create Unicode Extra Fields
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Whether to fall back to UTF-8 if a name cannot be enoded using * the specified encoding. * * <p>Defaults to false.</p> * * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Whether to fall back to UTF-8 if a name cannot be enoded using the specified encoding. * <p>Defaults to false.</p> * @since Ant 1.8.0 
public	TokenNamepublic	
void	TokenNamevoid	
setFallBackToUTF8	TokenNameIdentifier	 set Fall Back To UT F8
(	TokenNameLPAREN	
boolean	TokenNameboolean	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fallBackToUTF8	TokenNameIdentifier	 fall Back To UT F8
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Whether to fall back to UTF-8 if a name cannot be enoded using * the specified encoding. * * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Whether to fall back to UTF-8 if a name cannot be enoded using the specified encoding. * @since Ant 1.8.0 
public	TokenNamepublic	
boolean	TokenNameboolean	
getFallBackToUTF8	TokenNameIdentifier	 get Fall Back To UT F8
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fallBackToUTF8	TokenNameIdentifier	 fall Back To UT F8
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * validate and build * @throws BuildException on error */	TokenNameCOMMENT_JAVADOC	 validate and build @throws BuildException on error 
public	TokenNamepublic	
void	TokenNamevoid	
execute	TokenNameIdentifier	 execute
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
BuildException	TokenNameIdentifier	 Build Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
doubleFilePass	TokenNameIdentifier	 double File Pass
)	TokenNameRPAREN	
{	TokenNameLBRACE	
skipWriting	TokenNameIdentifier	 skip Writing
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
executeMain	TokenNameIdentifier	 execute Main
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
skipWriting	TokenNameIdentifier	 skip Writing
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
executeMain	TokenNameIdentifier	 execute Main
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
executeMain	TokenNameIdentifier	 execute Main
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Get the value of the updatedFile attribute. * This should only be called after executeMain has been * called. * @return true if executeMain has written to the zip file. */	TokenNameCOMMENT_JAVADOC	 Get the value of the updatedFile attribute. This should only be called after executeMain has been called. @return true if executeMain has written to the zip file. 
protected	TokenNameprotected	
boolean	TokenNameboolean	
hasUpdatedFile	TokenNameIdentifier	 has Updated File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
updatedFile	TokenNameIdentifier	 updated File
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Build the zip file. * This is called twice if doubleFilePass is true. * @throws BuildException on error */	TokenNameCOMMENT_JAVADOC	 Build the zip file. This is called twice if doubleFilePass is true. @throws BuildException on error 
public	TokenNamepublic	
void	TokenNamevoid	
executeMain	TokenNameIdentifier	 execute Main
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
BuildException	TokenNameIdentifier	 Build Exception
{	TokenNameLBRACE	
checkAttributesAndElements	TokenNameIdentifier	 check Attributes And Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Renamed version of original file, if it exists 	TokenNameCOMMENT_LINE	Renamed version of original file, if it exists 
File	TokenNameIdentifier	 File
renamedFile	TokenNameIdentifier	 renamed File
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
addingNewFiles	TokenNameIdentifier	 adding New Files
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
processDoUpdate	TokenNameIdentifier	 process Do Update
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
processGroupFilesets	TokenNameIdentifier	 process Group Filesets
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// collect filesets to pass them to getResourcesToAdd 	TokenNameCOMMENT_LINE	collect filesets to pass them to getResourcesToAdd 
Vector	TokenNameIdentifier	 Vector
vfss	TokenNameIdentifier	 vfss
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
baseDir	TokenNameIdentifier	 base Dir
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
FileSet	TokenNameIdentifier	 File Set
fs	TokenNameIdentifier	 fs
=	TokenNameEQUAL	
(	TokenNameLPAREN	
FileSet	TokenNameIdentifier	 File Set
)	TokenNameRPAREN	
getImplicitFileSet	TokenNameIdentifier	 get Implicit File Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fs	TokenNameIdentifier	 fs
.	TokenNameDOT	
setDir	TokenNameIdentifier	 set Dir
(	TokenNameLPAREN	
baseDir	TokenNameIdentifier	 base Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
vfss	TokenNameIdentifier	 vfss
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
fs	TokenNameIdentifier	 fs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ResourceCollection	TokenNameIdentifier	 Resource Collection
rc	TokenNameIdentifier	 rc
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ResourceCollection	TokenNameIdentifier	 Resource Collection
)	TokenNameRPAREN	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
vfss	TokenNameIdentifier	 vfss
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
rc	TokenNameIdentifier	 rc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ResourceCollection	TokenNameIdentifier	 Resource Collection
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fss	TokenNameIdentifier	 fss
=	TokenNameEQUAL	
new	TokenNamenew	
ResourceCollection	TokenNameIdentifier	 Resource Collection
[	TokenNameLBRACKET	
vfss	TokenNameIdentifier	 vfss
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
vfss	TokenNameIdentifier	 vfss
.	TokenNameDOT	
copyInto	TokenNameIdentifier	 copy Into
(	TokenNameLPAREN	
fss	TokenNameIdentifier	 fss
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
// can also handle empty archives 	TokenNameCOMMENT_LINE	can also handle empty archives 
ArchiveState	TokenNameIdentifier	 Archive State
state	TokenNameIdentifier	 state
=	TokenNameEQUAL	
getResourcesToAdd	TokenNameIdentifier	 get Resources To Add
(	TokenNameLPAREN	
fss	TokenNameIdentifier	 fss
,	TokenNameCOMMA	
zipFile	TokenNameIdentifier	 zip File
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// quick exit if the target is up to date 	TokenNameCOMMENT_LINE	quick exit if the target is up to date 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
state	TokenNameIdentifier	 state
.	TokenNameDOT	
isOutOfDate	TokenNameIdentifier	 is Out Of Date
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
File	TokenNameIdentifier	 File
parent	TokenNameIdentifier	 parent
=	TokenNameEQUAL	
zipFile	TokenNameIdentifier	 zip File
.	TokenNameDOT	
getParentFile	TokenNameIdentifier	 get Parent File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
parent	TokenNameIdentifier	 parent
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
parent	TokenNameIdentifier	 parent
.	TokenNameDOT	
isDirectory	TokenNameIdentifier	 is Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
parent	TokenNameIdentifier	 parent
.	TokenNameDOT	
mkdirs	TokenNameIdentifier	 mkdirs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Failed to create missing parent"	TokenNameStringLiteral	Failed to create missing parent
+	TokenNamePLUS	
" directory for "	TokenNameStringLiteral	 directory for 
+	TokenNamePLUS	
zipFile	TokenNameIdentifier	 zip File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
updatedFile	TokenNameIdentifier	 updated File
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
zipFile	TokenNameIdentifier	 zip File
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
state	TokenNameIdentifier	 state
.	TokenNameDOT	
isWithoutAnyResources	TokenNameIdentifier	 is Without Any Resources
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
createEmptyZip	TokenNameIdentifier	 create Empty Zip
(	TokenNameLPAREN	
zipFile	TokenNameIdentifier	 zip File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
addThem	TokenNameIdentifier	 add Them
=	TokenNameEQUAL	
state	TokenNameIdentifier	 state
.	TokenNameDOT	
getResourcesToAdd	TokenNameIdentifier	 get Resources To Add
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
doUpdate	TokenNameIdentifier	 do Update
)	TokenNameRPAREN	
{	TokenNameLBRACE	
renamedFile	TokenNameIdentifier	 renamed File
=	TokenNameEQUAL	
renameFile	TokenNameIdentifier	 rename File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
action	TokenNameIdentifier	 action
=	TokenNameEQUAL	
doUpdate	TokenNameIdentifier	 do Update
?	TokenNameQUESTION	
"Updating "	TokenNameStringLiteral	Updating 
:	TokenNameCOLON	
"Building "	TokenNameStringLiteral	Building 
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
skipWriting	TokenNameIdentifier	 skip Writing
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
action	TokenNameIdentifier	 action
+	TokenNamePLUS	
archiveType	TokenNameIdentifier	 archive Type
+	TokenNamePLUS	
": "	TokenNameStringLiteral	: 
+	TokenNamePLUS	
zipFile	TokenNameIdentifier	 zip File
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
zOut	TokenNameIdentifier	 z Out
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
skipWriting	TokenNameIdentifier	 skip Writing
)	TokenNameRPAREN	
{	TokenNameLBRACE	
zOut	TokenNameIdentifier	 z Out
=	TokenNameEQUAL	
new	TokenNamenew	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
(	TokenNameLPAREN	
zipFile	TokenNameIdentifier	 zip File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
zOut	TokenNameIdentifier	 z Out
.	TokenNameDOT	
setEncoding	TokenNameIdentifier	 set Encoding
(	TokenNameLPAREN	
encoding	TokenNameIdentifier	 encoding
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
zOut	TokenNameIdentifier	 z Out
.	TokenNameDOT	
setUseLanguageEncodingFlag	TokenNameIdentifier	 set Use Language Encoding Flag
(	TokenNameLPAREN	
useLanguageEncodingFlag	TokenNameIdentifier	 use Language Encoding Flag
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
zOut	TokenNameIdentifier	 z Out
.	TokenNameDOT	
setCreateUnicodeExtraFields	TokenNameIdentifier	 set Create Unicode Extra Fields
(	TokenNameLPAREN	
createUnicodeExtraFields	TokenNameIdentifier	 create Unicode Extra Fields
.	TokenNameDOT	
getPolicy	TokenNameIdentifier	 get Policy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
zOut	TokenNameIdentifier	 z Out
.	TokenNameDOT	
setFallbackToUTF8	TokenNameIdentifier	 set Fallback To UT F8
(	TokenNameLPAREN	
fallBackToUTF8	TokenNameIdentifier	 fall Back To UT F8
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
zOut	TokenNameIdentifier	 z Out
.	TokenNameDOT	
setMethod	TokenNameIdentifier	 set Method
(	TokenNameLPAREN	
doCompress	TokenNameIdentifier	 do Compress
?	TokenNameQUESTION	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
.	TokenNameDOT	
DEFLATED	TokenNameIdentifier	 DEFLATED
:	TokenNameCOLON	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
.	TokenNameDOT	
STORED	TokenNameIdentifier	 STORED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
zOut	TokenNameIdentifier	 z Out
.	TokenNameDOT	
setLevel	TokenNameIdentifier	 set Level
(	TokenNameLPAREN	
level	TokenNameIdentifier	 level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
initZipOutputStream	TokenNameIdentifier	 init Zip Output Stream
(	TokenNameLPAREN	
zOut	TokenNameIdentifier	 z Out
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Add the explicit resource collections to the archive. 	TokenNameCOMMENT_LINE	Add the explicit resource collections to the archive. 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fss	TokenNameIdentifier	 fss
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
addThem	TokenNameIdentifier	 add Them
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addResources	TokenNameIdentifier	 add Resources
(	TokenNameLPAREN	
fss	TokenNameIdentifier	 fss
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
addThem	TokenNameIdentifier	 add Them
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
zOut	TokenNameIdentifier	 z Out
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
doUpdate	TokenNameIdentifier	 do Update
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addingNewFiles	TokenNameIdentifier	 adding New Files
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
ZipFileSet	TokenNameIdentifier	 Zip File Set
oldFiles	TokenNameIdentifier	 old Files
=	TokenNameEQUAL	
new	TokenNamenew	
ZipFileSet	TokenNameIdentifier	 Zip File Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
oldFiles	TokenNameIdentifier	 old Files
.	TokenNameDOT	
setProject	TokenNameIdentifier	 set Project
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
oldFiles	TokenNameIdentifier	 old Files
.	TokenNameDOT	
setSrc	TokenNameIdentifier	 set Src
(	TokenNameLPAREN	
renamedFile	TokenNameIdentifier	 renamed File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
oldFiles	TokenNameIdentifier	 old Files
.	TokenNameDOT	
setDefaultexcludes	TokenNameIdentifier	 set Defaultexcludes
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
addSize	TokenNameIdentifier	 add Size
=	TokenNameEQUAL	
addedFiles	TokenNameIdentifier	 added Files
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
addSize	TokenNameIdentifier	 add Size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
PatternSet	TokenNameIdentifier	 Pattern Set
.	TokenNameDOT	
NameEntry	TokenNameIdentifier	 Name Entry
ne	TokenNameIdentifier	 ne
=	TokenNameEQUAL	
oldFiles	TokenNameIdentifier	 old Files
.	TokenNameDOT	
createExclude	TokenNameIdentifier	 create Exclude
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ne	TokenNameIdentifier	 ne
.	TokenNameDOT	
setName	TokenNameIdentifier	 set Name
(	TokenNameLPAREN	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
addedFiles	TokenNameIdentifier	 added Files
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
DirectoryScanner	TokenNameIdentifier	 Directory Scanner
ds	TokenNameIdentifier	 ds
=	TokenNameEQUAL	
oldFiles	TokenNameIdentifier	 old Files
.	TokenNameDOT	
getDirectoryScanner	TokenNameIdentifier	 get Directory Scanner
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
ZipScanner	TokenNameIdentifier	 Zip Scanner
)	TokenNameRPAREN	
ds	TokenNameIdentifier	 ds
)	TokenNameRPAREN	
.	TokenNameDOT	
setEncoding	TokenNameIdentifier	 set Encoding
(	TokenNameLPAREN	
encoding	TokenNameIdentifier	 encoding
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
ds	TokenNameIdentifier	 ds
.	TokenNameDOT	
getIncludedFiles	TokenNameIdentifier	 get Included Files
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
new	TokenNamenew	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
f	TokenNameIdentifier	 f
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
f	TokenNameIdentifier	 f
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
ds	TokenNameIdentifier	 ds
.	TokenNameDOT	
getResource	TokenNameIdentifier	 get Resource
(	TokenNameLPAREN	
f	TokenNameIdentifier	 f
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
doFilesonly	TokenNameIdentifier	 do Filesonly
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
d	TokenNameIdentifier	 d
=	TokenNameEQUAL	
ds	TokenNameIdentifier	 ds
.	TokenNameDOT	
getIncludedDirectories	TokenNameIdentifier	 get Included Directories
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
dr	TokenNameIdentifier	 dr
=	TokenNameEQUAL	
new	TokenNamenew	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
d	TokenNameIdentifier	 d
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
d	TokenNameIdentifier	 d
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dr	TokenNameIdentifier	 dr
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
ds	TokenNameIdentifier	 ds
.	TokenNameDOT	
getResource	TokenNameIdentifier	 get Resource
(	TokenNameLPAREN	
d	TokenNameIdentifier	 d
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
tmp	TokenNameIdentifier	 tmp
=	TokenNameEQUAL	
r	TokenNameIdentifier	 r
;	TokenNameSEMICOLON	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
new	TokenNamenew	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
tmp	TokenNameIdentifier	 tmp
.	TokenNameDOT	
length	TokenNameIdentifier	 length
+	TokenNamePLUS	
dr	TokenNameIdentifier	 dr
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
dr	TokenNameIdentifier	 dr
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
dr	TokenNameIdentifier	 dr
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
tmp	TokenNameIdentifier	 tmp
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
dr	TokenNameIdentifier	 dr
.	TokenNameDOT	
length	TokenNameIdentifier	 length
,	TokenNameCOMMA	
tmp	TokenNameIdentifier	 tmp
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
addResources	TokenNameIdentifier	 add Resources
(	TokenNameLPAREN	
oldFiles	TokenNameIdentifier	 old Files
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
zOut	TokenNameIdentifier	 z Out
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
zOut	TokenNameIdentifier	 z Out
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
zOut	TokenNameIdentifier	 z Out
.	TokenNameDOT	
setComment	TokenNameIdentifier	 set Comment
(	TokenNameLPAREN	
comment	TokenNameIdentifier	 comment
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finalizeZipOutputStream	TokenNameIdentifier	 finalize Zip Output Stream
(	TokenNameLPAREN	
zOut	TokenNameIdentifier	 z Out
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// If we've been successful on an update, delete the 	TokenNameCOMMENT_LINE	If we've been successful on an update, delete the 
// temporary file 	TokenNameCOMMENT_LINE	temporary file 
if	TokenNameif	
(	TokenNameLPAREN	
doUpdate	TokenNameIdentifier	 do Update
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
renamedFile	TokenNameIdentifier	 renamed File
.	TokenNameDOT	
delete	TokenNameIdentifier	 delete
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Warning: unable to delete temporary file "	TokenNameStringLiteral	Warning: unable to delete temporary file 
+	TokenNamePLUS	
renamedFile	TokenNameIdentifier	 renamed File
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_WARN	TokenNameIdentifier	 MSG  WARN
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
// Close the output stream. 	TokenNameCOMMENT_LINE	Close the output stream. 
closeZout	TokenNameIdentifier	 close Zout
(	TokenNameLPAREN	
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
success	TokenNameIdentifier	 success
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ioe	TokenNameIdentifier	 ioe
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
msg	TokenNameIdentifier	 msg
=	TokenNameEQUAL	
"Problem creating "	TokenNameStringLiteral	Problem creating 
+	TokenNamePLUS	
archiveType	TokenNameIdentifier	 archive Type
+	TokenNamePLUS	
": "	TokenNameStringLiteral	: 
+	TokenNamePLUS	
ioe	TokenNameIdentifier	 ioe
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// delete a bogus ZIP file (but only if it's not the original one) 	TokenNameCOMMENT_LINE	delete a bogus ZIP file (but only if it's not the original one) 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
!	TokenNameNOT	
doUpdate	TokenNameIdentifier	 do Update
||	TokenNameOR_OR	
renamedFile	TokenNameIdentifier	 renamed File
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
zipFile	TokenNameIdentifier	 zip File
.	TokenNameDOT	
delete	TokenNameIdentifier	 delete
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
msg	TokenNameIdentifier	 msg
+=	TokenNamePLUS_EQUAL	
" (and the archive is probably corrupt but I could not "	TokenNameStringLiteral	 (and the archive is probably corrupt but I could not 
+	TokenNamePLUS	
"delete it)"	TokenNameStringLiteral	delete it)
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
doUpdate	TokenNameIdentifier	 do Update
&&	TokenNameAND_AND	
renamedFile	TokenNameIdentifier	 renamed File
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
FILE_UTILS	TokenNameIdentifier	 FILE  UTILS
.	TokenNameDOT	
rename	TokenNameIdentifier	 rename
(	TokenNameLPAREN	
renamedFile	TokenNameIdentifier	 renamed File
,	TokenNameCOMMA	
zipFile	TokenNameIdentifier	 zip File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
msg	TokenNameIdentifier	 msg
+=	TokenNamePLUS_EQUAL	
" (and I couldn't rename the temporary file "	TokenNameStringLiteral	 (and I couldn't rename the temporary file 
+	TokenNamePLUS	
renamedFile	TokenNameIdentifier	 renamed File
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" back)"	TokenNameStringLiteral	 back)
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
msg	TokenNameIdentifier	 msg
,	TokenNameCOMMA	
ioe	TokenNameIdentifier	 ioe
,	TokenNameCOMMA	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
cleanUp	TokenNameIdentifier	 clean Up
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** rename the zip file. */	TokenNameCOMMENT_JAVADOC	 rename the zip file. 
private	TokenNameprivate	
File	TokenNameIdentifier	 File
renameFile	TokenNameIdentifier	 rename File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
renamedFile	TokenNameIdentifier	 renamed File
=	TokenNameEQUAL	
FILE_UTILS	TokenNameIdentifier	 FILE  UTILS
.	TokenNameDOT	
createTempFile	TokenNameIdentifier	 create Temp File
(	TokenNameLPAREN	
"zip"	TokenNameStringLiteral	zip
,	TokenNameCOMMA	
".tmp"	TokenNameStringLiteral	.tmp
,	TokenNameCOMMA	
zipFile	TokenNameIdentifier	 zip File
.	TokenNameDOT	
getParentFile	TokenNameIdentifier	 get Parent File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
FILE_UTILS	TokenNameIdentifier	 FILE  UTILS
.	TokenNameDOT	
rename	TokenNameIdentifier	 rename
(	TokenNameLPAREN	
zipFile	TokenNameIdentifier	 zip File
,	TokenNameCOMMA	
renamedFile	TokenNameIdentifier	 renamed File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
SecurityException	TokenNameIdentifier	 Security Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Not allowed to rename old file ("	TokenNameStringLiteral	Not allowed to rename old file (
+	TokenNamePLUS	
zipFile	TokenNameIdentifier	 zip File
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
") to temporary file"	TokenNameStringLiteral	) to temporary file
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Unable to rename old file ("	TokenNameStringLiteral	Unable to rename old file (
+	TokenNamePLUS	
zipFile	TokenNameIdentifier	 zip File
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
") to temporary file"	TokenNameStringLiteral	) to temporary file
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
renamedFile	TokenNameIdentifier	 renamed File
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Close zout */	TokenNameCOMMENT_JAVADOC	 Close zout 
private	TokenNameprivate	
void	TokenNamevoid	
closeZout	TokenNameIdentifier	 close Zout
(	TokenNameLPAREN	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
boolean	TokenNameboolean	
success	TokenNameIdentifier	 success
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
zOut	TokenNameIdentifier	 z Out
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
zOut	TokenNameIdentifier	 z Out
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If we're in this finally clause because of an 	TokenNameCOMMENT_LINE	If we're in this finally clause because of an 
// exception, we don't really care if there's an 	TokenNameCOMMENT_LINE	exception, we don't really care if there's an 
// exception when closing the stream. E.g. if it 	TokenNameCOMMENT_LINE	exception when closing the stream. E.g. if it 
// throws "ZIP file must have at least one entry", 	TokenNameCOMMENT_LINE	throws "ZIP file must have at least one entry", 
// because an exception happened before we added 	TokenNameCOMMENT_LINE	because an exception happened before we added 
// any files, then we must swallow this 	TokenNameCOMMENT_LINE	any files, then we must swallow this 
// exception. Otherwise, the error that's reported 	TokenNameCOMMENT_LINE	exception. Otherwise, the error that's reported 
// will be the close() error, which is not the 	TokenNameCOMMENT_LINE	will be the close() error, which is not the 
// real cause of the problem. 	TokenNameCOMMENT_LINE	real cause of the problem. 
if	TokenNameif	
(	TokenNameLPAREN	
success	TokenNameIdentifier	 success
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
ex	TokenNameIdentifier	 ex
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Check the attributes and elements */	TokenNameCOMMENT_JAVADOC	 Check the attributes and elements 
private	TokenNameprivate	
void	TokenNamevoid	
checkAttributesAndElements	TokenNameIdentifier	 check Attributes And Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
baseDir	TokenNameIdentifier	 base Dir
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
groupfilesets	TokenNameIdentifier	 groupfilesets
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
"zip"	TokenNameStringLiteral	zip
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
archiveType	TokenNameIdentifier	 archive Type
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"basedir attribute must be set, "	TokenNameStringLiteral	basedir attribute must be set, 
+	TokenNamePLUS	
"or at least one "	TokenNameStringLiteral	or at least one 
+	TokenNamePLUS	
"resource collection must be given!"	TokenNameStringLiteral	resource collection must be given!
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
zipFile	TokenNameIdentifier	 zip File
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"You must specify the "	TokenNameStringLiteral	You must specify the 
+	TokenNamePLUS	
archiveType	TokenNameIdentifier	 archive Type
+	TokenNamePLUS	
" file to create!"	TokenNameStringLiteral	 file to create!
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
zipFile	TokenNameIdentifier	 zip File
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
zipFile	TokenNameIdentifier	 zip File
.	TokenNameDOT	
isFile	TokenNameIdentifier	 is File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
zipFile	TokenNameIdentifier	 zip File
+	TokenNamePLUS	
" is not a file."	TokenNameStringLiteral	 is not a file.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
zipFile	TokenNameIdentifier	 zip File
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
zipFile	TokenNameIdentifier	 zip File
.	TokenNameDOT	
canWrite	TokenNameIdentifier	 can Write
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
zipFile	TokenNameIdentifier	 zip File
+	TokenNamePLUS	
" is read-only."	TokenNameStringLiteral	 is read-only.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Process doupdate */	TokenNameCOMMENT_JAVADOC	 Process doupdate 
private	TokenNameprivate	
void	TokenNamevoid	
processDoUpdate	TokenNameIdentifier	 process Do Update
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Whether or not an actual update is required - 	TokenNameCOMMENT_LINE	Whether or not an actual update is required - 
// we don't need to update if the original file doesn't exist 	TokenNameCOMMENT_LINE	we don't need to update if the original file doesn't exist 
if	TokenNameif	
(	TokenNameLPAREN	
doUpdate	TokenNameIdentifier	 do Update
&&	TokenNameAND_AND	
!	TokenNameNOT	
zipFile	TokenNameIdentifier	 zip File
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
doUpdate	TokenNameIdentifier	 do Update
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
logWhenWriting	TokenNameIdentifier	 log When Writing
(	TokenNameLPAREN	
"ignoring update attribute as "	TokenNameStringLiteral	ignoring update attribute as 
+	TokenNamePLUS	
archiveType	TokenNameIdentifier	 archive Type
+	TokenNamePLUS	
" doesn't exist."	TokenNameStringLiteral	 doesn't exist.
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_DEBUG	TokenNameIdentifier	 MSG  DEBUG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Process groupfilesets */	TokenNameCOMMENT_JAVADOC	 Process groupfilesets 
private	TokenNameprivate	
void	TokenNamevoid	
processGroupFilesets	TokenNameIdentifier	 process Group Filesets
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Add the files found in groupfileset to fileset 	TokenNameCOMMENT_LINE	Add the files found in groupfileset to fileset 
final	TokenNamefinal	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
groupfilesets	TokenNameIdentifier	 groupfilesets
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logWhenWriting	TokenNameIdentifier	 log When Writing
(	TokenNameLPAREN	
"Processing groupfileset "	TokenNameStringLiteral	Processing groupfileset 
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_VERBOSE	TokenNameIdentifier	 MSG  VERBOSE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
FileSet	TokenNameIdentifier	 File Set
fs	TokenNameIdentifier	 fs
=	TokenNameEQUAL	
(	TokenNameLPAREN	
FileSet	TokenNameIdentifier	 File Set
)	TokenNameRPAREN	
groupfilesets	TokenNameIdentifier	 groupfilesets
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
FileScanner	TokenNameIdentifier	 File Scanner
scanner	TokenNameIdentifier	 scanner
=	TokenNameEQUAL	
fs	TokenNameIdentifier	 fs
.	TokenNameDOT	
getDirectoryScanner	TokenNameIdentifier	 get Directory Scanner
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
files	TokenNameIdentifier	 files
=	TokenNameEQUAL	
scanner	TokenNameIdentifier	 scanner
.	TokenNameDOT	
getIncludedFiles	TokenNameIdentifier	 get Included Files
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
basedir	TokenNameIdentifier	 basedir
=	TokenNameEQUAL	
scanner	TokenNameIdentifier	 scanner
.	TokenNameDOT	
getBasedir	TokenNameIdentifier	 get Basedir
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
files	TokenNameIdentifier	 files
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logWhenWriting	TokenNameIdentifier	 log When Writing
(	TokenNameLPAREN	
"Adding file "	TokenNameStringLiteral	Adding file 
+	TokenNamePLUS	
files	TokenNameIdentifier	 files
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
+	TokenNamePLUS	
" to fileset"	TokenNameStringLiteral	 to fileset
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_VERBOSE	TokenNameIdentifier	 MSG  VERBOSE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ZipFileSet	TokenNameIdentifier	 Zip File Set
zf	TokenNameIdentifier	 zf
=	TokenNameEQUAL	
new	TokenNamenew	
ZipFileSet	TokenNameIdentifier	 Zip File Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
zf	TokenNameIdentifier	 zf
.	TokenNameDOT	
setProject	TokenNameIdentifier	 set Project
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
zf	TokenNameIdentifier	 zf
.	TokenNameDOT	
setSrc	TokenNameIdentifier	 set Src
(	TokenNameLPAREN	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
basedir	TokenNameIdentifier	 basedir
,	TokenNameCOMMA	
files	TokenNameIdentifier	 files
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
zf	TokenNameIdentifier	 zf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
filesetsFromGroupfilesets	TokenNameIdentifier	 filesets From Groupfilesets
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
zf	TokenNameIdentifier	 zf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Indicates if the task is adding new files into the archive as opposed to * copying back unchanged files from the backup copy * @return true if adding new files */	TokenNameCOMMENT_JAVADOC	 Indicates if the task is adding new files into the archive as opposed to copying back unchanged files from the backup copy @return true if adding new files 
protected	TokenNameprotected	
final	TokenNamefinal	
boolean	TokenNameboolean	
isAddingNewFiles	TokenNameIdentifier	 is Adding New Files
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
addingNewFiles	TokenNameIdentifier	 adding New Files
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Add the given resources. * * @param fileset may give additional information like fullpath or * permissions. * @param resources the resources to add * @param zOut the stream to write to * @throws IOException on error * * @since Ant 1.5.2 */	TokenNameCOMMENT_JAVADOC	 Add the given resources. * @param fileset may give additional information like fullpath or permissions. @param resources the resources to add @param zOut the stream to write to @throws IOException on error * @since Ant 1.5.2 
protected	TokenNameprotected	
final	TokenNamefinal	
void	TokenNamevoid	
addResources	TokenNameIdentifier	 add Resources
(	TokenNameLPAREN	
FileSet	TokenNameIdentifier	 File Set
fileset	TokenNameIdentifier	 fileset
,	TokenNameCOMMA	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
resources	TokenNameIdentifier	 resources
,	TokenNameCOMMA	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
zOut	TokenNameIdentifier	 z Out
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
prefix	TokenNameIdentifier	 prefix
=	TokenNameEQUAL	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
fullpath	TokenNameIdentifier	 fullpath
=	TokenNameEQUAL	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
int	TokenNameint	
dirMode	TokenNameIdentifier	 dir Mode
=	TokenNameEQUAL	
ArchiveFileSet	TokenNameIdentifier	 Archive File Set
.	TokenNameDOT	
DEFAULT_DIR_MODE	TokenNameIdentifier	 DEFAULT  DIR  MODE
;	TokenNameSEMICOLON	
int	TokenNameint	
fileMode	TokenNameIdentifier	 file Mode
=	TokenNameEQUAL	
ArchiveFileSet	TokenNameIdentifier	 Archive File Set
.	TokenNameDOT	
DEFAULT_FILE_MODE	TokenNameIdentifier	 DEFAULT  FILE  MODE
;	TokenNameSEMICOLON	
ArchiveFileSet	TokenNameIdentifier	 Archive File Set
zfs	TokenNameIdentifier	 zfs
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fileset	TokenNameIdentifier	 fileset
instanceof	TokenNameinstanceof	
ArchiveFileSet	TokenNameIdentifier	 Archive File Set
)	TokenNameRPAREN	
{	TokenNameLBRACE	
zfs	TokenNameIdentifier	 zfs
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ArchiveFileSet	TokenNameIdentifier	 Archive File Set
)	TokenNameRPAREN	
fileset	TokenNameIdentifier	 fileset
;	TokenNameSEMICOLON	
prefix	TokenNameIdentifier	 prefix
=	TokenNameEQUAL	
zfs	TokenNameIdentifier	 zfs
.	TokenNameDOT	
getPrefix	TokenNameIdentifier	 get Prefix
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fullpath	TokenNameIdentifier	 fullpath
=	TokenNameEQUAL	
zfs	TokenNameIdentifier	 zfs
.	TokenNameDOT	
getFullpath	TokenNameIdentifier	 get Fullpath
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dirMode	TokenNameIdentifier	 dir Mode
=	TokenNameEQUAL	
zfs	TokenNameIdentifier	 zfs
.	TokenNameDOT	
getDirMode	TokenNameIdentifier	 get Dir Mode
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fileMode	TokenNameIdentifier	 file Mode
=	TokenNameEQUAL	
zfs	TokenNameIdentifier	 zfs
.	TokenNameDOT	
getFileMode	TokenNameIdentifier	 get File Mode
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
fullpath	TokenNameIdentifier	 fullpath
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Both prefix and fullpath attributes must"	TokenNameStringLiteral	Both prefix and fullpath attributes must
+	TokenNamePLUS	
" not be set on the same fileset."	TokenNameStringLiteral	 not be set on the same fileset.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
length	TokenNameIdentifier	 length
!=	TokenNameNOT_EQUAL	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
fullpath	TokenNameIdentifier	 fullpath
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"fullpath attribute may only be specified"	TokenNameStringLiteral	fullpath attribute may only be specified
+	TokenNamePLUS	
" for filesets that specify a single"	TokenNameStringLiteral	 for filesets that specify a single
+	TokenNamePLUS	
" file."	TokenNameStringLiteral	 file.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
prefix	TokenNameIdentifier	 prefix
.	TokenNameDOT	
endsWith	TokenNameIdentifier	 ends With
(	TokenNameLPAREN	
"/"	TokenNameStringLiteral	/
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
prefix	TokenNameIdentifier	 prefix
.	TokenNameDOT	
endsWith	TokenNameIdentifier	 ends With
(	TokenNameLPAREN	
"\"	TokenNameStringLiteral	\
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
prefix	TokenNameIdentifier	 prefix
+=	TokenNamePLUS_EQUAL	
"/"	TokenNameStringLiteral	/
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
addParentDirs	TokenNameIdentifier	 add Parent Dirs
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
prefix	TokenNameIdentifier	 prefix
,	TokenNameCOMMA	
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
,	TokenNameCOMMA	
dirMode	TokenNameIdentifier	 dir Mode
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ZipFile	TokenNameIdentifier	 Zip File
zf	TokenNameIdentifier	 zf
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
dealingWithFiles	TokenNameIdentifier	 dealing With Files
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
base	TokenNameIdentifier	 base
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
zfs	TokenNameIdentifier	 zfs
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
zfs	TokenNameIdentifier	 zfs
.	TokenNameDOT	
getSrc	TokenNameIdentifier	 get Src
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dealingWithFiles	TokenNameIdentifier	 dealing With Files
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
base	TokenNameIdentifier	 base
=	TokenNameEQUAL	
fileset	TokenNameIdentifier	 fileset
.	TokenNameDOT	
getDir	TokenNameIdentifier	 get Dir
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
zfs	TokenNameIdentifier	 zfs
instanceof	TokenNameinstanceof	
ZipFileSet	TokenNameIdentifier	 Zip File Set
)	TokenNameRPAREN	
{	TokenNameLBRACE	
zf	TokenNameIdentifier	 zf
=	TokenNameEQUAL	
new	TokenNamenew	
ZipFile	TokenNameIdentifier	 Zip File
(	TokenNameLPAREN	
zfs	TokenNameIdentifier	 zfs
.	TokenNameDOT	
getSrc	TokenNameIdentifier	 get Src
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
encoding	TokenNameIdentifier	 encoding
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fullpath	TokenNameIdentifier	 fullpath
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
fullpath	TokenNameIdentifier	 fullpath
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
resources	TokenNameIdentifier	 resources
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separatorChar	TokenNameIdentifier	 separator Char
,	TokenNameCOMMA	
'/'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
""	TokenNameStringLiteral	 
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
resources	TokenNameIdentifier	 resources
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
isDirectory	TokenNameIdentifier	 is Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
doFilesonly	TokenNameIdentifier	 do Filesonly
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
thisDirMode	TokenNameIdentifier	 this Dir Mode
=	TokenNameEQUAL	
zfs	TokenNameIdentifier	 zfs
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
zfs	TokenNameIdentifier	 zfs
.	TokenNameDOT	
hasDirModeBeenSet	TokenNameIdentifier	 has Dir Mode Been Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
dirMode	TokenNameIdentifier	 dir Mode
:	TokenNameCOLON	
getUnixMode	TokenNameIdentifier	 get Unix Mode
(	TokenNameLPAREN	
resources	TokenNameIdentifier	 resources
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
zf	TokenNameIdentifier	 zf
,	TokenNameCOMMA	
dirMode	TokenNameIdentifier	 dir Mode
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
addDirectoryResource	TokenNameIdentifier	 add Directory Resource
(	TokenNameLPAREN	
resources	TokenNameIdentifier	 resources
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
prefix	TokenNameIdentifier	 prefix
,	TokenNameCOMMA	
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
dirMode	TokenNameIdentifier	 dir Mode
,	TokenNameCOMMA	
thisDirMode	TokenNameIdentifier	 this Dir Mode
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// !isDirectory 	TokenNameCOMMENT_LINE	!isDirectory 
addParentDirs	TokenNameIdentifier	 add Parent Dirs
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
prefix	TokenNameIdentifier	 prefix
,	TokenNameCOMMA	
dirMode	TokenNameIdentifier	 dir Mode
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dealingWithFiles	TokenNameIdentifier	 dealing With Files
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
FILE_UTILS	TokenNameIdentifier	 FILE  UTILS
.	TokenNameDOT	
resolveFile	TokenNameIdentifier	 resolve File
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
resources	TokenNameIdentifier	 resources
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
zipFile	TokenNameIdentifier	 zip File
(	TokenNameLPAREN	
f	TokenNameIdentifier	 f
,	TokenNameCOMMA	
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
prefix	TokenNameIdentifier	 prefix
+	TokenNamePLUS	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
fileMode	TokenNameIdentifier	 file Mode
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
thisFileMode	TokenNameIdentifier	 this File Mode
=	TokenNameEQUAL	
zfs	TokenNameIdentifier	 zfs
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
zfs	TokenNameIdentifier	 zfs
.	TokenNameDOT	
hasFileModeBeenSet	TokenNameIdentifier	 has File Mode Been Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
fileMode	TokenNameIdentifier	 file Mode
:	TokenNameCOLON	
getUnixMode	TokenNameIdentifier	 get Unix Mode
(	TokenNameLPAREN	
resources	TokenNameIdentifier	 resources
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
zf	TokenNameIdentifier	 zf
,	TokenNameCOMMA	
fileMode	TokenNameIdentifier	 file Mode
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
addResource	TokenNameIdentifier	 add Resource
(	TokenNameLPAREN	
resources	TokenNameIdentifier	 resources
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
prefix	TokenNameIdentifier	 prefix
,	TokenNameCOMMA	
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
thisFileMode	TokenNameIdentifier	 this File Mode
,	TokenNameCOMMA	
zf	TokenNameIdentifier	 zf
,	TokenNameCOMMA	
zfs	TokenNameIdentifier	 zfs
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
zfs	TokenNameIdentifier	 zfs
.	TokenNameDOT	
getSrc	TokenNameIdentifier	 get Src
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
zf	TokenNameIdentifier	 zf
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
zf	TokenNameIdentifier	 zf
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Add a directory entry to the archive using a specified * Unix-mode and the default mode for its parent directories (if * necessary). */	TokenNameCOMMENT_JAVADOC	 Add a directory entry to the archive using a specified Unix-mode and the default mode for its parent directories (if necessary). 
private	TokenNameprivate	
void	TokenNamevoid	
addDirectoryResource	TokenNameIdentifier	 add Directory Resource
(	TokenNameLPAREN	
Resource	TokenNameIdentifier	 Resource
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
prefix	TokenNameIdentifier	 prefix
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
int	TokenNameint	
defaultDirMode	TokenNameIdentifier	 default Dir Mode
,	TokenNameCOMMA	
int	TokenNameint	
thisDirMode	TokenNameIdentifier	 this Dir Mode
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
endsWith	TokenNameIdentifier	 ends With
(	TokenNameLPAREN	
"/"	TokenNameStringLiteral	/
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
name	TokenNameIdentifier	 name
+	TokenNamePLUS	
"/"	TokenNameStringLiteral	/
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
nextToLastSlash	TokenNameIdentifier	 next To Last Slash
=	TokenNameEQUAL	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
lastIndexOf	TokenNameIdentifier	 last Index Of
(	TokenNameLPAREN	
"/"	TokenNameStringLiteral	/
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nextToLastSlash	TokenNameIdentifier	 next To Last Slash
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addParentDirs	TokenNameIdentifier	 add Parent Dirs
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
nextToLastSlash	TokenNameIdentifier	 next To Last Slash
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
prefix	TokenNameIdentifier	 prefix
,	TokenNameCOMMA	
defaultDirMode	TokenNameIdentifier	 default Dir Mode
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
zipDir	TokenNameIdentifier	 zip Dir
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
prefix	TokenNameIdentifier	 prefix
+	TokenNamePLUS	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
thisDirMode	TokenNameIdentifier	 this Dir Mode
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
instanceof	TokenNameinstanceof	
ZipResource	TokenNameIdentifier	 Zip Resource
?	TokenNameQUESTION	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
ZipResource	TokenNameIdentifier	 Zip Resource
)	TokenNameRPAREN	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
.	TokenNameDOT	
getExtraFields	TokenNameIdentifier	 get Extra Fields
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Determine a Resource's Unix mode or return the given default * value if not available. */	TokenNameCOMMENT_JAVADOC	 Determine a Resource's Unix mode or return the given default value if not available. 
private	TokenNameprivate	
int	TokenNameint	
getUnixMode	TokenNameIdentifier	 get Unix Mode
(	TokenNameLPAREN	
Resource	TokenNameIdentifier	 Resource
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
ZipFile	TokenNameIdentifier	 Zip File
zf	TokenNameIdentifier	 zf
,	TokenNameCOMMA	
int	TokenNameint	
defaultMode	TokenNameIdentifier	 default Mode
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
int	TokenNameint	
unixMode	TokenNameIdentifier	 unix Mode
=	TokenNameEQUAL	
defaultMode	TokenNameIdentifier	 default Mode
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
zf	TokenNameIdentifier	 zf
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ZipEntry	TokenNameIdentifier	 Zip Entry
ze	TokenNameIdentifier	 ze
=	TokenNameEQUAL	
zf	TokenNameIdentifier	 zf
.	TokenNameDOT	
getEntry	TokenNameIdentifier	 get Entry
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
unixMode	TokenNameIdentifier	 unix Mode
=	TokenNameEQUAL	
ze	TokenNameIdentifier	 ze
.	TokenNameDOT	
getUnixMode	TokenNameIdentifier	 get Unix Mode
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
unixMode	TokenNameIdentifier	 unix Mode
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
unixMode	TokenNameIdentifier	 unix Mode
==	TokenNameEQUAL_EQUAL	
UnixStat	TokenNameIdentifier	 Unix Stat
.	TokenNameDOT	
DIR_FLAG	TokenNameIdentifier	 DIR  FLAG
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
preserve0Permissions	TokenNameIdentifier	 preserve0 Permissions
)	TokenNameRPAREN	
{	TokenNameLBRACE	
unixMode	TokenNameIdentifier	 unix Mode
=	TokenNameEQUAL	
defaultMode	TokenNameIdentifier	 default Mode
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
instanceof	TokenNameinstanceof	
ArchiveResource	TokenNameIdentifier	 Archive Resource
)	TokenNameRPAREN	
{	TokenNameLBRACE	
unixMode	TokenNameIdentifier	 unix Mode
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
ArchiveResource	TokenNameIdentifier	 Archive Resource
)	TokenNameRPAREN	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
.	TokenNameDOT	
getMode	TokenNameIdentifier	 get Mode
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
unixMode	TokenNameIdentifier	 unix Mode
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Add a file entry. */	TokenNameCOMMENT_JAVADOC	 Add a file entry. 
private	TokenNameprivate	
void	TokenNamevoid	
addResource	TokenNameIdentifier	 add Resource
(	TokenNameLPAREN	
Resource	TokenNameIdentifier	 Resource
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
prefix	TokenNameIdentifier	 prefix
,	TokenNameCOMMA	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
int	TokenNameint	
mode	TokenNameIdentifier	 mode
,	TokenNameCOMMA	
ZipFile	TokenNameIdentifier	 Zip File
zf	TokenNameIdentifier	 zf
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
fromArchive	TokenNameIdentifier	 from Archive
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
zf	TokenNameIdentifier	 zf
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ZipEntry	TokenNameIdentifier	 Zip Entry
ze	TokenNameIdentifier	 ze
=	TokenNameEQUAL	
zf	TokenNameIdentifier	 zf
.	TokenNameDOT	
getEntry	TokenNameIdentifier	 get Entry
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ze	TokenNameIdentifier	 ze
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
oldCompress	TokenNameIdentifier	 old Compress
=	TokenNameEQUAL	
doCompress	TokenNameIdentifier	 do Compress
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
keepCompression	TokenNameIdentifier	 keep Compression
)	TokenNameRPAREN	
{	TokenNameLBRACE	
doCompress	TokenNameIdentifier	 do Compress
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ze	TokenNameIdentifier	 ze
.	TokenNameDOT	
getMethod	TokenNameIdentifier	 get Method
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
ZipEntry	TokenNameIdentifier	 Zip Entry
.	TokenNameDOT	
DEFLATED	TokenNameIdentifier	 DEFLATED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
InputStream	TokenNameIdentifier	 Input Stream
is	TokenNameIdentifier	 is
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
is	TokenNameIdentifier	 is
=	TokenNameEQUAL	
zf	TokenNameIdentifier	 zf
.	TokenNameDOT	
getInputStream	TokenNameIdentifier	 get Input Stream
(	TokenNameLPAREN	
ze	TokenNameIdentifier	 ze
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
zipFile	TokenNameIdentifier	 zip File
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
,	TokenNameCOMMA	
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
prefix	TokenNameIdentifier	 prefix
+	TokenNamePLUS	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
ze	TokenNameIdentifier	 ze
.	TokenNameDOT	
getTime	TokenNameIdentifier	 get Time
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fromArchive	TokenNameIdentifier	 from Archive
,	TokenNameCOMMA	
mode	TokenNameIdentifier	 mode
,	TokenNameCOMMA	
ze	TokenNameIdentifier	 ze
.	TokenNameDOT	
getExtraFields	TokenNameIdentifier	 get Extra Fields
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
doCompress	TokenNameIdentifier	 do Compress
=	TokenNameEQUAL	
oldCompress	TokenNameIdentifier	 old Compress
;	TokenNameSEMICOLON	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
InputStream	TokenNameIdentifier	 Input Stream
is	TokenNameIdentifier	 is
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
is	TokenNameIdentifier	 is
=	TokenNameEQUAL	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
getInputStream	TokenNameIdentifier	 get Input Stream
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
zipFile	TokenNameIdentifier	 zip File
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
,	TokenNameCOMMA	
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
prefix	TokenNameIdentifier	 prefix
+	TokenNamePLUS	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
getLastModified	TokenNameIdentifier	 get Last Modified
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fromArchive	TokenNameIdentifier	 from Archive
,	TokenNameCOMMA	
mode	TokenNameIdentifier	 mode
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
instanceof	TokenNameinstanceof	
ZipResource	TokenNameIdentifier	 Zip Resource
?	TokenNameQUESTION	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
ZipResource	TokenNameIdentifier	 Zip Resource
)	TokenNameRPAREN	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
.	TokenNameDOT	
getExtraFields	TokenNameIdentifier	 get Extra Fields
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Add the given resources. * * @param rc may give additional information like fullpath or * permissions. * @param resources the resources to add * @param zOut the stream to write to * @throws IOException on error * * @since Ant 1.7 */	TokenNameCOMMENT_JAVADOC	 Add the given resources. * @param rc may give additional information like fullpath or permissions. @param resources the resources to add @param zOut the stream to write to @throws IOException on error * @since Ant 1.7 
protected	TokenNameprotected	
final	TokenNamefinal	
void	TokenNamevoid	
addResources	TokenNameIdentifier	 add Resources
(	TokenNameLPAREN	
ResourceCollection	TokenNameIdentifier	 Resource Collection
rc	TokenNameIdentifier	 rc
,	TokenNameCOMMA	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
resources	TokenNameIdentifier	 resources
,	TokenNameCOMMA	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
zOut	TokenNameIdentifier	 z Out
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
rc	TokenNameIdentifier	 rc
instanceof	TokenNameinstanceof	
FileSet	TokenNameIdentifier	 File Set
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addResources	TokenNameIdentifier	 add Resources
(	TokenNameLPAREN	
(	TokenNameLPAREN	
FileSet	TokenNameIdentifier	 File Set
)	TokenNameRPAREN	
rc	TokenNameIdentifier	 rc
,	TokenNameCOMMA	
resources	TokenNameIdentifier	 resources
,	TokenNameCOMMA	
zOut	TokenNameIdentifier	 z Out
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
resources	TokenNameIdentifier	 resources
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separatorChar	TokenNameIdentifier	 separator Char
,	TokenNameCOMMA	
'/'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
""	TokenNameStringLiteral	 
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
resources	TokenNameIdentifier	 resources
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
isDirectory	TokenNameIdentifier	 is Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
doFilesonly	TokenNameIdentifier	 do Filesonly
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
File	TokenNameIdentifier	 File
base	TokenNameIdentifier	 base
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
FileProvider	TokenNameIdentifier	 File Provider
fp	TokenNameIdentifier	 fp
=	TokenNameEQUAL	
(	TokenNameLPAREN	
FileProvider	TokenNameIdentifier	 File Provider
)	TokenNameRPAREN	
resources	TokenNameIdentifier	 resources
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
as	TokenNameIdentifier	 as
(	TokenNameLPAREN	
FileProvider	TokenNameIdentifier	 File Provider
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fp	TokenNameIdentifier	 fp
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
base	TokenNameIdentifier	 base
=	TokenNameEQUAL	
ResourceUtils	TokenNameIdentifier	 Resource Utils
.	TokenNameDOT	
asFileResource	TokenNameIdentifier	 as File Resource
(	TokenNameLPAREN	
fp	TokenNameIdentifier	 fp
)	TokenNameRPAREN	
.	TokenNameDOT	
getBaseDir	TokenNameIdentifier	 get Base Dir
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
resources	TokenNameIdentifier	 resources
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
isDirectory	TokenNameIdentifier	 is Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addDirectoryResource	TokenNameIdentifier	 add Directory Resource
(	TokenNameLPAREN	
resources	TokenNameIdentifier	 resources
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
,	TokenNameCOMMA	
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
ArchiveFileSet	TokenNameIdentifier	 Archive File Set
.	TokenNameDOT	
DEFAULT_DIR_MODE	TokenNameIdentifier	 DEFAULT  DIR  MODE
,	TokenNameCOMMA	
ArchiveFileSet	TokenNameIdentifier	 Archive File Set
.	TokenNameDOT	
DEFAULT_DIR_MODE	TokenNameIdentifier	 DEFAULT  DIR  MODE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
addParentDirs	TokenNameIdentifier	 add Parent Dirs
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
,	TokenNameCOMMA	
ArchiveFileSet	TokenNameIdentifier	 Archive File Set
.	TokenNameDOT	
DEFAULT_DIR_MODE	TokenNameIdentifier	 DEFAULT  DIR  MODE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fp	TokenNameIdentifier	 fp
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
(	TokenNameLPAREN	
fp	TokenNameIdentifier	 fp
)	TokenNameRPAREN	
.	TokenNameDOT	
getFile	TokenNameIdentifier	 get File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
zipFile	TokenNameIdentifier	 zip File
(	TokenNameLPAREN	
f	TokenNameIdentifier	 f
,	TokenNameCOMMA	
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
ArchiveFileSet	TokenNameIdentifier	 Archive File Set
.	TokenNameDOT	
DEFAULT_FILE_MODE	TokenNameIdentifier	 DEFAULT  FILE  MODE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
addResource	TokenNameIdentifier	 add Resource
(	TokenNameLPAREN	
resources	TokenNameIdentifier	 resources
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
,	TokenNameCOMMA	
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
ArchiveFileSet	TokenNameIdentifier	 Archive File Set
.	TokenNameDOT	
DEFAULT_FILE_MODE	TokenNameIdentifier	 DEFAULT  FILE  MODE
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * method for subclasses to override * @param zOut the zip output stream * @throws IOException on output error * @throws BuildException on other errors */	TokenNameCOMMENT_JAVADOC	 method for subclasses to override @param zOut the zip output stream @throws IOException on output error @throws BuildException on other errors 
protected	TokenNameprotected	
void	TokenNamevoid	
initZipOutputStream	TokenNameIdentifier	 init Zip Output Stream
(	TokenNameLPAREN	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
zOut	TokenNameIdentifier	 z Out
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
BuildException	TokenNameIdentifier	 Build Exception
{	TokenNameLBRACE	
}	TokenNameRBRACE	
/** * method for subclasses to override * @param zOut the zip output stream * @throws IOException on output error * @throws BuildException on other errors */	TokenNameCOMMENT_JAVADOC	 method for subclasses to override @param zOut the zip output stream @throws IOException on output error @throws BuildException on other errors 
protected	TokenNameprotected	
void	TokenNamevoid	
finalizeZipOutputStream	TokenNameIdentifier	 finalize Zip Output Stream
(	TokenNameLPAREN	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
zOut	TokenNameIdentifier	 z Out
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
BuildException	TokenNameIdentifier	 Build Exception
{	TokenNameLBRACE	
}	TokenNameRBRACE	
/** * Create an empty zip file * @param zipFile the zip file * @return true for historic reasons * @throws BuildException on error */	TokenNameCOMMENT_JAVADOC	 Create an empty zip file @param zipFile the zip file @return true for historic reasons @throws BuildException on error 
protected	TokenNameprotected	
boolean	TokenNameboolean	
createEmptyZip	TokenNameIdentifier	 create Empty Zip
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
zipFile	TokenNameIdentifier	 zip File
)	TokenNameRPAREN	
throws	TokenNamethrows	
BuildException	TokenNameIdentifier	 Build Exception
{	TokenNameLBRACE	
// In this case using java.util.zip will not work 	TokenNameCOMMENT_LINE	In this case using java.util.zip will not work 
// because it does not permit a zero-entry archive. 	TokenNameCOMMENT_LINE	because it does not permit a zero-entry archive. 
// Must create it manually. 	TokenNameCOMMENT_LINE	Must create it manually. 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
skipWriting	TokenNameIdentifier	 skip Writing
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Note: creating empty "	TokenNameStringLiteral	Note: creating empty 
+	TokenNamePLUS	
archiveType	TokenNameIdentifier	 archive Type
+	TokenNamePLUS	
" archive "	TokenNameStringLiteral	 archive 
+	TokenNamePLUS	
zipFile	TokenNameIdentifier	 zip File
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_INFO	TokenNameIdentifier	 MSG  INFO
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
OutputStream	TokenNameIdentifier	 Output Stream
os	TokenNameIdentifier	 os
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
os	TokenNameIdentifier	 os
=	TokenNameEQUAL	
new	TokenNamenew	
FileOutputStream	TokenNameIdentifier	 File Output Stream
(	TokenNameLPAREN	
zipFile	TokenNameIdentifier	 zip File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// CheckStyle:MagicNumber OFF 	TokenNameCOMMENT_LINE	CheckStyle:MagicNumber OFF 
// Cf. PKZIP specification. 	TokenNameCOMMENT_LINE	Cf. PKZIP specification. 
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
empty	TokenNameIdentifier	 empty
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
22	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
empty	TokenNameIdentifier	 empty
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
80	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// P 	TokenNameCOMMENT_LINE	P 
empty	TokenNameIdentifier	 empty
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
75	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// K 	TokenNameCOMMENT_LINE	K 
empty	TokenNameIdentifier	 empty
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
5	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
empty	TokenNameIdentifier	 empty
[	TokenNameLBRACKET	
3	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// remainder zeros 	TokenNameCOMMENT_LINE	remainder zeros 
// CheckStyle:MagicNumber ON 	TokenNameCOMMENT_LINE	CheckStyle:MagicNumber ON 
os	TokenNameIdentifier	 os
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
empty	TokenNameIdentifier	 empty
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ioe	TokenNameIdentifier	 ioe
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Could not create empty ZIP archive "	TokenNameStringLiteral	Could not create empty ZIP archive 
+	TokenNamePLUS	
"("	TokenNameStringLiteral	(
+	TokenNamePLUS	
ioe	TokenNameIdentifier	 ioe
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
")"	TokenNameStringLiteral	)
,	TokenNameCOMMA	
ioe	TokenNameIdentifier	 ioe
,	TokenNameCOMMA	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
os	TokenNameIdentifier	 os
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @since Ant 1.5.2 */	TokenNameCOMMENT_JAVADOC	 @since Ant 1.5.2 
private	TokenNameprivate	
synchronized	TokenNamesynchronized	
ZipScanner	TokenNameIdentifier	 Zip Scanner
getZipScanner	TokenNameIdentifier	 get Zip Scanner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
zs	TokenNameIdentifier	 zs
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
zs	TokenNameIdentifier	 zs
=	TokenNameEQUAL	
new	TokenNamenew	
ZipScanner	TokenNameIdentifier	 Zip Scanner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
zs	TokenNameIdentifier	 zs
.	TokenNameDOT	
setEncoding	TokenNameIdentifier	 set Encoding
(	TokenNameLPAREN	
encoding	TokenNameIdentifier	 encoding
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
zs	TokenNameIdentifier	 zs
.	TokenNameDOT	
setSrc	TokenNameIdentifier	 set Src
(	TokenNameLPAREN	
zipFile	TokenNameIdentifier	 zip File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
zs	TokenNameIdentifier	 zs
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Collect the resources that are newer than the corresponding * entries (or missing) in the original archive. * * <p>If we are going to recreate the archive instead of updating * it, all resources should be considered as new, if a single one * is. Because of this, subclasses overriding this method must * call <code>super.getResourcesToAdd</code> and indicate with the * third arg if they already know that the archive is * out-of-date.</p> * * <p>This method first delegates to getNonFileSetResourceToAdd * and then invokes the FileSet-arg version. All this to keep * backwards compatibility for subclasses that don't know how to * deal with non-FileSet ResourceCollections.</p> * * @param rcs The resource collections to grab resources from * @param zipFile intended archive file (may or may not exist) * @param needsUpdate whether we already know that the archive is * out-of-date. Subclasses overriding this method are supposed to * set this value correctly in their call to * <code>super.getResourcesToAdd</code>. * @return an array of resources to add for each fileset passed in as well * as a flag that indicates whether the archive is uptodate. * * @exception BuildException if it likes * @since Ant 1.7 */	TokenNameCOMMENT_JAVADOC	 Collect the resources that are newer than the corresponding entries (or missing) in the original archive. * <p>If we are going to recreate the archive instead of updating it, all resources should be considered as new, if a single one is. Because of this, subclasses overriding this method must call <code>super.getResourcesToAdd</code> and indicate with the third arg if they already know that the archive is out-of-date.</p> * <p>This method first delegates to getNonFileSetResourceToAdd and then invokes the FileSet-arg version. All this to keep backwards compatibility for subclasses that don't know how to deal with non-FileSet ResourceCollections.</p> * @param rcs The resource collections to grab resources from @param zipFile intended archive file (may or may not exist) @param needsUpdate whether we already know that the archive is out-of-date. Subclasses overriding this method are supposed to set this value correctly in their call to <code>super.getResourcesToAdd</code>. @return an array of resources to add for each fileset passed in as well as a flag that indicates whether the archive is uptodate. * @exception BuildException if it likes @since Ant 1.7 
protected	TokenNameprotected	
ArchiveState	TokenNameIdentifier	 Archive State
getResourcesToAdd	TokenNameIdentifier	 get Resources To Add
(	TokenNameLPAREN	
ResourceCollection	TokenNameIdentifier	 Resource Collection
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
rcs	TokenNameIdentifier	 rcs
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
zipFile	TokenNameIdentifier	 zip File
,	TokenNameCOMMA	
boolean	TokenNameboolean	
needsUpdate	TokenNameIdentifier	 needs Update
)	TokenNameRPAREN	
throws	TokenNamethrows	
BuildException	TokenNameIdentifier	 Build Exception
{	TokenNameLBRACE	
ArrayList	TokenNameIdentifier	 Array List
filesets	TokenNameIdentifier	 filesets
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ArrayList	TokenNameIdentifier	 Array List
rest	TokenNameIdentifier	 rest
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
rcs	TokenNameIdentifier	 rcs
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
rcs	TokenNameIdentifier	 rcs
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
instanceof	TokenNameinstanceof	
FileSet	TokenNameIdentifier	 File Set
)	TokenNameRPAREN	
{	TokenNameLBRACE	
filesets	TokenNameIdentifier	 filesets
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
rcs	TokenNameIdentifier	 rcs
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
rest	TokenNameIdentifier	 rest
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
rcs	TokenNameIdentifier	 rcs
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
ResourceCollection	TokenNameIdentifier	 Resource Collection
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
rc	TokenNameIdentifier	 rc
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ResourceCollection	TokenNameIdentifier	 Resource Collection
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
rest	TokenNameIdentifier	 rest
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
new	TokenNamenew	
ResourceCollection	TokenNameIdentifier	 Resource Collection
[	TokenNameLBRACKET	
rest	TokenNameIdentifier	 rest
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ArchiveState	TokenNameIdentifier	 Archive State
as	TokenNameIdentifier	 as
=	TokenNameEQUAL	
getNonFileSetResourcesToAdd	TokenNameIdentifier	 get Non File Set Resources To Add
(	TokenNameLPAREN	
rc	TokenNameIdentifier	 rc
,	TokenNameCOMMA	
zipFile	TokenNameIdentifier	 zip File
,	TokenNameCOMMA	
needsUpdate	TokenNameIdentifier	 needs Update
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
FileSet	TokenNameIdentifier	 File Set
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fs	TokenNameIdentifier	 fs
=	TokenNameEQUAL	
(	TokenNameLPAREN	
FileSet	TokenNameIdentifier	 File Set
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
filesets	TokenNameIdentifier	 filesets
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
new	TokenNamenew	
FileSet	TokenNameIdentifier	 File Set
[	TokenNameLBRACKET	
filesets	TokenNameIdentifier	 filesets
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ArchiveState	TokenNameIdentifier	 Archive State
as2	TokenNameIdentifier	 as2
=	TokenNameEQUAL	
getResourcesToAdd	TokenNameIdentifier	 get Resources To Add
(	TokenNameLPAREN	
fs	TokenNameIdentifier	 fs
,	TokenNameCOMMA	
zipFile	TokenNameIdentifier	 zip File
,	TokenNameCOMMA	
as	TokenNameIdentifier	 as
.	TokenNameDOT	
isOutOfDate	TokenNameIdentifier	 is Out Of Date
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
as	TokenNameIdentifier	 as
.	TokenNameDOT	
isOutOfDate	TokenNameIdentifier	 is Out Of Date
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
as2	TokenNameIdentifier	 as2
.	TokenNameDOT	
isOutOfDate	TokenNameIdentifier	 is Out Of Date
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
/* * Bad luck. * * There are resources in the filesets that make the * archive out of date, but not in the non-fileset * resources. We need to rescan the non-FileSets to grab * all of them now. */	TokenNameCOMMENT_BLOCK	 Bad luck. * There are resources in the filesets that make the archive out of date, but not in the non-fileset resources. We need to rescan the non-FileSets to grab all of them now. 
as	TokenNameIdentifier	 as
=	TokenNameEQUAL	
getNonFileSetResourcesToAdd	TokenNameIdentifier	 get Non File Set Resources To Add
(	TokenNameLPAREN	
rc	TokenNameIdentifier	 rc
,	TokenNameCOMMA	
zipFile	TokenNameIdentifier	 zip File
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
toAdd	TokenNameIdentifier	 to Add
=	TokenNameEQUAL	
new	TokenNamenew	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
rcs	TokenNameIdentifier	 rcs
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
fsIndex	TokenNameIdentifier	 fs Index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
restIndex	TokenNameIdentifier	 rest Index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
rcs	TokenNameIdentifier	 rcs
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
rcs	TokenNameIdentifier	 rcs
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
instanceof	TokenNameinstanceof	
FileSet	TokenNameIdentifier	 File Set
)	TokenNameRPAREN	
{	TokenNameLBRACE	
toAdd	TokenNameIdentifier	 to Add
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
as2	TokenNameIdentifier	 as2
.	TokenNameDOT	
getResourcesToAdd	TokenNameIdentifier	 get Resources To Add
(	TokenNameLPAREN	
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
fsIndex	TokenNameIdentifier	 fs Index
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
toAdd	TokenNameIdentifier	 to Add
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
as	TokenNameIdentifier	 as
.	TokenNameDOT	
getResourcesToAdd	TokenNameIdentifier	 get Resources To Add
(	TokenNameLPAREN	
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
restIndex	TokenNameIdentifier	 rest Index
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
new	TokenNamenew	
ArchiveState	TokenNameIdentifier	 Archive State
(	TokenNameLPAREN	
as2	TokenNameIdentifier	 as2
.	TokenNameDOT	
isOutOfDate	TokenNameIdentifier	 is Out Of Date
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
toAdd	TokenNameIdentifier	 to Add
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* * This is yet another hacky construct to extend the FileSet[] * getResourcesToAdd method so we can pass the information whether * non-fileset resources have been available to it without having * to move the withEmpty behavior checks (since either would break * subclasses in several ways). */	TokenNameCOMMENT_BLOCK	 This is yet another hacky construct to extend the FileSet[] getResourcesToAdd method so we can pass the information whether non-fileset resources have been available to it without having to move the withEmpty behavior checks (since either would break subclasses in several ways). 
private	TokenNameprivate	
static	TokenNamestatic	
ThreadLocal	TokenNameIdentifier	 Thread Local
haveNonFileSetResourcesToAdd	TokenNameIdentifier	 have Non File Set Resources To Add
=	TokenNameEQUAL	
new	TokenNamenew	
ThreadLocal	TokenNameIdentifier	 Thread Local
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
protected	TokenNameprotected	
Object	TokenNameIdentifier	 Object
initialValue	TokenNameIdentifier	 initial Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
FALSE	TokenNameIdentifier	 FALSE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** * Collect the resources that are newer than the corresponding * entries (or missing) in the original archive. * * <p>If we are going to recreate the archive instead of updating * it, all resources should be considered as new, if a single one * is. Because of this, subclasses overriding this method must * call <code>super.getResourcesToAdd</code> and indicate with the * third arg if they already know that the archive is * out-of-date.</p> * * @param filesets The filesets to grab resources from * @param zipFile intended archive file (may or may not exist) * @param needsUpdate whether we already know that the archive is * out-of-date. Subclasses overriding this method are supposed to * set this value correctly in their call to * <code>super.getResourcesToAdd</code>. * @return an array of resources to add for each fileset passed in as well * as a flag that indicates whether the archive is uptodate. * * @exception BuildException if it likes */	TokenNameCOMMENT_JAVADOC	 Collect the resources that are newer than the corresponding entries (or missing) in the original archive. * <p>If we are going to recreate the archive instead of updating it, all resources should be considered as new, if a single one is. Because of this, subclasses overriding this method must call <code>super.getResourcesToAdd</code> and indicate with the third arg if they already know that the archive is out-of-date.</p> * @param filesets The filesets to grab resources from @param zipFile intended archive file (may or may not exist) @param needsUpdate whether we already know that the archive is out-of-date. Subclasses overriding this method are supposed to set this value correctly in their call to <code>super.getResourcesToAdd</code>. @return an array of resources to add for each fileset passed in as well as a flag that indicates whether the archive is uptodate. * @exception BuildException if it likes 
protected	TokenNameprotected	
ArchiveState	TokenNameIdentifier	 Archive State
getResourcesToAdd	TokenNameIdentifier	 get Resources To Add
(	TokenNameLPAREN	
FileSet	TokenNameIdentifier	 File Set
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
filesets	TokenNameIdentifier	 filesets
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
zipFile	TokenNameIdentifier	 zip File
,	TokenNameCOMMA	
boolean	TokenNameboolean	
needsUpdate	TokenNameIdentifier	 needs Update
)	TokenNameRPAREN	
throws	TokenNamethrows	
BuildException	TokenNameIdentifier	 Build Exception
{	TokenNameLBRACE	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
initialResources	TokenNameIdentifier	 initial Resources
=	TokenNameEQUAL	
grabResources	TokenNameIdentifier	 grab Resources
(	TokenNameLPAREN	
filesets	TokenNameIdentifier	 filesets
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
initialResources	TokenNameIdentifier	 initial Resources
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
FALSE	TokenNameIdentifier	 FALSE
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
haveNonFileSetResourcesToAdd	TokenNameIdentifier	 have Non File Set Resources To Add
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
needsUpdate	TokenNameIdentifier	 needs Update
&&	TokenNameAND_AND	
doUpdate	TokenNameIdentifier	 do Update
)	TokenNameRPAREN	
{	TokenNameLBRACE	
/* * This is a rather hairy case. * * One of our subclasses knows that we need to * update the archive, but at the same time, there * are no resources known to us that would need to * be added. Only the subclass seems to know * what's going on. * * This happens if <jar> detects that the manifest * has changed, for example. The manifest is not * part of any resources because of our support * for inline <manifest>s. * * If we invoke createEmptyZip like Ant 1.5.2 did, * we'll loose all stuff that has been in the * original archive (bugzilla report 17780). */	TokenNameCOMMENT_BLOCK	 This is a rather hairy case. * One of our subclasses knows that we need to update the archive, but at the same time, there are no resources known to us that would need to be added. Only the subclass seems to know what's going on. * This happens if <jar> detects that the manifest has changed, for example. The manifest is not part of any resources because of our support for inline <manifest>s. * If we invoke createEmptyZip like Ant 1.5.2 did, we'll loose all stuff that has been in the original archive (bugzilla report 17780). 
return	TokenNamereturn	
new	TokenNamenew	
ArchiveState	TokenNameIdentifier	 Archive State
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
initialResources	TokenNameIdentifier	 initial Resources
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
emptyBehavior	TokenNameIdentifier	 empty Behavior
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"skip"	TokenNameStringLiteral	skip
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
doUpdate	TokenNameIdentifier	 do Update
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logWhenWriting	TokenNameIdentifier	 log When Writing
(	TokenNameLPAREN	
archiveType	TokenNameIdentifier	 archive Type
+	TokenNamePLUS	
" archive "	TokenNameStringLiteral	 archive 
+	TokenNamePLUS	
zipFile	TokenNameIdentifier	 zip File
+	TokenNamePLUS	
" not updated because no new files were"	TokenNameStringLiteral	 not updated because no new files were
+	TokenNamePLUS	
" included."	TokenNameStringLiteral	 included.
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_VERBOSE	TokenNameIdentifier	 MSG  VERBOSE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
logWhenWriting	TokenNameIdentifier	 log When Writing
(	TokenNameLPAREN	
"Warning: skipping "	TokenNameStringLiteral	Warning: skipping 
+	TokenNamePLUS	
archiveType	TokenNameIdentifier	 archive Type
+	TokenNamePLUS	
" archive "	TokenNameStringLiteral	 archive 
+	TokenNamePLUS	
zipFile	TokenNameIdentifier	 zip File
+	TokenNamePLUS	
" because no files were included."	TokenNameStringLiteral	 because no files were included.
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_WARN	TokenNameIdentifier	 MSG  WARN
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
emptyBehavior	TokenNameIdentifier	 empty Behavior
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"fail"	TokenNameStringLiteral	fail
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Cannot create "	TokenNameStringLiteral	Cannot create 
+	TokenNamePLUS	
archiveType	TokenNameIdentifier	 archive Type
+	TokenNamePLUS	
" archive "	TokenNameStringLiteral	 archive 
+	TokenNamePLUS	
zipFile	TokenNameIdentifier	 zip File
+	TokenNamePLUS	
": no files were included."	TokenNameStringLiteral	: no files were included.
,	TokenNameCOMMA	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Create. 	TokenNameCOMMENT_LINE	Create. 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
zipFile	TokenNameIdentifier	 zip File
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
needsUpdate	TokenNameIdentifier	 needs Update
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// either there are non-fileset resources or we 	TokenNameCOMMENT_LINE	either there are non-fileset resources or we 
// (re-)create the archive anyway 	TokenNameCOMMENT_LINE	(re-)create the archive anyway 
return	TokenNamereturn	
new	TokenNamenew	
ArchiveState	TokenNameIdentifier	 Archive State
(	TokenNameLPAREN	
needsUpdate	TokenNameIdentifier	 needs Update
,	TokenNameCOMMA	
initialResources	TokenNameIdentifier	 initial Resources
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// initialResources is not empty 	TokenNameCOMMENT_LINE	initialResources is not empty 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
zipFile	TokenNameIdentifier	 zip File
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
ArchiveState	TokenNameIdentifier	 Archive State
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
initialResources	TokenNameIdentifier	 initial Resources
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
needsUpdate	TokenNameIdentifier	 needs Update
&&	TokenNameAND_AND	
!	TokenNameNOT	
doUpdate	TokenNameIdentifier	 do Update
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// we are recreating the archive, need all resources 	TokenNameCOMMENT_LINE	we are recreating the archive, need all resources 
return	TokenNamereturn	
new	TokenNamenew	
ArchiveState	TokenNameIdentifier	 Archive State
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
initialResources	TokenNameIdentifier	 initial Resources
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newerResources	TokenNameIdentifier	 newer Resources
=	TokenNameEQUAL	
new	TokenNamenew	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
filesets	TokenNameIdentifier	 filesets
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
filesets	TokenNameIdentifier	 filesets
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
fileset	TokenNameIdentifier	 fileset
instanceof	TokenNameinstanceof	
ZipFileSet	TokenNameIdentifier	 Zip File Set
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
ZipFileSet	TokenNameIdentifier	 Zip File Set
)	TokenNameRPAREN	
fileset	TokenNameIdentifier	 fileset
)	TokenNameRPAREN	
.	TokenNameDOT	
getSrc	TokenNameIdentifier	 get Src
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
base	TokenNameIdentifier	 base
=	TokenNameEQUAL	
filesets	TokenNameIdentifier	 filesets
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
getDir	TokenNameIdentifier	 get Dir
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
initialResources	TokenNameIdentifier	 initial Resources
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
resourceAsFile	TokenNameIdentifier	 resource As File
=	TokenNameEQUAL	
FILE_UTILS	TokenNameIdentifier	 FILE  UTILS
.	TokenNameDOT	
resolveFile	TokenNameIdentifier	 resolve File
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
initialResources	TokenNameIdentifier	 initial Resources
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
resourceAsFile	TokenNameIdentifier	 resource As File
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
zipFile	TokenNameIdentifier	 zip File
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"A zip file cannot include "	TokenNameStringLiteral	A zip file cannot include 
+	TokenNamePLUS	
"itself"	TokenNameStringLiteral	itself
,	TokenNameCOMMA	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
filesets	TokenNameIdentifier	 filesets
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
initialResources	TokenNameIdentifier	 initial Resources
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
newerResources	TokenNameIdentifier	 newer Resources
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
FileNameMapper	TokenNameIdentifier	 File Name Mapper
myMapper	TokenNameIdentifier	 my Mapper
=	TokenNameEQUAL	
new	TokenNamenew	
IdentityMapper	TokenNameIdentifier	 Identity Mapper
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
filesets	TokenNameIdentifier	 filesets
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
instanceof	TokenNameinstanceof	
ZipFileSet	TokenNameIdentifier	 Zip File Set
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ZipFileSet	TokenNameIdentifier	 Zip File Set
zfs	TokenNameIdentifier	 zfs
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ZipFileSet	TokenNameIdentifier	 Zip File Set
)	TokenNameRPAREN	
filesets	TokenNameIdentifier	 filesets
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
zfs	TokenNameIdentifier	 zfs
.	TokenNameDOT	
getFullpath	TokenNameIdentifier	 get Fullpath
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
zfs	TokenNameIdentifier	 zfs
.	TokenNameDOT	
getFullpath	TokenNameIdentifier	 get Fullpath
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// in this case all files from origin map to 	TokenNameCOMMENT_LINE	in this case all files from origin map to 
// the fullPath attribute of the zipfileset at 	TokenNameCOMMENT_LINE	the fullPath attribute of the zipfileset at 
// destination 	TokenNameCOMMENT_LINE	destination 
MergingMapper	TokenNameIdentifier	 Merging Mapper
fm	TokenNameIdentifier	 fm
=	TokenNameEQUAL	
new	TokenNamenew	
MergingMapper	TokenNameIdentifier	 Merging Mapper
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fm	TokenNameIdentifier	 fm
.	TokenNameDOT	
setTo	TokenNameIdentifier	 set To
(	TokenNameLPAREN	
zfs	TokenNameIdentifier	 zfs
.	TokenNameDOT	
getFullpath	TokenNameIdentifier	 get Fullpath
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
myMapper	TokenNameIdentifier	 my Mapper
=	TokenNameEQUAL	
fm	TokenNameIdentifier	 fm
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
zfs	TokenNameIdentifier	 zfs
.	TokenNameDOT	
getPrefix	TokenNameIdentifier	 get Prefix
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
zfs	TokenNameIdentifier	 zfs
.	TokenNameDOT	
getPrefix	TokenNameIdentifier	 get Prefix
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
GlobPatternMapper	TokenNameIdentifier	 Glob Pattern Mapper
gm	TokenNameIdentifier	 gm
=	TokenNameEQUAL	
new	TokenNamenew	
GlobPatternMapper	TokenNameIdentifier	 Glob Pattern Mapper
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
gm	TokenNameIdentifier	 gm
.	TokenNameDOT	
setFrom	TokenNameIdentifier	 set From
(	TokenNameLPAREN	
"*"	TokenNameStringLiteral	*
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
prefix	TokenNameIdentifier	 prefix
=	TokenNameEQUAL	
zfs	TokenNameIdentifier	 zfs
.	TokenNameDOT	
getPrefix	TokenNameIdentifier	 get Prefix
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
prefix	TokenNameIdentifier	 prefix
.	TokenNameDOT	
endsWith	TokenNameIdentifier	 ends With
(	TokenNameLPAREN	
"/"	TokenNameStringLiteral	/
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
prefix	TokenNameIdentifier	 prefix
.	TokenNameDOT	
endsWith	TokenNameIdentifier	 ends With
(	TokenNameLPAREN	
"\"	TokenNameStringLiteral	\
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
prefix	TokenNameIdentifier	 prefix
+=	TokenNamePLUS_EQUAL	
"/"	TokenNameStringLiteral	/
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
gm	TokenNameIdentifier	 gm
.	TokenNameDOT	
setTo	TokenNameIdentifier	 set To
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
+	TokenNamePLUS	
"*"	TokenNameStringLiteral	*
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
myMapper	TokenNameIdentifier	 my Mapper
=	TokenNameEQUAL	
gm	TokenNameIdentifier	 gm
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
newerResources	TokenNameIdentifier	 newer Resources
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
selectOutOfDateResources	TokenNameIdentifier	 select Out Of Date Resources
(	TokenNameLPAREN	
initialResources	TokenNameIdentifier	 initial Resources
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
myMapper	TokenNameIdentifier	 my Mapper
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
needsUpdate	TokenNameIdentifier	 needs Update
=	TokenNameEQUAL	
needsUpdate	TokenNameIdentifier	 needs Update
||	TokenNameOR_OR	
(	TokenNameLPAREN	
newerResources	TokenNameIdentifier	 newer Resources
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
needsUpdate	TokenNameIdentifier	 needs Update
&&	TokenNameAND_AND	
!	TokenNameNOT	
doUpdate	TokenNameIdentifier	 do Update
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// we will return initialResources anyway, no reason 	TokenNameCOMMENT_LINE	we will return initialResources anyway, no reason 
// to scan further. 	TokenNameCOMMENT_LINE	to scan further. 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
needsUpdate	TokenNameIdentifier	 needs Update
&&	TokenNameAND_AND	
!	TokenNameNOT	
doUpdate	TokenNameIdentifier	 do Update
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// we are recreating the archive, need all resources 	TokenNameCOMMENT_LINE	we are recreating the archive, need all resources 
return	TokenNamereturn	
new	TokenNamenew	
ArchiveState	TokenNameIdentifier	 Archive State
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
initialResources	TokenNameIdentifier	 initial Resources
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
new	TokenNamenew	
ArchiveState	TokenNameIdentifier	 Archive State
(	TokenNameLPAREN	
needsUpdate	TokenNameIdentifier	 needs Update
,	TokenNameCOMMA	
newerResources	TokenNameIdentifier	 newer Resources
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Collect the resources that are newer than the corresponding * entries (or missing) in the original archive. * * <p>If we are going to recreate the archive instead of updating * it, all resources should be considered as new, if a single one * is. Because of this, subclasses overriding this method must * call <code>super.getResourcesToAdd</code> and indicate with the * third arg if they already know that the archive is * out-of-date.</p> * * @param rcs The filesets to grab resources from * @param zipFile intended archive file (may or may not exist) * @param needsUpdate whether we already know that the archive is * out-of-date. Subclasses overriding this method are supposed to * set this value correctly in their call to * <code>super.getResourcesToAdd</code>. * @return an array of resources to add for each fileset passed in as well * as a flag that indicates whether the archive is uptodate. * * @exception BuildException if it likes */	TokenNameCOMMENT_JAVADOC	 Collect the resources that are newer than the corresponding entries (or missing) in the original archive. * <p>If we are going to recreate the archive instead of updating it, all resources should be considered as new, if a single one is. Because of this, subclasses overriding this method must call <code>super.getResourcesToAdd</code> and indicate with the third arg if they already know that the archive is out-of-date.</p> * @param rcs The filesets to grab resources from @param zipFile intended archive file (may or may not exist) @param needsUpdate whether we already know that the archive is out-of-date. Subclasses overriding this method are supposed to set this value correctly in their call to <code>super.getResourcesToAdd</code>. @return an array of resources to add for each fileset passed in as well as a flag that indicates whether the archive is uptodate. * @exception BuildException if it likes 
protected	TokenNameprotected	
ArchiveState	TokenNameIdentifier	 Archive State
getNonFileSetResourcesToAdd	TokenNameIdentifier	 get Non File Set Resources To Add
(	TokenNameLPAREN	
ResourceCollection	TokenNameIdentifier	 Resource Collection
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
rcs	TokenNameIdentifier	 rcs
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
zipFile	TokenNameIdentifier	 zip File
,	TokenNameCOMMA	
boolean	TokenNameboolean	
needsUpdate	TokenNameIdentifier	 needs Update
)	TokenNameRPAREN	
throws	TokenNamethrows	
BuildException	TokenNameIdentifier	 Build Exception
{	TokenNameLBRACE	
/* * Backwards compatibility forces us to repeat the logic of * getResourcesToAdd(FileSet[], ...) here once again. */	TokenNameCOMMENT_BLOCK	 Backwards compatibility forces us to repeat the logic of getResourcesToAdd(FileSet[], ...) here once again. 
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
initialResources	TokenNameIdentifier	 initial Resources
=	TokenNameEQUAL	
grabNonFileSetResources	TokenNameIdentifier	 grab Non File Set Resources
(	TokenNameLPAREN	
rcs	TokenNameIdentifier	 rcs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
empty	TokenNameIdentifier	 empty
=	TokenNameEQUAL	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
initialResources	TokenNameIdentifier	 initial Resources
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
haveNonFileSetResourcesToAdd	TokenNameIdentifier	 have Non File Set Resources To Add
.	TokenNameDOT	
set	TokenNameIdentifier	 set
(	TokenNameLPAREN	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
!	TokenNameNOT	
empty	TokenNameIdentifier	 empty
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
empty	TokenNameIdentifier	 empty
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// no emptyBehavior handling since the FileSet version 	TokenNameCOMMENT_LINE	no emptyBehavior handling since the FileSet version 
// will take care of it. 	TokenNameCOMMENT_LINE	will take care of it. 
return	TokenNamereturn	
new	TokenNamenew	
ArchiveState	TokenNameIdentifier	 Archive State
(	TokenNameLPAREN	
needsUpdate	TokenNameIdentifier	 needs Update
,	TokenNameCOMMA	
initialResources	TokenNameIdentifier	 initial Resources
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// initialResources is not empty 	TokenNameCOMMENT_LINE	initialResources is not empty 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
zipFile	TokenNameIdentifier	 zip File
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
ArchiveState	TokenNameIdentifier	 Archive State
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
initialResources	TokenNameIdentifier	 initial Resources
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
needsUpdate	TokenNameIdentifier	 needs Update
&&	TokenNameAND_AND	
!	TokenNameNOT	
doUpdate	TokenNameIdentifier	 do Update
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// we are recreating the archive, need all resources 	TokenNameCOMMENT_LINE	we are recreating the archive, need all resources 
return	TokenNamereturn	
new	TokenNamenew	
ArchiveState	TokenNameIdentifier	 Archive State
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
initialResources	TokenNameIdentifier	 initial Resources
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newerResources	TokenNameIdentifier	 newer Resources
=	TokenNameEQUAL	
new	TokenNamenew	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
rcs	TokenNameIdentifier	 rcs
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
rcs	TokenNameIdentifier	 rcs
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
initialResources	TokenNameIdentifier	 initial Resources
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
newerResources	TokenNameIdentifier	 newer Resources
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
initialResources	TokenNameIdentifier	 initial Resources
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
FileProvider	TokenNameIdentifier	 File Provider
fp	TokenNameIdentifier	 fp
=	TokenNameEQUAL	
(	TokenNameLPAREN	
FileProvider	TokenNameIdentifier	 File Provider
)	TokenNameRPAREN	
initialResources	TokenNameIdentifier	 initial Resources
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
.	TokenNameDOT	
as	TokenNameIdentifier	 as
(	TokenNameLPAREN	
FileProvider	TokenNameIdentifier	 File Provider
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fp	TokenNameIdentifier	 fp
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
zipFile	TokenNameIdentifier	 zip File
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
fp	TokenNameIdentifier	 fp
.	TokenNameDOT	
getFile	TokenNameIdentifier	 get File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"A zip file cannot include "	TokenNameStringLiteral	A zip file cannot include 
+	TokenNamePLUS	
"itself"	TokenNameStringLiteral	itself
,	TokenNameCOMMA	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
newerResources	TokenNameIdentifier	 newer Resources
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
selectOutOfDateResources	TokenNameIdentifier	 select Out Of Date Resources
(	TokenNameLPAREN	
initialResources	TokenNameIdentifier	 initial Resources
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
new	TokenNamenew	
IdentityMapper	TokenNameIdentifier	 Identity Mapper
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
needsUpdate	TokenNameIdentifier	 needs Update
=	TokenNameEQUAL	
needsUpdate	TokenNameIdentifier	 needs Update
||	TokenNameOR_OR	
(	TokenNameLPAREN	
newerResources	TokenNameIdentifier	 newer Resources
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
needsUpdate	TokenNameIdentifier	 needs Update
&&	TokenNameAND_AND	
!	TokenNameNOT	
doUpdate	TokenNameIdentifier	 do Update
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// we will return initialResources anyway, no reason 	TokenNameCOMMENT_LINE	we will return initialResources anyway, no reason 
// to scan further. 	TokenNameCOMMENT_LINE	to scan further. 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
needsUpdate	TokenNameIdentifier	 needs Update
&&	TokenNameAND_AND	
!	TokenNameNOT	
doUpdate	TokenNameIdentifier	 do Update
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// we are recreating the archive, need all resources 	TokenNameCOMMENT_LINE	we are recreating the archive, need all resources 
return	TokenNamereturn	
new	TokenNamenew	
ArchiveState	TokenNameIdentifier	 Archive State
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
initialResources	TokenNameIdentifier	 initial Resources
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
new	TokenNamenew	
ArchiveState	TokenNameIdentifier	 Archive State
(	TokenNameLPAREN	
needsUpdate	TokenNameIdentifier	 needs Update
,	TokenNameCOMMA	
newerResources	TokenNameIdentifier	 newer Resources
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
selectOutOfDateResources	TokenNameIdentifier	 select Out Of Date Resources
(	TokenNameLPAREN	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
initial	TokenNameIdentifier	 initial
,	TokenNameCOMMA	
FileNameMapper	TokenNameIdentifier	 File Name Mapper
mapper	TokenNameIdentifier	 mapper
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
rs	TokenNameIdentifier	 rs
=	TokenNameEQUAL	
selectFileResources	TokenNameIdentifier	 select File Resources
(	TokenNameLPAREN	
initial	TokenNameIdentifier	 initial
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
ResourceUtils	TokenNameIdentifier	 Resource Utils
.	TokenNameDOT	
selectOutOfDateSources	TokenNameIdentifier	 select Out Of Date Sources
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
rs	TokenNameIdentifier	 rs
,	TokenNameCOMMA	
mapper	TokenNameIdentifier	 mapper
,	TokenNameCOMMA	
getZipScanner	TokenNameIdentifier	 get Zip Scanner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
doFilesonly	TokenNameIdentifier	 do Filesonly
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Union	TokenNameIdentifier	 Union
u	TokenNameIdentifier	 u
=	TokenNameEQUAL	
new	TokenNamenew	
Union	TokenNameIdentifier	 Union
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
u	TokenNameIdentifier	 u
.	TokenNameDOT	
addAll	TokenNameIdentifier	 add All
(	TokenNameLPAREN	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
asList	TokenNameIdentifier	 as List
(	TokenNameLPAREN	
selectDirectoryResources	TokenNameIdentifier	 select Directory Resources
(	TokenNameLPAREN	
initial	TokenNameIdentifier	 initial
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ResourceCollection	TokenNameIdentifier	 Resource Collection
rc	TokenNameIdentifier	 rc
=	TokenNameEQUAL	
ResourceUtils	TokenNameIdentifier	 Resource Utils
.	TokenNameDOT	
selectSources	TokenNameIdentifier	 select Sources
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
u	TokenNameIdentifier	 u
,	TokenNameCOMMA	
mapper	TokenNameIdentifier	 mapper
,	TokenNameCOMMA	
getZipScanner	TokenNameIdentifier	 get Zip Scanner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
MISSING_DIR_PROVIDER	TokenNameIdentifier	 MISSING  DIR  PROVIDER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
rc	TokenNameIdentifier	 rc
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ArrayList	TokenNameIdentifier	 Array List
newer	TokenNameIdentifier	 newer
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
newer	TokenNameIdentifier	 newer
.	TokenNameDOT	
addAll	TokenNameIdentifier	 add All
(	TokenNameLPAREN	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
asList	TokenNameIdentifier	 as List
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Union	TokenNameIdentifier	 Union
)	TokenNameRPAREN	
rc	TokenNameIdentifier	 rc
)	TokenNameRPAREN	
.	TokenNameDOT	
listResources	TokenNameIdentifier	 list Resources
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
newer	TokenNameIdentifier	 newer
.	TokenNameDOT	
addAll	TokenNameIdentifier	 add All
(	TokenNameLPAREN	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
asList	TokenNameIdentifier	 as List
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
newer	TokenNameIdentifier	 newer
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
result	TokenNameIdentifier	 result
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Fetch all included and not excluded resources from the sets. * * <p>Included directories will precede included files.</p> * @param filesets an array of filesets * @return the resources included * @since Ant 1.5.2 */	TokenNameCOMMENT_JAVADOC	 Fetch all included and not excluded resources from the sets. * <p>Included directories will precede included files.</p> @param filesets an array of filesets @return the resources included @since Ant 1.5.2 
protected	TokenNameprotected	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
grabResources	TokenNameIdentifier	 grab Resources
(	TokenNameLPAREN	
FileSet	TokenNameIdentifier	 File Set
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
filesets	TokenNameIdentifier	 filesets
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
new	TokenNamenew	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
filesets	TokenNameIdentifier	 filesets
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
filesets	TokenNameIdentifier	 filesets
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
skipEmptyNames	TokenNameIdentifier	 skip Empty Names
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
filesets	TokenNameIdentifier	 filesets
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
instanceof	TokenNameinstanceof	
ZipFileSet	TokenNameIdentifier	 Zip File Set
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ZipFileSet	TokenNameIdentifier	 Zip File Set
zfs	TokenNameIdentifier	 zfs
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ZipFileSet	TokenNameIdentifier	 Zip File Set
)	TokenNameRPAREN	
filesets	TokenNameIdentifier	 filesets
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
skipEmptyNames	TokenNameIdentifier	 skip Empty Names
=	TokenNameEQUAL	
zfs	TokenNameIdentifier	 zfs
.	TokenNameDOT	
getPrefix	TokenNameIdentifier	 get Prefix
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
zfs	TokenNameIdentifier	 zfs
.	TokenNameDOT	
getFullpath	TokenNameIdentifier	 get Fullpath
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
DirectoryScanner	TokenNameIdentifier	 Directory Scanner
rs	TokenNameIdentifier	 rs
=	TokenNameEQUAL	
filesets	TokenNameIdentifier	 filesets
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
getDirectoryScanner	TokenNameIdentifier	 get Directory Scanner
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
rs	TokenNameIdentifier	 rs
instanceof	TokenNameinstanceof	
ZipScanner	TokenNameIdentifier	 Zip Scanner
)	TokenNameRPAREN	
{	TokenNameLBRACE	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
ZipScanner	TokenNameIdentifier	 Zip Scanner
)	TokenNameRPAREN	
rs	TokenNameIdentifier	 rs
)	TokenNameRPAREN	
.	TokenNameDOT	
setEncoding	TokenNameIdentifier	 set Encoding
(	TokenNameLPAREN	
encoding	TokenNameIdentifier	 encoding
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Vector	TokenNameIdentifier	 Vector
resources	TokenNameIdentifier	 resources
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
doFilesonly	TokenNameIdentifier	 do Filesonly
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
directories	TokenNameIdentifier	 directories
=	TokenNameEQUAL	
rs	TokenNameIdentifier	 rs
.	TokenNameDOT	
getIncludedDirectories	TokenNameIdentifier	 get Included Directories
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
directories	TokenNameIdentifier	 directories
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
""	TokenNameStringLiteral	 
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
directories	TokenNameIdentifier	 directories
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
skipEmptyNames	TokenNameIdentifier	 skip Empty Names
)	TokenNameRPAREN	
{	TokenNameLBRACE	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
rs	TokenNameIdentifier	 rs
.	TokenNameDOT	
getResource	TokenNameIdentifier	 get Resource
(	TokenNameLPAREN	
directories	TokenNameIdentifier	 directories
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
files	TokenNameIdentifier	 files
=	TokenNameEQUAL	
rs	TokenNameIdentifier	 rs
.	TokenNameDOT	
getIncludedFiles	TokenNameIdentifier	 get Included Files
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
files	TokenNameIdentifier	 files
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
""	TokenNameStringLiteral	 
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
files	TokenNameIdentifier	 files
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
skipEmptyNames	TokenNameIdentifier	 skip Empty Names
)	TokenNameRPAREN	
{	TokenNameLBRACE	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
rs	TokenNameIdentifier	 rs
.	TokenNameDOT	
getResource	TokenNameIdentifier	 get Resource
(	TokenNameLPAREN	
files	TokenNameIdentifier	 files
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
result	TokenNameIdentifier	 result
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
copyInto	TokenNameIdentifier	 copy Into
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
result	TokenNameIdentifier	 result
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Fetch all included and not excluded resources from the collections. * * <p>Included directories will precede included files.</p> * @param rcs an array of resource collections * @return the resources included * @since Ant 1.7 */	TokenNameCOMMENT_JAVADOC	 Fetch all included and not excluded resources from the collections. * <p>Included directories will precede included files.</p> @param rcs an array of resource collections @return the resources included @since Ant 1.7 
protected	TokenNameprotected	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
grabNonFileSetResources	TokenNameIdentifier	 grab Non File Set Resources
(	TokenNameLPAREN	
ResourceCollection	TokenNameIdentifier	 Resource Collection
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
rcs	TokenNameIdentifier	 rcs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
new	TokenNamenew	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
rcs	TokenNameIdentifier	 rcs
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
rcs	TokenNameIdentifier	 rcs
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Iterator	TokenNameIdentifier	 Iterator
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
rcs	TokenNameIdentifier	 rcs
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ArrayList	TokenNameIdentifier	 Array List
dirs	TokenNameIdentifier	 dirs
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ArrayList	TokenNameIdentifier	 Array List
files	TokenNameIdentifier	 files
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Resource	TokenNameIdentifier	 Resource
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Resource	TokenNameIdentifier	 Resource
)	TokenNameRPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
isExists	TokenNameIdentifier	 is Exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
isDirectory	TokenNameIdentifier	 is Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dirs	TokenNameIdentifier	 dirs
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
files	TokenNameIdentifier	 files
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// make sure directories are in alpha-order - this also 	TokenNameCOMMENT_LINE	make sure directories are in alpha-order - this also 
// ensures parents come before their children 	TokenNameCOMMENT_LINE	ensures parents come before their children 
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
dirs	TokenNameIdentifier	 dirs
,	TokenNameCOMMA	
new	TokenNamenew	
Comparator	TokenNameIdentifier	 Comparator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
int	TokenNameint	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
o1	TokenNameIdentifier	 o1
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
o2	TokenNameIdentifier	 o2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Resource	TokenNameIdentifier	 Resource
r1	TokenNameIdentifier	 r1
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Resource	TokenNameIdentifier	 Resource
)	TokenNameRPAREN	
o1	TokenNameIdentifier	 o1
;	TokenNameSEMICOLON	
Resource	TokenNameIdentifier	 Resource
r2	TokenNameIdentifier	 r2
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Resource	TokenNameIdentifier	 Resource
)	TokenNameRPAREN	
o2	TokenNameIdentifier	 o2
;	TokenNameSEMICOLON	
return	TokenNamereturn	
r1	TokenNameIdentifier	 r1
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
compareTo	TokenNameIdentifier	 compare To
(	TokenNameLPAREN	
r2	TokenNameIdentifier	 r2
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ArrayList	TokenNameIdentifier	 Array List
rs	TokenNameIdentifier	 rs
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
dirs	TokenNameIdentifier	 dirs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rs	TokenNameIdentifier	 rs
.	TokenNameDOT	
addAll	TokenNameIdentifier	 add All
(	TokenNameLPAREN	
files	TokenNameIdentifier	 files
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
result	TokenNameIdentifier	 result
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
rs	TokenNameIdentifier	 rs
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
new	TokenNamenew	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
rs	TokenNameIdentifier	 rs
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
result	TokenNameIdentifier	 result
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Add a directory to the zip stream. * @param dir the directort to add to the archive * @param zOut the stream to write to * @param vPath the name this entry shall have in the archive * @param mode the Unix permissions to set. * @throws IOException on error * @since Ant 1.5.2 */	TokenNameCOMMENT_JAVADOC	 Add a directory to the zip stream. @param dir the directort to add to the archive @param zOut the stream to write to @param vPath the name this entry shall have in the archive @param mode the Unix permissions to set. @throws IOException on error @since Ant 1.5.2 
protected	TokenNameprotected	
void	TokenNamevoid	
zipDir	TokenNameIdentifier	 zip Dir
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
vPath	TokenNameIdentifier	 v Path
,	TokenNameCOMMA	
int	TokenNameint	
mode	TokenNameIdentifier	 mode
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
zipDir	TokenNameIdentifier	 zip Dir
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
vPath	TokenNameIdentifier	 v Path
,	TokenNameCOMMA	
mode	TokenNameIdentifier	 mode
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Add a directory to the zip stream. * @param dir the directory to add to the archive * @param zOut the stream to write to * @param vPath the name this entry shall have in the archive * @param mode the Unix permissions to set. * @param extra ZipExtraFields to add * @throws IOException on error * @since Ant 1.6.3 */	TokenNameCOMMENT_JAVADOC	 Add a directory to the zip stream. @param dir the directory to add to the archive @param zOut the stream to write to @param vPath the name this entry shall have in the archive @param mode the Unix permissions to set. @param extra ZipExtraFields to add @throws IOException on error @since Ant 1.6.3 
protected	TokenNameprotected	
void	TokenNamevoid	
zipDir	TokenNameIdentifier	 zip Dir
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
vPath	TokenNameIdentifier	 v Path
,	TokenNameCOMMA	
int	TokenNameint	
mode	TokenNameIdentifier	 mode
,	TokenNameCOMMA	
ZipExtraField	TokenNameIdentifier	 Zip Extra Field
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
extra	TokenNameIdentifier	 extra
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
zipDir	TokenNameIdentifier	 zip Dir
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
(	TokenNameLPAREN	
Resource	TokenNameIdentifier	 Resource
)	TokenNameRPAREN	
null	TokenNamenull	
:	TokenNameCOLON	
new	TokenNamenew	
FileResource	TokenNameIdentifier	 File Resource
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
,	TokenNameCOMMA	
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
vPath	TokenNameIdentifier	 v Path
,	TokenNameCOMMA	
mode	TokenNameIdentifier	 mode
,	TokenNameCOMMA	
extra	TokenNameIdentifier	 extra
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Add a directory to the zip stream. * @param dir the directory to add to the archive * @param zOut the stream to write to * @param vPath the name this entry shall have in the archive * @param mode the Unix permissions to set. * @param extra ZipExtraFields to add * @throws IOException on error * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Add a directory to the zip stream. @param dir the directory to add to the archive @param zOut the stream to write to @param vPath the name this entry shall have in the archive @param mode the Unix permissions to set. @param extra ZipExtraFields to add @throws IOException on error @since Ant 1.8.0 
protected	TokenNameprotected	
void	TokenNamevoid	
zipDir	TokenNameIdentifier	 zip Dir
(	TokenNameLPAREN	
Resource	TokenNameIdentifier	 Resource
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
vPath	TokenNameIdentifier	 v Path
,	TokenNameCOMMA	
int	TokenNameint	
mode	TokenNameIdentifier	 mode
,	TokenNameCOMMA	
ZipExtraField	TokenNameIdentifier	 Zip Extra Field
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
extra	TokenNameIdentifier	 extra
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
doFilesonly	TokenNameIdentifier	 do Filesonly
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logWhenWriting	TokenNameIdentifier	 log When Writing
(	TokenNameLPAREN	
"skipping directory "	TokenNameStringLiteral	skipping directory 
+	TokenNamePLUS	
vPath	TokenNameIdentifier	 v Path
+	TokenNamePLUS	
" for file-only archive"	TokenNameStringLiteral	 for file-only archive
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_VERBOSE	TokenNameIdentifier	 MSG  VERBOSE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
addedDirs	TokenNameIdentifier	 added Dirs
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
vPath	TokenNameIdentifier	 v Path
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// don't add directories we've already added. 	TokenNameCOMMENT_LINE	don't add directories we've already added. 
// no warning if we try, it is harmless in and of itself 	TokenNameCOMMENT_LINE	no warning if we try, it is harmless in and of itself 
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
logWhenWriting	TokenNameIdentifier	 log When Writing
(	TokenNameLPAREN	
"adding directory "	TokenNameStringLiteral	adding directory 
+	TokenNamePLUS	
vPath	TokenNameIdentifier	 v Path
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_VERBOSE	TokenNameIdentifier	 MSG  VERBOSE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
addedDirs	TokenNameIdentifier	 added Dirs
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
vPath	TokenNameIdentifier	 v Path
,	TokenNameCOMMA	
vPath	TokenNameIdentifier	 v Path
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
skipWriting	TokenNameIdentifier	 skip Writing
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ZipEntry	TokenNameIdentifier	 Zip Entry
ze	TokenNameIdentifier	 ze
=	TokenNameEQUAL	
new	TokenNamenew	
ZipEntry	TokenNameIdentifier	 Zip Entry
(	TokenNameLPAREN	
vPath	TokenNameIdentifier	 v Path
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// ZIPs store time with a granularity of 2 seconds, round up 	TokenNameCOMMENT_LINE	ZIPs store time with a granularity of 2 seconds, round up 
int	TokenNameint	
millisToAdd	TokenNameIdentifier	 millis To Add
=	TokenNameEQUAL	
roundUp	TokenNameIdentifier	 round Up
?	TokenNameQUESTION	
ROUNDUP_MILLIS	TokenNameIdentifier	 ROUNDUP  MILLIS
:	TokenNameCOLON	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
isExists	TokenNameIdentifier	 is Exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ze	TokenNameIdentifier	 ze
.	TokenNameDOT	
setTime	TokenNameIdentifier	 set Time
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getLastModified	TokenNameIdentifier	 get Last Modified
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
millisToAdd	TokenNameIdentifier	 millis To Add
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
ze	TokenNameIdentifier	 ze
.	TokenNameDOT	
setTime	TokenNameIdentifier	 set Time
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
millisToAdd	TokenNameIdentifier	 millis To Add
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ze	TokenNameIdentifier	 ze
.	TokenNameDOT	
setSize	TokenNameIdentifier	 set Size
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ze	TokenNameIdentifier	 ze
.	TokenNameDOT	
setMethod	TokenNameIdentifier	 set Method
(	TokenNameLPAREN	
ZipEntry	TokenNameIdentifier	 Zip Entry
.	TokenNameDOT	
STORED	TokenNameIdentifier	 STORED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// This is faintly ridiculous: 	TokenNameCOMMENT_LINE	This is faintly ridiculous: 
ze	TokenNameIdentifier	 ze
.	TokenNameDOT	
setCrc	TokenNameIdentifier	 set Crc
(	TokenNameLPAREN	
EMPTY_CRC	TokenNameIdentifier	 EMPTY  CRC
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ze	TokenNameIdentifier	 ze
.	TokenNameDOT	
setUnixMode	TokenNameIdentifier	 set Unix Mode
(	TokenNameLPAREN	
mode	TokenNameIdentifier	 mode
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
extra	TokenNameIdentifier	 extra
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ze	TokenNameIdentifier	 ze
.	TokenNameDOT	
setExtraFields	TokenNameIdentifier	 set Extra Fields
(	TokenNameLPAREN	
extra	TokenNameIdentifier	 extra
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
zOut	TokenNameIdentifier	 z Out
.	TokenNameDOT	
putNextEntry	TokenNameIdentifier	 put Next Entry
(	TokenNameLPAREN	
ze	TokenNameIdentifier	 ze
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* * This is a hacky construct to extend the zipFile method to * support a new parameter (extra fields to preserve) without * breaking subclasses that override the old method signature. */	TokenNameCOMMENT_BLOCK	 This is a hacky construct to extend the zipFile method to support a new parameter (extra fields to preserve) without breaking subclasses that override the old method signature. 
private	TokenNameprivate	
static	TokenNamestatic	
ThreadLocal	TokenNameIdentifier	 Thread Local
currentZipExtra	TokenNameIdentifier	 current Zip Extra
=	TokenNameEQUAL	
new	TokenNamenew	
ThreadLocal	TokenNameIdentifier	 Thread Local
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
protected	TokenNameprotected	
Object	TokenNameIdentifier	 Object
initialValue	TokenNameIdentifier	 initial Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** * Provides the extra fields for the zip entry currently being * added to the archive - if any. * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Provides the extra fields for the zip entry currently being added to the archive - if any. @since Ant 1.8.0 
protected	TokenNameprotected	
final	TokenNamefinal	
ZipExtraField	TokenNameIdentifier	 Zip Extra Field
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getCurrentExtraFields	TokenNameIdentifier	 get Current Extra Fields
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
ZipExtraField	TokenNameIdentifier	 Zip Extra Field
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
currentZipExtra	TokenNameIdentifier	 current Zip Extra
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets the extra fields for the zip entry currently being * added to the archive - if any. * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Sets the extra fields for the zip entry currently being added to the archive - if any. @since Ant 1.8.0 
protected	TokenNameprotected	
final	TokenNamefinal	
void	TokenNamevoid	
setCurrentExtraFields	TokenNameIdentifier	 set Current Extra Fields
(	TokenNameLPAREN	
ZipExtraField	TokenNameIdentifier	 Zip Extra Field
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
extra	TokenNameIdentifier	 extra
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currentZipExtra	TokenNameIdentifier	 current Zip Extra
.	TokenNameDOT	
set	TokenNameIdentifier	 set
(	TokenNameLPAREN	
extra	TokenNameIdentifier	 extra
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Adds a new entry to the archive, takes care of duplicates as well. * * @param in the stream to read data for the entry from. The * caller of the method is responsible for closing the stream. * @param zOut the stream to write to. * @param vPath the name this entry shall have in the archive. * @param lastModified last modification time for the entry. * @param fromArchive the original archive we are copying this * entry from, will be null if we are not copying from an archive. * @param mode the Unix permissions to set. * * @since Ant 1.5.2 * @throws IOException on error */	TokenNameCOMMENT_JAVADOC	 Adds a new entry to the archive, takes care of duplicates as well. * @param in the stream to read data for the entry from. The caller of the method is responsible for closing the stream. @param zOut the stream to write to. @param vPath the name this entry shall have in the archive. @param lastModified last modification time for the entry. @param fromArchive the original archive we are copying this entry from, will be null if we are not copying from an archive. @param mode the Unix permissions to set. * @since Ant 1.5.2 @throws IOException on error 
protected	TokenNameprotected	
void	TokenNamevoid	
zipFile	TokenNameIdentifier	 zip File
(	TokenNameLPAREN	
InputStream	TokenNameIdentifier	 Input Stream
in	TokenNameIdentifier	 in
,	TokenNameCOMMA	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
vPath	TokenNameIdentifier	 v Path
,	TokenNameCOMMA	
long	TokenNamelong	
lastModified	TokenNameIdentifier	 last Modified
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
fromArchive	TokenNameIdentifier	 from Archive
,	TokenNameCOMMA	
int	TokenNameint	
mode	TokenNameIdentifier	 mode
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// fromArchive is used in subclasses overriding this method 	TokenNameCOMMENT_LINE	fromArchive is used in subclasses overriding this method 
if	TokenNameif	
(	TokenNameLPAREN	
entries	TokenNameIdentifier	 entries
.	TokenNameDOT	
containsKey	TokenNameIdentifier	 contains Key
(	TokenNameLPAREN	
vPath	TokenNameIdentifier	 v Path
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
duplicate	TokenNameIdentifier	 duplicate
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"preserve"	TokenNameStringLiteral	preserve
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logWhenWriting	TokenNameIdentifier	 log When Writing
(	TokenNameLPAREN	
vPath	TokenNameIdentifier	 v Path
+	TokenNamePLUS	
" already added, skipping"	TokenNameStringLiteral	 already added, skipping
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_INFO	TokenNameIdentifier	 MSG  INFO
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
duplicate	TokenNameIdentifier	 duplicate
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"fail"	TokenNameStringLiteral	fail
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Duplicate file "	TokenNameStringLiteral	Duplicate file 
+	TokenNamePLUS	
vPath	TokenNameIdentifier	 v Path
+	TokenNamePLUS	
" was found and the duplicate "	TokenNameStringLiteral	 was found and the duplicate 
+	TokenNamePLUS	
"attribute is 'fail'."	TokenNameStringLiteral	attribute is 'fail'.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// duplicate equal to add, so we continue 	TokenNameCOMMENT_LINE	duplicate equal to add, so we continue 
logWhenWriting	TokenNameIdentifier	 log When Writing
(	TokenNameLPAREN	
"duplicate file "	TokenNameStringLiteral	duplicate file 
+	TokenNamePLUS	
vPath	TokenNameIdentifier	 v Path
+	TokenNamePLUS	
" found, adding."	TokenNameStringLiteral	 found, adding.
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_VERBOSE	TokenNameIdentifier	 MSG  VERBOSE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
logWhenWriting	TokenNameIdentifier	 log When Writing
(	TokenNameLPAREN	
"adding entry "	TokenNameStringLiteral	adding entry 
+	TokenNamePLUS	
vPath	TokenNameIdentifier	 v Path
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_VERBOSE	TokenNameIdentifier	 MSG  VERBOSE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
entries	TokenNameIdentifier	 entries
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
vPath	TokenNameIdentifier	 v Path
,	TokenNameCOMMA	
vPath	TokenNameIdentifier	 v Path
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
skipWriting	TokenNameIdentifier	 skip Writing
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ZipEntry	TokenNameIdentifier	 Zip Entry
ze	TokenNameIdentifier	 ze
=	TokenNameEQUAL	
new	TokenNamenew	
ZipEntry	TokenNameIdentifier	 Zip Entry
(	TokenNameLPAREN	
vPath	TokenNameIdentifier	 v Path
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ze	TokenNameIdentifier	 ze
.	TokenNameDOT	
setTime	TokenNameIdentifier	 set Time
(	TokenNameLPAREN	
lastModified	TokenNameIdentifier	 last Modified
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ze	TokenNameIdentifier	 ze
.	TokenNameDOT	
setMethod	TokenNameIdentifier	 set Method
(	TokenNameLPAREN	
doCompress	TokenNameIdentifier	 do Compress
?	TokenNameQUESTION	
ZipEntry	TokenNameIdentifier	 Zip Entry
.	TokenNameDOT	
DEFLATED	TokenNameIdentifier	 DEFLATED
:	TokenNameCOLON	
ZipEntry	TokenNameIdentifier	 Zip Entry
.	TokenNameDOT	
STORED	TokenNameIdentifier	 STORED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* * ZipOutputStream.putNextEntry expects the ZipEntry to * know its size and the CRC sum before you start writing * the data when using STORED mode - unless it is seekable. * * This forces us to process the data twice. */	TokenNameCOMMENT_BLOCK	 ZipOutputStream.putNextEntry expects the ZipEntry to know its size and the CRC sum before you start writing the data when using STORED mode - unless it is seekable. * This forces us to process the data twice. 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
zOut	TokenNameIdentifier	 z Out
.	TokenNameDOT	
isSeekable	TokenNameIdentifier	 is Seekable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
doCompress	TokenNameIdentifier	 do Compress
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
CRC32	TokenNameIdentifier	 CR C32
cal	TokenNameIdentifier	 cal
=	TokenNameEQUAL	
new	TokenNamenew	
CRC32	TokenNameIdentifier	 CR C32
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
markSupported	TokenNameIdentifier	 mark Supported
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Store data into a byte[] 	TokenNameCOMMENT_LINE	Store data into a byte[] 
ByteArrayOutputStream	TokenNameIdentifier	 Byte Array Output Stream
bos	TokenNameIdentifier	 bos
=	TokenNameEQUAL	
new	TokenNamenew	
ByteArrayOutputStream	TokenNameIdentifier	 Byte Array Output Stream
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
buffer	TokenNameIdentifier	 buffer
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
BUFFER_SIZE	TokenNameIdentifier	 BUFFER  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
size	TokenNameIdentifier	 size
+=	TokenNamePLUS_EQUAL	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
cal	TokenNameIdentifier	 cal
.	TokenNameDOT	
update	TokenNameIdentifier	 update
(	TokenNameLPAREN	
buffer	TokenNameIdentifier	 buffer
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bos	TokenNameIdentifier	 bos
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
buffer	TokenNameIdentifier	 buffer
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
read	TokenNameIdentifier	 read
(	TokenNameLPAREN	
buffer	TokenNameIdentifier	 buffer
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
in	TokenNameIdentifier	 in
=	TokenNameEQUAL	
new	TokenNamenew	
ByteArrayInputStream	TokenNameIdentifier	 Byte Array Input Stream
(	TokenNameLPAREN	
bos	TokenNameIdentifier	 bos
.	TokenNameDOT	
toByteArray	TokenNameIdentifier	 to Byte Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
mark	TokenNameIdentifier	 mark
(	TokenNameLPAREN	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
buffer	TokenNameIdentifier	 buffer
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
BUFFER_SIZE	TokenNameIdentifier	 BUFFER  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
size	TokenNameIdentifier	 size
+=	TokenNamePLUS_EQUAL	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
cal	TokenNameIdentifier	 cal
.	TokenNameDOT	
update	TokenNameIdentifier	 update
(	TokenNameLPAREN	
buffer	TokenNameIdentifier	 buffer
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
read	TokenNameIdentifier	 read
(	TokenNameLPAREN	
buffer	TokenNameIdentifier	 buffer
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ze	TokenNameIdentifier	 ze
.	TokenNameDOT	
setSize	TokenNameIdentifier	 set Size
(	TokenNameLPAREN	
size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ze	TokenNameIdentifier	 ze
.	TokenNameDOT	
setCrc	TokenNameIdentifier	 set Crc
(	TokenNameLPAREN	
cal	TokenNameIdentifier	 cal
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ze	TokenNameIdentifier	 ze
.	TokenNameDOT	
setUnixMode	TokenNameIdentifier	 set Unix Mode
(	TokenNameLPAREN	
mode	TokenNameIdentifier	 mode
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ZipExtraField	TokenNameIdentifier	 Zip Extra Field
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
extra	TokenNameIdentifier	 extra
=	TokenNameEQUAL	
getCurrentExtraFields	TokenNameIdentifier	 get Current Extra Fields
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
extra	TokenNameIdentifier	 extra
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ze	TokenNameIdentifier	 ze
.	TokenNameDOT	
setExtraFields	TokenNameIdentifier	 set Extra Fields
(	TokenNameLPAREN	
extra	TokenNameIdentifier	 extra
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
zOut	TokenNameIdentifier	 z Out
.	TokenNameDOT	
putNextEntry	TokenNameIdentifier	 put Next Entry
(	TokenNameLPAREN	
ze	TokenNameIdentifier	 ze
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
buffer	TokenNameIdentifier	 buffer
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
BUFFER_SIZE	TokenNameIdentifier	 BUFFER  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
zOut	TokenNameIdentifier	 z Out
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
buffer	TokenNameIdentifier	 buffer
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
read	TokenNameIdentifier	 read
(	TokenNameLPAREN	
buffer	TokenNameIdentifier	 buffer
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
addedFiles	TokenNameIdentifier	 added Files
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
vPath	TokenNameIdentifier	 v Path
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Adds a new entry to the archive, takes care of duplicates as well. * * @param in the stream to read data for the entry from. The * caller of the method is responsible for closing the stream. * @param zOut the stream to write to. * @param vPath the name this entry shall have in the archive. * @param lastModified last modification time for the entry. * @param fromArchive the original archive we are copying this * entry from, will be null if we are not copying from an archive. * @param mode the Unix permissions to set. * @param extra ZipExtraFields to add * * @since Ant 1.8.0 * @throws IOException on error */	TokenNameCOMMENT_JAVADOC	 Adds a new entry to the archive, takes care of duplicates as well. * @param in the stream to read data for the entry from. The caller of the method is responsible for closing the stream. @param zOut the stream to write to. @param vPath the name this entry shall have in the archive. @param lastModified last modification time for the entry. @param fromArchive the original archive we are copying this entry from, will be null if we are not copying from an archive. @param mode the Unix permissions to set. @param extra ZipExtraFields to add * @since Ant 1.8.0 @throws IOException on error 
protected	TokenNameprotected	
final	TokenNamefinal	
void	TokenNamevoid	
zipFile	TokenNameIdentifier	 zip File
(	TokenNameLPAREN	
InputStream	TokenNameIdentifier	 Input Stream
in	TokenNameIdentifier	 in
,	TokenNameCOMMA	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
vPath	TokenNameIdentifier	 v Path
,	TokenNameCOMMA	
long	TokenNamelong	
lastModified	TokenNameIdentifier	 last Modified
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
fromArchive	TokenNameIdentifier	 from Archive
,	TokenNameCOMMA	
int	TokenNameint	
mode	TokenNameIdentifier	 mode
,	TokenNameCOMMA	
ZipExtraField	TokenNameIdentifier	 Zip Extra Field
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
extra	TokenNameIdentifier	 extra
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
setCurrentExtraFields	TokenNameIdentifier	 set Current Extra Fields
(	TokenNameLPAREN	
extra	TokenNameIdentifier	 extra
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
zipFile	TokenNameIdentifier	 zip File
(	TokenNameLPAREN	
in	TokenNameIdentifier	 in
,	TokenNameCOMMA	
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
vPath	TokenNameIdentifier	 v Path
,	TokenNameCOMMA	
lastModified	TokenNameIdentifier	 last Modified
,	TokenNameCOMMA	
fromArchive	TokenNameIdentifier	 from Archive
,	TokenNameCOMMA	
mode	TokenNameIdentifier	 mode
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
setCurrentExtraFields	TokenNameIdentifier	 set Current Extra Fields
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Method that gets called when adding from <code>java.io.File</code> instances. * * <p>This implementation delegates to the six-arg version.</p> * * @param file the file to add to the archive * @param zOut the stream to write to * @param vPath the name this entry shall have in the archive * @param mode the Unix permissions to set. * @throws IOException on error * * @since Ant 1.5.2 */	TokenNameCOMMENT_JAVADOC	 Method that gets called when adding from <code>java.io.File</code> instances. * <p>This implementation delegates to the six-arg version.</p> * @param file the file to add to the archive @param zOut the stream to write to @param vPath the name this entry shall have in the archive @param mode the Unix permissions to set. @throws IOException on error * @since Ant 1.5.2 
protected	TokenNameprotected	
void	TokenNamevoid	
zipFile	TokenNameIdentifier	 zip File
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
vPath	TokenNameIdentifier	 v Path
,	TokenNameCOMMA	
int	TokenNameint	
mode	TokenNameIdentifier	 mode
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
zipFile	TokenNameIdentifier	 zip File
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"A zip file cannot include itself"	TokenNameStringLiteral	A zip file cannot include itself
,	TokenNameCOMMA	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
FileInputStream	TokenNameIdentifier	 File Input Stream
fIn	TokenNameIdentifier	 f In
=	TokenNameEQUAL	
new	TokenNamenew	
FileInputStream	TokenNameIdentifier	 File Input Stream
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
// ZIPs store time with a granularity of 2 seconds, round up 	TokenNameCOMMENT_LINE	ZIPs store time with a granularity of 2 seconds, round up 
zipFile	TokenNameIdentifier	 zip File
(	TokenNameLPAREN	
fIn	TokenNameIdentifier	 f In
,	TokenNameCOMMA	
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
vPath	TokenNameIdentifier	 v Path
,	TokenNameCOMMA	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
lastModified	TokenNameIdentifier	 last Modified
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
(	TokenNameLPAREN	
roundUp	TokenNameIdentifier	 round Up
?	TokenNameQUESTION	
ROUNDUP_MILLIS	TokenNameIdentifier	 ROUNDUP  MILLIS
:	TokenNameCOLON	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
mode	TokenNameIdentifier	 mode
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
fIn	TokenNameIdentifier	 f In
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Ensure all parent dirs of a given entry have been added. * @param baseDir the base directory to use (may be null) * @param entry the entry name to create directories from * @param zOut the stream to write to * @param prefix a prefix to place on the created entries * @param dirMode the directory mode * @throws IOException on error * @since Ant 1.5.2 */	TokenNameCOMMENT_JAVADOC	 Ensure all parent dirs of a given entry have been added. @param baseDir the base directory to use (may be null) @param entry the entry name to create directories from @param zOut the stream to write to @param prefix a prefix to place on the created entries @param dirMode the directory mode @throws IOException on error @since Ant 1.5.2 
protected	TokenNameprotected	
final	TokenNamefinal	
void	TokenNamevoid	
addParentDirs	TokenNameIdentifier	 add Parent Dirs
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
baseDir	TokenNameIdentifier	 base Dir
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
entry	TokenNameIdentifier	 entry
,	TokenNameCOMMA	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
prefix	TokenNameIdentifier	 prefix
,	TokenNameCOMMA	
int	TokenNameint	
dirMode	TokenNameIdentifier	 dir Mode
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
doFilesonly	TokenNameIdentifier	 do Filesonly
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Stack	TokenNameIdentifier	 Stack
directories	TokenNameIdentifier	 directories
=	TokenNameEQUAL	
new	TokenNamenew	
Stack	TokenNameIdentifier	 Stack
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
slashPos	TokenNameIdentifier	 slash Pos
=	TokenNameEQUAL	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
slashPos	TokenNameIdentifier	 slash Pos
=	TokenNameEQUAL	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
lastIndexOf	TokenNameIdentifier	 last Index Of
(	TokenNameLPAREN	
'/'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
slashPos	TokenNameIdentifier	 slash Pos
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
slashPos	TokenNameIdentifier	 slash Pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
addedDirs	TokenNameIdentifier	 added Dirs
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
+	TokenNamePLUS	
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
directories	TokenNameIdentifier	 directories
.	TokenNameDOT	
push	TokenNameIdentifier	 push
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
!	TokenNameNOT	
directories	TokenNameIdentifier	 directories
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
directories	TokenNameIdentifier	 directories
.	TokenNameDOT	
pop	TokenNameIdentifier	 pop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
baseDir	TokenNameIdentifier	 base Dir
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
baseDir	TokenNameIdentifier	 base Dir
,	TokenNameCOMMA	
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
zipDir	TokenNameIdentifier	 zip Dir
(	TokenNameLPAREN	
f	TokenNameIdentifier	 f
,	TokenNameCOMMA	
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
prefix	TokenNameIdentifier	 prefix
+	TokenNamePLUS	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
dirMode	TokenNameIdentifier	 dir Mode
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Do any clean up necessary to allow this instance to be used again. * * <p>When we get here, the Zip file has been closed and all we * need to do is to reset some globals.</p> * * <p>This method will only reset globals that have been changed * during execute(), it will not alter the attributes or nested * child elements. If you want to reset the instance so that you * can later zip a completely different set of files, you must use * the reset method.</p> * * @see #reset */	TokenNameCOMMENT_JAVADOC	 Do any clean up necessary to allow this instance to be used again. * <p>When we get here, the Zip file has been closed and all we need to do is to reset some globals.</p> * <p>This method will only reset globals that have been changed during execute(), it will not alter the attributes or nested child elements. If you want to reset the instance so that you can later zip a completely different set of files, you must use the reset method.</p> * @see #reset 
protected	TokenNameprotected	
void	TokenNamevoid	
cleanUp	TokenNameIdentifier	 clean Up
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addedDirs	TokenNameIdentifier	 added Dirs
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
addedFiles	TokenNameIdentifier	 added Files
.	TokenNameDOT	
removeAllElements	TokenNameIdentifier	 remove All Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
entries	TokenNameIdentifier	 entries
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
addingNewFiles	TokenNameIdentifier	 adding New Files
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
doUpdate	TokenNameIdentifier	 do Update
=	TokenNameEQUAL	
savedDoUpdate	TokenNameIdentifier	 saved Do Update
;	TokenNameSEMICOLON	
Enumeration	TokenNameIdentifier	 Enumeration
e	TokenNameIdentifier	 e
=	TokenNameEQUAL	
filesetsFromGroupfilesets	TokenNameIdentifier	 filesets From Groupfilesets
.	TokenNameDOT	
elements	TokenNameIdentifier	 elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
hasMoreElements	TokenNameIdentifier	 has More Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ZipFileSet	TokenNameIdentifier	 Zip File Set
zf	TokenNameIdentifier	 zf
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ZipFileSet	TokenNameIdentifier	 Zip File Set
)	TokenNameRPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
nextElement	TokenNameIdentifier	 next Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
removeElement	TokenNameIdentifier	 remove Element
(	TokenNameLPAREN	
zf	TokenNameIdentifier	 zf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
filesetsFromGroupfilesets	TokenNameIdentifier	 filesets From Groupfilesets
.	TokenNameDOT	
removeAllElements	TokenNameIdentifier	 remove All Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
haveNonFileSetResourcesToAdd	TokenNameIdentifier	 have Non File Set Resources To Add
.	TokenNameDOT	
set	TokenNameIdentifier	 set
(	TokenNameLPAREN	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
FALSE	TokenNameIdentifier	 FALSE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Makes this instance reset all attributes to their default * values and forget all children. * * @since Ant 1.5 * * @see #cleanUp */	TokenNameCOMMENT_JAVADOC	 Makes this instance reset all attributes to their default values and forget all children. * @since Ant 1.5 * @see #cleanUp 
public	TokenNamepublic	
void	TokenNamevoid	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
removeAllElements	TokenNameIdentifier	 remove All Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
zipFile	TokenNameIdentifier	 zip File
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
baseDir	TokenNameIdentifier	 base Dir
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
groupfilesets	TokenNameIdentifier	 groupfilesets
.	TokenNameDOT	
removeAllElements	TokenNameIdentifier	 remove All Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
duplicate	TokenNameIdentifier	 duplicate
=	TokenNameEQUAL	
"add"	TokenNameStringLiteral	add
;	TokenNameSEMICOLON	
archiveType	TokenNameIdentifier	 archive Type
=	TokenNameEQUAL	
"zip"	TokenNameStringLiteral	zip
;	TokenNameSEMICOLON	
doCompress	TokenNameIdentifier	 do Compress
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
emptyBehavior	TokenNameIdentifier	 empty Behavior
=	TokenNameEQUAL	
"skip"	TokenNameStringLiteral	skip
;	TokenNameSEMICOLON	
doUpdate	TokenNameIdentifier	 do Update
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
doFilesonly	TokenNameIdentifier	 do Filesonly
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
encoding	TokenNameIdentifier	 encoding
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Check is the resource arrays are empty. * @param r the arrays to check * @return true if all individual arrays are empty * * @since Ant 1.5.2 */	TokenNameCOMMENT_JAVADOC	 Check is the resource arrays are empty. @param r the arrays to check @return true if all individual arrays are empty * @since Ant 1.5.2 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Drops all non-file resources from the given array. * @param orig the resources to filter * @return the filters resources * @since Ant 1.6 */	TokenNameCOMMENT_JAVADOC	 Drops all non-file resources from the given array. @param orig the resources to filter @return the filters resources @since Ant 1.6 
protected	TokenNameprotected	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
selectFileResources	TokenNameIdentifier	 select File Resources
(	TokenNameLPAREN	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
orig	TokenNameIdentifier	 orig
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
selectResources	TokenNameIdentifier	 select Resources
(	TokenNameLPAREN	
orig	TokenNameIdentifier	 orig
,	TokenNameCOMMA	
new	TokenNamenew	
ResourceSelector	TokenNameIdentifier	 Resource Selector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isSelected	TokenNameIdentifier	 is Selected
(	TokenNameLPAREN	
Resource	TokenNameIdentifier	 Resource
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
isDirectory	TokenNameIdentifier	 is Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
doFilesonly	TokenNameIdentifier	 do Filesonly
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logWhenWriting	TokenNameIdentifier	 log When Writing
(	TokenNameLPAREN	
"Ignoring directory "	TokenNameStringLiteral	Ignoring directory 
+	TokenNamePLUS	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" as only files will"	TokenNameStringLiteral	 as only files will
+	TokenNamePLUS	
" be added."	TokenNameStringLiteral	 be added.
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_VERBOSE	TokenNameIdentifier	 MSG  VERBOSE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Drops all non-directory resources from the given array. * @param orig the resources to filter * @return the filters resources * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Drops all non-directory resources from the given array. @param orig the resources to filter @return the filters resources @since Ant 1.8.0 
protected	TokenNameprotected	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
selectDirectoryResources	TokenNameIdentifier	 select Directory Resources
(	TokenNameLPAREN	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
orig	TokenNameIdentifier	 orig
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
selectResources	TokenNameIdentifier	 select Resources
(	TokenNameLPAREN	
orig	TokenNameIdentifier	 orig
,	TokenNameCOMMA	
new	TokenNamenew	
ResourceSelector	TokenNameIdentifier	 Resource Selector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isSelected	TokenNameIdentifier	 is Selected
(	TokenNameLPAREN	
Resource	TokenNameIdentifier	 Resource
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
isDirectory	TokenNameIdentifier	 is Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Drops all resources from the given array that are not selected * @param orig the resources to filter * @return the filters resources * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Drops all resources from the given array that are not selected @param orig the resources to filter @return the filters resources @since Ant 1.8.0 
protected	TokenNameprotected	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
selectResources	TokenNameIdentifier	 select Resources
(	TokenNameLPAREN	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
orig	TokenNameIdentifier	 orig
,	TokenNameCOMMA	
ResourceSelector	TokenNameIdentifier	 Resource Selector
selector	TokenNameIdentifier	 selector
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
orig	TokenNameIdentifier	 orig
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
orig	TokenNameIdentifier	 orig
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ArrayList	TokenNameIdentifier	 Array List
v	TokenNameIdentifier	 v
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
orig	TokenNameIdentifier	 orig
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
orig	TokenNameIdentifier	 orig
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
selector	TokenNameIdentifier	 selector
.	TokenNameDOT	
isSelected	TokenNameIdentifier	 is Selected
(	TokenNameLPAREN	
orig	TokenNameIdentifier	 orig
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
v	TokenNameIdentifier	 v
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
orig	TokenNameIdentifier	 orig
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
v	TokenNameIdentifier	 v
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
orig	TokenNameIdentifier	 orig
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
new	TokenNamenew	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
v	TokenNameIdentifier	 v
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
v	TokenNameIdentifier	 v
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
orig	TokenNameIdentifier	 orig
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Logs a message at the given output level, but only if this is * the pass that will actually create the archive. * * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Logs a message at the given output level, but only if this is the pass that will actually create the archive. * @since Ant 1.8.0 
protected	TokenNameprotected	
void	TokenNamevoid	
logWhenWriting	TokenNameIdentifier	 log When Writing
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
msg	TokenNameIdentifier	 msg
,	TokenNameCOMMA	
int	TokenNameint	
level	TokenNameIdentifier	 level
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
skipWriting	TokenNameIdentifier	 skip Writing
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
msg	TokenNameIdentifier	 msg
,	TokenNameCOMMA	
level	TokenNameIdentifier	 level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Possible behaviors when a duplicate file is added: * "add", "preserve" or "fail" */	TokenNameCOMMENT_JAVADOC	 Possible behaviors when a duplicate file is added: "add", "preserve" or "fail" 
public	TokenNamepublic	
static	TokenNamestatic	
class	TokenNameclass	
Duplicate	TokenNameIdentifier	 Duplicate
extends	TokenNameextends	
EnumeratedAttribute	TokenNameIdentifier	 Enumerated Attribute
{	TokenNameLBRACE	
/** * @see EnumeratedAttribute#getValues() */	TokenNameCOMMENT_JAVADOC	 @see EnumeratedAttribute#getValues() 
/** {@inheritDoc} */	TokenNameCOMMENT_JAVADOC	 {@inheritDoc} 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getValues	TokenNameIdentifier	 get Values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"add"	TokenNameStringLiteral	add
,	TokenNameCOMMA	
"preserve"	TokenNameStringLiteral	preserve
,	TokenNameCOMMA	
"fail"	TokenNameStringLiteral	fail
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Holds the up-to-date status and the out-of-date resources of * the original archive. * * @since Ant 1.5.3 */	TokenNameCOMMENT_JAVADOC	 Holds the up-to-date status and the out-of-date resources of the original archive. * @since Ant 1.5.3 
public	TokenNamepublic	
static	TokenNamestatic	
class	TokenNameclass	
ArchiveState	TokenNameIdentifier	 Archive State
{	TokenNameLBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
outOfDate	TokenNameIdentifier	 out Of Date
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
resourcesToAdd	TokenNameIdentifier	 resources To Add
;	TokenNameSEMICOLON	
ArchiveState	TokenNameIdentifier	 Archive State
(	TokenNameLPAREN	
boolean	TokenNameboolean	
state	TokenNameIdentifier	 state
,	TokenNameCOMMA	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
{	TokenNameLBRACE	
outOfDate	TokenNameIdentifier	 out Of Date
=	TokenNameEQUAL	
state	TokenNameIdentifier	 state
;	TokenNameSEMICOLON	
resourcesToAdd	TokenNameIdentifier	 resources To Add
=	TokenNameEQUAL	
r	TokenNameIdentifier	 r
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return the outofdate status. * @return the outofdate status */	TokenNameCOMMENT_JAVADOC	 Return the outofdate status. @return the outofdate status 
public	TokenNamepublic	
boolean	TokenNameboolean	
isOutOfDate	TokenNameIdentifier	 is Out Of Date
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
outOfDate	TokenNameIdentifier	 out Of Date
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the resources to add. * @return the resources to add */	TokenNameCOMMENT_JAVADOC	 Get the resources to add. @return the resources to add 
public	TokenNamepublic	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getResourcesToAdd	TokenNameIdentifier	 get Resources To Add
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
resourcesToAdd	TokenNameIdentifier	 resources To Add
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * find out if there are absolutely no resources to add * @since Ant 1.6.3 * @return true if there are no resources to add */	TokenNameCOMMENT_JAVADOC	 find out if there are absolutely no resources to add @since Ant 1.6.3 @return true if there are no resources to add 
public	TokenNamepublic	
boolean	TokenNameboolean	
isWithoutAnyResources	TokenNameIdentifier	 is Without Any Resources
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
resourcesToAdd	TokenNameIdentifier	 resources To Add
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
counter	TokenNameIdentifier	 counter
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
counter	TokenNameIdentifier	 counter
<	TokenNameLESS	
resourcesToAdd	TokenNameIdentifier	 resources To Add
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
counter	TokenNameIdentifier	 counter
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
resourcesToAdd	TokenNameIdentifier	 resources To Add
[	TokenNameLBRACKET	
counter	TokenNameIdentifier	 counter
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
resourcesToAdd	TokenNameIdentifier	 resources To Add
[	TokenNameLBRACKET	
counter	TokenNameIdentifier	 counter
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Policiy for creation of Unicode extra fields: never, always or * not-encodeable. * * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Policiy for creation of Unicode extra fields: never, always or not-encodeable. * @since Ant 1.8.0 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
class	TokenNameclass	
UnicodeExtraField	TokenNameIdentifier	 Unicode Extra Field
extends	TokenNameextends	
EnumeratedAttribute	TokenNameIdentifier	 Enumerated Attribute
{	TokenNameLBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Map	TokenNameIdentifier	 Map
POLICIES	TokenNameIdentifier	 POLICIES
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
NEVER_KEY	TokenNameIdentifier	 NEVER  KEY
=	TokenNameEQUAL	
"never"	TokenNameStringLiteral	never
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
ALWAYS_KEY	TokenNameIdentifier	 ALWAYS  KEY
=	TokenNameEQUAL	
"always"	TokenNameStringLiteral	always
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
N_E_KEY	TokenNameIdentifier	 N  E  KEY
=	TokenNameEQUAL	
"not-encodeable"	TokenNameStringLiteral	not-encodeable
;	TokenNameSEMICOLON	
static	TokenNamestatic	
{	TokenNameLBRACE	
POLICIES	TokenNameIdentifier	 POLICIES
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
NEVER_KEY	TokenNameIdentifier	 NEVER  KEY
,	TokenNameCOMMA	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
.	TokenNameDOT	
UnicodeExtraFieldPolicy	TokenNameIdentifier	 Unicode Extra Field Policy
.	TokenNameDOT	
NEVER	TokenNameIdentifier	 NEVER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
POLICIES	TokenNameIdentifier	 POLICIES
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
ALWAYS_KEY	TokenNameIdentifier	 ALWAYS  KEY
,	TokenNameCOMMA	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
.	TokenNameDOT	
UnicodeExtraFieldPolicy	TokenNameIdentifier	 Unicode Extra Field Policy
.	TokenNameDOT	
ALWAYS	TokenNameIdentifier	 ALWAYS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
POLICIES	TokenNameIdentifier	 POLICIES
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
N_E_KEY	TokenNameIdentifier	 N  E  KEY
,	TokenNameCOMMA	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
.	TokenNameDOT	
UnicodeExtraFieldPolicy	TokenNameIdentifier	 Unicode Extra Field Policy
.	TokenNameDOT	
NOT_ENCODEABLE	TokenNameIdentifier	 NOT  ENCODEABLE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getValues	TokenNameIdentifier	 get Values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
NEVER_KEY	TokenNameIdentifier	 NEVER  KEY
,	TokenNameCOMMA	
ALWAYS_KEY	TokenNameIdentifier	 ALWAYS  KEY
,	TokenNameCOMMA	
N_E_KEY	TokenNameIdentifier	 N  E  KEY
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
UnicodeExtraField	TokenNameIdentifier	 Unicode Extra Field
NEVER	TokenNameIdentifier	 NEVER
=	TokenNameEQUAL	
new	TokenNamenew	
UnicodeExtraField	TokenNameIdentifier	 Unicode Extra Field
(	TokenNameLPAREN	
NEVER_KEY	TokenNameIdentifier	 NEVER  KEY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
UnicodeExtraField	TokenNameIdentifier	 Unicode Extra Field
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
setValue	TokenNameIdentifier	 set Value
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
UnicodeExtraField	TokenNameIdentifier	 Unicode Extra Field
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
.	TokenNameDOT	
UnicodeExtraFieldPolicy	TokenNameIdentifier	 Unicode Extra Field Policy
getPolicy	TokenNameIdentifier	 get Policy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
.	TokenNameDOT	
UnicodeExtraFieldPolicy	TokenNameIdentifier	 Unicode Extra Field Policy
)	TokenNameRPAREN	
POLICIES	TokenNameIdentifier	 POLICIES
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
