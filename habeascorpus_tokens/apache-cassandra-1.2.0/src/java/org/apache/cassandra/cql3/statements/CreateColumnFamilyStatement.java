/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
cql3	TokenNameIdentifier	 cql3
.	TokenNameDOT	
statements	TokenNameIdentifier	 statements
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
nio	TokenNameIdentifier	 nio
.	TokenNameDOT	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
exceptions	TokenNameIdentifier	 exceptions
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
commons	TokenNameIdentifier	 commons
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
StringUtils	TokenNameIdentifier	 String Utils
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
collect	TokenNameIdentifier	 collect
.	TokenNameDOT	
HashMultiset	TokenNameIdentifier	 Hash Multiset
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
collect	TokenNameIdentifier	 collect
.	TokenNameDOT	
Multiset	TokenNameIdentifier	 Multiset
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
auth	TokenNameIdentifier	 auth
.	TokenNameDOT	
Permission	TokenNameIdentifier	 Permission
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
ColumnDefinition	TokenNameIdentifier	 Column Definition
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
CFMetaData	TokenNameIdentifier	 CF Meta Data
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
Schema	TokenNameIdentifier	 Schema
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
cql3	TokenNameIdentifier	 cql3
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
ColumnFamilyType	TokenNameIdentifier	 Column Family Type
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
marshal	TokenNameIdentifier	 marshal
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
compress	TokenNameIdentifier	 compress
.	TokenNameDOT	
CompressionParameters	TokenNameIdentifier	 Compression Parameters
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
service	TokenNameIdentifier	 service
.	TokenNameDOT	
ClientState	TokenNameIdentifier	 Client State
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
service	TokenNameIdentifier	 service
.	TokenNameDOT	
MigrationManager	TokenNameIdentifier	 Migration Manager
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
thrift	TokenNameIdentifier	 thrift
.	TokenNameDOT	
CqlResult	TokenNameIdentifier	 Cql Result
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
transport	TokenNameIdentifier	 transport
.	TokenNameDOT	
messages	TokenNameIdentifier	 messages
.	TokenNameDOT	
ResultMessage	TokenNameIdentifier	 Result Message
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
;	TokenNameSEMICOLON	
/** A <code>CREATE COLUMNFAMILY</code> parsed from a CQL query statement. */	TokenNameCOMMENT_JAVADOC	 A <code>CREATE COLUMNFAMILY</code> parsed from a CQL query statement. 
public	TokenNamepublic	
class	TokenNameclass	
CreateColumnFamilyStatement	TokenNameIdentifier	 Create Column Family Statement
extends	TokenNameextends	
SchemaAlteringStatement	TokenNameIdentifier	 Schema Altering Statement
{	TokenNameLBRACE	
public	TokenNamepublic	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
comparator	TokenNameIdentifier	 comparator
;	TokenNameSEMICOLON	
private	TokenNameprivate	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
defaultValidator	TokenNameIdentifier	 default Validator
;	TokenNameSEMICOLON	
private	TokenNameprivate	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
keyValidator	TokenNameIdentifier	 key Validator
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
keyAliases	TokenNameIdentifier	 key Aliases
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
columnAliases	TokenNameIdentifier	 column Aliases
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
valueAlias	TokenNameIdentifier	 value Alias
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
,	TokenNameCOMMA	
AbstractType	TokenNameIdentifier	 Abstract Type
>	TokenNameGREATER	
columns	TokenNameIdentifier	 columns
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
,	TokenNameCOMMA	
AbstractType	TokenNameIdentifier	 Abstract Type
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
CFPropDefs	TokenNameIdentifier	 CF Prop Defs
properties	TokenNameIdentifier	 properties
;	TokenNameSEMICOLON	
public	TokenNamepublic	
CreateColumnFamilyStatement	TokenNameIdentifier	 Create Column Family Statement
(	TokenNameLPAREN	
CFName	TokenNameIdentifier	 CF Name
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
CFPropDefs	TokenNameIdentifier	 CF Prop Defs
properties	TokenNameIdentifier	 properties
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
properties	TokenNameIdentifier	 properties
=	TokenNameEQUAL	
properties	TokenNameIdentifier	 properties
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
this	TokenNamethis	
.	TokenNameDOT	
properties	TokenNameIdentifier	 properties
.	TokenNameDOT	
hasProperty	TokenNameIdentifier	 has Property
(	TokenNameLPAREN	
CFPropDefs	TokenNameIdentifier	 CF Prop Defs
.	TokenNameDOT	
KW_COMPRESSION	TokenNameIdentifier	 KW  COMPRESSION
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
CFMetaData	TokenNameIdentifier	 CF Meta Data
.	TokenNameDOT	
DEFAULT_COMPRESSOR	TokenNameIdentifier	 DEFAULT  COMPRESSOR
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
this	TokenNamethis	
.	TokenNameDOT	
properties	TokenNameIdentifier	 properties
.	TokenNameDOT	
addProperty	TokenNameIdentifier	 add Property
(	TokenNameLPAREN	
CFPropDefs	TokenNameIdentifier	 CF Prop Defs
.	TokenNameDOT	
KW_COMPRESSION	TokenNameIdentifier	 KW  COMPRESSION
,	TokenNameCOMMA	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
{	TokenNameLBRACE	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
CompressionParameters	TokenNameIdentifier	 Compression Parameters
.	TokenNameDOT	
SSTABLE_COMPRESSION	TokenNameIdentifier	 SSTABLE  COMPRESSION
,	TokenNameCOMMA	
CFMetaData	TokenNameIdentifier	 CF Meta Data
.	TokenNameDOT	
DEFAULT_COMPRESSOR	TokenNameIdentifier	 DEFAULT  COMPRESSOR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
SyntaxException	TokenNameIdentifier	 Syntax Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
AssertionError	TokenNameIdentifier	 Assertion Error
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
checkAccess	TokenNameIdentifier	 check Access
(	TokenNameLPAREN	
ClientState	TokenNameIdentifier	 Client State
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
throws	TokenNamethrows	
UnauthorizedException	TokenNameIdentifier	 Unauthorized Exception
,	TokenNameCOMMA	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
{	TokenNameLBRACE	
state	TokenNameIdentifier	 state
.	TokenNameDOT	
hasKeyspaceAccess	TokenNameIdentifier	 has Keyspace Access
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Permission	TokenNameIdentifier	 Permission
.	TokenNameDOT	
CREATE	TokenNameIdentifier	 CREATE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Column definitions 	TokenNameCOMMENT_LINE	Column definitions 
private	TokenNameprivate	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
ColumnDefinition	TokenNameIdentifier	 Column Definition
>	TokenNameGREATER	
getColumns	TokenNameIdentifier	 get Columns
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
{	TokenNameLBRACE	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
ColumnDefinition	TokenNameIdentifier	 Column Definition
>	TokenNameGREATER	
columnDefs	TokenNameIdentifier	 column Defs
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
ColumnDefinition	TokenNameIdentifier	 Column Definition
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Integer	TokenNameIdentifier	 Integer
componentIndex	TokenNameIdentifier	 component Index
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
comparator	TokenNameIdentifier	 comparator
instanceof	TokenNameinstanceof	
CompositeType	TokenNameIdentifier	 Composite Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CompositeType	TokenNameIdentifier	 Composite Type
ct	TokenNameIdentifier	 ct
=	TokenNameEQUAL	
(	TokenNameLPAREN	
CompositeType	TokenNameIdentifier	 Composite Type
)	TokenNameRPAREN	
comparator	TokenNameIdentifier	 comparator
;	TokenNameSEMICOLON	
componentIndex	TokenNameIdentifier	 component Index
=	TokenNameEQUAL	
ct	TokenNameIdentifier	 ct
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
ct	TokenNameIdentifier	 ct
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
instanceof	TokenNameinstanceof	
ColumnToCollectionType	TokenNameIdentifier	 Column To Collection Type
?	TokenNameQUESTION	
ct	TokenNameIdentifier	 ct
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
2	TokenNameIntegerLiteral	
:	TokenNameCOLON	
ct	TokenNameIdentifier	 ct
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
,	TokenNameCOMMA	
AbstractType	TokenNameIdentifier	 Abstract Type
>	TokenNameGREATER	
col	TokenNameIdentifier	 col
:	TokenNameCOLON	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
columnDefs	TokenNameIdentifier	 column Defs
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
col	TokenNameIdentifier	 col
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
new	TokenNamenew	
ColumnDefinition	TokenNameIdentifier	 Column Definition
(	TokenNameLPAREN	
col	TokenNameIdentifier	 col
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
col	TokenNameIdentifier	 col
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
componentIndex	TokenNameIdentifier	 component Index
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
columnDefs	TokenNameIdentifier	 column Defs
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
announceMigration	TokenNameIdentifier	 announce Migration
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
RequestValidationException	TokenNameIdentifier	 Request Validation Exception
{	TokenNameLBRACE	
MigrationManager	TokenNameIdentifier	 Migration Manager
.	TokenNameDOT	
announceNewColumnFamily	TokenNameIdentifier	 announce New Column Family
(	TokenNameLPAREN	
getCFMetaData	TokenNameIdentifier	 get CF Meta Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
ResultMessage	TokenNameIdentifier	 Result Message
.	TokenNameDOT	
SchemaChange	TokenNameIdentifier	 Schema Change
.	TokenNameDOT	
Change	TokenNameIdentifier	 Change
changeType	TokenNameIdentifier	 change Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
ResultMessage	TokenNameIdentifier	 Result Message
.	TokenNameDOT	
SchemaChange	TokenNameIdentifier	 Schema Change
.	TokenNameDOT	
Change	TokenNameIdentifier	 Change
.	TokenNameDOT	
CREATED	TokenNameIdentifier	 CREATED
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns a CFMetaData instance based on the parameters parsed from this * <code>CREATE</code> statement, or defaults where applicable. * * @return a CFMetaData instance corresponding to the values parsed from this statement * @throws InvalidRequestException on failure to validate parsed parameters */	TokenNameCOMMENT_JAVADOC	 Returns a CFMetaData instance based on the parameters parsed from this <code>CREATE</code> statement, or defaults where applicable. * @return a CFMetaData instance corresponding to the values parsed from this statement @throws InvalidRequestException on failure to validate parsed parameters 
public	TokenNamepublic	
CFMetaData	TokenNameIdentifier	 CF Meta Data
getCFMetaData	TokenNameIdentifier	 get CF Meta Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
RequestValidationException	TokenNameIdentifier	 Request Validation Exception
{	TokenNameLBRACE	
CFMetaData	TokenNameIdentifier	 CF Meta Data
newCFMD	TokenNameIdentifier	 new CFMD
;	TokenNameSEMICOLON	
newCFMD	TokenNameIdentifier	 new CFMD
=	TokenNameEQUAL	
new	TokenNamenew	
CFMetaData	TokenNameIdentifier	 CF Meta Data
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ColumnFamilyType	TokenNameIdentifier	 Column Family Type
.	TokenNameDOT	
Standard	TokenNameIdentifier	 Standard
,	TokenNameCOMMA	
comparator	TokenNameIdentifier	 comparator
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
applyPropertiesTo	TokenNameIdentifier	 apply Properties To
(	TokenNameLPAREN	
newCFMD	TokenNameIdentifier	 new CFMD
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
newCFMD	TokenNameIdentifier	 new CFMD
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
applyPropertiesTo	TokenNameIdentifier	 apply Properties To
(	TokenNameLPAREN	
CFMetaData	TokenNameIdentifier	 CF Meta Data
cfmd	TokenNameIdentifier	 cfmd
)	TokenNameRPAREN	
throws	TokenNamethrows	
RequestValidationException	TokenNameIdentifier	 Request Validation Exception
{	TokenNameLBRACE	
cfmd	TokenNameIdentifier	 cfmd
.	TokenNameDOT	
defaultValidator	TokenNameIdentifier	 default Validator
(	TokenNameLPAREN	
defaultValidator	TokenNameIdentifier	 default Validator
)	TokenNameRPAREN	
.	TokenNameDOT	
columnMetadata	TokenNameIdentifier	 column Metadata
(	TokenNameLPAREN	
getColumns	TokenNameIdentifier	 get Columns
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
keyValidator	TokenNameIdentifier	 key Validator
(	TokenNameLPAREN	
keyValidator	TokenNameIdentifier	 key Validator
)	TokenNameRPAREN	
.	TokenNameDOT	
keyAliases	TokenNameIdentifier	 key Aliases
(	TokenNameLPAREN	
keyAliases	TokenNameIdentifier	 key Aliases
)	TokenNameRPAREN	
.	TokenNameDOT	
columnAliases	TokenNameIdentifier	 column Aliases
(	TokenNameLPAREN	
columnAliases	TokenNameIdentifier	 column Aliases
)	TokenNameRPAREN	
.	TokenNameDOT	
valueAlias	TokenNameIdentifier	 value Alias
(	TokenNameLPAREN	
valueAlias	TokenNameIdentifier	 value Alias
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
properties	TokenNameIdentifier	 properties
.	TokenNameDOT	
applyToCFMetadata	TokenNameIdentifier	 apply To CF Metadata
(	TokenNameLPAREN	
cfmd	TokenNameIdentifier	 cfmd
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
class	TokenNameclass	
RawStatement	TokenNameIdentifier	 Raw Statement
extends	TokenNameextends	
CFStatement	TokenNameIdentifier	 CF Statement
{	TokenNameLBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
,	TokenNameCOMMA	
ParsedType	TokenNameIdentifier	 Parsed Type
>	TokenNameGREATER	
definitions	TokenNameIdentifier	 definitions
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
,	TokenNameCOMMA	
ParsedType	TokenNameIdentifier	 Parsed Type
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
CFPropDefs	TokenNameIdentifier	 CF Prop Defs
properties	TokenNameIdentifier	 properties
=	TokenNameEQUAL	
new	TokenNamenew	
CFPropDefs	TokenNameIdentifier	 CF Prop Defs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
>>	TokenNameRIGHT_SHIFT	
keyAliases	TokenNameIdentifier	 key Aliases
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
>	TokenNameGREATER	
columnAliases	TokenNameIdentifier	 column Aliases
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
,	TokenNameCOMMA	
Boolean	TokenNameIdentifier	 Boolean
>	TokenNameGREATER	
definedOrdering	TokenNameIdentifier	 defined Ordering
=	TokenNameEQUAL	
new	TokenNamenew	
LinkedHashMap	TokenNameIdentifier	 Linked Hash Map
<	TokenNameLESS	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
,	TokenNameCOMMA	
Boolean	TokenNameIdentifier	 Boolean
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Insertion ordering is important 	TokenNameCOMMENT_LINE	Insertion ordering is important 
private	TokenNameprivate	
boolean	TokenNameboolean	
useCompactStorage	TokenNameIdentifier	 use Compact Storage
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Multiset	TokenNameIdentifier	 Multiset
<	TokenNameLESS	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
>	TokenNameGREATER	
definedNames	TokenNameIdentifier	 defined Names
=	TokenNameEQUAL	
HashMultiset	TokenNameIdentifier	 Hash Multiset
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
RawStatement	TokenNameIdentifier	 Raw Statement
(	TokenNameLPAREN	
CFName	TokenNameIdentifier	 CF Name
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Transform this raw statement into a CreateColumnFamilyStatement. */	TokenNameCOMMENT_JAVADOC	 Transform this raw statement into a CreateColumnFamilyStatement. 
public	TokenNamepublic	
ParsedStatement	TokenNameIdentifier	 Parsed Statement
.	TokenNameDOT	
Prepared	TokenNameIdentifier	 Prepared
prepare	TokenNameIdentifier	 prepare
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
RequestValidationException	TokenNameIdentifier	 Request Validation Exception
{	TokenNameLBRACE	
// Column family name 	TokenNameCOMMENT_LINE	Column family name 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
columnFamily	TokenNameIdentifier	 column Family
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
matches	TokenNameIdentifier	 matches
(	TokenNameLPAREN	
"\w+"	TokenNameStringLiteral	\w+
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
""%s" is not a valid column family name (must be alphanumeric character only: [0-9A-Za-z]+)"	TokenNameStringLiteral	"%s" is not a valid column family name (must be alphanumeric character only: [0-9A-Za-z]+)
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
NAME_LENGTH	TokenNameIdentifier	 NAME  LENGTH
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Column family names shouldn't be more than %s characters long (got "%s")"	TokenNameStringLiteral	Column family names shouldn't be more than %s characters long (got "%s")
,	TokenNameCOMMA	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
NAME_LENGTH	TokenNameIdentifier	 NAME  LENGTH
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Multiset	TokenNameIdentifier	 Multiset
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
>	TokenNameGREATER	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
definedNames	TokenNameIdentifier	 defined Names
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
if	TokenNameif	
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getCount	TokenNameIdentifier	 get Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Multiple definition of identifier %s"	TokenNameStringLiteral	Multiple definition of identifier %s
,	TokenNameCOMMA	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getElement	TokenNameIdentifier	 get Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
properties	TokenNameIdentifier	 properties
.	TokenNameDOT	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CreateColumnFamilyStatement	TokenNameIdentifier	 Create Column Family Statement
stmt	TokenNameIdentifier	 stmt
=	TokenNameEQUAL	
new	TokenNamenew	
CreateColumnFamilyStatement	TokenNameIdentifier	 Create Column Family Statement
(	TokenNameLPAREN	
cfName	TokenNameIdentifier	 cf Name
,	TokenNameCOMMA	
properties	TokenNameIdentifier	 properties
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
setBoundTerms	TokenNameIdentifier	 set Bound Terms
(	TokenNameLPAREN	
getBoundsTerms	TokenNameIdentifier	 get Bounds Terms
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
CollectionType	TokenNameIdentifier	 Collection Type
>	TokenNameGREATER	
definedCollections	TokenNameIdentifier	 defined Collections
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
,	TokenNameCOMMA	
ParsedType	TokenNameIdentifier	 Parsed Type
>	TokenNameGREATER	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
definitions	TokenNameIdentifier	 definitions
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
id	TokenNameIdentifier	 id
=	TokenNameEQUAL	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ParsedType	TokenNameIdentifier	 Parsed Type
pt	TokenNameIdentifier	 pt
=	TokenNameEQUAL	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
pt	TokenNameIdentifier	 pt
.	TokenNameDOT	
isCollection	TokenNameIdentifier	 is Collection
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
definedCollections	TokenNameIdentifier	 defined Collections
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
definedCollections	TokenNameIdentifier	 defined Collections
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
CollectionType	TokenNameIdentifier	 Collection Type
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
definedCollections	TokenNameIdentifier	 defined Collections
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
id	TokenNameIdentifier	 id
.	TokenNameDOT	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
(	TokenNameLPAREN	
CollectionType	TokenNameIdentifier	 Collection Type
)	TokenNameRPAREN	
pt	TokenNameIdentifier	 pt
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
id	TokenNameIdentifier	 id
,	TokenNameCOMMA	
pt	TokenNameIdentifier	 pt
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// we'll remove what is not a column below 	TokenNameCOMMENT_LINE	we'll remove what is not a column below 
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
keyAliases	TokenNameIdentifier	 key Aliases
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
"You must specify one and only one PRIMARY KEY"	TokenNameStringLiteral	You must specify one and only one PRIMARY KEY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
>	TokenNameGREATER	
kAliases	TokenNameIdentifier	 k Aliases
=	TokenNameEQUAL	
keyAliases	TokenNameIdentifier	 key Aliases
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>>	TokenNameRIGHT_SHIFT	
keyTypes	TokenNameIdentifier	 key Types
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
kAliases	TokenNameIdentifier	 k Aliases
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
alias	TokenNameIdentifier	 alias
:	TokenNameCOLON	
kAliases	TokenNameIdentifier	 k Aliases
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
keyAliases	TokenNameIdentifier	 key Aliases
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
alias	TokenNameIdentifier	 alias
.	TokenNameDOT	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
getTypeAndRemove	TokenNameIdentifier	 get Type And Remove
(	TokenNameLPAREN	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
,	TokenNameCOMMA	
alias	TokenNameIdentifier	 alias
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
instanceof	TokenNameinstanceof	
CounterColumnType	TokenNameIdentifier	 Counter Column Type
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"counter type is not supported for PRIMARY KEY part %s"	TokenNameStringLiteral	counter type is not supported for PRIMARY KEY part %s
,	TokenNameCOMMA	
alias	TokenNameIdentifier	 alias
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
keyTypes	TokenNameIdentifier	 key Types
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
keyValidator	TokenNameIdentifier	 key Validator
=	TokenNameEQUAL	
keyTypes	TokenNameIdentifier	 key Types
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
keyTypes	TokenNameIdentifier	 key Types
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
:	TokenNameCOLON	
CompositeType	TokenNameIdentifier	 Composite Type
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
keyTypes	TokenNameIdentifier	 key Types
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Handle column aliases 	TokenNameCOMMENT_LINE	Handle column aliases 
if	TokenNameif	
(	TokenNameLPAREN	
columnAliases	TokenNameIdentifier	 column Aliases
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
useCompactStorage	TokenNameIdentifier	 use Compact Storage
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// There should remain some column definition since it is a non-composite "static" CF 	TokenNameCOMMENT_LINE	There should remain some column definition since it is a non-composite "static" CF 
if	TokenNameif	
(	TokenNameLPAREN	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
"No definition found that is not part of the PRIMARY KEY"	TokenNameStringLiteral	No definition found that is not part of the PRIMARY KEY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
definedCollections	TokenNameIdentifier	 defined Collections
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
"Collection types are not supported with COMPACT STORAGE"	TokenNameStringLiteral	Collection types are not supported with COMPACT STORAGE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
comparator	TokenNameIdentifier	 comparator
=	TokenNameEQUAL	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
definitionType	TokenNameIdentifier	 definition Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>>	TokenNameRIGHT_SHIFT	
types	TokenNameIdentifier	 types
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
definedCollections	TokenNameIdentifier	 defined Collections
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
definitionType	TokenNameIdentifier	 definition Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
definedCollections	TokenNameIdentifier	 defined Collections
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
ColumnToCollectionType	TokenNameIdentifier	 Column To Collection Type
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
definedCollections	TokenNameIdentifier	 defined Collections
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
comparator	TokenNameIdentifier	 comparator
=	TokenNameEQUAL	
CompositeType	TokenNameIdentifier	 Composite Type
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
types	TokenNameIdentifier	 types
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// If we use compact storage and have only one alias, it is a 	TokenNameCOMMENT_LINE	If we use compact storage and have only one alias, it is a 
// standard "dynamic" CF, otherwise it's a composite 	TokenNameCOMMENT_LINE	standard "dynamic" CF, otherwise it's a composite 
if	TokenNameif	
(	TokenNameLPAREN	
useCompactStorage	TokenNameIdentifier	 use Compact Storage
&&	TokenNameAND_AND	
columnAliases	TokenNameIdentifier	 column Aliases
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
definedCollections	TokenNameIdentifier	 defined Collections
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
"Collection types are not supported with COMPACT STORAGE"	TokenNameStringLiteral	Collection types are not supported with COMPACT STORAGE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
columnAliases	TokenNameIdentifier	 column Aliases
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
columnAliases	TokenNameIdentifier	 column Aliases
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
comparator	TokenNameIdentifier	 comparator
=	TokenNameEQUAL	
getTypeAndRemove	TokenNameIdentifier	 get Type And Remove
(	TokenNameLPAREN	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
,	TokenNameCOMMA	
columnAliases	TokenNameIdentifier	 column Aliases
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
comparator	TokenNameIdentifier	 comparator
instanceof	TokenNameinstanceof	
CounterColumnType	TokenNameIdentifier	 Counter Column Type
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"counter type is not supported for PRIMARY KEY part %s"	TokenNameStringLiteral	counter type is not supported for PRIMARY KEY part %s
,	TokenNameCOMMA	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
columnAliases	TokenNameIdentifier	 column Aliases
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>>	TokenNameRIGHT_SHIFT	
types	TokenNameIdentifier	 types
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
columnAliases	TokenNameIdentifier	 column Aliases
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
t	TokenNameIdentifier	 t
:	TokenNameCOLON	
columnAliases	TokenNameIdentifier	 column Aliases
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
columnAliases	TokenNameIdentifier	 column Aliases
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
getTypeAndRemove	TokenNameIdentifier	 get Type And Remove
(	TokenNameLPAREN	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
,	TokenNameCOMMA	
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
instanceof	TokenNameinstanceof	
CounterColumnType	TokenNameIdentifier	 Counter Column Type
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"counter type is not supported for PRIMARY KEY part %s"	TokenNameStringLiteral	counter type is not supported for PRIMARY KEY part %s
,	TokenNameCOMMA	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
useCompactStorage	TokenNameIdentifier	 use Compact Storage
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
definedCollections	TokenNameIdentifier	 defined Collections
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
"Collection types are not supported with COMPACT STORAGE"	TokenNameStringLiteral	Collection types are not supported with COMPACT STORAGE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// For sparse, we must add the last UTF8 component 	TokenNameCOMMENT_LINE	For sparse, we must add the last UTF8 component 
// and the collection type if there is one 	TokenNameCOMMENT_LINE	and the collection type if there is one 
types	TokenNameIdentifier	 types
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
definitionType	TokenNameIdentifier	 definition Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
definedCollections	TokenNameIdentifier	 defined Collections
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
ColumnToCollectionType	TokenNameIdentifier	 Column To Collection Type
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
definedCollections	TokenNameIdentifier	 defined Collections
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
"Nonsensical empty parameter list for CompositeType"	TokenNameStringLiteral	Nonsensical empty parameter list for CompositeType
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
comparator	TokenNameIdentifier	 comparator
=	TokenNameEQUAL	
CompositeType	TokenNameIdentifier	 Composite Type
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
types	TokenNameIdentifier	 types
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
useCompactStorage	TokenNameIdentifier	 use Compact Storage
&&	TokenNameAND_AND	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<=	TokenNameLESS_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
columnAliases	TokenNameIdentifier	 column Aliases
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"COMPACT STORAGE with non-composite PRIMARY KEY require one column not part of the PRIMARY KEY (got: %s)"	TokenNameStringLiteral	COMPACT STORAGE with non-composite PRIMARY KEY require one column not part of the PRIMARY KEY (got: %s)
,	TokenNameCOMMA	
StringUtils	TokenNameIdentifier	 String Utils
.	TokenNameDOT	
join	TokenNameIdentifier	 join
(	TokenNameLPAREN	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
", "	TokenNameStringLiteral	, 
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// The only value we'll insert will be the empty one, so the default validator don't matter 	TokenNameCOMMENT_LINE	The only value we'll insert will be the empty one, so the default validator don't matter 
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
defaultValidator	TokenNameIdentifier	 default Validator
=	TokenNameEQUAL	
BytesType	TokenNameIdentifier	 Bytes Type
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
;	TokenNameSEMICOLON	
// We need to distinguish between 	TokenNameCOMMENT_LINE	We need to distinguish between 
// * I'm upgrading from thrift so the valueAlias is null 	TokenNameCOMMENT_LINE	* I'm upgrading from thrift so the valueAlias is null 
// * I've define my table with only a PK (and the column value will be empty) 	TokenNameCOMMENT_LINE	* I've define my table with only a PK (and the column value will be empty) 
// So, we use an empty valueAlias (rather than null) for the second case 	TokenNameCOMMENT_LINE	So, we use an empty valueAlias (rather than null) for the second case 
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
valueAlias	TokenNameIdentifier	 value Alias
=	TokenNameEQUAL	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
EMPTY_BYTE_BUFFER	TokenNameIdentifier	 EMPTY  BYTE  BUFFER
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
,	TokenNameCOMMA	
AbstractType	TokenNameIdentifier	 Abstract Type
>	TokenNameGREATER	
lastEntry	TokenNameIdentifier	 last Entry
=	TokenNameEQUAL	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
defaultValidator	TokenNameIdentifier	 default Validator
=	TokenNameEQUAL	
lastEntry	TokenNameIdentifier	 last Entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
valueAlias	TokenNameIdentifier	 value Alias
=	TokenNameEQUAL	
lastEntry	TokenNameIdentifier	 last Entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
key	TokenNameIdentifier	 key
;	TokenNameSEMICOLON	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
lastEntry	TokenNameIdentifier	 last Entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
useCompactStorage	TokenNameIdentifier	 use Compact Storage
&&	TokenNameAND_AND	
!	TokenNameNOT	
columnAliases	TokenNameIdentifier	 column Aliases
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"COMPACT STORAGE with composite PRIMARY KEY allows no more than one column not part of the PRIMARY KEY (got: %s)"	TokenNameStringLiteral	COMPACT STORAGE with composite PRIMARY KEY allows no more than one column not part of the PRIMARY KEY (got: %s)
,	TokenNameCOMMA	
StringUtils	TokenNameIdentifier	 String Utils
.	TokenNameDOT	
join	TokenNameIdentifier	 join
(	TokenNameLPAREN	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
", "	TokenNameStringLiteral	, 
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// There is no way to insert/access a column that is not defined for non-compact storage, so 	TokenNameCOMMENT_LINE	There is no way to insert/access a column that is not defined for non-compact storage, so 
// the actual validator don't matter much (except that we want to recognize counter CF as limitation apply to them). 	TokenNameCOMMENT_LINE	the actual validator don't matter much (except that we want to recognize counter CF as limitation apply to them). 
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
defaultValidator	TokenNameIdentifier	 default Validator
=	TokenNameEQUAL	
!	TokenNameNOT	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
values	TokenNameIdentifier	 values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
instanceof	TokenNameinstanceof	
CounterColumnType	TokenNameIdentifier	 Counter Column Type
)	TokenNameRPAREN	
?	TokenNameQUESTION	
CounterColumnType	TokenNameIdentifier	 Counter Column Type
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
:	TokenNameCOLON	
BytesType	TokenNameIdentifier	 Bytes Type
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// If we give a clustering order, we must explicitely do so for all aliases and in the order of the PK 	TokenNameCOMMENT_LINE	If we give a clustering order, we must explicitely do so for all aliases and in the order of the PK 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
definedOrdering	TokenNameIdentifier	 defined Ordering
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
definedOrdering	TokenNameIdentifier	 defined Ordering
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
columnAliases	TokenNameIdentifier	 column Aliases
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
"Too much columns provided for CLUSTERING ORDER"	TokenNameStringLiteral	Too much columns provided for CLUSTERING ORDER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
id	TokenNameIdentifier	 id
:	TokenNameCOLON	
definedOrdering	TokenNameIdentifier	 defined Ordering
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
columnAliases	TokenNameIdentifier	 column Aliases
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
id	TokenNameIdentifier	 id
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
definedOrdering	TokenNameIdentifier	 defined Ordering
.	TokenNameDOT	
containsKey	TokenNameIdentifier	 contains Key
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"The order of columns in the CLUSTERING ORDER directive must be the one of the clustering key (%s must appear before %s)"	TokenNameStringLiteral	The order of columns in the CLUSTERING ORDER directive must be the one of the clustering key (%s must appear before %s)
,	TokenNameCOMMA	
c	TokenNameIdentifier	 c
,	TokenNameCOMMA	
id	TokenNameIdentifier	 id
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Missing CLUSTERING ORDER for column %s"	TokenNameStringLiteral	Missing CLUSTERING ORDER for column %s
,	TokenNameCOMMA	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
new	TokenNamenew	
ParsedStatement	TokenNameIdentifier	 Parsed Statement
.	TokenNameDOT	
Prepared	TokenNameIdentifier	 Prepared
(	TokenNameLPAREN	
stmt	TokenNameIdentifier	 stmt
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
getTypeAndRemove	TokenNameIdentifier	 get Type And Remove
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
,	TokenNameCOMMA	
AbstractType	TokenNameIdentifier	 Abstract Type
>	TokenNameGREATER	
columns	TokenNameIdentifier	 columns
,	TokenNameCOMMA	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
,	TokenNameCOMMA	
ConfigurationException	TokenNameIdentifier	 Configuration Exception
{	TokenNameLBRACE	
AbstractType	TokenNameIdentifier	 Abstract Type
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Unkown definition %s referenced in PRIMARY KEY"	TokenNameStringLiteral	Unkown definition %s referenced in PRIMARY KEY
,	TokenNameCOMMA	
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
instanceof	TokenNameinstanceof	
CollectionType	TokenNameIdentifier	 Collection Type
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Invalid collection type for PRIMARY KEY component %s"	TokenNameStringLiteral	Invalid collection type for PRIMARY KEY component %s
,	TokenNameCOMMA	
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Boolean	TokenNameIdentifier	 Boolean
isReversed	TokenNameIdentifier	 is Reversed
=	TokenNameEQUAL	
definedOrdering	TokenNameIdentifier	 defined Ordering
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
isReversed	TokenNameIdentifier	 is Reversed
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
isReversed	TokenNameIdentifier	 is Reversed
?	TokenNameQUESTION	
ReversedType	TokenNameIdentifier	 Reversed Type
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
:	TokenNameCOLON	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
addDefinition	TokenNameIdentifier	 add Definition
(	TokenNameLPAREN	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
def	TokenNameIdentifier	 def
,	TokenNameCOMMA	
ParsedType	TokenNameIdentifier	 Parsed Type
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
definedNames	TokenNameIdentifier	 defined Names
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
def	TokenNameIdentifier	 def
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
definitions	TokenNameIdentifier	 definitions
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
def	TokenNameIdentifier	 def
,	TokenNameCOMMA	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
addKeyAliases	TokenNameIdentifier	 add Key Aliases
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
>	TokenNameGREATER	
aliases	TokenNameIdentifier	 aliases
)	TokenNameRPAREN	
{	TokenNameLBRACE	
keyAliases	TokenNameIdentifier	 key Aliases
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
aliases	TokenNameIdentifier	 aliases
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
addColumnAlias	TokenNameIdentifier	 add Column Alias
(	TokenNameLPAREN	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
alias	TokenNameIdentifier	 alias
)	TokenNameRPAREN	
{	TokenNameLBRACE	
columnAliases	TokenNameIdentifier	 column Aliases
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
alias	TokenNameIdentifier	 alias
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setOrdering	TokenNameIdentifier	 set Ordering
(	TokenNameLPAREN	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
alias	TokenNameIdentifier	 alias
,	TokenNameCOMMA	
boolean	TokenNameboolean	
reversed	TokenNameIdentifier	 reversed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
definedOrdering	TokenNameIdentifier	 defined Ordering
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
alias	TokenNameIdentifier	 alias
,	TokenNameCOMMA	
reversed	TokenNameIdentifier	 reversed
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setCompactStorage	TokenNameIdentifier	 set Compact Storage
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
useCompactStorage	TokenNameIdentifier	 use Compact Storage
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
checkAccess	TokenNameIdentifier	 check Access
(	TokenNameLPAREN	
ClientState	TokenNameIdentifier	 Client State
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
UnsupportedOperationException	TokenNameIdentifier	 Unsupported Operation Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
CqlResult	TokenNameIdentifier	 Cql Result
execute	TokenNameIdentifier	 execute
(	TokenNameLPAREN	
ClientState	TokenNameIdentifier	 Client State
state	TokenNameIdentifier	 state
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
UnsupportedOperationException	TokenNameIdentifier	 Unsupported Operation Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
