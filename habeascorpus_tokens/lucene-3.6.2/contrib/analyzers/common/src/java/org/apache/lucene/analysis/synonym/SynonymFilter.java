package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
synonym	TokenNameIdentifier	 synonym
;	TokenNameSEMICOLON	
/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_JAVADOC	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
TokenFilter	TokenNameIdentifier	 Token Filter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
TokenStream	TokenNameIdentifier	 Token Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
tokenattributes	TokenNameIdentifier	 tokenattributes
.	TokenNameDOT	
CharTermAttribute	TokenNameIdentifier	 Char Term Attribute
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
tokenattributes	TokenNameIdentifier	 tokenattributes
.	TokenNameDOT	
OffsetAttribute	TokenNameIdentifier	 Offset Attribute
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
tokenattributes	TokenNameIdentifier	 tokenattributes
.	TokenNameDOT	
PositionIncrementAttribute	TokenNameIdentifier	 Position Increment Attribute
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
tokenattributes	TokenNameIdentifier	 tokenattributes
.	TokenNameDOT	
PositionLengthAttribute	TokenNameIdentifier	 Position Length Attribute
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
tokenattributes	TokenNameIdentifier	 tokenattributes
.	TokenNameDOT	
TypeAttribute	TokenNameIdentifier	 Type Attribute
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
ByteArrayDataInput	TokenNameIdentifier	 Byte Array Data Input
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayUtil	TokenNameIdentifier	 Array Util
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
AttributeSource	TokenNameIdentifier	 Attribute Source
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
BytesRef	TokenNameIdentifier	 Bytes Ref
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
CharsRef	TokenNameIdentifier	 Chars Ref
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
RamUsageEstimator	TokenNameIdentifier	 Ram Usage Estimator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
UnicodeUtil	TokenNameIdentifier	 Unicode Util
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
FST	TokenNameIdentifier	 FST
;	TokenNameSEMICOLON	
/** * Matches single or multi word synonyms in a token stream. * This token stream cannot properly handle position * increments != 1, ie, you should place this filter before * filtering out stop words. * * <p>Note that with the current implementation, parsing is * greedy, so whenever multiple parses would apply, the rule * starting the earliest and parsing the most tokens wins. * For example if you have these rules: * * <pre> * a -> x * a b -> y * b c d -> z * </pre> * * Then input <code>a b c d e</code> parses to <code>y b c * d</code>, ie the 2nd rule "wins" because it started * earliest and matched the most input tokens of other rules * starting at that point.</p> * * <p>A future improvement to this filter could allow * non-greedy parsing, such that the 3rd rule would win, and * also separately allow multiple parses, such that all 3 * rules would match, perhaps even on a rule by rule * basis.</p> * * <p><b>NOTE</b>: when a match occurs, the output tokens * associated with the matching rule are "stacked" on top of * the input stream (if the rule had * <code>keepOrig=true</code>) and also on top of aother * matched rule's output tokens. This is not a correct * solution, as really the output should be an abitrary * graph/lattice. For example, with the above match, you * would expect an exact <code>PhraseQuery</code> <code>"y b * c"</code> to match the parsed tokens, but it will fail to * do so. This limitations is necessary because Lucene's * TokenStream (and index) cannot yet represent an arbitrary * graph.</p> * * <p><b>NOTE</b>: If multiple incoming tokens arrive on the * same position, only the first token at that position is * used for parsing. Subsequent tokens simply pass through * and are not parsed. A future improvement would be to * allow these tokens to also be matched.</p> */	TokenNameCOMMENT_JAVADOC	 Matches single or multi word synonyms in a token stream. This token stream cannot properly handle position increments != 1, ie, you should place this filter before filtering out stop words. * <p>Note that with the current implementation, parsing is greedy, so whenever multiple parses would apply, the rule starting the earliest and parsing the most tokens wins. For example if you have these rules: * <pre> a -> x a b -> y b c d -> z </pre> * Then input <code>a b c d e</code> parses to <code>y b c d</code>, ie the 2nd rule "wins" because it started earliest and matched the most input tokens of other rules starting at that point.</p> * <p>A future improvement to this filter could allow non-greedy parsing, such that the 3rd rule would win, and also separately allow multiple parses, such that all 3 rules would match, perhaps even on a rule by rule basis.</p> * <p><b>NOTE</b>: when a match occurs, the output tokens associated with the matching rule are "stacked" on top of the input stream (if the rule had <code>keepOrig=true</code>) and also on top of aother matched rule's output tokens. This is not a correct solution, as really the output should be an abitrary graph/lattice. For example, with the above match, you would expect an exact <code>PhraseQuery</code> <code>"y b c"</code> to match the parsed tokens, but it will fail to do so. This limitations is necessary because Lucene's TokenStream (and index) cannot yet represent an arbitrary graph.</p> * <p><b>NOTE</b>: If multiple incoming tokens arrive on the same position, only the first token at that position is used for parsing. Subsequent tokens simply pass through and are not parsed. A future improvement would be to allow these tokens to also be matched.</p> 
// TODO: maybe we should resolve token -> wordID then run 	TokenNameCOMMENT_LINE	TODO: maybe we should resolve token -> wordID then run 
// FST on wordIDs, for better perf? 	TokenNameCOMMENT_LINE	FST on wordIDs, for better perf? 
// TODO: a more efficient approach would be Aho/Corasick's 	TokenNameCOMMENT_LINE	TODO: a more efficient approach would be Aho/Corasick's 
// algorithm 	TokenNameCOMMENT_LINE	algorithm 
// http://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_string_matching_algorithm 	TokenNameCOMMENT_LINE	http://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_string_matching_algorithm 
// It improves over the current approach here 	TokenNameCOMMENT_LINE	It improves over the current approach here 
// because it does not fully re-start matching at every 	TokenNameCOMMENT_LINE	because it does not fully re-start matching at every 
// token. For exampl,e if one pattern is "a b c x" 	TokenNameCOMMENT_LINE	token. For exampl,e if one pattern is "a b c x" 
// and another is "b c d" and the input is "a b c d", on 	TokenNameCOMMENT_LINE	and another is "b c d" and the input is "a b c d", on 
// trying to parse "a b c x" but failing when you got to x, 	TokenNameCOMMENT_LINE	trying to parse "a b c x" but failing when you got to x, 
// rather than starting over again your really should 	TokenNameCOMMENT_LINE	rather than starting over again your really should 
// immediately recognize that "b c d" matches at the next 	TokenNameCOMMENT_LINE	immediately recognize that "b c d" matches at the next 
// input. I suspect this won't matter that much in 	TokenNameCOMMENT_LINE	input. I suspect this won't matter that much in 
// practice, but it's possible on some set of synonyms it 	TokenNameCOMMENT_LINE	practice, but it's possible on some set of synonyms it 
// will. We'd have to modify Aho/Corasick to enforce our 	TokenNameCOMMENT_LINE	will. We'd have to modify Aho/Corasick to enforce our 
// conflict resolving (eg greedy matching) because that algo 	TokenNameCOMMENT_LINE	conflict resolving (eg greedy matching) because that algo 
// finds all matches. This really amounts to adding a .* 	TokenNameCOMMENT_LINE	finds all matches. This really amounts to adding a .* 
// closure to the FST and then determinizing it. 	TokenNameCOMMENT_LINE	closure to the FST and then determinizing it. 
public	TokenNamepublic	
final	TokenNamefinal	
class	TokenNameclass	
SynonymFilter	TokenNameIdentifier	 Synonym Filter
extends	TokenNameextends	
TokenFilter	TokenNameIdentifier	 Token Filter
{	TokenNameLBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
TYPE_SYNONYM	TokenNameIdentifier	 TYPE  SYNONYM
=	TokenNameEQUAL	
"SYNONYM"	TokenNameStringLiteral	SYNONYM
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
SynonymMap	TokenNameIdentifier	 Synonym Map
synonyms	TokenNameIdentifier	 synonyms
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
boolean	TokenNameboolean	
ignoreCase	TokenNameIdentifier	 ignore Case
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
rollBufferSize	TokenNameIdentifier	 roll Buffer Size
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
captureCount	TokenNameIdentifier	 capture Count
;	TokenNameSEMICOLON	
// TODO: we should set PositionLengthAttr too... 	TokenNameCOMMENT_LINE	TODO: we should set PositionLengthAttr too... 
private	TokenNameprivate	
final	TokenNamefinal	
CharTermAttribute	TokenNameIdentifier	 Char Term Attribute
termAtt	TokenNameIdentifier	 term Att
=	TokenNameEQUAL	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
CharTermAttribute	TokenNameIdentifier	 Char Term Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
PositionIncrementAttribute	TokenNameIdentifier	 Position Increment Attribute
posIncrAtt	TokenNameIdentifier	 pos Incr Att
=	TokenNameEQUAL	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
PositionIncrementAttribute	TokenNameIdentifier	 Position Increment Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
PositionLengthAttribute	TokenNameIdentifier	 Position Length Attribute
posLenAtt	TokenNameIdentifier	 pos Len Att
=	TokenNameEQUAL	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
PositionLengthAttribute	TokenNameIdentifier	 Position Length Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
TypeAttribute	TokenNameIdentifier	 Type Attribute
typeAtt	TokenNameIdentifier	 type Att
=	TokenNameEQUAL	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
TypeAttribute	TokenNameIdentifier	 Type Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
OffsetAttribute	TokenNameIdentifier	 Offset Attribute
offsetAtt	TokenNameIdentifier	 offset Att
=	TokenNameEQUAL	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
OffsetAttribute	TokenNameIdentifier	 Offset Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// How many future input tokens have already been matched 	TokenNameCOMMENT_LINE	How many future input tokens have already been matched 
// to a synonym; because the matching is "greedy" we don't 	TokenNameCOMMENT_LINE	to a synonym; because the matching is "greedy" we don't 
// try to do any more matching for such tokens: 	TokenNameCOMMENT_LINE	try to do any more matching for such tokens: 
private	TokenNameprivate	
int	TokenNameint	
inputSkipCount	TokenNameIdentifier	 input Skip Count
;	TokenNameSEMICOLON	
// Hold all buffered (read ahead) stacked input tokens for 	TokenNameCOMMENT_LINE	Hold all buffered (read ahead) stacked input tokens for 
// a future position. When multiple tokens are at the 	TokenNameCOMMENT_LINE	a future position. When multiple tokens are at the 
// same position, we only store (and match against) the 	TokenNameCOMMENT_LINE	same position, we only store (and match against) the 
// term for the first token at the position, but capture 	TokenNameCOMMENT_LINE	term for the first token at the position, but capture 
// state for (and enumerate) all other tokens at this 	TokenNameCOMMENT_LINE	state for (and enumerate) all other tokens at this 
// position: 	TokenNameCOMMENT_LINE	position: 
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
PendingInput	TokenNameIdentifier	 Pending Input
{	TokenNameLBRACE	
final	TokenNamefinal	
CharsRef	TokenNameIdentifier	 Chars Ref
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
new	TokenNamenew	
CharsRef	TokenNameIdentifier	 Chars Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AttributeSource	TokenNameIdentifier	 Attribute Source
.	TokenNameDOT	
State	TokenNameIdentifier	 State
state	TokenNameIdentifier	 state
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
keepOrig	TokenNameIdentifier	 keep Orig
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
matched	TokenNameIdentifier	 matched
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
consumed	TokenNameIdentifier	 consumed
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
int	TokenNameint	
startOffset	TokenNameIdentifier	 start Offset
;	TokenNameSEMICOLON	
int	TokenNameint	
endOffset	TokenNameIdentifier	 end Offset
;	TokenNameSEMICOLON	
public	TokenNamepublic	
void	TokenNamevoid	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
state	TokenNameIdentifier	 state
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
consumed	TokenNameIdentifier	 consumed
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
keepOrig	TokenNameIdentifier	 keep Orig
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
matched	TokenNameIdentifier	 matched
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
// Rolling buffer, holding pending input tokens we had to 	TokenNameCOMMENT_LINE	Rolling buffer, holding pending input tokens we had to 
// clone because we needed to look ahead, indexed by 	TokenNameCOMMENT_LINE	clone because we needed to look ahead, indexed by 
// position: 	TokenNameCOMMENT_LINE	position: 
private	TokenNameprivate	
final	TokenNamefinal	
PendingInput	TokenNameIdentifier	 Pending Input
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
futureInputs	TokenNameIdentifier	 future Inputs
;	TokenNameSEMICOLON	
// Holds pending output synonyms for one future position: 	TokenNameCOMMENT_LINE	Holds pending output synonyms for one future position: 
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
PendingOutputs	TokenNameIdentifier	 Pending Outputs
{	TokenNameLBRACE	
CharsRef	TokenNameIdentifier	 Chars Ref
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
outputs	TokenNameIdentifier	 outputs
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
endOffsets	TokenNameIdentifier	 end Offsets
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
posLengths	TokenNameIdentifier	 pos Lengths
;	TokenNameSEMICOLON	
int	TokenNameint	
upto	TokenNameIdentifier	 upto
;	TokenNameSEMICOLON	
int	TokenNameint	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
int	TokenNameint	
posIncr	TokenNameIdentifier	 pos Incr
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
lastEndOffset	TokenNameIdentifier	 last End Offset
;	TokenNameSEMICOLON	
int	TokenNameint	
lastPosLength	TokenNameIdentifier	 last Pos Length
;	TokenNameSEMICOLON	
public	TokenNamepublic	
PendingOutputs	TokenNameIdentifier	 Pending Outputs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
new	TokenNamenew	
CharsRef	TokenNameIdentifier	 Chars Ref
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
endOffsets	TokenNameIdentifier	 end Offsets
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
posLengths	TokenNameIdentifier	 pos Lengths
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
upto	TokenNameIdentifier	 upto
=	TokenNameEQUAL	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
posIncr	TokenNameIdentifier	 pos Incr
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
CharsRef	TokenNameIdentifier	 Chars Ref
pullNext	TokenNameIdentifier	 pull Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
upto	TokenNameIdentifier	 upto
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
lastEndOffset	TokenNameIdentifier	 last End Offset
=	TokenNameEQUAL	
endOffsets	TokenNameIdentifier	 end Offsets
[	TokenNameLBRACKET	
upto	TokenNameIdentifier	 upto
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
lastPosLength	TokenNameIdentifier	 last Pos Length
=	TokenNameEQUAL	
posLengths	TokenNameIdentifier	 pos Lengths
[	TokenNameLBRACKET	
upto	TokenNameIdentifier	 upto
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
CharsRef	TokenNameIdentifier	 Chars Ref
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
[	TokenNameLBRACKET	
upto	TokenNameIdentifier	 upto
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
posIncr	TokenNameIdentifier	 pos Incr
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
upto	TokenNameIdentifier	 upto
==	TokenNameEQUAL_EQUAL	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
result	TokenNameIdentifier	 result
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getLastEndOffset	TokenNameIdentifier	 get Last End Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
lastEndOffset	TokenNameIdentifier	 last End Offset
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getLastPosLength	TokenNameIdentifier	 get Last Pos Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
lastPosLength	TokenNameIdentifier	 last Pos Length
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
int	TokenNameint	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
int	TokenNameint	
len	TokenNameIdentifier	 len
,	TokenNameCOMMA	
int	TokenNameint	
endOffset	TokenNameIdentifier	 end Offset
,	TokenNameCOMMA	
int	TokenNameint	
posLength	TokenNameIdentifier	 pos Length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
==	TokenNameEQUAL_EQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
CharsRef	TokenNameIdentifier	 Chars Ref
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
new	TokenNamenew	
CharsRef	TokenNameIdentifier	 Chars Ref
[	TokenNameLBRACKET	
ArrayUtil	TokenNameIdentifier	 Array Util
.	TokenNameDOT	
oversize	TokenNameIdentifier	 oversize
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
count	TokenNameIdentifier	 count
,	TokenNameCOMMA	
RamUsageEstimator	TokenNameIdentifier	 Ram Usage Estimator
.	TokenNameDOT	
NUM_BYTES_OBJECT_REF	TokenNameIdentifier	 NUM  BYTES  OBJECT  REF
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
outputs	TokenNameIdentifier	 outputs
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
next	TokenNameIdentifier	 next
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
==	TokenNameEQUAL_EQUAL	
endOffsets	TokenNameIdentifier	 end Offsets
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
ArrayUtil	TokenNameIdentifier	 Array Util
.	TokenNameDOT	
oversize	TokenNameIdentifier	 oversize
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
count	TokenNameIdentifier	 count
,	TokenNameCOMMA	
RamUsageEstimator	TokenNameIdentifier	 Ram Usage Estimator
.	TokenNameDOT	
NUM_BYTES_INT	TokenNameIdentifier	 NUM  BYTES  INT
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
endOffsets	TokenNameIdentifier	 end Offsets
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
next	TokenNameIdentifier	 next
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
endOffsets	TokenNameIdentifier	 end Offsets
=	TokenNameEQUAL	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
==	TokenNameEQUAL_EQUAL	
posLengths	TokenNameIdentifier	 pos Lengths
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
ArrayUtil	TokenNameIdentifier	 Array Util
.	TokenNameDOT	
oversize	TokenNameIdentifier	 oversize
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
count	TokenNameIdentifier	 count
,	TokenNameCOMMA	
RamUsageEstimator	TokenNameIdentifier	 Ram Usage Estimator
.	TokenNameDOT	
NUM_BYTES_INT	TokenNameIdentifier	 NUM  BYTES  INT
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
posLengths	TokenNameIdentifier	 pos Lengths
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
next	TokenNameIdentifier	 next
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
posLengths	TokenNameIdentifier	 pos Lengths
=	TokenNameEQUAL	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
outputs	TokenNameIdentifier	 outputs
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
outputs	TokenNameIdentifier	 outputs
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
CharsRef	TokenNameIdentifier	 Chars Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
outputs	TokenNameIdentifier	 outputs
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
]	TokenNameRBRACKET	
.	TokenNameDOT	
copyChars	TokenNameIdentifier	 copy Chars
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
len	TokenNameIdentifier	 len
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// endOffset can be -1, in which case we should simply 	TokenNameCOMMENT_LINE	endOffset can be -1, in which case we should simply 
// use the endOffset of the input token, or X >= 0, in 	TokenNameCOMMENT_LINE	use the endOffset of the input token, or X >= 0, in 
// which case we use X as the endOffset for this output 	TokenNameCOMMENT_LINE	which case we use X as the endOffset for this output 
endOffsets	TokenNameIdentifier	 end Offsets
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
endOffset	TokenNameIdentifier	 end Offset
;	TokenNameSEMICOLON	
posLengths	TokenNameIdentifier	 pos Lengths
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
posLength	TokenNameIdentifier	 pos Length
;	TokenNameSEMICOLON	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
ByteArrayDataInput	TokenNameIdentifier	 Byte Array Data Input
bytesReader	TokenNameIdentifier	 bytes Reader
=	TokenNameEQUAL	
new	TokenNamenew	
ByteArrayDataInput	TokenNameIdentifier	 Byte Array Data Input
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Rolling buffer, holding stack of pending synonym 	TokenNameCOMMENT_LINE	Rolling buffer, holding stack of pending synonym 
// outputs, indexed by position: 	TokenNameCOMMENT_LINE	outputs, indexed by position: 
private	TokenNameprivate	
final	TokenNamefinal	
PendingOutputs	TokenNameIdentifier	 Pending Outputs
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
futureOutputs	TokenNameIdentifier	 future Outputs
;	TokenNameSEMICOLON	
// Where (in rolling buffers) to write next input saved state: 	TokenNameCOMMENT_LINE	Where (in rolling buffers) to write next input saved state: 
private	TokenNameprivate	
int	TokenNameint	
nextWrite	TokenNameIdentifier	 next Write
;	TokenNameSEMICOLON	
// Where (in rolling buffers) to read next input saved state: 	TokenNameCOMMENT_LINE	Where (in rolling buffers) to read next input saved state: 
private	TokenNameprivate	
int	TokenNameint	
nextRead	TokenNameIdentifier	 next Read
;	TokenNameSEMICOLON	
// True once we've read last token 	TokenNameCOMMENT_LINE	True once we've read last token 
private	TokenNameprivate	
boolean	TokenNameboolean	
finished	TokenNameIdentifier	 finished
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
BytesRef	TokenNameIdentifier	 Bytes Ref
>	TokenNameGREATER	
scratchArc	TokenNameIdentifier	 scratch Arc
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
BytesRef	TokenNameIdentifier	 Bytes Ref
>	TokenNameGREATER	
fst	TokenNameIdentifier	 fst
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
BytesReader	TokenNameIdentifier	 Bytes Reader
fstReader	TokenNameIdentifier	 fst Reader
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
BytesRef	TokenNameIdentifier	 Bytes Ref
scratchBytes	TokenNameIdentifier	 scratch Bytes
=	TokenNameEQUAL	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
CharsRef	TokenNameIdentifier	 Chars Ref
scratchChars	TokenNameIdentifier	 scratch Chars
=	TokenNameEQUAL	
new	TokenNamenew	
CharsRef	TokenNameIdentifier	 Chars Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * @param input input tokenstream * @param synonyms synonym map * @param ignoreCase case-folds input for matching with {@link Character#toLowerCase(int)}. * Note, if you set this to true, its your responsibility to lowercase * the input entries when you create the {@link SynonymMap} */	TokenNameCOMMENT_JAVADOC	 @param input input tokenstream @param synonyms synonym map @param ignoreCase case-folds input for matching with {@link Character#toLowerCase(int)}. Note, if you set this to true, its your responsibility to lowercase the input entries when you create the {@link SynonymMap} 
public	TokenNamepublic	
SynonymFilter	TokenNameIdentifier	 Synonym Filter
(	TokenNameLPAREN	
TokenStream	TokenNameIdentifier	 Token Stream
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
SynonymMap	TokenNameIdentifier	 Synonym Map
synonyms	TokenNameIdentifier	 synonyms
,	TokenNameCOMMA	
boolean	TokenNameboolean	
ignoreCase	TokenNameIdentifier	 ignore Case
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
synonyms	TokenNameIdentifier	 synonyms
=	TokenNameEQUAL	
synonyms	TokenNameIdentifier	 synonyms
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
ignoreCase	TokenNameIdentifier	 ignore Case
=	TokenNameEQUAL	
ignoreCase	TokenNameIdentifier	 ignore Case
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
fst	TokenNameIdentifier	 fst
=	TokenNameEQUAL	
synonyms	TokenNameIdentifier	 synonyms
.	TokenNameDOT	
fst	TokenNameIdentifier	 fst
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
fstReader	TokenNameIdentifier	 fst Reader
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
getBytesReader	TokenNameIdentifier	 get Bytes Reader
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"fst must be non-null"	TokenNameStringLiteral	fst must be non-null
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Must be 1+ so that when roll buffer is at full 	TokenNameCOMMENT_LINE	Must be 1+ so that when roll buffer is at full 
// lookahead we can distinguish this full buffer from 	TokenNameCOMMENT_LINE	lookahead we can distinguish this full buffer from 
// the empty buffer: 	TokenNameCOMMENT_LINE	the empty buffer: 
rollBufferSize	TokenNameIdentifier	 roll Buffer Size
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
synonyms	TokenNameIdentifier	 synonyms
.	TokenNameDOT	
maxHorizontalContext	TokenNameIdentifier	 max Horizontal Context
;	TokenNameSEMICOLON	
futureInputs	TokenNameIdentifier	 future Inputs
=	TokenNameEQUAL	
new	TokenNamenew	
PendingInput	TokenNameIdentifier	 Pending Input
[	TokenNameLBRACKET	
rollBufferSize	TokenNameIdentifier	 roll Buffer Size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
futureOutputs	TokenNameIdentifier	 future Outputs
=	TokenNameEQUAL	
new	TokenNamenew	
PendingOutputs	TokenNameIdentifier	 Pending Outputs
[	TokenNameLBRACKET	
rollBufferSize	TokenNameIdentifier	 roll Buffer Size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
pos	TokenNameIdentifier	 pos
<	TokenNameLESS	
rollBufferSize	TokenNameIdentifier	 roll Buffer Size
;	TokenNameSEMICOLON	
pos	TokenNameIdentifier	 pos
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
futureInputs	TokenNameIdentifier	 future Inputs
[	TokenNameLBRACKET	
pos	TokenNameIdentifier	 pos
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
PendingInput	TokenNameIdentifier	 Pending Input
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
futureOutputs	TokenNameIdentifier	 future Outputs
[	TokenNameLBRACKET	
pos	TokenNameIdentifier	 pos
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
PendingOutputs	TokenNameIdentifier	 Pending Outputs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//System.out.println("FSTFilt maxH=" + synonyms.maxHorizontalContext); 	TokenNameCOMMENT_LINE	System.out.println("FSTFilt maxH=" + synonyms.maxHorizontalContext); 
scratchArc	TokenNameIdentifier	 scratch Arc
=	TokenNameEQUAL	
new	TokenNamenew	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
BytesRef	TokenNameIdentifier	 Bytes Ref
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
capture	TokenNameIdentifier	 capture
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
captureCount	TokenNameIdentifier	 capture Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
//System.out.println(" capture slot=" + nextWrite); 	TokenNameCOMMENT_LINE	System.out.println(" capture slot=" + nextWrite); 
final	TokenNamefinal	
PendingInput	TokenNameIdentifier	 Pending Input
input	TokenNameIdentifier	 input
=	TokenNameEQUAL	
futureInputs	TokenNameIdentifier	 future Inputs
[	TokenNameLBRACKET	
nextWrite	TokenNameIdentifier	 next Write
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
state	TokenNameIdentifier	 state
=	TokenNameEQUAL	
captureState	TokenNameIdentifier	 capture State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
consumed	TokenNameIdentifier	 consumed
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
copyChars	TokenNameIdentifier	 copy Chars
(	TokenNameLPAREN	
termAtt	TokenNameIdentifier	 term Att
.	TokenNameDOT	
buffer	TokenNameIdentifier	 buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
termAtt	TokenNameIdentifier	 term Att
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
nextWrite	TokenNameIdentifier	 next Write
=	TokenNameEQUAL	
rollIncr	TokenNameIdentifier	 roll Incr
(	TokenNameLPAREN	
nextWrite	TokenNameIdentifier	 next Write
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Buffer head should never catch up to tail: 	TokenNameCOMMENT_LINE	Buffer head should never catch up to tail: 
assert	TokenNameassert	
nextWrite	TokenNameIdentifier	 next Write
!=	TokenNameNOT_EQUAL	
nextRead	TokenNameIdentifier	 next Read
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* This is the core of this TokenFilter: it locates the synonym matches and buffers up the results into futureInputs/Outputs. NOTE: this calls input.incrementToken and does not capture the state if no further tokens were checked. So caller must then forward state to our caller, or capture: */	TokenNameCOMMENT_BLOCK	 This is the core of this TokenFilter: it locates the synonym matches and buffers up the results into futureInputs/Outputs. NOTE: this calls input.incrementToken and does not capture the state if no further tokens were checked. So caller must then forward state to our caller, or capture: 
private	TokenNameprivate	
int	TokenNameint	
lastStartOffset	TokenNameIdentifier	 last Start Offset
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
lastEndOffset	TokenNameIdentifier	 last End Offset
;	TokenNameSEMICOLON	
private	TokenNameprivate	
void	TokenNamevoid	
parse	TokenNameIdentifier	 parse
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
//System.out.println("\nS: parse"); 	TokenNameCOMMENT_LINE	System.out.println("\nS: parse"); 
assert	TokenNameassert	
inputSkipCount	TokenNameIdentifier	 input Skip Count
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
curNextRead	TokenNameIdentifier	 cur Next Read
=	TokenNameEQUAL	
nextRead	TokenNameIdentifier	 next Read
;	TokenNameSEMICOLON	
// Holds the longest match we've seen so far: 	TokenNameCOMMENT_LINE	Holds the longest match we've seen so far: 
BytesRef	TokenNameIdentifier	 Bytes Ref
matchOutput	TokenNameIdentifier	 match Output
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
matchInputLength	TokenNameIdentifier	 match Input Length
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
matchEndOffset	TokenNameIdentifier	 match End Offset
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
BytesRef	TokenNameIdentifier	 Bytes Ref
pendingOutput	TokenNameIdentifier	 pending Output
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
getNoOutput	TokenNameIdentifier	 get No Output
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
getFirstArc	TokenNameIdentifier	 get First Arc
(	TokenNameLPAREN	
scratchArc	TokenNameIdentifier	 scratch Arc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
scratchArc	TokenNameIdentifier	 scratch Arc
.	TokenNameDOT	
output	TokenNameIdentifier	 output
==	TokenNameEQUAL_EQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
getNoOutput	TokenNameIdentifier	 get No Output
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
tokenCount	TokenNameIdentifier	 token Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
byToken	TokenNameIdentifier	 by Token
:	TokenNameCOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Pull next token's chars: 	TokenNameCOMMENT_LINE	Pull next token's chars: 
final	TokenNamefinal	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
buffer	TokenNameIdentifier	 buffer
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
bufferLen	TokenNameIdentifier	 buffer Len
;	TokenNameSEMICOLON	
//System.out.println(" cycle nextRead=" + curNextRead + " nextWrite=" + nextWrite); 	TokenNameCOMMENT_LINE	System.out.println(" cycle nextRead=" + curNextRead + " nextWrite=" + nextWrite); 
int	TokenNameint	
inputEndOffset	TokenNameIdentifier	 input End Offset
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curNextRead	TokenNameIdentifier	 cur Next Read
==	TokenNameEQUAL_EQUAL	
nextWrite	TokenNameIdentifier	 next Write
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// We used up our lookahead buffer of input tokens 	TokenNameCOMMENT_LINE	We used up our lookahead buffer of input tokens 
// -- pull next real input token: 	TokenNameCOMMENT_LINE	-- pull next real input token: 
if	TokenNameif	
(	TokenNameLPAREN	
finished	TokenNameIdentifier	 finished
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
//System.out.println(" input.incrToken"); 	TokenNameCOMMENT_LINE	System.out.println(" input.incrToken"); 
assert	TokenNameassert	
futureInputs	TokenNameIdentifier	 future Inputs
[	TokenNameLBRACKET	
nextWrite	TokenNameIdentifier	 next Write
]	TokenNameRBRACKET	
.	TokenNameDOT	
consumed	TokenNameIdentifier	 consumed
;	TokenNameSEMICOLON	
// Not correct: a syn match whose output is longer 	TokenNameCOMMENT_LINE	Not correct: a syn match whose output is longer 
// than its input can set future inputs keepOrig 	TokenNameCOMMENT_LINE	than its input can set future inputs keepOrig 
// to true: 	TokenNameCOMMENT_LINE	to true: 
//assert !futureInputs[nextWrite].keepOrig; 	TokenNameCOMMENT_LINE	assert !futureInputs[nextWrite].keepOrig; 
if	TokenNameif	
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
incrementToken	TokenNameIdentifier	 increment Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buffer	TokenNameIdentifier	 buffer
=	TokenNameEQUAL	
termAtt	TokenNameIdentifier	 term Att
.	TokenNameDOT	
buffer	TokenNameIdentifier	 buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bufferLen	TokenNameIdentifier	 buffer Len
=	TokenNameEQUAL	
termAtt	TokenNameIdentifier	 term Att
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
PendingInput	TokenNameIdentifier	 Pending Input
input	TokenNameIdentifier	 input
=	TokenNameEQUAL	
futureInputs	TokenNameIdentifier	 future Inputs
[	TokenNameLBRACKET	
nextWrite	TokenNameIdentifier	 next Write
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
lastStartOffset	TokenNameIdentifier	 last Start Offset
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
startOffset	TokenNameIdentifier	 start Offset
=	TokenNameEQUAL	
offsetAtt	TokenNameIdentifier	 offset Att
.	TokenNameDOT	
startOffset	TokenNameIdentifier	 start Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
lastEndOffset	TokenNameIdentifier	 last End Offset
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
endOffset	TokenNameIdentifier	 end Offset
=	TokenNameEQUAL	
offsetAtt	TokenNameIdentifier	 offset Att
.	TokenNameDOT	
endOffset	TokenNameIdentifier	 end Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
inputEndOffset	TokenNameIdentifier	 input End Offset
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
endOffset	TokenNameIdentifier	 end Offset
;	TokenNameSEMICOLON	
//System.out.println(" new token=" + new String(buffer, 0, bufferLen)); 	TokenNameCOMMENT_LINE	System.out.println(" new token=" + new String(buffer, 0, bufferLen)); 
if	TokenNameif	
(	TokenNameLPAREN	
nextRead	TokenNameIdentifier	 next Read
!=	TokenNameNOT_EQUAL	
nextWrite	TokenNameIdentifier	 next Write
)	TokenNameRPAREN	
{	TokenNameLBRACE	
capture	TokenNameIdentifier	 capture
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
consumed	TokenNameIdentifier	 consumed
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// No more input tokens 	TokenNameCOMMENT_LINE	No more input tokens 
//System.out.println(" set end"); 	TokenNameCOMMENT_LINE	System.out.println(" set end"); 
finished	TokenNameIdentifier	 finished
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Still in our lookahead 	TokenNameCOMMENT_LINE	Still in our lookahead 
buffer	TokenNameIdentifier	 buffer
=	TokenNameEQUAL	
futureInputs	TokenNameIdentifier	 future Inputs
[	TokenNameLBRACKET	
curNextRead	TokenNameIdentifier	 cur Next Read
]	TokenNameRBRACKET	
.	TokenNameDOT	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
chars	TokenNameIdentifier	 chars
;	TokenNameSEMICOLON	
bufferLen	TokenNameIdentifier	 buffer Len
=	TokenNameEQUAL	
futureInputs	TokenNameIdentifier	 future Inputs
[	TokenNameLBRACKET	
curNextRead	TokenNameIdentifier	 cur Next Read
]	TokenNameRBRACKET	
.	TokenNameDOT	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
inputEndOffset	TokenNameIdentifier	 input End Offset
=	TokenNameEQUAL	
futureInputs	TokenNameIdentifier	 future Inputs
[	TokenNameLBRACKET	
curNextRead	TokenNameIdentifier	 cur Next Read
]	TokenNameRBRACKET	
.	TokenNameDOT	
endOffset	TokenNameIdentifier	 end Offset
;	TokenNameSEMICOLON	
//System.out.println(" old token=" + new String(buffer, 0, bufferLen)); 	TokenNameCOMMENT_LINE	System.out.println(" old token=" + new String(buffer, 0, bufferLen)); 
}	TokenNameRBRACE	
tokenCount	TokenNameIdentifier	 token Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
// Run each char in this token through the FST: 	TokenNameCOMMENT_LINE	Run each char in this token through the FST: 
int	TokenNameint	
bufUpto	TokenNameIdentifier	 buf Upto
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
bufUpto	TokenNameIdentifier	 buf Upto
<	TokenNameLESS	
bufferLen	TokenNameIdentifier	 buffer Len
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
codePoint	TokenNameIdentifier	 code Point
=	TokenNameEQUAL	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
codePointAt	TokenNameIdentifier	 code Point At
(	TokenNameLPAREN	
buffer	TokenNameIdentifier	 buffer
,	TokenNameCOMMA	
bufUpto	TokenNameIdentifier	 buf Upto
,	TokenNameCOMMA	
bufferLen	TokenNameIdentifier	 buffer Len
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
findTargetArc	TokenNameIdentifier	 find Target Arc
(	TokenNameLPAREN	
ignoreCase	TokenNameIdentifier	 ignore Case
?	TokenNameQUESTION	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
toLowerCase	TokenNameIdentifier	 to Lower Case
(	TokenNameLPAREN	
codePoint	TokenNameIdentifier	 code Point
)	TokenNameRPAREN	
:	TokenNameCOLON	
codePoint	TokenNameIdentifier	 code Point
,	TokenNameCOMMA	
scratchArc	TokenNameIdentifier	 scratch Arc
,	TokenNameCOMMA	
scratchArc	TokenNameIdentifier	 scratch Arc
,	TokenNameCOMMA	
fstReader	TokenNameIdentifier	 fst Reader
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println(" stop"); 	TokenNameCOMMENT_LINE	System.out.println(" stop"); 
break	TokenNamebreak	
byToken	TokenNameIdentifier	 by Token
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Accum the output 	TokenNameCOMMENT_LINE	Accum the output 
pendingOutput	TokenNameIdentifier	 pending Output
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
pendingOutput	TokenNameIdentifier	 pending Output
,	TokenNameCOMMA	
scratchArc	TokenNameIdentifier	 scratch Arc
.	TokenNameDOT	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println(" char=" + buffer[bufUpto] + " output=" + pendingOutput + " arc.output=" + scratchArc.output); 	TokenNameCOMMENT_LINE	System.out.println(" char=" + buffer[bufUpto] + " output=" + pendingOutput + " arc.output=" + scratchArc.output); 
bufUpto	TokenNameIdentifier	 buf Upto
+=	TokenNamePLUS_EQUAL	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
charCount	TokenNameIdentifier	 char Count
(	TokenNameLPAREN	
codePoint	TokenNameIdentifier	 code Point
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// OK, entire token matched; now see if this is a final 	TokenNameCOMMENT_LINE	OK, entire token matched; now see if this is a final 
// state: 	TokenNameCOMMENT_LINE	state: 
if	TokenNameif	
(	TokenNameLPAREN	
scratchArc	TokenNameIdentifier	 scratch Arc
.	TokenNameDOT	
isFinal	TokenNameIdentifier	 is Final
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
matchOutput	TokenNameIdentifier	 match Output
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
pendingOutput	TokenNameIdentifier	 pending Output
,	TokenNameCOMMA	
scratchArc	TokenNameIdentifier	 scratch Arc
.	TokenNameDOT	
nextFinalOutput	TokenNameIdentifier	 next Final Output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
matchInputLength	TokenNameIdentifier	 match Input Length
=	TokenNameEQUAL	
tokenCount	TokenNameIdentifier	 token Count
;	TokenNameSEMICOLON	
matchEndOffset	TokenNameIdentifier	 match End Offset
=	TokenNameEQUAL	
inputEndOffset	TokenNameIdentifier	 input End Offset
;	TokenNameSEMICOLON	
//System.out.println(" found matchLength=" + matchInputLength + " output=" + matchOutput); 	TokenNameCOMMENT_LINE	System.out.println(" found matchLength=" + matchInputLength + " output=" + matchOutput); 
}	TokenNameRBRACE	
// See if the FST wants to continue matching (ie, needs to 	TokenNameCOMMENT_LINE	See if the FST wants to continue matching (ie, needs to 
// see the next input token): 	TokenNameCOMMENT_LINE	see the next input token): 
if	TokenNameif	
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
findTargetArc	TokenNameIdentifier	 find Target Arc
(	TokenNameLPAREN	
SynonymMap	TokenNameIdentifier	 Synonym Map
.	TokenNameDOT	
WORD_SEPARATOR	TokenNameIdentifier	 WORD  SEPARATOR
,	TokenNameCOMMA	
scratchArc	TokenNameIdentifier	 scratch Arc
,	TokenNameCOMMA	
scratchArc	TokenNameIdentifier	 scratch Arc
,	TokenNameCOMMA	
fstReader	TokenNameIdentifier	 fst Reader
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// No further rules can match here; we're done 	TokenNameCOMMENT_LINE	No further rules can match here; we're done 
// searching for matching rules starting at the 	TokenNameCOMMENT_LINE	searching for matching rules starting at the 
// current input position. 	TokenNameCOMMENT_LINE	current input position. 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// More matching is possible -- accum the output (if 	TokenNameCOMMENT_LINE	More matching is possible -- accum the output (if 
// any) of the WORD_SEP arc: 	TokenNameCOMMENT_LINE	any) of the WORD_SEP arc: 
pendingOutput	TokenNameIdentifier	 pending Output
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
pendingOutput	TokenNameIdentifier	 pending Output
,	TokenNameCOMMA	
scratchArc	TokenNameIdentifier	 scratch Arc
.	TokenNameDOT	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nextRead	TokenNameIdentifier	 next Read
==	TokenNameEQUAL_EQUAL	
nextWrite	TokenNameIdentifier	 next Write
)	TokenNameRPAREN	
{	TokenNameLBRACE	
capture	TokenNameIdentifier	 capture
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
curNextRead	TokenNameIdentifier	 cur Next Read
=	TokenNameEQUAL	
rollIncr	TokenNameIdentifier	 roll Incr
(	TokenNameLPAREN	
curNextRead	TokenNameIdentifier	 cur Next Read
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
nextRead	TokenNameIdentifier	 next Read
==	TokenNameEQUAL_EQUAL	
nextWrite	TokenNameIdentifier	 next Write
&&	TokenNameAND_AND	
!	TokenNameNOT	
finished	TokenNameIdentifier	 finished
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println(" skip write slot=" + nextWrite); 	TokenNameCOMMENT_LINE	System.out.println(" skip write slot=" + nextWrite); 
nextWrite	TokenNameIdentifier	 next Write
=	TokenNameEQUAL	
rollIncr	TokenNameIdentifier	 roll Incr
(	TokenNameLPAREN	
nextWrite	TokenNameIdentifier	 next Write
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
matchOutput	TokenNameIdentifier	 match Output
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println(" add matchLength=" + matchInputLength + " output=" + matchOutput); 	TokenNameCOMMENT_LINE	System.out.println(" add matchLength=" + matchInputLength + " output=" + matchOutput); 
inputSkipCount	TokenNameIdentifier	 input Skip Count
=	TokenNameEQUAL	
matchInputLength	TokenNameIdentifier	 match Input Length
;	TokenNameSEMICOLON	
addOutput	TokenNameIdentifier	 add Output
(	TokenNameLPAREN	
matchOutput	TokenNameIdentifier	 match Output
,	TokenNameCOMMA	
matchInputLength	TokenNameIdentifier	 match Input Length
,	TokenNameCOMMA	
matchEndOffset	TokenNameIdentifier	 match End Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
nextRead	TokenNameIdentifier	 next Read
!=	TokenNameNOT_EQUAL	
nextWrite	TokenNameIdentifier	 next Write
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Even though we had no match here, we set to 1 	TokenNameCOMMENT_LINE	Even though we had no match here, we set to 1 
// because we need to skip current input token before 	TokenNameCOMMENT_LINE	because we need to skip current input token before 
// trying to match again: 	TokenNameCOMMENT_LINE	trying to match again: 
inputSkipCount	TokenNameIdentifier	 input Skip Count
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
assert	TokenNameassert	
finished	TokenNameIdentifier	 finished
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//System.out.println(" parse done inputSkipCount=" + inputSkipCount + " nextRead=" + nextRead + " nextWrite=" + nextWrite); 	TokenNameCOMMENT_LINE	System.out.println(" parse done inputSkipCount=" + inputSkipCount + " nextRead=" + nextRead + " nextWrite=" + nextWrite); 
}	TokenNameRBRACE	
// Interleaves all output tokens onto the futureOutputs: 	TokenNameCOMMENT_LINE	Interleaves all output tokens onto the futureOutputs: 
private	TokenNameprivate	
void	TokenNamevoid	
addOutput	TokenNameIdentifier	 add Output
(	TokenNameLPAREN	
BytesRef	TokenNameIdentifier	 Bytes Ref
bytes	TokenNameIdentifier	 bytes
,	TokenNameCOMMA	
int	TokenNameint	
matchInputLength	TokenNameIdentifier	 match Input Length
,	TokenNameCOMMA	
int	TokenNameint	
matchEndOffset	TokenNameIdentifier	 match End Offset
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bytesReader	TokenNameIdentifier	 bytes Reader
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
bytes	TokenNameIdentifier	 bytes
.	TokenNameDOT	
bytes	TokenNameIdentifier	 bytes
,	TokenNameCOMMA	
bytes	TokenNameIdentifier	 bytes
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
bytes	TokenNameIdentifier	 bytes
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
code	TokenNameIdentifier	 code
=	TokenNameEQUAL	
bytesReader	TokenNameIdentifier	 bytes Reader
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
boolean	TokenNameboolean	
keepOrig	TokenNameIdentifier	 keep Orig
=	TokenNameEQUAL	
(	TokenNameLPAREN	
code	TokenNameIdentifier	 code
&	TokenNameAND	
0x1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
code	TokenNameIdentifier	 code
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
//System.out.println(" addOutput count=" + count + " keepOrig=" + keepOrig); 	TokenNameCOMMENT_LINE	System.out.println(" addOutput count=" + count + " keepOrig=" + keepOrig); 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
outputIDX	TokenNameIdentifier	 output IDX
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
outputIDX	TokenNameIdentifier	 output IDX
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
outputIDX	TokenNameIdentifier	 output IDX
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
synonyms	TokenNameIdentifier	 synonyms
.	TokenNameDOT	
words	TokenNameIdentifier	 words
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
bytesReader	TokenNameIdentifier	 bytes Reader
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
scratchBytes	TokenNameIdentifier	 scratch Bytes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println(" outIDX=" + outputIDX + " bytes=" + scratchBytes.length); 	TokenNameCOMMENT_LINE	System.out.println(" outIDX=" + outputIDX + " bytes=" + scratchBytes.length); 
UnicodeUtil	TokenNameIdentifier	 Unicode Util
.	TokenNameDOT	
UTF8toUTF16	TokenNameIdentifier	 UT F8to UT F16
(	TokenNameLPAREN	
scratchBytes	TokenNameIdentifier	 scratch Bytes
,	TokenNameCOMMA	
scratchChars	TokenNameIdentifier	 scratch Chars
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
lastStart	TokenNameIdentifier	 last Start
=	TokenNameEQUAL	
scratchChars	TokenNameIdentifier	 scratch Chars
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
chEnd	TokenNameIdentifier	 ch End
=	TokenNameEQUAL	
lastStart	TokenNameIdentifier	 last Start
+	TokenNamePLUS	
scratchChars	TokenNameIdentifier	 scratch Chars
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
int	TokenNameint	
outputUpto	TokenNameIdentifier	 output Upto
=	TokenNameEQUAL	
nextRead	TokenNameIdentifier	 next Read
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
chIDX	TokenNameIdentifier	 ch IDX
=	TokenNameEQUAL	
lastStart	TokenNameIdentifier	 last Start
;	TokenNameSEMICOLON	
chIDX	TokenNameIdentifier	 ch IDX
<=	TokenNameLESS_EQUAL	
chEnd	TokenNameIdentifier	 ch End
;	TokenNameSEMICOLON	
chIDX	TokenNameIdentifier	 ch IDX
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
chIDX	TokenNameIdentifier	 ch IDX
==	TokenNameEQUAL_EQUAL	
chEnd	TokenNameIdentifier	 ch End
||	TokenNameOR_OR	
scratchChars	TokenNameIdentifier	 scratch Chars
.	TokenNameDOT	
chars	TokenNameIdentifier	 chars
[	TokenNameLBRACKET	
chIDX	TokenNameIdentifier	 ch IDX
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
SynonymMap	TokenNameIdentifier	 Synonym Map
.	TokenNameDOT	
WORD_SEPARATOR	TokenNameIdentifier	 WORD  SEPARATOR
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
outputLen	TokenNameIdentifier	 output Len
=	TokenNameEQUAL	
chIDX	TokenNameIdentifier	 ch IDX
-	TokenNameMINUS	
lastStart	TokenNameIdentifier	 last Start
;	TokenNameSEMICOLON	
// Caller is not allowed to have empty string in 	TokenNameCOMMENT_LINE	Caller is not allowed to have empty string in 
// the output: 	TokenNameCOMMENT_LINE	the output: 
assert	TokenNameassert	
outputLen	TokenNameIdentifier	 output Len
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
"output contains empty string: "	TokenNameStringLiteral	output contains empty string: 
+	TokenNamePLUS	
scratchChars	TokenNameIdentifier	 scratch Chars
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
endOffset	TokenNameIdentifier	 end Offset
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
posLen	TokenNameIdentifier	 pos Len
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
chIDX	TokenNameIdentifier	 ch IDX
==	TokenNameEQUAL_EQUAL	
chEnd	TokenNameIdentifier	 ch End
&&	TokenNameAND_AND	
lastStart	TokenNameIdentifier	 last Start
==	TokenNameEQUAL_EQUAL	
scratchChars	TokenNameIdentifier	 scratch Chars
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// This rule had a single output token, so, we set 	TokenNameCOMMENT_LINE	This rule had a single output token, so, we set 
// this output's endOffset to the current 	TokenNameCOMMENT_LINE	this output's endOffset to the current 
// endOffset (ie, endOffset of the last input 	TokenNameCOMMENT_LINE	endOffset (ie, endOffset of the last input 
// token it matched): 	TokenNameCOMMENT_LINE	token it matched): 
endOffset	TokenNameIdentifier	 end Offset
=	TokenNameEQUAL	
matchEndOffset	TokenNameIdentifier	 match End Offset
;	TokenNameSEMICOLON	
posLen	TokenNameIdentifier	 pos Len
=	TokenNameEQUAL	
matchInputLength	TokenNameIdentifier	 match Input Length
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// This rule has more than one output token; we 	TokenNameCOMMENT_LINE	This rule has more than one output token; we 
// can't pick any particular endOffset for this 	TokenNameCOMMENT_LINE	can't pick any particular endOffset for this 
// case, so, we inherit the endOffset for the 	TokenNameCOMMENT_LINE	case, so, we inherit the endOffset for the 
// input token which this output overlaps: 	TokenNameCOMMENT_LINE	input token which this output overlaps: 
endOffset	TokenNameIdentifier	 end Offset
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
posLen	TokenNameIdentifier	 pos Len
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
futureOutputs	TokenNameIdentifier	 future Outputs
[	TokenNameLBRACKET	
outputUpto	TokenNameIdentifier	 output Upto
]	TokenNameRBRACKET	
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
scratchChars	TokenNameIdentifier	 scratch Chars
.	TokenNameDOT	
chars	TokenNameIdentifier	 chars
,	TokenNameCOMMA	
lastStart	TokenNameIdentifier	 last Start
,	TokenNameCOMMA	
outputLen	TokenNameIdentifier	 output Len
,	TokenNameCOMMA	
endOffset	TokenNameIdentifier	 end Offset
,	TokenNameCOMMA	
posLen	TokenNameIdentifier	 pos Len
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println(" " + new String(scratchChars.chars, lastStart, outputLen) + " outputUpto=" + outputUpto); 	TokenNameCOMMENT_LINE	System.out.println(" " + new String(scratchChars.chars, lastStart, outputLen) + " outputUpto=" + outputUpto); 
lastStart	TokenNameIdentifier	 last Start
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
chIDX	TokenNameIdentifier	 ch IDX
;	TokenNameSEMICOLON	
//System.out.println(" slot=" + outputUpto + " keepOrig=" + keepOrig); 	TokenNameCOMMENT_LINE	System.out.println(" slot=" + outputUpto + " keepOrig=" + keepOrig); 
outputUpto	TokenNameIdentifier	 output Upto
=	TokenNameEQUAL	
rollIncr	TokenNameIdentifier	 roll Incr
(	TokenNameLPAREN	
outputUpto	TokenNameIdentifier	 output Upto
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
futureOutputs	TokenNameIdentifier	 future Outputs
[	TokenNameLBRACKET	
outputUpto	TokenNameIdentifier	 output Upto
]	TokenNameRBRACKET	
.	TokenNameDOT	
posIncr	TokenNameIdentifier	 pos Incr
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
"outputUpto="	TokenNameStringLiteral	outputUpto=
+	TokenNamePLUS	
outputUpto	TokenNameIdentifier	 output Upto
+	TokenNamePLUS	
" vs nextWrite="	TokenNameStringLiteral	 vs nextWrite=
+	TokenNamePLUS	
nextWrite	TokenNameIdentifier	 next Write
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
int	TokenNameint	
upto	TokenNameIdentifier	 upto
=	TokenNameEQUAL	
nextRead	TokenNameIdentifier	 next Read
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
<	TokenNameLESS	
matchInputLength	TokenNameIdentifier	 match Input Length
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
futureInputs	TokenNameIdentifier	 future Inputs
[	TokenNameLBRACKET	
upto	TokenNameIdentifier	 upto
]	TokenNameRBRACKET	
.	TokenNameDOT	
keepOrig	TokenNameIdentifier	 keep Orig
|=	TokenNameOR_EQUAL	
keepOrig	TokenNameIdentifier	 keep Orig
;	TokenNameSEMICOLON	
futureInputs	TokenNameIdentifier	 future Inputs
[	TokenNameLBRACKET	
upto	TokenNameIdentifier	 upto
]	TokenNameRBRACKET	
.	TokenNameDOT	
matched	TokenNameIdentifier	 matched
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
upto	TokenNameIdentifier	 upto
=	TokenNameEQUAL	
rollIncr	TokenNameIdentifier	 roll Incr
(	TokenNameLPAREN	
upto	TokenNameIdentifier	 upto
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// ++ mod rollBufferSize 	TokenNameCOMMENT_LINE	++ mod rollBufferSize 
private	TokenNameprivate	
int	TokenNameint	
rollIncr	TokenNameIdentifier	 roll Incr
(	TokenNameLPAREN	
int	TokenNameint	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
==	TokenNameEQUAL_EQUAL	
rollBufferSize	TokenNameIdentifier	 roll Buffer Size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// for testing 	TokenNameCOMMENT_LINE	for testing 
int	TokenNameint	
getCaptureCount	TokenNameIdentifier	 get Capture Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
captureCount	TokenNameIdentifier	 capture Count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
boolean	TokenNameboolean	
incrementToken	TokenNameIdentifier	 increment Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
//System.out.println("\nS: incrToken inputSkipCount=" + inputSkipCount + " nextRead=" + nextRead + " nextWrite=" + nextWrite); 	TokenNameCOMMENT_LINE	System.out.println("\nS: incrToken inputSkipCount=" + inputSkipCount + " nextRead=" + nextRead + " nextWrite=" + nextWrite); 
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// First play back any buffered future inputs/outputs 	TokenNameCOMMENT_LINE	First play back any buffered future inputs/outputs 
// w/o running parsing again: 	TokenNameCOMMENT_LINE	w/o running parsing again: 
while	TokenNamewhile	
(	TokenNameLPAREN	
inputSkipCount	TokenNameIdentifier	 input Skip Count
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// At each position, we first output the original 	TokenNameCOMMENT_LINE	At each position, we first output the original 
// token 	TokenNameCOMMENT_LINE	token 
// TODO: maybe just a PendingState class, holding 	TokenNameCOMMENT_LINE	TODO: maybe just a PendingState class, holding 
// both input & outputs? 	TokenNameCOMMENT_LINE	both input & outputs? 
final	TokenNamefinal	
PendingInput	TokenNameIdentifier	 Pending Input
input	TokenNameIdentifier	 input
=	TokenNameEQUAL	
futureInputs	TokenNameIdentifier	 future Inputs
[	TokenNameLBRACKET	
nextRead	TokenNameIdentifier	 next Read
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
PendingOutputs	TokenNameIdentifier	 Pending Outputs
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
futureOutputs	TokenNameIdentifier	 future Outputs
[	TokenNameLBRACKET	
nextRead	TokenNameIdentifier	 next Read
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
//System.out.println(" cycle nextRead=" + nextRead + " nextWrite=" + nextWrite + " inputSkipCount="+ inputSkipCount + " input.keepOrig=" + input.keepOrig + " input.consumed=" + input.consumed + " input.state=" + input.state); 	TokenNameCOMMENT_LINE	System.out.println(" cycle nextRead=" + nextRead + " nextWrite=" + nextWrite + " inputSkipCount="+ inputSkipCount + " input.keepOrig=" + input.keepOrig + " input.consumed=" + input.consumed + " input.state=" + input.state); 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
consumed	TokenNameIdentifier	 consumed
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
keepOrig	TokenNameIdentifier	 keep Orig
||	TokenNameOR_OR	
!	TokenNameNOT	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
matched	TokenNameIdentifier	 matched
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
state	TokenNameIdentifier	 state
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Return a previously saved token (because we 	TokenNameCOMMENT_LINE	Return a previously saved token (because we 
// had to lookahead): 	TokenNameCOMMENT_LINE	had to lookahead): 
restoreState	TokenNameIdentifier	 restore State
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Pass-through case: return token we just pulled 	TokenNameCOMMENT_LINE	Pass-through case: return token we just pulled 
// but didn't capture: 	TokenNameCOMMENT_LINE	but didn't capture: 
assert	TokenNameassert	
inputSkipCount	TokenNameIdentifier	 input Skip Count
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
"inputSkipCount="	TokenNameStringLiteral	inputSkipCount=
+	TokenNamePLUS	
inputSkipCount	TokenNameIdentifier	 input Skip Count
+	TokenNamePLUS	
" nextRead="	TokenNameStringLiteral	 nextRead=
+	TokenNamePLUS	
nextRead	TokenNameIdentifier	 next Read
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
count	TokenNameIdentifier	 count
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
posIncr	TokenNameIdentifier	 pos Incr
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
nextRead	TokenNameIdentifier	 next Read
=	TokenNameEQUAL	
rollIncr	TokenNameIdentifier	 roll Incr
(	TokenNameLPAREN	
nextRead	TokenNameIdentifier	 next Read
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
inputSkipCount	TokenNameIdentifier	 input Skip Count
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//System.out.println(" return token=" + termAtt.toString()); 	TokenNameCOMMENT_LINE	System.out.println(" return token=" + termAtt.toString()); 
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
upto	TokenNameIdentifier	 upto
<	TokenNameLESS	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Still have pending outputs to replay at this 	TokenNameCOMMENT_LINE	Still have pending outputs to replay at this 
// position 	TokenNameCOMMENT_LINE	position 
input	TokenNameIdentifier	 input
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
posIncr	TokenNameIdentifier	 pos Incr
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
posIncr	TokenNameIdentifier	 pos Incr
;	TokenNameSEMICOLON	
final	TokenNamefinal	
CharsRef	TokenNameIdentifier	 Chars Ref
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
pullNext	TokenNameIdentifier	 pull Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
clearAttributes	TokenNameIdentifier	 clear Attributes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
termAtt	TokenNameIdentifier	 term Att
.	TokenNameDOT	
copyBuffer	TokenNameIdentifier	 copy Buffer
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
chars	TokenNameIdentifier	 chars
,	TokenNameCOMMA	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
typeAtt	TokenNameIdentifier	 type Att
.	TokenNameDOT	
setType	TokenNameIdentifier	 set Type
(	TokenNameLPAREN	
TYPE_SYNONYM	TokenNameIdentifier	 TYPE  SYNONYM
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
endOffset	TokenNameIdentifier	 end Offset
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
getLastEndOffset	TokenNameIdentifier	 get Last End Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
endOffset	TokenNameIdentifier	 end Offset
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
endOffset	TokenNameIdentifier	 end Offset
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
endOffset	TokenNameIdentifier	 end Offset
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
offsetAtt	TokenNameIdentifier	 offset Att
.	TokenNameDOT	
setOffset	TokenNameIdentifier	 set Offset
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
startOffset	TokenNameIdentifier	 start Offset
,	TokenNameCOMMA	
endOffset	TokenNameIdentifier	 end Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
posIncrAtt	TokenNameIdentifier	 pos Incr Att
.	TokenNameDOT	
setPositionIncrement	TokenNameIdentifier	 set Position Increment
(	TokenNameLPAREN	
posIncr	TokenNameIdentifier	 pos Incr
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
posLenAtt	TokenNameIdentifier	 pos Len Att
.	TokenNameDOT	
setPositionLength	TokenNameIdentifier	 set Position Length
(	TokenNameLPAREN	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
getLastPosLength	TokenNameIdentifier	 get Last Pos Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
count	TokenNameIdentifier	 count
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Done with the buffered input and all outputs at 	TokenNameCOMMENT_LINE	Done with the buffered input and all outputs at 
// this position 	TokenNameCOMMENT_LINE	this position 
nextRead	TokenNameIdentifier	 next Read
=	TokenNameEQUAL	
rollIncr	TokenNameIdentifier	 roll Incr
(	TokenNameLPAREN	
nextRead	TokenNameIdentifier	 next Read
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
inputSkipCount	TokenNameIdentifier	 input Skip Count
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//System.out.println(" return token=" + termAtt.toString()); 	TokenNameCOMMENT_LINE	System.out.println(" return token=" + termAtt.toString()); 
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Done with the buffered input and all outputs at 	TokenNameCOMMENT_LINE	Done with the buffered input and all outputs at 
// this position 	TokenNameCOMMENT_LINE	this position 
input	TokenNameIdentifier	 input
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
nextRead	TokenNameIdentifier	 next Read
=	TokenNameEQUAL	
rollIncr	TokenNameIdentifier	 roll Incr
(	TokenNameLPAREN	
nextRead	TokenNameIdentifier	 next Read
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
inputSkipCount	TokenNameIdentifier	 input Skip Count
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
finished	TokenNameIdentifier	 finished
&&	TokenNameAND_AND	
nextRead	TokenNameIdentifier	 next Read
==	TokenNameEQUAL_EQUAL	
nextWrite	TokenNameIdentifier	 next Write
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// End case: if any output syns went beyond end of 	TokenNameCOMMENT_LINE	End case: if any output syns went beyond end of 
// input stream, enumerate them now: 	TokenNameCOMMENT_LINE	input stream, enumerate them now: 
final	TokenNamefinal	
PendingOutputs	TokenNameIdentifier	 Pending Outputs
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
futureOutputs	TokenNameIdentifier	 future Outputs
[	TokenNameLBRACKET	
nextRead	TokenNameIdentifier	 next Read
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
upto	TokenNameIdentifier	 upto
<	TokenNameLESS	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
posIncr	TokenNameIdentifier	 pos Incr
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
posIncr	TokenNameIdentifier	 pos Incr
;	TokenNameSEMICOLON	
final	TokenNamefinal	
CharsRef	TokenNameIdentifier	 Chars Ref
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
pullNext	TokenNameIdentifier	 pull Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
futureInputs	TokenNameIdentifier	 future Inputs
[	TokenNameLBRACKET	
nextRead	TokenNameIdentifier	 next Read
]	TokenNameRBRACKET	
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
count	TokenNameIdentifier	 count
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nextWrite	TokenNameIdentifier	 next Write
=	TokenNameEQUAL	
nextRead	TokenNameIdentifier	 next Read
=	TokenNameEQUAL	
rollIncr	TokenNameIdentifier	 roll Incr
(	TokenNameLPAREN	
nextRead	TokenNameIdentifier	 next Read
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
clearAttributes	TokenNameIdentifier	 clear Attributes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Keep offset from last input token: 	TokenNameCOMMENT_LINE	Keep offset from last input token: 
offsetAtt	TokenNameIdentifier	 offset Att
.	TokenNameDOT	
setOffset	TokenNameIdentifier	 set Offset
(	TokenNameLPAREN	
lastStartOffset	TokenNameIdentifier	 last Start Offset
,	TokenNameCOMMA	
lastEndOffset	TokenNameIdentifier	 last End Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
termAtt	TokenNameIdentifier	 term Att
.	TokenNameDOT	
copyBuffer	TokenNameIdentifier	 copy Buffer
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
chars	TokenNameIdentifier	 chars
,	TokenNameCOMMA	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
typeAtt	TokenNameIdentifier	 type Att
.	TokenNameDOT	
setType	TokenNameIdentifier	 set Type
(	TokenNameLPAREN	
TYPE_SYNONYM	TokenNameIdentifier	 TYPE  SYNONYM
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println(" set posIncr=" + outputs.posIncr + " outputs=" + outputs); 	TokenNameCOMMENT_LINE	System.out.println(" set posIncr=" + outputs.posIncr + " outputs=" + outputs); 
posIncrAtt	TokenNameIdentifier	 pos Incr Att
.	TokenNameDOT	
setPositionIncrement	TokenNameIdentifier	 set Position Increment
(	TokenNameLPAREN	
posIncr	TokenNameIdentifier	 pos Incr
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println(" return token=" + termAtt.toString()); 	TokenNameCOMMENT_LINE	System.out.println(" return token=" + termAtt.toString()); 
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Find new synonym matches: 	TokenNameCOMMENT_LINE	Find new synonym matches: 
parse	TokenNameIdentifier	 parse
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
captureCount	TokenNameIdentifier	 capture Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
finished	TokenNameIdentifier	 finished
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
inputSkipCount	TokenNameIdentifier	 input Skip Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
nextRead	TokenNameIdentifier	 next Read
=	TokenNameEQUAL	
nextWrite	TokenNameIdentifier	 next Write
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// In normal usage these resets would not be needed, 	TokenNameCOMMENT_LINE	In normal usage these resets would not be needed, 
// since they reset-as-they-are-consumed, but the app 	TokenNameCOMMENT_LINE	since they reset-as-they-are-consumed, but the app 
// may not consume all input tokens (or we might hit an 	TokenNameCOMMENT_LINE	may not consume all input tokens (or we might hit an 
// exception), in which case we have leftover state 	TokenNameCOMMENT_LINE	exception), in which case we have leftover state 
// here: 	TokenNameCOMMENT_LINE	here: 
for	TokenNamefor	
(	TokenNameLPAREN	
PendingInput	TokenNameIdentifier	 Pending Input
input	TokenNameIdentifier	 input
:	TokenNameCOLON	
futureInputs	TokenNameIdentifier	 future Inputs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
PendingOutputs	TokenNameIdentifier	 Pending Outputs
output	TokenNameIdentifier	 output
:	TokenNameCOLON	
futureOutputs	TokenNameIdentifier	 future Outputs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
