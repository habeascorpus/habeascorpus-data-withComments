/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
service	TokenNameIdentifier	 service
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
ByteArrayInputStream	TokenNameIdentifier	 Byte Array Input Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
DataInputStream	TokenNameIdentifier	 Data Input Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
File	TokenNameIdentifier	 File
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
management	TokenNameIdentifier	 management
.	TokenNameDOT	
ManagementFactory	TokenNameIdentifier	 Management Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
net	TokenNameIdentifier	 net
.	TokenNameDOT	
InetAddress	TokenNameIdentifier	 Inet Address
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
net	TokenNameIdentifier	 net
.	TokenNameDOT	
UnknownHostException	TokenNameIdentifier	 Unknown Host Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
nio	TokenNameIdentifier	 nio
.	TokenNameDOT	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
atomic	TokenNameIdentifier	 atomic
.	TokenNameDOT	
AtomicInteger	TokenNameIdentifier	 Atomic Integer
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
management	TokenNameIdentifier	 management
.	TokenNameDOT	
MBeanServer	TokenNameIdentifier	 M Bean Server
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
management	TokenNameIdentifier	 management
.	TokenNameDOT	
ObjectName	TokenNameIdentifier	 Object Name
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
collect	TokenNameIdentifier	 collect
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
log4j	TokenNameIdentifier	 log4j
.	TokenNameDOT	
Level	TokenNameIdentifier	 Level
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
commons	TokenNameIdentifier	 commons
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
StringUtils	TokenNameIdentifier	 String Utils
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
slf4j	TokenNameIdentifier	 slf4j
.	TokenNameDOT	
Logger	TokenNameIdentifier	 Logger
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
slf4j	TokenNameIdentifier	 slf4j
.	TokenNameDOT	
LoggerFactory	TokenNameIdentifier	 Logger Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
auth	TokenNameIdentifier	 auth
.	TokenNameDOT	
Auth	TokenNameIdentifier	 Auth
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
DebuggableScheduledThreadPoolExecutor	TokenNameIdentifier	 Debuggable Scheduled Thread Pool Executor
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
Stage	TokenNameIdentifier	 Stage
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
StageManager	TokenNameIdentifier	 Stage Manager
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
CFMetaData	TokenNameIdentifier	 CF Meta Data
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
KSMetaData	TokenNameIdentifier	 KS Meta Data
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
Schema	TokenNameIdentifier	 Schema
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
Table	TokenNameIdentifier	 Table
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
commitlog	TokenNameIdentifier	 commitlog
.	TokenNameDOT	
CommitLog	TokenNameIdentifier	 Commit Log
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
dht	TokenNameIdentifier	 dht
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
dht	TokenNameIdentifier	 dht
.	TokenNameDOT	
Range	TokenNameIdentifier	 Range
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
exceptions	TokenNameIdentifier	 exceptions
.	TokenNameDOT	
ConfigurationException	TokenNameIdentifier	 Configuration Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
exceptions	TokenNameIdentifier	 exceptions
.	TokenNameDOT	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
exceptions	TokenNameIdentifier	 exceptions
.	TokenNameDOT	
UnavailableException	TokenNameIdentifier	 Unavailable Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
gms	TokenNameIdentifier	 gms
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
SSTableDeletingTask	TokenNameIdentifier	 SS Table Deleting Task
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
SSTableLoader	TokenNameIdentifier	 SS Table Loader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
FileUtils	TokenNameIdentifier	 File Utils
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
locator	TokenNameIdentifier	 locator
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
StorageMetrics	TokenNameIdentifier	 Storage Metrics
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
net	TokenNameIdentifier	 net
.	TokenNameDOT	
IAsyncResult	TokenNameIdentifier	 I Async Result
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
net	TokenNameIdentifier	 net
.	TokenNameDOT	
MessageOut	TokenNameIdentifier	 Message Out
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
net	TokenNameIdentifier	 net
.	TokenNameDOT	
MessagingService	TokenNameIdentifier	 Messaging Service
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
net	TokenNameIdentifier	 net
.	TokenNameDOT	
ResponseVerbHandler	TokenNameIdentifier	 Response Verb Handler
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
service	TokenNameIdentifier	 service
.	TokenNameDOT	
AntiEntropyService	TokenNameIdentifier	 Anti Entropy Service
.	TokenNameDOT	
TreeRequestVerbHandler	TokenNameIdentifier	 Tree Request Verb Handler
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
streaming	TokenNameIdentifier	 streaming
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
thrift	TokenNameIdentifier	 thrift
.	TokenNameDOT	
Constants	TokenNameIdentifier	 Constants
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
thrift	TokenNameIdentifier	 thrift
.	TokenNameDOT	
EndpointDetails	TokenNameIdentifier	 Endpoint Details
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
thrift	TokenNameIdentifier	 thrift
.	TokenNameDOT	
TokenRange	TokenNameIdentifier	 Token Range
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
tracing	TokenNameIdentifier	 tracing
.	TokenNameDOT	
Tracing	TokenNameIdentifier	 Tracing
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
static	TokenNamestatic	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
base	TokenNameIdentifier	 base
.	TokenNameDOT	
Charsets	TokenNameIdentifier	 Charsets
.	TokenNameDOT	
ISO_8859_1	TokenNameIdentifier	 ISO 8859 1
;	TokenNameSEMICOLON	
/** * This abstraction contains the token/identifier of this node * on the identifier space. This token gets gossiped around. * This class will also maintain histograms of the load information * of other nodes in the cluster. */	TokenNameCOMMENT_JAVADOC	 This abstraction contains the token/identifier of this node on the identifier space. This token gets gossiped around. This class will also maintain histograms of the load information of other nodes in the cluster. 
public	TokenNamepublic	
class	TokenNameclass	
StorageService	TokenNameIdentifier	 Storage Service
implements	TokenNameimplements	
IEndpointStateChangeSubscriber	TokenNameIdentifier	 I Endpoint State Change Subscriber
,	TokenNameCOMMA	
StorageServiceMBean	TokenNameIdentifier	 Storage Service M Bean
{	TokenNameLBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Logger	TokenNameIdentifier	 Logger
logger	TokenNameIdentifier	 logger
=	TokenNameEQUAL	
LoggerFactory	TokenNameIdentifier	 Logger Factory
.	TokenNameDOT	
getLogger	TokenNameIdentifier	 get Logger
(	TokenNameLPAREN	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
RING_DELAY	TokenNameIdentifier	 RING  DELAY
=	TokenNameEQUAL	
getRingDelay	TokenNameIdentifier	 get Ring Delay
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// delay after which we assume ring has stablized 	TokenNameCOMMENT_LINE	delay after which we assume ring has stablized 
private	TokenNameprivate	
static	TokenNamestatic	
int	TokenNameint	
getRingDelay	TokenNameIdentifier	 get Ring Delay
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
newdelay	TokenNameIdentifier	 newdelay
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"cassandra.ring_delay_ms"	TokenNameStringLiteral	cassandra.ring_delay_ms
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
newdelay	TokenNameIdentifier	 newdelay
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Overriding RING_DELAY to {}ms"	TokenNameStringLiteral	Overriding RING_DELAY to {}ms
,	TokenNameCOMMA	
newdelay	TokenNameIdentifier	 newdelay
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
parseInt	TokenNameIdentifier	 parse Int
(	TokenNameLPAREN	
newdelay	TokenNameIdentifier	 newdelay
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
return	TokenNamereturn	
30	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
1000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * This pool is used for periodic short (sub-second) tasks. */	TokenNameCOMMENT_JAVADOC	 This pool is used for periodic short (sub-second) tasks. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
DebuggableScheduledThreadPoolExecutor	TokenNameIdentifier	 Debuggable Scheduled Thread Pool Executor
scheduledTasks	TokenNameIdentifier	 scheduled Tasks
=	TokenNameEQUAL	
new	TokenNamenew	
DebuggableScheduledThreadPoolExecutor	TokenNameIdentifier	 Debuggable Scheduled Thread Pool Executor
(	TokenNameLPAREN	
"ScheduledTasks"	TokenNameStringLiteral	ScheduledTasks
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * This pool is used by tasks that can have longer execution times, and usually are non periodic. */	TokenNameCOMMENT_JAVADOC	 This pool is used by tasks that can have longer execution times, and usually are non periodic. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
DebuggableScheduledThreadPoolExecutor	TokenNameIdentifier	 Debuggable Scheduled Thread Pool Executor
tasks	TokenNameIdentifier	 tasks
=	TokenNameEQUAL	
new	TokenNamenew	
DebuggableScheduledThreadPoolExecutor	TokenNameIdentifier	 Debuggable Scheduled Thread Pool Executor
(	TokenNameLPAREN	
"NonPeriodicTasks"	TokenNameStringLiteral	NonPeriodicTasks
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * tasks that do not need to be waited for on shutdown/drain */	TokenNameCOMMENT_JAVADOC	 tasks that do not need to be waited for on shutdown/drain 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
DebuggableScheduledThreadPoolExecutor	TokenNameIdentifier	 Debuggable Scheduled Thread Pool Executor
optionalTasks	TokenNameIdentifier	 optional Tasks
=	TokenNameEQUAL	
new	TokenNamenew	
DebuggableScheduledThreadPoolExecutor	TokenNameIdentifier	 Debuggable Scheduled Thread Pool Executor
(	TokenNameLPAREN	
"OptionalTasks"	TokenNameStringLiteral	OptionalTasks
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
{	TokenNameLBRACE	
tasks	TokenNameIdentifier	 tasks
.	TokenNameDOT	
setExecuteExistingDelayedTasksAfterShutdownPolicy	TokenNameIdentifier	 set Execute Existing Delayed Tasks After Shutdown Policy
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* This abstraction maintains the token/endpoint metadata information */	TokenNameCOMMENT_BLOCK	 This abstraction maintains the token/endpoint metadata information 
private	TokenNameprivate	
TokenMetadata	TokenNameIdentifier	 Token Metadata
tokenMetadata	TokenNameIdentifier	 token Metadata
=	TokenNameEQUAL	
new	TokenNamenew	
TokenMetadata	TokenNameIdentifier	 Token Metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
VersionedValue	TokenNameIdentifier	 Versioned Value
.	TokenNameDOT	
VersionedValueFactory	TokenNameIdentifier	 Versioned Value Factory
valueFactory	TokenNameIdentifier	 value Factory
=	TokenNameEQUAL	
new	TokenNamenew	
VersionedValue	TokenNameIdentifier	 Versioned Value
.	TokenNameDOT	
VersionedValueFactory	TokenNameIdentifier	 Versioned Value Factory
(	TokenNameLPAREN	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
StorageService	TokenNameIdentifier	 Storage Service
instance	TokenNameIdentifier	 instance
=	TokenNameEQUAL	
new	TokenNamenew	
StorageService	TokenNameIdentifier	 Storage Service
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
StorageMetrics	TokenNameIdentifier	 Storage Metrics
metrics	TokenNameIdentifier	 metrics
=	TokenNameEQUAL	
new	TokenNamenew	
StorageMetrics	TokenNameIdentifier	 Storage Metrics
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
IPartitioner	TokenNameIdentifier	 I Partitioner
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
getLocalRanges	TokenNameIdentifier	 get Local Ranges
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getRangesForEndpoint	TokenNameIdentifier	 get Ranges For Endpoint
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
getLocalPrimaryRanges	TokenNameIdentifier	 get Local Primary Ranges
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getPrimaryRangesForEndpoint	TokenNameIdentifier	 get Primary Ranges For Endpoint
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
public	TokenNamepublic	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
getLocalPrimaryRange	TokenNameIdentifier	 get Local Primary Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getPrimaryRangeForEndpoint	TokenNameIdentifier	 get Primary Range For Endpoint
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// For JMX's sake. Use getLocalPrimaryRange for internal uses 	TokenNameCOMMENT_LINE	For JMX's sake. Use getLocalPrimaryRange for internal uses 
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
getPrimaryRange	TokenNameIdentifier	 get Primary Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getLocalPrimaryRange	TokenNameIdentifier	 get Local Primary Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
asList	TokenNameIdentifier	 as List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
replicatingNodes	TokenNameIdentifier	 replicating Nodes
=	TokenNameEQUAL	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
synchronizedSet	TokenNameIdentifier	 synchronized Set
(	TokenNameLPAREN	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
CassandraDaemon	TokenNameIdentifier	 Cassandra Daemon
daemon	TokenNameIdentifier	 daemon
;	TokenNameSEMICOLON	
private	TokenNameprivate	
InetAddress	TokenNameIdentifier	 Inet Address
removingNode	TokenNameIdentifier	 removing Node
;	TokenNameSEMICOLON	
/* Are we starting this node in bootstrap mode? */	TokenNameCOMMENT_BLOCK	 Are we starting this node in bootstrap mode? 
private	TokenNameprivate	
boolean	TokenNameboolean	
isBootstrapMode	TokenNameIdentifier	 is Bootstrap Mode
;	TokenNameSEMICOLON	
/* we bootstrap but do NOT join the ring unless told to do so */	TokenNameCOMMENT_BLOCK	 we bootstrap but do NOT join the ring unless told to do so 
private	TokenNameprivate	
boolean	TokenNameboolean	
isSurveyMode	TokenNameIdentifier	 is Survey Mode
=	TokenNameEQUAL	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
parseBoolean	TokenNameIdentifier	 parse Boolean
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"cassandra.write_survey"	TokenNameStringLiteral	cassandra.write_survey
,	TokenNameCOMMA	
"false"	TokenNameStringLiteral	false
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* when intialized as a client, we shouldn't write to the system table. */	TokenNameCOMMENT_BLOCK	 when intialized as a client, we shouldn't write to the system table. 
private	TokenNameprivate	
boolean	TokenNameboolean	
isClientMode	TokenNameIdentifier	 is Client Mode
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
initialized	TokenNameIdentifier	 initialized
;	TokenNameSEMICOLON	
private	TokenNameprivate	
volatile	TokenNamevolatile	
boolean	TokenNameboolean	
joined	TokenNameIdentifier	 joined
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/* the probability for tracing any particular request, 0 disables tracing and 1 enables for all */	TokenNameCOMMENT_BLOCK	 the probability for tracing any particular request, 0 disables tracing and 1 enables for all 
private	TokenNameprivate	
double	TokenNamedouble	
tracingProbability	TokenNameIdentifier	 tracing Probability
=	TokenNameEQUAL	
0.0	TokenNameDoubleLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
enum	TokenNameenum	
Mode	TokenNameIdentifier	 Mode
{	TokenNameLBRACE	
NORMAL	TokenNameIdentifier	 NORMAL
,	TokenNameCOMMA	
CLIENT	TokenNameIdentifier	 CLIENT
,	TokenNameCOMMA	
JOINING	TokenNameIdentifier	 JOINING
,	TokenNameCOMMA	
LEAVING	TokenNameIdentifier	 LEAVING
,	TokenNameCOMMA	
DECOMMISSIONED	TokenNameIdentifier	 DECOMMISSIONED
,	TokenNameCOMMA	
MOVING	TokenNameIdentifier	 MOVING
,	TokenNameCOMMA	
DRAINING	TokenNameIdentifier	 DRAINING
,	TokenNameCOMMA	
DRAINED	TokenNameIdentifier	 DRAINED
,	TokenNameCOMMA	
RELOCATING	TokenNameIdentifier	 RELOCATING
}	TokenNameRBRACE	
private	TokenNameprivate	
Mode	TokenNameIdentifier	 Mode
operationMode	TokenNameIdentifier	 operation Mode
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
MigrationManager	TokenNameIdentifier	 Migration Manager
migrationManager	TokenNameIdentifier	 migration Manager
=	TokenNameEQUAL	
MigrationManager	TokenNameIdentifier	 Migration Manager
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
;	TokenNameSEMICOLON	
/* Used for tracking drain progress */	TokenNameCOMMENT_BLOCK	 Used for tracking drain progress 
private	TokenNameprivate	
volatile	TokenNamevolatile	
int	TokenNameint	
totalCFs	TokenNameIdentifier	 total C Fs
,	TokenNameCOMMA	
remainingCFs	TokenNameIdentifier	 remaining C Fs
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
AtomicInteger	TokenNameIdentifier	 Atomic Integer
nextRepairCommand	TokenNameIdentifier	 next Repair Command
=	TokenNameEQUAL	
new	TokenNamenew	
AtomicInteger	TokenNameIdentifier	 Atomic Integer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
ScheduledRangeTransferExecutorService	TokenNameIdentifier	 Scheduled Range Transfer Executor Service
rangeXferExecutor	TokenNameIdentifier	 range Xfer Executor
=	TokenNameEQUAL	
new	TokenNamenew	
ScheduledRangeTransferExecutorService	TokenNameIdentifier	 Scheduled Range Transfer Executor Service
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
IEndpointLifecycleSubscriber	TokenNameIdentifier	 I Endpoint Lifecycle Subscriber
>	TokenNameGREATER	
lifecycleSubscribers	TokenNameIdentifier	 lifecycle Subscribers
=	TokenNameEQUAL	
new	TokenNamenew	
CopyOnWriteArrayList	TokenNameIdentifier	 Copy On Write Array List
<	TokenNameLESS	
IEndpointLifecycleSubscriber	TokenNameIdentifier	 I Endpoint Lifecycle Subscriber
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
void	TokenNamevoid	
finishBootstrapping	TokenNameIdentifier	 finish Bootstrapping
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
isBootstrapMode	TokenNameIdentifier	 is Bootstrap Mode
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** This method updates the local token on disk */	TokenNameCOMMENT_JAVADOC	 This method updates the local token on disk 
public	TokenNamepublic	
void	TokenNamevoid	
setTokens	TokenNameIdentifier	 set Tokens
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Setting tokens to {}"	TokenNameStringLiteral	Setting tokens to {}
,	TokenNameCOMMA	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
updateTokens	TokenNameIdentifier	 update Tokens
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
updateNormalTokens	TokenNameIdentifier	 update Normal Tokens
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// order is important here, the gossiper can fire in between adding these two states. It's ok to send TOKENS without STATUS, but *not* vice versa. 	TokenNameCOMMENT_LINE	order is important here, the gossiper can fire in between adding these two states. It's ok to send TOKENS without STATUS, but *not* vice versa. 
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
addLocalApplicationState	TokenNameIdentifier	 add Local Application State
(	TokenNameLPAREN	
ApplicationState	TokenNameIdentifier	 Application State
.	TokenNameDOT	
TOKENS	TokenNameIdentifier	 TOKENS
,	TokenNameCOMMA	
valueFactory	TokenNameIdentifier	 value Factory
.	TokenNameDOT	
tokens	TokenNameIdentifier	 tokens
(	TokenNameLPAREN	
getLocalTokens	TokenNameIdentifier	 get Local Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
addLocalApplicationState	TokenNameIdentifier	 add Local Application State
(	TokenNameLPAREN	
ApplicationState	TokenNameIdentifier	 Application State
.	TokenNameDOT	
STATUS	TokenNameIdentifier	 STATUS
,	TokenNameCOMMA	
valueFactory	TokenNameIdentifier	 value Factory
.	TokenNameDOT	
normal	TokenNameIdentifier	 normal
(	TokenNameLPAREN	
getLocalTokens	TokenNameIdentifier	 get Local Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setMode	TokenNameIdentifier	 set Mode
(	TokenNameLPAREN	
Mode	TokenNameIdentifier	 Mode
.	TokenNameDOT	
NORMAL	TokenNameIdentifier	 NORMAL
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
StorageService	TokenNameIdentifier	 Storage Service
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
MBeanServer	TokenNameIdentifier	 M Bean Server
mbs	TokenNameIdentifier	 mbs
=	TokenNameEQUAL	
ManagementFactory	TokenNameIdentifier	 Management Factory
.	TokenNameDOT	
getPlatformMBeanServer	TokenNameIdentifier	 get Platform M Bean Server
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
mbs	TokenNameIdentifier	 mbs
.	TokenNameDOT	
registerMBean	TokenNameIdentifier	 register M Bean
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
new	TokenNamenew	
ObjectName	TokenNameIdentifier	 Object Name
(	TokenNameLPAREN	
"org.apache.cassandra.db:type=StorageService"	TokenNameStringLiteral	org.apache.cassandra.db:type=StorageService
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* register the verb handlers */	TokenNameCOMMENT_BLOCK	 register the verb handlers 
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
registerVerbHandlers	TokenNameIdentifier	 register Verb Handlers
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
MUTATION	TokenNameIdentifier	 MUTATION
,	TokenNameCOMMA	
new	TokenNamenew	
RowMutationVerbHandler	TokenNameIdentifier	 Row Mutation Verb Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
registerVerbHandlers	TokenNameIdentifier	 register Verb Handlers
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
READ_REPAIR	TokenNameIdentifier	 READ  REPAIR
,	TokenNameCOMMA	
new	TokenNamenew	
ReadRepairVerbHandler	TokenNameIdentifier	 Read Repair Verb Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
registerVerbHandlers	TokenNameIdentifier	 register Verb Handlers
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
READ	TokenNameIdentifier	 READ
,	TokenNameCOMMA	
new	TokenNamenew	
ReadVerbHandler	TokenNameIdentifier	 Read Verb Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
registerVerbHandlers	TokenNameIdentifier	 register Verb Handlers
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
RANGE_SLICE	TokenNameIdentifier	 RANGE  SLICE
,	TokenNameCOMMA	
new	TokenNamenew	
RangeSliceVerbHandler	TokenNameIdentifier	 Range Slice Verb Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
registerVerbHandlers	TokenNameIdentifier	 register Verb Handlers
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
INDEX_SCAN	TokenNameIdentifier	 INDEX  SCAN
,	TokenNameCOMMA	
new	TokenNamenew	
IndexScanVerbHandler	TokenNameIdentifier	 Index Scan Verb Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
registerVerbHandlers	TokenNameIdentifier	 register Verb Handlers
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
COUNTER_MUTATION	TokenNameIdentifier	 COUNTER  MUTATION
,	TokenNameCOMMA	
new	TokenNamenew	
CounterMutationVerbHandler	TokenNameIdentifier	 Counter Mutation Verb Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
registerVerbHandlers	TokenNameIdentifier	 register Verb Handlers
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
TRUNCATE	TokenNameIdentifier	 TRUNCATE
,	TokenNameCOMMA	
new	TokenNamenew	
TruncateVerbHandler	TokenNameIdentifier	 Truncate Verb Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// see BootStrapper for a summary of how the bootstrap verbs interact 	TokenNameCOMMENT_LINE	see BootStrapper for a summary of how the bootstrap verbs interact 
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
registerVerbHandlers	TokenNameIdentifier	 register Verb Handlers
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
BOOTSTRAP_TOKEN	TokenNameIdentifier	 BOOTSTRAP  TOKEN
,	TokenNameCOMMA	
new	TokenNamenew	
BootStrapper	TokenNameIdentifier	 Boot Strapper
.	TokenNameDOT	
BootstrapTokenVerbHandler	TokenNameIdentifier	 Bootstrap Token Verb Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
registerVerbHandlers	TokenNameIdentifier	 register Verb Handlers
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
STREAM_REQUEST	TokenNameIdentifier	 STREAM  REQUEST
,	TokenNameCOMMA	
new	TokenNamenew	
StreamRequestVerbHandler	TokenNameIdentifier	 Stream Request Verb Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
registerVerbHandlers	TokenNameIdentifier	 register Verb Handlers
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
STREAM_REPLY	TokenNameIdentifier	 STREAM  REPLY
,	TokenNameCOMMA	
new	TokenNamenew	
StreamReplyVerbHandler	TokenNameIdentifier	 Stream Reply Verb Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
registerVerbHandlers	TokenNameIdentifier	 register Verb Handlers
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
REPLICATION_FINISHED	TokenNameIdentifier	 REPLICATION  FINISHED
,	TokenNameCOMMA	
new	TokenNamenew	
ReplicationFinishedVerbHandler	TokenNameIdentifier	 Replication Finished Verb Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
registerVerbHandlers	TokenNameIdentifier	 register Verb Handlers
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
REQUEST_RESPONSE	TokenNameIdentifier	 REQUEST  RESPONSE
,	TokenNameCOMMA	
new	TokenNamenew	
ResponseVerbHandler	TokenNameIdentifier	 Response Verb Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
registerVerbHandlers	TokenNameIdentifier	 register Verb Handlers
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
INTERNAL_RESPONSE	TokenNameIdentifier	 INTERNAL  RESPONSE
,	TokenNameCOMMA	
new	TokenNamenew	
ResponseVerbHandler	TokenNameIdentifier	 Response Verb Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
registerVerbHandlers	TokenNameIdentifier	 register Verb Handlers
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
TREE_REQUEST	TokenNameIdentifier	 TREE  REQUEST
,	TokenNameCOMMA	
new	TokenNamenew	
TreeRequestVerbHandler	TokenNameIdentifier	 Tree Request Verb Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
registerVerbHandlers	TokenNameIdentifier	 register Verb Handlers
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
TREE_RESPONSE	TokenNameIdentifier	 TREE  RESPONSE
,	TokenNameCOMMA	
new	TokenNamenew	
AntiEntropyService	TokenNameIdentifier	 Anti Entropy Service
.	TokenNameDOT	
TreeResponseVerbHandler	TokenNameIdentifier	 Tree Response Verb Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
registerVerbHandlers	TokenNameIdentifier	 register Verb Handlers
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
STREAMING_REPAIR_REQUEST	TokenNameIdentifier	 STREAMING  REPAIR  REQUEST
,	TokenNameCOMMA	
new	TokenNamenew	
StreamingRepairTask	TokenNameIdentifier	 Streaming Repair Task
.	TokenNameDOT	
StreamingRepairRequest	TokenNameIdentifier	 Streaming Repair Request
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
registerVerbHandlers	TokenNameIdentifier	 register Verb Handlers
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
STREAMING_REPAIR_RESPONSE	TokenNameIdentifier	 STREAMING  REPAIR  RESPONSE
,	TokenNameCOMMA	
new	TokenNamenew	
StreamingRepairTask	TokenNameIdentifier	 Streaming Repair Task
.	TokenNameDOT	
StreamingRepairResponse	TokenNameIdentifier	 Streaming Repair Response
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
registerVerbHandlers	TokenNameIdentifier	 register Verb Handlers
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
GOSSIP_SHUTDOWN	TokenNameIdentifier	 GOSSIP  SHUTDOWN
,	TokenNameCOMMA	
new	TokenNamenew	
GossipShutdownVerbHandler	TokenNameIdentifier	 Gossip Shutdown Verb Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
registerVerbHandlers	TokenNameIdentifier	 register Verb Handlers
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
GOSSIP_DIGEST_SYN	TokenNameIdentifier	 GOSSIP  DIGEST  SYN
,	TokenNameCOMMA	
new	TokenNamenew	
GossipDigestSynVerbHandler	TokenNameIdentifier	 Gossip Digest Syn Verb Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
registerVerbHandlers	TokenNameIdentifier	 register Verb Handlers
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
GOSSIP_DIGEST_ACK	TokenNameIdentifier	 GOSSIP  DIGEST  ACK
,	TokenNameCOMMA	
new	TokenNamenew	
GossipDigestAckVerbHandler	TokenNameIdentifier	 Gossip Digest Ack Verb Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
registerVerbHandlers	TokenNameIdentifier	 register Verb Handlers
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
GOSSIP_DIGEST_ACK2	TokenNameIdentifier	 GOSSIP  DIGEST  AC K2
,	TokenNameCOMMA	
new	TokenNamenew	
GossipDigestAck2VerbHandler	TokenNameIdentifier	 Gossip Digest Ack2 Verb Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
registerVerbHandlers	TokenNameIdentifier	 register Verb Handlers
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
DEFINITIONS_UPDATE	TokenNameIdentifier	 DEFINITIONS  UPDATE
,	TokenNameCOMMA	
new	TokenNamenew	
DefinitionsUpdateVerbHandler	TokenNameIdentifier	 Definitions Update Verb Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
registerVerbHandlers	TokenNameIdentifier	 register Verb Handlers
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
SCHEMA_CHECK	TokenNameIdentifier	 SCHEMA  CHECK
,	TokenNameCOMMA	
new	TokenNamenew	
SchemaCheckVerbHandler	TokenNameIdentifier	 Schema Check Verb Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
registerVerbHandlers	TokenNameIdentifier	 register Verb Handlers
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
MIGRATION_REQUEST	TokenNameIdentifier	 MIGRATION  REQUEST
,	TokenNameCOMMA	
new	TokenNamenew	
MigrationRequestVerbHandler	TokenNameIdentifier	 Migration Request Verb Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
registerVerbHandlers	TokenNameIdentifier	 register Verb Handlers
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
SNAPSHOT	TokenNameIdentifier	 SNAPSHOT
,	TokenNameCOMMA	
new	TokenNamenew	
SnapshotVerbHandler	TokenNameIdentifier	 Snapshot Verb Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// spin up the streaming service so it is available for jmx tools. 	TokenNameCOMMENT_LINE	spin up the streaming service so it is available for jmx tools. 
if	TokenNameif	
(	TokenNameLPAREN	
StreamingService	TokenNameIdentifier	 Streaming Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"Streaming service is unavailable."	TokenNameStringLiteral	Streaming service is unavailable.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
registerDaemon	TokenNameIdentifier	 register Daemon
(	TokenNameLPAREN	
CassandraDaemon	TokenNameIdentifier	 Cassandra Daemon
daemon	TokenNameIdentifier	 daemon
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
daemon	TokenNameIdentifier	 daemon
=	TokenNameEQUAL	
daemon	TokenNameIdentifier	 daemon
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
register	TokenNameIdentifier	 register
(	TokenNameLPAREN	
IEndpointLifecycleSubscriber	TokenNameIdentifier	 I Endpoint Lifecycle Subscriber
subscriber	TokenNameIdentifier	 subscriber
)	TokenNameRPAREN	
{	TokenNameLBRACE	
lifecycleSubscribers	TokenNameIdentifier	 lifecycle Subscribers
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
subscriber	TokenNameIdentifier	 subscriber
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
unregister	TokenNameIdentifier	 unregister
(	TokenNameLPAREN	
IEndpointLifecycleSubscriber	TokenNameIdentifier	 I Endpoint Lifecycle Subscriber
subscriber	TokenNameIdentifier	 subscriber
)	TokenNameRPAREN	
{	TokenNameLBRACE	
lifecycleSubscribers	TokenNameIdentifier	 lifecycle Subscribers
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
subscriber	TokenNameIdentifier	 subscriber
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// should only be called via JMX 	TokenNameCOMMENT_LINE	should only be called via JMX 
public	TokenNamepublic	
void	TokenNamevoid	
stopGossiping	TokenNameIdentifier	 stop Gossiping
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
initialized	TokenNameIdentifier	 initialized
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
"Stopping gossip by operator request"	TokenNameStringLiteral	Stopping gossip by operator request
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
stop	TokenNameIdentifier	 stop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
initialized	TokenNameIdentifier	 initialized
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// should only be called via JMX 	TokenNameCOMMENT_LINE	should only be called via JMX 
public	TokenNamepublic	
void	TokenNamevoid	
startGossiping	TokenNameIdentifier	 start Gossiping
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
initialized	TokenNameIdentifier	 initialized
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
"Starting gossip by operator request"	TokenNameStringLiteral	Starting gossip by operator request
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
start	TokenNameIdentifier	 start
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
1000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
initialized	TokenNameIdentifier	 initialized
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// should only be called via JMX 	TokenNameCOMMENT_LINE	should only be called via JMX 
public	TokenNamepublic	
void	TokenNamevoid	
startRPCServer	TokenNameIdentifier	 start RPC Server
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
daemon	TokenNameIdentifier	 daemon
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
"No configured daemon"	TokenNameStringLiteral	No configured daemon
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
daemon	TokenNameIdentifier	 daemon
.	TokenNameDOT	
thriftServer	TokenNameIdentifier	 thrift Server
.	TokenNameDOT	
start	TokenNameIdentifier	 start
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
stopRPCServer	TokenNameIdentifier	 stop RPC Server
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
daemon	TokenNameIdentifier	 daemon
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
"No configured daemon"	TokenNameStringLiteral	No configured daemon
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
daemon	TokenNameIdentifier	 daemon
.	TokenNameDOT	
thriftServer	TokenNameIdentifier	 thrift Server
.	TokenNameDOT	
stop	TokenNameIdentifier	 stop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isRPCServerRunning	TokenNameIdentifier	 is RPC Server Running
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
daemon	TokenNameIdentifier	 daemon
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
daemon	TokenNameIdentifier	 daemon
.	TokenNameDOT	
thriftServer	TokenNameIdentifier	 thrift Server
.	TokenNameDOT	
isRunning	TokenNameIdentifier	 is Running
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
startNativeTransport	TokenNameIdentifier	 start Native Transport
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
daemon	TokenNameIdentifier	 daemon
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
"No configured daemon"	TokenNameStringLiteral	No configured daemon
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
daemon	TokenNameIdentifier	 daemon
.	TokenNameDOT	
nativeServer	TokenNameIdentifier	 native Server
.	TokenNameDOT	
start	TokenNameIdentifier	 start
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
stopNativeTransport	TokenNameIdentifier	 stop Native Transport
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
daemon	TokenNameIdentifier	 daemon
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
"No configured daemon"	TokenNameStringLiteral	No configured daemon
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
daemon	TokenNameIdentifier	 daemon
.	TokenNameDOT	
nativeServer	TokenNameIdentifier	 native Server
.	TokenNameDOT	
stop	TokenNameIdentifier	 stop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isNativeTransportRunning	TokenNameIdentifier	 is Native Transport Running
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
daemon	TokenNameIdentifier	 daemon
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
daemon	TokenNameIdentifier	 daemon
.	TokenNameDOT	
nativeServer	TokenNameIdentifier	 native Server
.	TokenNameDOT	
isRunning	TokenNameIdentifier	 is Running
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
stopClient	TokenNameIdentifier	 stop Client
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
unregister	TokenNameIdentifier	 unregister
(	TokenNameLPAREN	
migrationManager	TokenNameIdentifier	 migration Manager
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
unregister	TokenNameIdentifier	 unregister
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
stop	TokenNameIdentifier	 stop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
shutdown	TokenNameIdentifier	 shutdown
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// give it a second so that task accepted before the MessagingService shutdown gets submitted to the stage (to avoid RejectedExecutionException) 	TokenNameCOMMENT_LINE	give it a second so that task accepted before the MessagingService shutdown gets submitted to the stage (to avoid RejectedExecutionException) 
try	TokenNametry	
{	TokenNameLBRACE	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
sleep	TokenNameIdentifier	 sleep
(	TokenNameLPAREN	
1000L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
StageManager	TokenNameIdentifier	 Stage Manager
.	TokenNameDOT	
shutdownNow	TokenNameIdentifier	 shutdown Now
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isInitialized	TokenNameIdentifier	 is Initialized
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
initialized	TokenNameIdentifier	 initialized
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
initClient	TokenNameIdentifier	 init Client
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
ConfigurationException	TokenNameIdentifier	 Configuration Exception
{	TokenNameLBRACE	
initClient	TokenNameIdentifier	 init Client
(	TokenNameLPAREN	
RING_DELAY	TokenNameIdentifier	 RING  DELAY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
initClient	TokenNameIdentifier	 init Client
(	TokenNameLPAREN	
int	TokenNameint	
delay	TokenNameIdentifier	 delay
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
ConfigurationException	TokenNameIdentifier	 Configuration Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
initialized	TokenNameIdentifier	 initialized
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isClientMode	TokenNameIdentifier	 is Client Mode
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
UnsupportedOperationException	TokenNameIdentifier	 Unsupported Operation Exception
(	TokenNameLPAREN	
"StorageService does not support switching modes."	TokenNameStringLiteral	StorageService does not support switching modes.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
initialized	TokenNameIdentifier	 initialized
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
isClientMode	TokenNameIdentifier	 is Client Mode
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Starting up client gossip"	TokenNameStringLiteral	Starting up client gossip
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setMode	TokenNameIdentifier	 set Mode
(	TokenNameLPAREN	
Mode	TokenNameIdentifier	 Mode
.	TokenNameDOT	
CLIENT	TokenNameIdentifier	 CLIENT
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
register	TokenNameIdentifier	 register
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
start	TokenNameIdentifier	 start
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
1000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// needed for node-ring gathering. 	TokenNameCOMMENT_LINE	needed for node-ring gathering. 
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
addLocalApplicationState	TokenNameIdentifier	 add Local Application State
(	TokenNameLPAREN	
ApplicationState	TokenNameIdentifier	 Application State
.	TokenNameDOT	
NET_VERSION	TokenNameIdentifier	 NET  VERSION
,	TokenNameCOMMA	
valueFactory	TokenNameIdentifier	 value Factory
.	TokenNameDOT	
networkVersion	TokenNameIdentifier	 network Version
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
listen	TokenNameIdentifier	 listen
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getLocalAddress	TokenNameIdentifier	 get Local Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// sleep a while to allow gossip to warm up (the other nodes need to know about this one before they can reply). 	TokenNameCOMMENT_LINE	sleep a while to allow gossip to warm up (the other nodes need to know about this one before they can reply). 
try	TokenNametry	
{	TokenNameLBRACE	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
sleep	TokenNameIdentifier	 sleep
(	TokenNameLPAREN	
delay	TokenNameIdentifier	 delay
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
AssertionError	TokenNameIdentifier	 Assertion Error
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
initServer	TokenNameIdentifier	 init Server
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
ConfigurationException	TokenNameIdentifier	 Configuration Exception
{	TokenNameLBRACE	
initServer	TokenNameIdentifier	 init Server
(	TokenNameLPAREN	
RING_DELAY	TokenNameIdentifier	 RING  DELAY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
initServer	TokenNameIdentifier	 init Server
(	TokenNameLPAREN	
int	TokenNameint	
delay	TokenNameIdentifier	 delay
)	TokenNameRPAREN	
throws	TokenNamethrows	
ConfigurationException	TokenNameIdentifier	 Configuration Exception
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Cassandra version: "	TokenNameStringLiteral	Cassandra version: 
+	TokenNamePLUS	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getReleaseVersionString	TokenNameIdentifier	 get Release Version String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Thrift API version: "	TokenNameStringLiteral	Thrift API version: 
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
VERSION	TokenNameIdentifier	 VERSION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"CQL supported versions: "	TokenNameStringLiteral	CQL supported versions: 
+	TokenNamePLUS	
StringUtils	TokenNameIdentifier	 String Utils
.	TokenNameDOT	
join	TokenNameIdentifier	 join
(	TokenNameLPAREN	
ClientState	TokenNameIdentifier	 Client State
.	TokenNameDOT	
getCQLSupportedVersion	TokenNameIdentifier	 get CQL Supported Version
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
","	TokenNameStringLiteral	,
)	TokenNameRPAREN	
+	TokenNamePLUS	
" (default: "	TokenNameStringLiteral	 (default: 
+	TokenNamePLUS	
ClientState	TokenNameIdentifier	 Client State
.	TokenNameDOT	
DEFAULT_CQL_VERSION	TokenNameIdentifier	 DEFAULT  CQL  VERSION
+	TokenNamePLUS	
")"	TokenNameStringLiteral	)
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
initialized	TokenNameIdentifier	 initialized
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isClientMode	TokenNameIdentifier	 is Client Mode
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
UnsupportedOperationException	TokenNameIdentifier	 Unsupported Operation Exception
(	TokenNameLPAREN	
"StorageService does not support switching modes."	TokenNameStringLiteral	StorageService does not support switching modes.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
initialized	TokenNameIdentifier	 initialized
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
isClientMode	TokenNameIdentifier	 is Client Mode
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// Ensure StorageProxy is initialized on start-up; see CASSANDRA-3797. 	TokenNameCOMMENT_LINE	Ensure StorageProxy is initialized on start-up; see CASSANDRA-3797. 
try	TokenNametry	
{	TokenNameLBRACE	
Class	TokenNameIdentifier	 Class
.	TokenNameDOT	
forName	TokenNameIdentifier	 for Name
(	TokenNameLPAREN	
"org.apache.cassandra.service.StorageProxy"	TokenNameStringLiteral	org.apache.cassandra.service.StorageProxy
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ClassNotFoundException	TokenNameIdentifier	 Class Not Found Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
AssertionError	TokenNameIdentifier	 Assertion Error
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
PBSPredictor	TokenNameIdentifier	 PBS Predictor
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
init	TokenNameIdentifier	 init
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
parseBoolean	TokenNameIdentifier	 parse Boolean
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"cassandra.load_ring_state"	TokenNameStringLiteral	cassandra.load_ring_state
,	TokenNameCOMMA	
"true"	TokenNameStringLiteral	true
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Loading persisted ring state"	TokenNameStringLiteral	Loading persisted ring state
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
loadedTokens	TokenNameIdentifier	 loaded Tokens
=	TokenNameEQUAL	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
loadTokens	TokenNameIdentifier	 load Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
UUID	TokenNameIdentifier	 UUID
>	TokenNameGREATER	
loadedHostIds	TokenNameIdentifier	 loaded Host Ids
=	TokenNameEQUAL	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
loadHostIds	TokenNameIdentifier	 load Host Ids
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
ep	TokenNameIdentifier	 ep
:	TokenNameCOLON	
loadedTokens	TokenNameIdentifier	 loaded Tokens
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ep	TokenNameIdentifier	 ep
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// entry has been mistakenly added, delete it 	TokenNameCOMMENT_LINE	entry has been mistakenly added, delete it 
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
removeTokens	TokenNameIdentifier	 remove Tokens
(	TokenNameLPAREN	
loadedTokens	TokenNameIdentifier	 loaded Tokens
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
updateNormalTokens	TokenNameIdentifier	 update Normal Tokens
(	TokenNameLPAREN	
loadedTokens	TokenNameIdentifier	 loaded Tokens
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
updateHostId	TokenNameIdentifier	 update Host Id
(	TokenNameLPAREN	
loadedHostIds	TokenNameIdentifier	 loaded Host Ids
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
addSavedEndpoint	TokenNameIdentifier	 add Saved Endpoint
(	TokenNameLPAREN	
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
parseBoolean	TokenNameIdentifier	 parse Boolean
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"cassandra.renew_counter_id"	TokenNameStringLiteral	cassandra.renew_counter_id
,	TokenNameCOMMA	
"false"	TokenNameStringLiteral	false
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Renewing local node id (as requested)"	TokenNameStringLiteral	Renewing local node id (as requested)
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CounterId	TokenNameIdentifier	 Counter Id
.	TokenNameDOT	
renewLocalId	TokenNameIdentifier	 renew Local Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// daemon threads, like our executors', continue to run while shutdown hooks are invoked 	TokenNameCOMMENT_LINE	daemon threads, like our executors', continue to run while shutdown hooks are invoked 
Thread	TokenNameIdentifier	 Thread
drainOnShutdown	TokenNameIdentifier	 drain On Shutdown
=	TokenNameEQUAL	
new	TokenNamenew	
Thread	TokenNameIdentifier	 Thread
(	TokenNameLPAREN	
new	TokenNamenew	
WrappedRunnable	TokenNameIdentifier	 Wrapped Runnable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
runMayThrow	TokenNameIdentifier	 run May Throw
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
ExecutionException	TokenNameIdentifier	 Execution Exception
,	TokenNameCOMMA	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
,	TokenNameCOMMA	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
ExecutorService	TokenNameIdentifier	 Executor Service
mutationStage	TokenNameIdentifier	 mutation Stage
=	TokenNameEQUAL	
StageManager	TokenNameIdentifier	 Stage Manager
.	TokenNameDOT	
getStage	TokenNameIdentifier	 get Stage
(	TokenNameLPAREN	
Stage	TokenNameIdentifier	 Stage
.	TokenNameDOT	
MUTATION	TokenNameIdentifier	 MUTATION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
mutationStage	TokenNameIdentifier	 mutation Stage
.	TokenNameDOT	
isShutdown	TokenNameIdentifier	 is Shutdown
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
// drained already 	TokenNameCOMMENT_LINE	drained already 
stopRPCServer	TokenNameIdentifier	 stop RPC Server
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
optionalTasks	TokenNameIdentifier	 optional Tasks
.	TokenNameDOT	
shutdown	TokenNameIdentifier	 shutdown
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
stop	TokenNameIdentifier	 stop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// In-progress writes originating here could generate hints to be written, so shut down MessagingService 	TokenNameCOMMENT_LINE	In-progress writes originating here could generate hints to be written, so shut down MessagingService 
// before mutation stage, so we can get all the hints saved before shutting down 	TokenNameCOMMENT_LINE	before mutation stage, so we can get all the hints saved before shutting down 
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
shutdown	TokenNameIdentifier	 shutdown
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
mutationStage	TokenNameIdentifier	 mutation Stage
.	TokenNameDOT	
shutdown	TokenNameIdentifier	 shutdown
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
mutationStage	TokenNameIdentifier	 mutation Stage
.	TokenNameDOT	
awaitTermination	TokenNameIdentifier	 await Termination
(	TokenNameLPAREN	
3600	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
TimeUnit	TokenNameIdentifier	 Time Unit
.	TokenNameDOT	
SECONDS	TokenNameIdentifier	 SECONDS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
StorageProxy	TokenNameIdentifier	 Storage Proxy
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
verifyNoHintsInProgress	TokenNameIdentifier	 verify No Hints In Progress
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Future	TokenNameIdentifier	 Future
<	TokenNameLESS	
?	TokenNameQUESTION	
>>	TokenNameRIGHT_SHIFT	
flushes	TokenNameIdentifier	 flushes
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Future	TokenNameIdentifier	 Future
<	TokenNameLESS	
?	TokenNameQUESTION	
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Table	TokenNameIdentifier	 Table
table	TokenNameIdentifier	 table
:	TokenNameCOLON	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
all	TokenNameIdentifier	 all
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
KSMetaData	TokenNameIdentifier	 KS Meta Data
ksm	TokenNameIdentifier	 ksm
=	TokenNameEQUAL	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getKSMetaData	TokenNameIdentifier	 get KS Meta Data
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
ksm	TokenNameIdentifier	 ksm
.	TokenNameDOT	
durableWrites	TokenNameIdentifier	 durable Writes
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
:	TokenNameCOLON	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
getColumnFamilyStores	TokenNameIdentifier	 get Column Family Stores
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
flushes	TokenNameIdentifier	 flushes
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
forceFlush	TokenNameIdentifier	 force Flush
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
waitOnFutures	TokenNameIdentifier	 wait On Futures
(	TokenNameLPAREN	
flushes	TokenNameIdentifier	 flushes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CommitLog	TokenNameIdentifier	 Commit Log
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
shutdownBlocking	TokenNameIdentifier	 shutdown Blocking
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// wait for miscellaneous tasks like sstable and commitlog segment deletion 	TokenNameCOMMENT_LINE	wait for miscellaneous tasks like sstable and commitlog segment deletion 
tasks	TokenNameIdentifier	 tasks
.	TokenNameDOT	
shutdown	TokenNameIdentifier	 shutdown
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
tasks	TokenNameIdentifier	 tasks
.	TokenNameDOT	
awaitTermination	TokenNameIdentifier	 await Termination
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
TimeUnit	TokenNameIdentifier	 Time Unit
.	TokenNameDOT	
MINUTES	TokenNameIdentifier	 MINUTES
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
"Miscellaneous task executor still busy after one minute; proceeding with shutdown"	TokenNameStringLiteral	Miscellaneous task executor still busy after one minute; proceeding with shutdown
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
"StorageServiceShutdownHook"	TokenNameStringLiteral	StorageServiceShutdownHook
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Runtime	TokenNameIdentifier	 Runtime
.	TokenNameDOT	
getRuntime	TokenNameIdentifier	 get Runtime
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
addShutdownHook	TokenNameIdentifier	 add Shutdown Hook
(	TokenNameLPAREN	
drainOnShutdown	TokenNameIdentifier	 drain On Shutdown
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
parseBoolean	TokenNameIdentifier	 parse Boolean
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"cassandra.join_ring"	TokenNameStringLiteral	cassandra.join_ring
,	TokenNameCOMMA	
"true"	TokenNameStringLiteral	true
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
joinTokenRing	TokenNameIdentifier	 join Token Ring
(	TokenNameLPAREN	
delay	TokenNameIdentifier	 delay
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Not joining ring as requested. Use JMX (StorageService->joinRing()) to initiate ring joining"	TokenNameStringLiteral	Not joining ring as requested. Use JMX (StorageService->joinRing()) to initiate ring joining
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
joinTokenRing	TokenNameIdentifier	 join Token Ring
(	TokenNameLPAREN	
int	TokenNameint	
delay	TokenNameIdentifier	 delay
)	TokenNameRPAREN	
throws	TokenNamethrows	
ConfigurationException	TokenNameIdentifier	 Configuration Exception
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Starting up server gossip"	TokenNameStringLiteral	Starting up server gossip
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
joined	TokenNameIdentifier	 joined
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// Seed the host ID-to-endpoint map with our own ID. 	TokenNameCOMMENT_LINE	Seed the host ID-to-endpoint map with our own ID. 
getTokenMetadata	TokenNameIdentifier	 get Token Metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
updateHostId	TokenNameIdentifier	 update Host Id
(	TokenNameLPAREN	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
getLocalHostId	TokenNameIdentifier	 get Local Host Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// have to start the gossip service before we can see any info on other nodes. this is necessary 	TokenNameCOMMENT_LINE	have to start the gossip service before we can see any info on other nodes. this is necessary 
// for bootstrap to get the load info it needs. 	TokenNameCOMMENT_LINE	for bootstrap to get the load info it needs. 
// (we won't be part of the storage ring though until we add a counterId to our state, below.) 	TokenNameCOMMENT_LINE	(we won't be part of the storage ring though until we add a counterId to our state, below.) 
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
register	TokenNameIdentifier	 register
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
register	TokenNameIdentifier	 register
(	TokenNameLPAREN	
migrationManager	TokenNameIdentifier	 migration Manager
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
start	TokenNameIdentifier	 start
(	TokenNameLPAREN	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
incrementAndGetGeneration	TokenNameIdentifier	 increment And Get Generation
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// needed for node-ring gathering. 	TokenNameCOMMENT_LINE	needed for node-ring gathering. 
// gossip network proto version 	TokenNameCOMMENT_LINE	gossip network proto version 
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
addLocalApplicationState	TokenNameIdentifier	 add Local Application State
(	TokenNameLPAREN	
ApplicationState	TokenNameIdentifier	 Application State
.	TokenNameDOT	
NET_VERSION	TokenNameIdentifier	 NET  VERSION
,	TokenNameCOMMA	
valueFactory	TokenNameIdentifier	 value Factory
.	TokenNameDOT	
networkVersion	TokenNameIdentifier	 network Version
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
addLocalApplicationState	TokenNameIdentifier	 add Local Application State
(	TokenNameLPAREN	
ApplicationState	TokenNameIdentifier	 Application State
.	TokenNameDOT	
HOST_ID	TokenNameIdentifier	 HOST  ID
,	TokenNameCOMMA	
valueFactory	TokenNameIdentifier	 value Factory
.	TokenNameDOT	
hostId	TokenNameIdentifier	 host Id
(	TokenNameLPAREN	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
getLocalHostId	TokenNameIdentifier	 get Local Host Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// gossip snitch infos (local DC and rack) 	TokenNameCOMMENT_LINE	gossip snitch infos (local DC and rack) 
gossipSnitchInfo	TokenNameIdentifier	 gossip Snitch Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
updateVersionAndAnnounce	TokenNameIdentifier	 update Version And Announce
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Ensure we know our own actual Schema UUID in preparation for updates 	TokenNameCOMMENT_LINE	Ensure we know our own actual Schema UUID in preparation for updates 
// add rpc listening info 	TokenNameCOMMENT_LINE	add rpc listening info 
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
addLocalApplicationState	TokenNameIdentifier	 add Local Application State
(	TokenNameLPAREN	
ApplicationState	TokenNameIdentifier	 Application State
.	TokenNameDOT	
RPC_ADDRESS	TokenNameIdentifier	 RPC  ADDRESS
,	TokenNameCOMMA	
valueFactory	TokenNameIdentifier	 value Factory
.	TokenNameDOT	
rpcaddress	TokenNameIdentifier	 rpcaddress
(	TokenNameLPAREN	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getRpcAddress	TokenNameIdentifier	 get Rpc Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
!=	TokenNameNOT_EQUAL	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getReplaceTokens	TokenNameIdentifier	 get Replace Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
addLocalApplicationState	TokenNameIdentifier	 add Local Application State
(	TokenNameLPAREN	
ApplicationState	TokenNameIdentifier	 Application State
.	TokenNameDOT	
STATUS	TokenNameIdentifier	 STATUS
,	TokenNameCOMMA	
valueFactory	TokenNameIdentifier	 value Factory
.	TokenNameDOT	
hibernate	TokenNameIdentifier	 hibernate
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
listen	TokenNameIdentifier	 listen
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getLocalAddress	TokenNameIdentifier	 get Local Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
LoadBroadcaster	TokenNameIdentifier	 Load Broadcaster
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
startBroadcasting	TokenNameIdentifier	 start Broadcasting
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
addLocalApplicationState	TokenNameIdentifier	 add Local Application State
(	TokenNameLPAREN	
ApplicationState	TokenNameIdentifier	 Application State
.	TokenNameDOT	
RELEASE_VERSION	TokenNameIdentifier	 RELEASE  VERSION
,	TokenNameCOMMA	
valueFactory	TokenNameIdentifier	 value Factory
.	TokenNameDOT	
releaseVersion	TokenNameIdentifier	 release Version
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
HintedHandOffManager	TokenNameIdentifier	 Hinted Hand Off Manager
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
start	TokenNameIdentifier	 start
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
BatchlogManager	TokenNameIdentifier	 Batchlog Manager
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
start	TokenNameIdentifier	 start
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// We bootstrap if we haven't successfully bootstrapped before, as long as we are not a seed. 	TokenNameCOMMENT_LINE	We bootstrap if we haven't successfully bootstrapped before, as long as we are not a seed. 
// If we are a seed, or if the user manually sets auto_bootstrap to false, 	TokenNameCOMMENT_LINE	If we are a seed, or if the user manually sets auto_bootstrap to false, 
// we'll skip streaming data from other nodes and jump directly into the ring. 	TokenNameCOMMENT_LINE	we'll skip streaming data from other nodes and jump directly into the ring. 
// 	TokenNameCOMMENT_LINE	 
// The seed check allows us to skip the RING_DELAY sleep for the single-node cluster case, 	TokenNameCOMMENT_LINE	The seed check allows us to skip the RING_DELAY sleep for the single-node cluster case, 
// which is useful for both new users and testing. 	TokenNameCOMMENT_LINE	which is useful for both new users and testing. 
// 	TokenNameCOMMENT_LINE	 
// We attempted to replace this with a schema-presence check, but you need a meaningful sleep 	TokenNameCOMMENT_LINE	We attempted to replace this with a schema-presence check, but you need a meaningful sleep 
// to get schema info from gossip which defeats the purpose. See CASSANDRA-4427 for the gory details. 	TokenNameCOMMENT_LINE	to get schema info from gossip which defeats the purpose. See CASSANDRA-4427 for the gory details. 
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
current	TokenNameIdentifier	 current
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
tokens	TokenNameIdentifier	 tokens
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Bootstrap variables: {} {} {} {}"	TokenNameStringLiteral	Bootstrap variables: {} {} {} {}
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
isAutoBootstrap	TokenNameIdentifier	 is Auto Bootstrap
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
bootstrapInProgress	TokenNameIdentifier	 bootstrap In Progress
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
bootstrapComplete	TokenNameIdentifier	 bootstrap Complete
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getSeeds	TokenNameIdentifier	 get Seeds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
isAutoBootstrap	TokenNameIdentifier	 is Auto Bootstrap
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
bootstrapComplete	TokenNameIdentifier	 bootstrap Complete
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getSeeds	TokenNameIdentifier	 get Seeds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
bootstrapInProgress	TokenNameIdentifier	 bootstrap In Progress
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
"Detected previous bootstrap failure; retrying"	TokenNameStringLiteral	Detected previous bootstrap failure; retrying
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
setBootstrapState	TokenNameIdentifier	 set Bootstrap State
(	TokenNameLPAREN	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
BootstrapState	TokenNameIdentifier	 Bootstrap State
.	TokenNameDOT	
IN_PROGRESS	TokenNameIdentifier	 IN  PROGRESS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setMode	TokenNameIdentifier	 set Mode
(	TokenNameLPAREN	
Mode	TokenNameIdentifier	 Mode
.	TokenNameDOT	
JOINING	TokenNameIdentifier	 JOINING
,	TokenNameCOMMA	
"waiting for ring information"	TokenNameStringLiteral	waiting for ring information
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// first sleep the delay to make sure we see all our peers 	TokenNameCOMMENT_LINE	first sleep the delay to make sure we see all our peers 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
delay	TokenNameIdentifier	 delay
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
+=	TokenNamePLUS_EQUAL	
1000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if we see schema, we can proceed to the next check directly 	TokenNameCOMMENT_LINE	if we see schema, we can proceed to the next check directly 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getVersion	TokenNameIdentifier	 get Version
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
emptyVersion	TokenNameIdentifier	 empty Version
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"got schema: {}"	TokenNameStringLiteral	got schema: {}
,	TokenNameCOMMA	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getVersion	TokenNameIdentifier	 get Version
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
sleep	TokenNameIdentifier	 sleep
(	TokenNameLPAREN	
1000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
AssertionError	TokenNameIdentifier	 Assertion Error
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// if our schema hasn't matched yet, keep sleeping until it does 	TokenNameCOMMENT_LINE	if our schema hasn't matched yet, keep sleeping until it does 
// (post CASSANDRA-1391 we don't expect this to be necessary very often, but it doesn't hurt to be careful) 	TokenNameCOMMENT_LINE	(post CASSANDRA-1391 we don't expect this to be necessary very often, but it doesn't hurt to be careful) 
while	TokenNamewhile	
(	TokenNameLPAREN	
!	TokenNameNOT	
MigrationManager	TokenNameIdentifier	 Migration Manager
.	TokenNameDOT	
isReadyForBootstrap	TokenNameIdentifier	 is Ready For Bootstrap
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
setMode	TokenNameIdentifier	 set Mode
(	TokenNameLPAREN	
Mode	TokenNameIdentifier	 Mode
.	TokenNameDOT	
JOINING	TokenNameIdentifier	 JOINING
,	TokenNameCOMMA	
"waiting for schema information to complete"	TokenNameStringLiteral	waiting for schema information to complete
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
sleep	TokenNameIdentifier	 sleep
(	TokenNameLPAREN	
1000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
AssertionError	TokenNameIdentifier	 Assertion Error
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
setMode	TokenNameIdentifier	 set Mode
(	TokenNameLPAREN	
Mode	TokenNameIdentifier	 Mode
.	TokenNameDOT	
JOINING	TokenNameIdentifier	 JOINING
,	TokenNameCOMMA	
"schema complete, ready to bootstrap"	TokenNameStringLiteral	schema complete, ready to bootstrap
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"... got ring + schema info"	TokenNameStringLiteral	... got ring + schema info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getReplaceTokens	TokenNameIdentifier	 get Replace Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
isMember	TokenNameIdentifier	 is Member
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
"This node is already a member of the token ring; bootstrap aborted. (If replacing a dead node, remove the old one from the ring first.)"	TokenNameStringLiteral	This node is already a member of the token ring; bootstrap aborted. (If replacing a dead node, remove the old one from the ring first.)
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
UnsupportedOperationException	TokenNameIdentifier	 Unsupported Operation Exception
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
setMode	TokenNameIdentifier	 set Mode
(	TokenNameLPAREN	
Mode	TokenNameIdentifier	 Mode
.	TokenNameDOT	
JOINING	TokenNameIdentifier	 JOINING
,	TokenNameCOMMA	
"getting bootstrap token"	TokenNameStringLiteral	getting bootstrap token
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tokens	TokenNameIdentifier	 tokens
=	TokenNameEQUAL	
BootStrapper	TokenNameIdentifier	 Boot Strapper
.	TokenNameDOT	
getBootstrapTokens	TokenNameIdentifier	 get Bootstrap Tokens
(	TokenNameLPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
,	TokenNameCOMMA	
LoadBroadcaster	TokenNameIdentifier	 Load Broadcaster
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getLoadInfo	TokenNameIdentifier	 get Load Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
// Sleeping additionally to make sure that the server actually is not alive 	TokenNameCOMMENT_LINE	Sleeping additionally to make sure that the server actually is not alive 
// and giving it more time to gossip if alive. 	TokenNameCOMMENT_LINE	and giving it more time to gossip if alive. 
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
sleep	TokenNameIdentifier	 sleep
(	TokenNameLPAREN	
LoadBroadcaster	TokenNameIdentifier	 Load Broadcaster
.	TokenNameDOT	
BROADCAST_INTERVAL	TokenNameIdentifier	 BROADCAST  INTERVAL
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
AssertionError	TokenNameIdentifier	 Assertion Error
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
tokens	TokenNameIdentifier	 tokens
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
token	TokenNameIdentifier	 token
:	TokenNameCOLON	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getReplaceTokens	TokenNameIdentifier	 get Replace Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getTokenFactory	TokenNameIdentifier	 get Token Factory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
fromString	TokenNameIdentifier	 from String
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// check for operator errors... 	TokenNameCOMMENT_LINE	check for operator errors... 
for	TokenNamefor	
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
:	TokenNameCOLON	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
{	TokenNameLBRACE	
InetAddress	TokenNameIdentifier	 Inet Address
existing	TokenNameIdentifier	 existing
=	TokenNameEQUAL	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getEndpoint	TokenNameIdentifier	 get Endpoint
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
existing	TokenNameIdentifier	 existing
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getEndpointStateForEndpoint	TokenNameIdentifier	 get Endpoint State For Endpoint
(	TokenNameLPAREN	
existing	TokenNameIdentifier	 existing
)	TokenNameRPAREN	
.	TokenNameDOT	
getUpdateTimestamp	TokenNameIdentifier	 get Update Timestamp
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
delay	TokenNameIdentifier	 delay
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
UnsupportedOperationException	TokenNameIdentifier	 Unsupported Operation Exception
(	TokenNameLPAREN	
"Cannnot replace a token for a Live node... "	TokenNameStringLiteral	Cannnot replace a token for a Live node... 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
current	TokenNameIdentifier	 current
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
existing	TokenNameIdentifier	 existing
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
setMode	TokenNameIdentifier	 set Mode
(	TokenNameLPAREN	
Mode	TokenNameIdentifier	 Mode
.	TokenNameDOT	
JOINING	TokenNameIdentifier	 JOINING
,	TokenNameCOMMA	
"Replacing a node with token: "	TokenNameStringLiteral	Replacing a node with token: 
+	TokenNamePLUS	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
bootstrap	TokenNameIdentifier	 bootstrap
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
!	TokenNameNOT	
isBootstrapMode	TokenNameIdentifier	 is Bootstrap Mode
;	TokenNameSEMICOLON	
// bootstrap will block until finished 	TokenNameCOMMENT_LINE	bootstrap will block until finished 
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
tokens	TokenNameIdentifier	 tokens
=	TokenNameEQUAL	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
getSavedTokens	TokenNameIdentifier	 get Saved Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
initialTokens	TokenNameIdentifier	 initial Tokens
=	TokenNameEQUAL	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getInitialTokens	TokenNameIdentifier	 get Initial Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
initialTokens	TokenNameIdentifier	 initial Tokens
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<	TokenNameLESS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tokens	TokenNameIdentifier	 tokens
=	TokenNameEQUAL	
BootStrapper	TokenNameIdentifier	 Boot Strapper
.	TokenNameDOT	
getRandomTokens	TokenNameIdentifier	 get Random Tokens
(	TokenNameLPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
,	TokenNameCOMMA	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getNumTokens	TokenNameIdentifier	 get Num Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getNumTokens	TokenNameIdentifier	 get Num Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
"Generated random token "	TokenNameStringLiteral	Generated random token 
+	TokenNamePLUS	
tokens	TokenNameIdentifier	 tokens
+	TokenNamePLUS	
". Random tokens will result in an unbalanced ring; see http://wiki.apache.org/cassandra/Operations"	TokenNameStringLiteral	. Random tokens will result in an unbalanced ring; see http://wiki.apache.org/cassandra/Operations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Generated random tokens. tokens are {}"	TokenNameStringLiteral	Generated random tokens. tokens are {}
,	TokenNameCOMMA	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
tokens	TokenNameIdentifier	 tokens
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
token	TokenNameIdentifier	 token
:	TokenNameCOLON	
initialTokens	TokenNameIdentifier	 initial Tokens
)	TokenNameRPAREN	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getTokenFactory	TokenNameIdentifier	 get Token Factory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
fromString	TokenNameIdentifier	 from String
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Saved token not found. Using "	TokenNameStringLiteral	Saved token not found. Using 
+	TokenNamePLUS	
tokens	TokenNameIdentifier	 tokens
+	TokenNamePLUS	
" from configuration"	TokenNameStringLiteral	 from configuration
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// if we were already bootstrapped with 1 token but num_tokens is set higher in the config, 	TokenNameCOMMENT_LINE	if we were already bootstrapped with 1 token but num_tokens is set higher in the config, 
// then we need to migrate to multi-token 	TokenNameCOMMENT_LINE	then we need to migrate to multi-token 
if	TokenNameif	
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getNumTokens	TokenNameIdentifier	 get Num Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// wait for ring info 	TokenNameCOMMENT_LINE	wait for ring info 
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Sleeping for ring delay ("	TokenNameStringLiteral	Sleeping for ring delay (
+	TokenNamePLUS	
delay	TokenNameIdentifier	 delay
+	TokenNamePLUS	
"ms)"	TokenNameStringLiteral	ms)
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
sleep	TokenNameIdentifier	 sleep
(	TokenNameLPAREN	
delay	TokenNameIdentifier	 delay
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
AssertionError	TokenNameIdentifier	 Assertion Error
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Calculating new tokens"	TokenNameStringLiteral	Calculating new tokens
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// calculate num_tokens tokens evenly spaced in the range (left, right] 	TokenNameCOMMENT_LINE	calculate num_tokens tokens evenly spaced in the range (left, right] 
Token	TokenNameIdentifier	 Token
right	TokenNameIdentifier	 right
=	TokenNameEQUAL	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TokenMetadata	TokenNameIdentifier	 Token Metadata
clone	TokenNameIdentifier	 clone
=	TokenNameEQUAL	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
cloneOnlyTokenMap	TokenNameIdentifier	 clone Only Token Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
clone	TokenNameIdentifier	 clone
.	TokenNameDOT	
updateNormalToken	TokenNameIdentifier	 update Normal Token
(	TokenNameLPAREN	
right	TokenNameIdentifier	 right
,	TokenNameCOMMA	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Token	TokenNameIdentifier	 Token
left	TokenNameIdentifier	 left
=	TokenNameEQUAL	
clone	TokenNameIdentifier	 clone
.	TokenNameDOT	
getPredecessor	TokenNameIdentifier	 get Predecessor
(	TokenNameLPAREN	
right	TokenNameIdentifier	 right
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// get (num_tokens - 1) tokens spaced evenly, and the last token will be our current token (right) 	TokenNameCOMMENT_LINE	get (num_tokens - 1) tokens spaced evenly, and the last token will be our current token (right) 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
tok	TokenNameIdentifier	 tok
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
tok	TokenNameIdentifier	 tok
<	TokenNameLESS	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getNumTokens	TokenNameIdentifier	 get Num Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
tok	TokenNameIdentifier	 tok
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Token	TokenNameIdentifier	 Token
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
left	TokenNameIdentifier	 left
;	TokenNameSEMICOLON	
Token	TokenNameIdentifier	 Token
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
right	TokenNameIdentifier	 right
;	TokenNameSEMICOLON	
// iteratively calculate the location of the token using midpoint 	TokenNameCOMMENT_LINE	iteratively calculate the location of the token using midpoint 
// num iterations is number of bits in IEE754 mantissa (including implicit leading 1) 	TokenNameCOMMENT_LINE	num iterations is number of bits in IEE754 mantissa (including implicit leading 1) 
// we stop early for terminating fractions 	TokenNameCOMMENT_LINE	we stop early for terminating fractions 
// TODO: alternatively we could add an interpolate() method to IPartitioner 	TokenNameCOMMENT_LINE	TODO: alternatively we could add an interpolate() method to IPartitioner 
double	TokenNamedouble	
frac	TokenNameIdentifier	 frac
=	TokenNameEQUAL	
(	TokenNameLPAREN	
double	TokenNamedouble	
)	TokenNameRPAREN	
tok	TokenNameIdentifier	 tok
/	TokenNameDIVIDE	
(	TokenNameLPAREN	
double	TokenNamedouble	
)	TokenNameRPAREN	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getNumTokens	TokenNameIdentifier	 get Num Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Token	TokenNameIdentifier	 Token
midpoint	TokenNameIdentifier	 midpoint
=	TokenNameEQUAL	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
midpoint	TokenNameIdentifier	 midpoint
(	TokenNameLPAREN	
l	TokenNameIdentifier	 l
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
53	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
frac	TokenNameIdentifier	 frac
*=	TokenNameMULTIPLY_EQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
frac	TokenNameIdentifier	 frac
==	TokenNameEQUAL_EQUAL	
1.0	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
/* not a bug */	TokenNameCOMMENT_BLOCK	 not a bug 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
frac	TokenNameIdentifier	 frac
>	TokenNameGREATER	
1.0	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
midpoint	TokenNameIdentifier	 midpoint
;	TokenNameSEMICOLON	
frac	TokenNameIdentifier	 frac
-=	TokenNameMINUS_EQUAL	
1.0	TokenNameDoubleLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
midpoint	TokenNameIdentifier	 midpoint
;	TokenNameSEMICOLON	
midpoint	TokenNameIdentifier	 midpoint
=	TokenNameEQUAL	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
midpoint	TokenNameIdentifier	 midpoint
(	TokenNameLPAREN	
l	TokenNameIdentifier	 l
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
midpoint	TokenNameIdentifier	 midpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Split previous range ("	TokenNameStringLiteral	Split previous range (
+	TokenNamePLUS	
left	TokenNameIdentifier	 left
+	TokenNamePLUS	
", "	TokenNameStringLiteral	, 
+	TokenNamePLUS	
right	TokenNameIdentifier	 right
+	TokenNamePLUS	
"] into "	TokenNameStringLiteral	] into 
+	TokenNamePLUS	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Using saved token "	TokenNameStringLiteral	Using saved token 
+	TokenNamePLUS	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isSurveyMode	TokenNameIdentifier	 is Survey Mode
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// start participating in the ring. 	TokenNameCOMMENT_LINE	start participating in the ring. 
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
setBootstrapState	TokenNameIdentifier	 set Bootstrap State
(	TokenNameLPAREN	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
BootstrapState	TokenNameIdentifier	 Bootstrap State
.	TokenNameDOT	
COMPLETED	TokenNameIdentifier	 COMPLETED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setTokens	TokenNameIdentifier	 set Tokens
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// remove the existing info about the replaced node. 	TokenNameCOMMENT_LINE	remove the existing info about the replaced node. 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
current	TokenNameIdentifier	 current
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
for	TokenNamefor	
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
existing	TokenNameIdentifier	 existing
:	TokenNameCOLON	
current	TokenNameIdentifier	 current
)	TokenNameRPAREN	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
replacedEndpoint	TokenNameIdentifier	 replaced Endpoint
(	TokenNameLPAREN	
existing	TokenNameIdentifier	 existing
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Startup completed! Now serving reads."	TokenNameStringLiteral	Startup completed! Now serving reads.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
sortedTokens	TokenNameIdentifier	 sorted Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// setup default superuser (if needed). 	TokenNameCOMMENT_LINE	setup default superuser (if needed). 
Auth	TokenNameIdentifier	 Auth
.	TokenNameDOT	
setupSuperuser	TokenNameIdentifier	 setup Superuser
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Startup complete, but write survey mode is active, not becoming an active ring member. Use JMX (StorageService->joinRing()) to finalize ring joining."	TokenNameStringLiteral	Startup complete, but write survey mode is active, not becoming an active ring member. Use JMX (StorageService->joinRing()) to finalize ring joining.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
gossipSnitchInfo	TokenNameIdentifier	 gossip Snitch Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
IEndpointSnitch	TokenNameIdentifier	 I Endpoint Snitch
snitch	TokenNameIdentifier	 snitch
=	TokenNameEQUAL	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getEndpointSnitch	TokenNameIdentifier	 get Endpoint Snitch
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
dc	TokenNameIdentifier	 dc
=	TokenNameEQUAL	
snitch	TokenNameIdentifier	 snitch
.	TokenNameDOT	
getDatacenter	TokenNameIdentifier	 get Datacenter
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
rack	TokenNameIdentifier	 rack
=	TokenNameEQUAL	
snitch	TokenNameIdentifier	 snitch
.	TokenNameDOT	
getRack	TokenNameIdentifier	 get Rack
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
addLocalApplicationState	TokenNameIdentifier	 add Local Application State
(	TokenNameLPAREN	
ApplicationState	TokenNameIdentifier	 Application State
.	TokenNameDOT	
DC	TokenNameIdentifier	 DC
,	TokenNameCOMMA	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
valueFactory	TokenNameIdentifier	 value Factory
.	TokenNameDOT	
datacenter	TokenNameIdentifier	 datacenter
(	TokenNameLPAREN	
dc	TokenNameIdentifier	 dc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
addLocalApplicationState	TokenNameIdentifier	 add Local Application State
(	TokenNameLPAREN	
ApplicationState	TokenNameIdentifier	 Application State
.	TokenNameDOT	
RACK	TokenNameIdentifier	 RACK
,	TokenNameCOMMA	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
valueFactory	TokenNameIdentifier	 value Factory
.	TokenNameDOT	
rack	TokenNameIdentifier	 rack
(	TokenNameLPAREN	
rack	TokenNameIdentifier	 rack
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
joinRing	TokenNameIdentifier	 join Ring
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
joined	TokenNameIdentifier	 joined
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Joining ring by operator request"	TokenNameStringLiteral	Joining ring by operator request
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
joinTokenRing	TokenNameIdentifier	 join Token Ring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ConfigurationException	TokenNameIdentifier	 Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IOException	TokenNameIdentifier	 IO Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
isSurveyMode	TokenNameIdentifier	 is Survey Mode
)	TokenNameRPAREN	
{	TokenNameLBRACE	
setTokens	TokenNameIdentifier	 set Tokens
(	TokenNameLPAREN	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
getSavedTokens	TokenNameIdentifier	 get Saved Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
setBootstrapState	TokenNameIdentifier	 set Bootstrap State
(	TokenNameLPAREN	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
BootstrapState	TokenNameIdentifier	 Bootstrap State
.	TokenNameDOT	
COMPLETED	TokenNameIdentifier	 COMPLETED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
isSurveyMode	TokenNameIdentifier	 is Survey Mode
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Leaving write survey mode and joining ring at operator request"	TokenNameStringLiteral	Leaving write survey mode and joining ring at operator request
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
sortedTokens	TokenNameIdentifier	 sorted Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// setup default superuser (if needed). 	TokenNameCOMMENT_LINE	setup default superuser (if needed). 
Auth	TokenNameIdentifier	 Auth
.	TokenNameDOT	
setupSuperuser	TokenNameIdentifier	 setup Superuser
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isJoined	TokenNameIdentifier	 is Joined
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
joined	TokenNameIdentifier	 joined
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
rebuild	TokenNameIdentifier	 rebuild
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
sourceDc	TokenNameIdentifier	 source Dc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"rebuild from dc: {}"	TokenNameStringLiteral	rebuild from dc: {}
,	TokenNameCOMMA	
sourceDc	TokenNameIdentifier	 source Dc
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
"(any dc)"	TokenNameStringLiteral	(any dc)
:	TokenNameCOLON	
sourceDc	TokenNameIdentifier	 source Dc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
RangeStreamer	TokenNameIdentifier	 Range Streamer
streamer	TokenNameIdentifier	 streamer
=	TokenNameEQUAL	
new	TokenNamenew	
RangeStreamer	TokenNameIdentifier	 Range Streamer
(	TokenNameLPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
,	TokenNameCOMMA	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
OperationType	TokenNameIdentifier	 Operation Type
.	TokenNameDOT	
REBUILD	TokenNameIdentifier	 REBUILD
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
streamer	TokenNameIdentifier	 streamer
.	TokenNameDOT	
addSourceFilter	TokenNameIdentifier	 add Source Filter
(	TokenNameLPAREN	
new	TokenNamenew	
RangeStreamer	TokenNameIdentifier	 Range Streamer
.	TokenNameDOT	
FailureDetectorSourceFilter	TokenNameIdentifier	 Failure Detector Source Filter
(	TokenNameLPAREN	
FailureDetector	TokenNameIdentifier	 Failure Detector
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sourceDc	TokenNameIdentifier	 source Dc
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
streamer	TokenNameIdentifier	 streamer
.	TokenNameDOT	
addSourceFilter	TokenNameIdentifier	 add Source Filter
(	TokenNameLPAREN	
new	TokenNamenew	
RangeStreamer	TokenNameIdentifier	 Range Streamer
.	TokenNameDOT	
SingleDatacenterFilter	TokenNameIdentifier	 Single Datacenter Filter
(	TokenNameLPAREN	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getEndpointSnitch	TokenNameIdentifier	 get Endpoint Snitch
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
sourceDc	TokenNameIdentifier	 source Dc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
:	TokenNameCOLON	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getNonSystemTables	TokenNameIdentifier	 get Non System Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
streamer	TokenNameIdentifier	 streamer
.	TokenNameDOT	
addRanges	TokenNameIdentifier	 add Ranges
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
getLocalRanges	TokenNameIdentifier	 get Local Ranges
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
streamer	TokenNameIdentifier	 streamer
.	TokenNameDOT	
fetch	TokenNameIdentifier	 fetch
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setStreamThroughputMbPerSec	TokenNameIdentifier	 set Stream Throughput Mb Per Sec
(	TokenNameLPAREN	
int	TokenNameint	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
setStreamThroughputOutboundMegabitsPerSec	TokenNameIdentifier	 set Stream Throughput Outbound Megabits Per Sec
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"setstreamthroughput: throttle set to {}"	TokenNameStringLiteral	setstreamthroughput: throttle set to {}
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getStreamThroughputMbPerSec	TokenNameIdentifier	 get Stream Throughput Mb Per Sec
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getStreamThroughputOutboundMegabitsPerSec	TokenNameIdentifier	 get Stream Throughput Outbound Megabits Per Sec
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getCompactionThroughputMbPerSec	TokenNameIdentifier	 get Compaction Throughput Mb Per Sec
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getCompactionThroughputMbPerSec	TokenNameIdentifier	 get Compaction Throughput Mb Per Sec
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setCompactionThroughputMbPerSec	TokenNameIdentifier	 set Compaction Throughput Mb Per Sec
(	TokenNameLPAREN	
int	TokenNameint	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
setCompactionThroughputMbPerSec	TokenNameIdentifier	 set Compaction Throughput Mb Per Sec
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isIncrementalBackupsEnabled	TokenNameIdentifier	 is Incremental Backups Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
isIncrementalBackupsEnabled	TokenNameIdentifier	 is Incremental Backups Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setIncrementalBackupsEnabled	TokenNameIdentifier	 set Incremental Backups Enabled
(	TokenNameLPAREN	
boolean	TokenNameboolean	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
setIncrementalBackupsEnabled	TokenNameIdentifier	 set Incremental Backups Enabled
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
setMode	TokenNameIdentifier	 set Mode
(	TokenNameLPAREN	
Mode	TokenNameIdentifier	 Mode
m	TokenNameIdentifier	 m
,	TokenNameCOMMA	
boolean	TokenNameboolean	
log	TokenNameIdentifier	 log
)	TokenNameRPAREN	
{	TokenNameLBRACE	
setMode	TokenNameIdentifier	 set Mode
(	TokenNameLPAREN	
m	TokenNameIdentifier	 m
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
log	TokenNameIdentifier	 log
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
setMode	TokenNameIdentifier	 set Mode
(	TokenNameLPAREN	
Mode	TokenNameIdentifier	 Mode
m	TokenNameIdentifier	 m
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
msg	TokenNameIdentifier	 msg
,	TokenNameCOMMA	
boolean	TokenNameboolean	
log	TokenNameIdentifier	 log
)	TokenNameRPAREN	
{	TokenNameLBRACE	
operationMode	TokenNameIdentifier	 operation Mode
=	TokenNameEQUAL	
m	TokenNameIdentifier	 m
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
logMsg	TokenNameIdentifier	 log Msg
=	TokenNameEQUAL	
msg	TokenNameIdentifier	 msg
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
m	TokenNameIdentifier	 m
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"%s: %s"	TokenNameStringLiteral	%s: %s
,	TokenNameCOMMA	
m	TokenNameIdentifier	 m
,	TokenNameCOMMA	
msg	TokenNameIdentifier	 msg
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
log	TokenNameIdentifier	 log
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
logMsg	TokenNameIdentifier	 log Msg
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
logMsg	TokenNameIdentifier	 log Msg
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
bootstrap	TokenNameIdentifier	 bootstrap
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
{	TokenNameLBRACE	
isBootstrapMode	TokenNameIdentifier	 is Bootstrap Mode
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
updateTokens	TokenNameIdentifier	 update Tokens
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// DON'T use setToken, that makes us part of the ring locally which is incorrect until we are done bootstrapping 	TokenNameCOMMENT_LINE	DON'T use setToken, that makes us part of the ring locally which is incorrect until we are done bootstrapping 
if	TokenNameif	
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
==	TokenNameEQUAL_EQUAL	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getReplaceTokens	TokenNameIdentifier	 get Replace Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if not an existing token then bootstrap 	TokenNameCOMMENT_LINE	if not an existing token then bootstrap 
// order is important here, the gossiper can fire in between adding these two states. It's ok to send TOKENS without STATUS, but *not* vice versa. 	TokenNameCOMMENT_LINE	order is important here, the gossiper can fire in between adding these two states. It's ok to send TOKENS without STATUS, but *not* vice versa. 
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
addLocalApplicationState	TokenNameIdentifier	 add Local Application State
(	TokenNameLPAREN	
ApplicationState	TokenNameIdentifier	 Application State
.	TokenNameDOT	
TOKENS	TokenNameIdentifier	 TOKENS
,	TokenNameCOMMA	
valueFactory	TokenNameIdentifier	 value Factory
.	TokenNameDOT	
tokens	TokenNameIdentifier	 tokens
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
addLocalApplicationState	TokenNameIdentifier	 add Local Application State
(	TokenNameLPAREN	
ApplicationState	TokenNameIdentifier	 Application State
.	TokenNameDOT	
STATUS	TokenNameIdentifier	 STATUS
,	TokenNameCOMMA	
valueFactory	TokenNameIdentifier	 value Factory
.	TokenNameDOT	
bootstrapping	TokenNameIdentifier	 bootstrapping
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setMode	TokenNameIdentifier	 set Mode
(	TokenNameLPAREN	
Mode	TokenNameIdentifier	 Mode
.	TokenNameDOT	
JOINING	TokenNameIdentifier	 JOINING
,	TokenNameCOMMA	
"sleeping "	TokenNameStringLiteral	sleeping 
+	TokenNamePLUS	
RING_DELAY	TokenNameIdentifier	 RING  DELAY
+	TokenNamePLUS	
" ms for pending range setup"	TokenNameStringLiteral	 ms for pending range setup
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
sleep	TokenNameIdentifier	 sleep
(	TokenNameLPAREN	
RING_DELAY	TokenNameIdentifier	 RING  DELAY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
AssertionError	TokenNameIdentifier	 Assertion Error
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Dont set any state for the node which is bootstrapping the existing token... 	TokenNameCOMMENT_LINE	Dont set any state for the node which is bootstrapping the existing token... 
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
updateNormalTokens	TokenNameIdentifier	 update Normal Tokens
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Tracing	TokenNameIdentifier	 Tracing
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setMode	TokenNameIdentifier	 set Mode
(	TokenNameLPAREN	
Mode	TokenNameIdentifier	 Mode
.	TokenNameDOT	
JOINING	TokenNameIdentifier	 JOINING
,	TokenNameCOMMA	
"Starting to bootstrap..."	TokenNameStringLiteral	Starting to bootstrap...
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
new	TokenNamenew	
BootStrapper	TokenNameIdentifier	 Boot Strapper
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
tokenMetadata	TokenNameIdentifier	 token Metadata
)	TokenNameRPAREN	
.	TokenNameDOT	
bootstrap	TokenNameIdentifier	 bootstrap
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// handles token update 	TokenNameCOMMENT_LINE	handles token update 
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Bootstrap completed! for the tokens {}"	TokenNameStringLiteral	Bootstrap completed! for the tokens {}
,	TokenNameCOMMA	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isBootstrapMode	TokenNameIdentifier	 is Bootstrap Mode
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
isBootstrapMode	TokenNameIdentifier	 is Bootstrap Mode
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
TokenMetadata	TokenNameIdentifier	 Token Metadata
getTokenMetadata	TokenNameIdentifier	 get Token Metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
tokenMetadata	TokenNameIdentifier	 token Metadata
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Gossip about the known severity of the events in this node */	TokenNameCOMMENT_JAVADOC	 Gossip about the known severity of the events in this node 
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
boolean	TokenNameboolean	
reportSeverity	TokenNameIdentifier	 report Severity
(	TokenNameLPAREN	
double	TokenNamedouble	
incr	TokenNameIdentifier	 incr
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
isEnabled	TokenNameIdentifier	 is Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
update	TokenNameIdentifier	 update
=	TokenNameEQUAL	
getSeverity	TokenNameIdentifier	 get Severity
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
incr	TokenNameIdentifier	 incr
;	TokenNameSEMICOLON	
VersionedValue	TokenNameIdentifier	 Versioned Value
updated	TokenNameIdentifier	 updated
=	TokenNameEQUAL	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
valueFactory	TokenNameIdentifier	 value Factory
.	TokenNameDOT	
severity	TokenNameIdentifier	 severity
(	TokenNameLPAREN	
update	TokenNameIdentifier	 update
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
addLocalApplicationState	TokenNameIdentifier	 add Local Application State
(	TokenNameLPAREN	
ApplicationState	TokenNameIdentifier	 Application State
.	TokenNameDOT	
SEVERITY	TokenNameIdentifier	 SEVERITY
,	TokenNameCOMMA	
updated	TokenNameIdentifier	 updated
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
double	TokenNamedouble	
getSeverity	TokenNameIdentifier	 get Severity
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
{	TokenNameLBRACE	
VersionedValue	TokenNameIdentifier	 Versioned Value
event	TokenNameIdentifier	 event
;	TokenNameSEMICOLON	
EndpointState	TokenNameIdentifier	 Endpoint State
state	TokenNameIdentifier	 state
=	TokenNameEQUAL	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getEndpointStateForEndpoint	TokenNameIdentifier	 get Endpoint State For Endpoint
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
state	TokenNameIdentifier	 state
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
event	TokenNameIdentifier	 event
=	TokenNameEQUAL	
state	TokenNameIdentifier	 state
.	TokenNameDOT	
getApplicationState	TokenNameIdentifier	 get Application State
(	TokenNameLPAREN	
ApplicationState	TokenNameIdentifier	 Application State
.	TokenNameDOT	
SEVERITY	TokenNameIdentifier	 SEVERITY
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
Double	TokenNameIdentifier	 Double
.	TokenNameDOT	
parseDouble	TokenNameIdentifier	 parse Double
(	TokenNameLPAREN	
event	TokenNameIdentifier	 event
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
0.0	TokenNameDoubleLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * for a keyspace, return the ranges and corresponding listen addresses. * @param keyspace * @return the endpoint map */	TokenNameCOMMENT_JAVADOC	 for a keyspace, return the ranges and corresponding listen addresses. @param keyspace @return the endpoint map 
public	TokenNamepublic	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>>	TokenNameRIGHT_SHIFT	
getRangeToEndpointMap	TokenNameIdentifier	 get Range To Endpoint Map
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
/* All the ranges for the tokens */	TokenNameCOMMENT_BLOCK	 All the ranges for the tokens 
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>>	TokenNameRIGHT_SHIFT	
map	TokenNameIdentifier	 map
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
getRangeToAddressMap	TokenNameIdentifier	 get Range To Address Map
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
map	TokenNameIdentifier	 map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
asList	TokenNameIdentifier	 as List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
stringify	TokenNameIdentifier	 stringify
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
map	TokenNameIdentifier	 map
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return the rpc address associated with an endpoint as a string. * @param endpoint The endpoint to get rpc address for * @return the rpc address */	TokenNameCOMMENT_JAVADOC	 Return the rpc address associated with an endpoint as a string. @param endpoint The endpoint to get rpc address for @return the rpc address 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getRpcaddress	TokenNameIdentifier	 get Rpcaddress
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getRpcAddress	TokenNameIdentifier	 get Rpc Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getHostAddress	TokenNameIdentifier	 get Host Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getEndpointStateForEndpoint	TokenNameIdentifier	 get Endpoint State For Endpoint
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
.	TokenNameDOT	
getApplicationState	TokenNameIdentifier	 get Application State
(	TokenNameLPAREN	
ApplicationState	TokenNameIdentifier	 Application State
.	TokenNameDOT	
RPC_ADDRESS	TokenNameIdentifier	 RPC  ADDRESS
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
endpoint	TokenNameIdentifier	 endpoint
.	TokenNameDOT	
getHostAddress	TokenNameIdentifier	 get Host Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getEndpointStateForEndpoint	TokenNameIdentifier	 get Endpoint State For Endpoint
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
.	TokenNameDOT	
getApplicationState	TokenNameIdentifier	 get Application State
(	TokenNameLPAREN	
ApplicationState	TokenNameIdentifier	 Application State
.	TokenNameDOT	
RPC_ADDRESS	TokenNameIdentifier	 RPC  ADDRESS
)	TokenNameRPAREN	
.	TokenNameDOT	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * for a keyspace, return the ranges and corresponding RPC addresses for a given keyspace. * @param keyspace * @return the endpoint map */	TokenNameCOMMENT_JAVADOC	 for a keyspace, return the ranges and corresponding RPC addresses for a given keyspace. @param keyspace @return the endpoint map 
public	TokenNamepublic	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>>	TokenNameRIGHT_SHIFT	
getRangeToRpcaddressMap	TokenNameIdentifier	 get Range To Rpcaddress Map
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
/* All the ranges for the tokens */	TokenNameCOMMENT_BLOCK	 All the ranges for the tokens 
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>>	TokenNameRIGHT_SHIFT	
map	TokenNameIdentifier	 map
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
getRangeToAddressMap	TokenNameIdentifier	 get Range To Address Map
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
rpcaddrs	TokenNameIdentifier	 rpcaddrs
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
:	TokenNameCOLON	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
rpcaddrs	TokenNameIdentifier	 rpcaddrs
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
getRpcaddress	TokenNameIdentifier	 get Rpcaddress
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
map	TokenNameIdentifier	 map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
asList	TokenNameIdentifier	 as List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
rpcaddrs	TokenNameIdentifier	 rpcaddrs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
map	TokenNameIdentifier	 map
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>>	TokenNameRIGHT_SHIFT	
getPendingRangeToEndpointMap	TokenNameIdentifier	 get Pending Range To Endpoint Map
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// some people just want to get a visual representation of things. Allow null and set it to the first 	TokenNameCOMMENT_LINE	some people just want to get a visual representation of things. Allow null and set it to the first 
// non-system table. 	TokenNameCOMMENT_LINE	non-system table. 
if	TokenNameif	
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
keyspace	TokenNameIdentifier	 keyspace
=	TokenNameEQUAL	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getNonSystemTables	TokenNameIdentifier	 get Non System Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>>	TokenNameRIGHT_SHIFT	
map	TokenNameIdentifier	 map
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getPendingRanges	TokenNameIdentifier	 get Pending Ranges
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
map	TokenNameIdentifier	 map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
asList	TokenNameIdentifier	 as List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
stringify	TokenNameIdentifier	 stringify
(	TokenNameLPAREN	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
map	TokenNameIdentifier	 map
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
getRangeToAddressMap	TokenNameIdentifier	 get Range To Address Map
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// some people just want to get a visual representation of things. Allow null and set it to the first 	TokenNameCOMMENT_LINE	some people just want to get a visual representation of things. Allow null and set it to the first 
// non-system table. 	TokenNameCOMMENT_LINE	non-system table. 
if	TokenNameif	
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
keyspace	TokenNameIdentifier	 keyspace
=	TokenNameEQUAL	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getNonSystemTables	TokenNameIdentifier	 get Non System Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
ranges	TokenNameIdentifier	 ranges
=	TokenNameEQUAL	
getAllRanges	TokenNameIdentifier	 get All Ranges
(	TokenNameLPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
sortedTokens	TokenNameIdentifier	 sorted Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
constructRangeToEndpointMap	TokenNameIdentifier	 construct Range To Endpoint Map
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
ranges	TokenNameIdentifier	 ranges
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The same as {@code describeRing(String)} but converts TokenRange to the String for JMX compatibility * * @param keyspace The keyspace to fetch information about * * @return a List of TokenRange(s) converted to String for the given keyspace */	TokenNameCOMMENT_JAVADOC	 The same as {@code describeRing(String)} but converts TokenRange to the String for JMX compatibility * @param keyspace The keyspace to fetch information about * @return a List of TokenRange(s) converted to String for the given keyspace 
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
describeRingJMX	TokenNameIdentifier	 describe Ring JMX
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
TokenRange	TokenNameIdentifier	 Token Range
>	TokenNameGREATER	
tokenRanges	TokenNameIdentifier	 token Ranges
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
tokenRanges	TokenNameIdentifier	 token Ranges
=	TokenNameEQUAL	
describeRing	TokenNameIdentifier	 describe Ring
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IOException	TokenNameIdentifier	 IO Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
tokenRanges	TokenNameIdentifier	 token Ranges
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
TokenRange	TokenNameIdentifier	 Token Range
tokenRange	TokenNameIdentifier	 token Range
:	TokenNameCOLON	
tokenRanges	TokenNameIdentifier	 token Ranges
)	TokenNameRPAREN	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
tokenRange	TokenNameIdentifier	 token Range
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
result	TokenNameIdentifier	 result
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The TokenRange for a given keyspace. * * @param keyspace The keyspace to fetch information about * * @return a List of TokenRange(s) for the given keyspace * * @throws InvalidRequestException if there is no ring information available about keyspace */	TokenNameCOMMENT_JAVADOC	 The TokenRange for a given keyspace. * @param keyspace The keyspace to fetch information about * @return a List of TokenRange(s) for the given keyspace * @throws InvalidRequestException if there is no ring information available about keyspace 
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
TokenRange	TokenNameIdentifier	 Token Range
>	TokenNameGREATER	
describeRing	TokenNameIdentifier	 describe Ring
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
!	TokenNameNOT	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getNonSystemTables	TokenNameIdentifier	 get Non System Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
"There is no ring for the keyspace: "	TokenNameStringLiteral	There is no ring for the keyspace: 
+	TokenNamePLUS	
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
TokenRange	TokenNameIdentifier	 Token Range
>	TokenNameGREATER	
ranges	TokenNameIdentifier	 ranges
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
TokenRange	TokenNameIdentifier	 Token Range
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Token	TokenNameIdentifier	 Token
.	TokenNameDOT	
TokenFactory	TokenNameIdentifier	 Token Factory
tf	TokenNameIdentifier	 tf
=	TokenNameEQUAL	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getTokenFactory	TokenNameIdentifier	 get Token Factory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
getRangeToAddressMap	TokenNameIdentifier	 get Range To Address Map
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Range	TokenNameIdentifier	 Range
range	TokenNameIdentifier	 range
=	TokenNameEQUAL	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
addresses	TokenNameIdentifier	 addresses
=	TokenNameEQUAL	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
endpoints	TokenNameIdentifier	 endpoints
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
addresses	TokenNameIdentifier	 addresses
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
rpc_endpoints	TokenNameIdentifier	 rpc endpoints
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
addresses	TokenNameIdentifier	 addresses
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
EndpointDetails	TokenNameIdentifier	 Endpoint Details
>	TokenNameGREATER	
epDetails	TokenNameIdentifier	 ep Details
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
EndpointDetails	TokenNameIdentifier	 Endpoint Details
>	TokenNameGREATER	
(	TokenNameLPAREN	
addresses	TokenNameIdentifier	 addresses
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
:	TokenNameCOLON	
addresses	TokenNameIdentifier	 addresses
)	TokenNameRPAREN	
{	TokenNameLBRACE	
EndpointDetails	TokenNameIdentifier	 Endpoint Details
details	TokenNameIdentifier	 details
=	TokenNameEQUAL	
new	TokenNamenew	
EndpointDetails	TokenNameIdentifier	 Endpoint Details
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
details	TokenNameIdentifier	 details
.	TokenNameDOT	
host	TokenNameIdentifier	 host
=	TokenNameEQUAL	
endpoint	TokenNameIdentifier	 endpoint
.	TokenNameDOT	
getHostAddress	TokenNameIdentifier	 get Host Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
details	TokenNameIdentifier	 details
.	TokenNameDOT	
datacenter	TokenNameIdentifier	 datacenter
=	TokenNameEQUAL	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getEndpointSnitch	TokenNameIdentifier	 get Endpoint Snitch
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getDatacenter	TokenNameIdentifier	 get Datacenter
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
details	TokenNameIdentifier	 details
.	TokenNameDOT	
rack	TokenNameIdentifier	 rack
=	TokenNameEQUAL	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getEndpointSnitch	TokenNameIdentifier	 get Endpoint Snitch
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getRack	TokenNameIdentifier	 get Rack
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
endpoints	TokenNameIdentifier	 endpoints
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
details	TokenNameIdentifier	 details
.	TokenNameDOT	
host	TokenNameIdentifier	 host
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rpc_endpoints	TokenNameIdentifier	 rpc endpoints
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
getRpcaddress	TokenNameIdentifier	 get Rpcaddress
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
epDetails	TokenNameIdentifier	 ep Details
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
details	TokenNameIdentifier	 details
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
TokenRange	TokenNameIdentifier	 Token Range
tr	TokenNameIdentifier	 tr
=	TokenNameEQUAL	
new	TokenNamenew	
TokenRange	TokenNameIdentifier	 Token Range
(	TokenNameLPAREN	
tf	TokenNameIdentifier	 tf
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
left	TokenNameIdentifier	 left
.	TokenNameDOT	
getToken	TokenNameIdentifier	 get Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
tf	TokenNameIdentifier	 tf
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
right	TokenNameIdentifier	 right
.	TokenNameDOT	
getToken	TokenNameIdentifier	 get Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
endpoints	TokenNameIdentifier	 endpoints
)	TokenNameRPAREN	
.	TokenNameDOT	
setEndpoint_details	TokenNameIdentifier	 set Endpoint details
(	TokenNameLPAREN	
epDetails	TokenNameIdentifier	 ep Details
)	TokenNameRPAREN	
.	TokenNameDOT	
setRpc_endpoints	TokenNameIdentifier	 set Rpc endpoints
(	TokenNameLPAREN	
rpc_endpoints	TokenNameIdentifier	 rpc endpoints
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ranges	TokenNameIdentifier	 ranges
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
tr	TokenNameIdentifier	 tr
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
ranges	TokenNameIdentifier	 ranges
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
getTokenToEndpointMap	TokenNameIdentifier	 get Token To Endpoint Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
mapInetAddress	TokenNameIdentifier	 map Inet Address
=	TokenNameEQUAL	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getNormalAndBootstrappingTokenToEndpointMap	TokenNameIdentifier	 get Normal And Bootstrapping Token To Endpoint Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// in order to preserve tokens in ascending order, we use LinkedHashMap here 	TokenNameCOMMENT_LINE	in order to preserve tokens in ascending order, we use LinkedHashMap here 
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
mapString	TokenNameIdentifier	 map String
=	TokenNameEQUAL	
new	TokenNamenew	
LinkedHashMap	TokenNameIdentifier	 Linked Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
mapInetAddress	TokenNameIdentifier	 map Inet Address
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
tokens	TokenNameIdentifier	 tokens
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
(	TokenNameLPAREN	
mapInetAddress	TokenNameIdentifier	 map Inet Address
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
:	TokenNameCOLON	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
{	TokenNameLBRACE	
mapString	TokenNameIdentifier	 map String
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
mapInetAddress	TokenNameIdentifier	 map Inet Address
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
.	TokenNameDOT	
getHostAddress	TokenNameIdentifier	 get Host Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
mapString	TokenNameIdentifier	 map String
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getLocalHostId	TokenNameIdentifier	 get Local Host Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getTokenMetadata	TokenNameIdentifier	 get Token Metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getHostId	TokenNameIdentifier	 get Host Id
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
getHostIdMap	TokenNameIdentifier	 get Host Id Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
mapOut	TokenNameIdentifier	 map Out
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
UUID	TokenNameIdentifier	 UUID
>	TokenNameGREATER	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
getTokenMetadata	TokenNameIdentifier	 get Token Metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getEndpointToHostIdMapForReading	TokenNameIdentifier	 get Endpoint To Host Id Map For Reading
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
mapOut	TokenNameIdentifier	 map Out
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getHostAddress	TokenNameIdentifier	 get Host Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
mapOut	TokenNameIdentifier	 map Out
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Construct the range to endpoint mapping based on the true view * of the world. * @param ranges * @return mapping of ranges to the replicas responsible for them. */	TokenNameCOMMENT_JAVADOC	 Construct the range to endpoint mapping based on the true view of the world. @param ranges @return mapping of ranges to the replicas responsible for them. 
private	TokenNameprivate	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
constructRangeToEndpointMap	TokenNameIdentifier	 construct Range To Endpoint Map
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
ranges	TokenNameIdentifier	 ranges
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
rangeToEndpointMap	TokenNameIdentifier	 range To Endpoint Map
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
:	TokenNameCOLON	
ranges	TokenNameIdentifier	 ranges
)	TokenNameRPAREN	
{	TokenNameLBRACE	
rangeToEndpointMap	TokenNameIdentifier	 range To Endpoint Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
.	TokenNameDOT	
getReplicationStrategy	TokenNameIdentifier	 get Replication Strategy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getNaturalEndpoints	TokenNameIdentifier	 get Natural Endpoints
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
right	TokenNameIdentifier	 right
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
rangeToEndpointMap	TokenNameIdentifier	 range To Endpoint Map
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* * Handle the reception of a new particular ApplicationState for a particular endpoint. Note that the value of the * ApplicationState has not necessarily "changed" since the last known value, if we already received the same update * from somewhere else. * * onChange only ever sees one ApplicationState piece change at a time (even if many ApplicationState updates were * received at the same time), so we perform a kind of state machine here. We are concerned with two events: knowing * the token associated with an endpoint, and knowing its operation mode. Nodes can start in either bootstrap or * normal mode, and from bootstrap mode can change mode to normal. A node in bootstrap mode needs to have * pendingranges set in TokenMetadata; a node in normal mode should instead be part of the token ring. * * Normal progression of ApplicationState.STATUS values for a node should be like this: * STATUS_BOOTSTRAPPING,token * if bootstrapping. stays this way until all files are received. * STATUS_NORMAL,token * ready to serve reads and writes. * STATUS_LEAVING,token * get ready to leave the cluster as part of a decommission * STATUS_LEFT,token * set after decommission is completed. * * Other STATUS values that may be seen (possibly anywhere in the normal progression): * STATUS_MOVING,newtoken * set if node is currently moving to a new token in the ring * STATUS_RELOCATING,srcToken,srcToken,srcToken,... * set if the endpoint is in the process of relocating a token to itself * REMOVING_TOKEN,deadtoken * set if the node is dead and is being removed by its REMOVAL_COORDINATOR * REMOVED_TOKEN,deadtoken * set if the node is dead and has been removed by its REMOVAL_COORDINATOR * * Note: Any time a node state changes from STATUS_NORMAL, it will not be visible to new nodes. So it follows that * you should never bootstrap a new node during a removetoken, decommission or move. */	TokenNameCOMMENT_BLOCK	 Handle the reception of a new particular ApplicationState for a particular endpoint. Note that the value of the ApplicationState has not necessarily "changed" since the last known value, if we already received the same update from somewhere else. * onChange only ever sees one ApplicationState piece change at a time (even if many ApplicationState updates were received at the same time), so we perform a kind of state machine here. We are concerned with two events: knowing the token associated with an endpoint, and knowing its operation mode. Nodes can start in either bootstrap or normal mode, and from bootstrap mode can change mode to normal. A node in bootstrap mode needs to have pendingranges set in TokenMetadata; a node in normal mode should instead be part of the token ring. * Normal progression of ApplicationState.STATUS values for a node should be like this: STATUS_BOOTSTRAPPING,token if bootstrapping. stays this way until all files are received. STATUS_NORMAL,token ready to serve reads and writes. STATUS_LEAVING,token get ready to leave the cluster as part of a decommission STATUS_LEFT,token set after decommission is completed. * Other STATUS values that may be seen (possibly anywhere in the normal progression): STATUS_MOVING,newtoken set if node is currently moving to a new token in the ring STATUS_RELOCATING,srcToken,srcToken,srcToken,... set if the endpoint is in the process of relocating a token to itself REMOVING_TOKEN,deadtoken set if the node is dead and is being removed by its REMOVAL_COORDINATOR REMOVED_TOKEN,deadtoken set if the node is dead and has been removed by its REMOVAL_COORDINATOR * Note: Any time a node state changes from STATUS_NORMAL, it will not be visible to new nodes. So it follows that you should never bootstrap a new node during a removetoken, decommission or move. 
public	TokenNamepublic	
void	TokenNamevoid	
onChange	TokenNameIdentifier	 on Change
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
ApplicationState	TokenNameIdentifier	 Application State
state	TokenNameIdentifier	 state
,	TokenNameCOMMA	
VersionedValue	TokenNameIdentifier	 Versioned Value
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
STATUS	TokenNameIdentifier	 STATUS
:	TokenNameCOLON	
String	TokenNameIdentifier	 String
apStateValue	TokenNameIdentifier	 ap State Value
=	TokenNameEQUAL	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
pieces	TokenNameIdentifier	 pieces
=	TokenNameEQUAL	
apStateValue	TokenNameIdentifier	 ap State Value
.	TokenNameDOT	
split	TokenNameIdentifier	 split
(	TokenNameLPAREN	
VersionedValue	TokenNameIdentifier	 Versioned Value
.	TokenNameDOT	
DELIMITER_STR	TokenNameIdentifier	 DELIMITER  STR
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
(	TokenNameLPAREN	
pieces	TokenNameIdentifier	 pieces
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
moveName	TokenNameIdentifier	 move Name
=	TokenNameEQUAL	
pieces	TokenNameIdentifier	 pieces
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
moveName	TokenNameIdentifier	 move Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
VersionedValue	TokenNameIdentifier	 Versioned Value
.	TokenNameDOT	
STATUS_BOOTSTRAPPING	TokenNameIdentifier	 STATUS  BOOTSTRAPPING
)	TokenNameRPAREN	
)	TokenNameRPAREN	
handleStateBootstrap	TokenNameIdentifier	 handle State Bootstrap
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
pieces	TokenNameIdentifier	 pieces
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
moveName	TokenNameIdentifier	 move Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
VersionedValue	TokenNameIdentifier	 Versioned Value
.	TokenNameDOT	
STATUS_NORMAL	TokenNameIdentifier	 STATUS  NORMAL
)	TokenNameRPAREN	
)	TokenNameRPAREN	
handleStateNormal	TokenNameIdentifier	 handle State Normal
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
pieces	TokenNameIdentifier	 pieces
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
moveName	TokenNameIdentifier	 move Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
VersionedValue	TokenNameIdentifier	 Versioned Value
.	TokenNameDOT	
REMOVING_TOKEN	TokenNameIdentifier	 REMOVING  TOKEN
)	TokenNameRPAREN	
||	TokenNameOR_OR	
moveName	TokenNameIdentifier	 move Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
VersionedValue	TokenNameIdentifier	 Versioned Value
.	TokenNameDOT	
REMOVED_TOKEN	TokenNameIdentifier	 REMOVED  TOKEN
)	TokenNameRPAREN	
)	TokenNameRPAREN	
handleStateRemoving	TokenNameIdentifier	 handle State Removing
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
pieces	TokenNameIdentifier	 pieces
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
moveName	TokenNameIdentifier	 move Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
VersionedValue	TokenNameIdentifier	 Versioned Value
.	TokenNameDOT	
STATUS_LEAVING	TokenNameIdentifier	 STATUS  LEAVING
)	TokenNameRPAREN	
)	TokenNameRPAREN	
handleStateLeaving	TokenNameIdentifier	 handle State Leaving
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
pieces	TokenNameIdentifier	 pieces
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
moveName	TokenNameIdentifier	 move Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
VersionedValue	TokenNameIdentifier	 Versioned Value
.	TokenNameDOT	
STATUS_LEFT	TokenNameIdentifier	 STATUS  LEFT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
handleStateLeft	TokenNameIdentifier	 handle State Left
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
pieces	TokenNameIdentifier	 pieces
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
moveName	TokenNameIdentifier	 move Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
VersionedValue	TokenNameIdentifier	 Versioned Value
.	TokenNameDOT	
STATUS_MOVING	TokenNameIdentifier	 STATUS  MOVING
)	TokenNameRPAREN	
)	TokenNameRPAREN	
handleStateMoving	TokenNameIdentifier	 handle State Moving
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
pieces	TokenNameIdentifier	 pieces
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
moveName	TokenNameIdentifier	 move Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
VersionedValue	TokenNameIdentifier	 Versioned Value
.	TokenNameDOT	
STATUS_RELOCATING	TokenNameIdentifier	 STATUS  RELOCATING
)	TokenNameRPAREN	
)	TokenNameRPAREN	
handleStateRelocating	TokenNameIdentifier	 handle State Relocating
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
pieces	TokenNameIdentifier	 pieces
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
RELEASE_VERSION	TokenNameIdentifier	 RELEASE  VERSION
:	TokenNameCOLON	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
updatePeerInfo	TokenNameIdentifier	 update Peer Info
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
"release_version"	TokenNameStringLiteral	release_version
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
DC	TokenNameIdentifier	 DC
:	TokenNameCOLON	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
updatePeerInfo	TokenNameIdentifier	 update Peer Info
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
"data_center"	TokenNameStringLiteral	data_center
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
RACK	TokenNameIdentifier	 RACK
:	TokenNameCOLON	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
updatePeerInfo	TokenNameIdentifier	 update Peer Info
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
"rack"	TokenNameStringLiteral	rack
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
RPC_ADDRESS	TokenNameIdentifier	 RPC  ADDRESS
:	TokenNameCOLON	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
updatePeerInfo	TokenNameIdentifier	 update Peer Info
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
"rpc_address"	TokenNameStringLiteral	rpc_address
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
SCHEMA	TokenNameIdentifier	 SCHEMA
:	TokenNameCOLON	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
updatePeerInfo	TokenNameIdentifier	 update Peer Info
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
"schema_version"	TokenNameStringLiteral	schema_version
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
HOST_ID	TokenNameIdentifier	 HOST  ID
:	TokenNameCOLON	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
updatePeerInfo	TokenNameIdentifier	 update Peer Info
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
"host_id"	TokenNameStringLiteral	host_id
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getApplicationStateValue	TokenNameIdentifier	 get Application State Value
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
ApplicationState	TokenNameIdentifier	 Application State
appstate	TokenNameIdentifier	 appstate
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
vvalue	TokenNameIdentifier	 vvalue
=	TokenNameEQUAL	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getEndpointStateForEndpoint	TokenNameIdentifier	 get Endpoint State For Endpoint
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
.	TokenNameDOT	
getApplicationState	TokenNameIdentifier	 get Application State
(	TokenNameLPAREN	
appstate	TokenNameIdentifier	 appstate
)	TokenNameRPAREN	
.	TokenNameDOT	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
return	TokenNamereturn	
vvalue	TokenNameIdentifier	 vvalue
.	TokenNameDOT	
getBytes	TokenNameIdentifier	 get Bytes
(	TokenNameLPAREN	
ISO_8859_1	TokenNameIdentifier	 ISO 8859 1
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
getTokensFor	TokenNameIdentifier	 get Tokens For
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
return	TokenNamereturn	
TokenSerializer	TokenNameIdentifier	 Token Serializer
.	TokenNameDOT	
deserialize	TokenNameIdentifier	 deserialize
(	TokenNameLPAREN	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
DataInputStream	TokenNameIdentifier	 Data Input Stream
(	TokenNameLPAREN	
new	TokenNamenew	
ByteArrayInputStream	TokenNameIdentifier	 Byte Array Input Stream
(	TokenNameLPAREN	
getApplicationStateValue	TokenNameIdentifier	 get Application State Value
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
ApplicationState	TokenNameIdentifier	 Application State
.	TokenNameDOT	
TOKENS	TokenNameIdentifier	 TOKENS
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Handle node bootstrap * * @param endpoint bootstrapping node * @param pieces STATE_BOOTSTRAPPING,bootstrap token as string */	TokenNameCOMMENT_JAVADOC	 Handle node bootstrap * @param endpoint bootstrapping node @param pieces STATE_BOOTSTRAPPING,bootstrap token as string 
private	TokenNameprivate	
void	TokenNamevoid	
handleStateBootstrap	TokenNameIdentifier	 handle State Bootstrap
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
pieces	TokenNameIdentifier	 pieces
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
pieces	TokenNameIdentifier	 pieces
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>=	TokenNameGREATER_EQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Parse versioned values according to end-point version: 	TokenNameCOMMENT_LINE	Parse versioned values according to end-point version: 
// versions < 1.2 .....: STATUS,TOKEN 	TokenNameCOMMENT_LINE	versions < 1.2 .....: STATUS,TOKEN 
// versions >= 1.2 .....: use TOKENS app state 	TokenNameCOMMENT_LINE	versions >= 1.2 .....: use TOKENS app state 
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
tokens	TokenNameIdentifier	 tokens
;	TokenNameSEMICOLON	
// explicitly check for TOKENS, because a bootstrapping node might be bootstrapping in legacy mode; that is, not using vnodes and no token specified 	TokenNameCOMMENT_LINE	explicitly check for TOKENS, because a bootstrapping node might be bootstrapping in legacy mode; that is, not using vnodes and no token specified 
if	TokenNameif	
(	TokenNameLPAREN	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
usesHostId	TokenNameIdentifier	 uses Host Id
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getEndpointStateForEndpoint	TokenNameIdentifier	 get Endpoint State For Endpoint
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
.	TokenNameDOT	
getApplicationState	TokenNameIdentifier	 get Application State
(	TokenNameLPAREN	
ApplicationState	TokenNameIdentifier	 Application State
.	TokenNameDOT	
TOKENS	TokenNameIdentifier	 TOKENS
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
tokens	TokenNameIdentifier	 tokens
=	TokenNameEQUAL	
getTokensFor	TokenNameIdentifier	 get Tokens For
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
tokens	TokenNameIdentifier	 tokens
=	TokenNameEQUAL	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
asList	TokenNameIdentifier	 as List
(	TokenNameLPAREN	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getTokenFactory	TokenNameIdentifier	 get Token Factory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
fromString	TokenNameIdentifier	 from String
(	TokenNameLPAREN	
pieces	TokenNameIdentifier	 pieces
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Node "	TokenNameStringLiteral	Node 
+	TokenNamePLUS	
endpoint	TokenNameIdentifier	 endpoint
+	TokenNamePLUS	
" state bootstrapping, token "	TokenNameStringLiteral	 state bootstrapping, token 
+	TokenNamePLUS	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// if this node is present in token metadata, either we have missed intermediate states 	TokenNameCOMMENT_LINE	if this node is present in token metadata, either we have missed intermediate states 
// or the node had crashed. Print warning if needed, clear obsolete stuff and 	TokenNameCOMMENT_LINE	or the node had crashed. Print warning if needed, clear obsolete stuff and 
// continue. 	TokenNameCOMMENT_LINE	continue. 
if	TokenNameif	
(	TokenNameLPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
isMember	TokenNameIdentifier	 is Member
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If isLeaving is false, we have missed both LEAVING and LEFT. However, if 	TokenNameCOMMENT_LINE	If isLeaving is false, we have missed both LEAVING and LEFT. However, if 
// isLeaving is true, we have only missed LEFT. Waiting time between completing 	TokenNameCOMMENT_LINE	isLeaving is true, we have only missed LEFT. Waiting time between completing 
// leave operation and rebootstrapping is relatively short, so the latter is quite 	TokenNameCOMMENT_LINE	leave operation and rebootstrapping is relatively short, so the latter is quite 
// common (not enough time for gossip to spread). Therefore we report only the 	TokenNameCOMMENT_LINE	common (not enough time for gossip to spread). Therefore we report only the 
// former in the log. 	TokenNameCOMMENT_LINE	former in the log. 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
isLeaving	TokenNameIdentifier	 is Leaving
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Node "	TokenNameStringLiteral	Node 
+	TokenNamePLUS	
endpoint	TokenNameIdentifier	 endpoint
+	TokenNamePLUS	
" state jump to bootstrap"	TokenNameStringLiteral	 state jump to bootstrap
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
removeEndpoint	TokenNameIdentifier	 remove Endpoint
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
addBootstrapTokens	TokenNameIdentifier	 add Bootstrap Tokens
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
calculatePendingRanges	TokenNameIdentifier	 calculate Pending Ranges
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
usesHostId	TokenNameIdentifier	 uses Host Id
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
updateHostId	TokenNameIdentifier	 update Host Id
(	TokenNameLPAREN	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getHostId	TokenNameIdentifier	 get Host Id
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Handle node move to normal state. That is, node is entering token ring and participating * in reads. * * @param endpoint node * @param pieces STATE_NORMAL,token */	TokenNameCOMMENT_JAVADOC	 Handle node move to normal state. That is, node is entering token ring and participating in reads. * @param endpoint node @param pieces STATE_NORMAL,token 
private	TokenNameprivate	
void	TokenNamevoid	
handleStateNormal	TokenNameIdentifier	 handle State Normal
(	TokenNameLPAREN	
final	TokenNamefinal	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
pieces	TokenNameIdentifier	 pieces
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
pieces	TokenNameIdentifier	 pieces
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>=	TokenNameGREATER_EQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Parse versioned values according to end-point version: 	TokenNameCOMMENT_LINE	Parse versioned values according to end-point version: 
// versions < 1.2 .....: STATUS,TOKEN 	TokenNameCOMMENT_LINE	versions < 1.2 .....: STATUS,TOKEN 
// versions >= 1.2 .....: uses HOST_ID/TOKENS app states 	TokenNameCOMMENT_LINE	versions >= 1.2 .....: uses HOST_ID/TOKENS app states 
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
tokens	TokenNameIdentifier	 tokens
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
usesHostId	TokenNameIdentifier	 uses Host Id
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
tokens	TokenNameIdentifier	 tokens
=	TokenNameEQUAL	
getTokensFor	TokenNameIdentifier	 get Tokens For
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
tokens	TokenNameIdentifier	 tokens
=	TokenNameEQUAL	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
asList	TokenNameIdentifier	 as List
(	TokenNameLPAREN	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getTokenFactory	TokenNameIdentifier	 get Token Factory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
fromString	TokenNameIdentifier	 from String
(	TokenNameLPAREN	
pieces	TokenNameIdentifier	 pieces
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Node "	TokenNameStringLiteral	Node 
+	TokenNamePLUS	
endpoint	TokenNameIdentifier	 endpoint
+	TokenNamePLUS	
" state normal, token "	TokenNameStringLiteral	 state normal, token 
+	TokenNamePLUS	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
isMember	TokenNameIdentifier	 is Member
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Node "	TokenNameStringLiteral	Node 
+	TokenNamePLUS	
endpoint	TokenNameIdentifier	 endpoint
+	TokenNamePLUS	
" state jump to normal"	TokenNameStringLiteral	 state jump to normal
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isClientMode	TokenNameIdentifier	 is Client Mode
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
IEndpointLifecycleSubscriber	TokenNameIdentifier	 I Endpoint Lifecycle Subscriber
subscriber	TokenNameIdentifier	 subscriber
:	TokenNameCOLON	
lifecycleSubscribers	TokenNameIdentifier	 lifecycle Subscribers
)	TokenNameRPAREN	
subscriber	TokenNameIdentifier	 subscriber
.	TokenNameDOT	
onUp	TokenNameIdentifier	 on Up
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isClientMode	TokenNameIdentifier	 is Client Mode
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
IEndpointLifecycleSubscriber	TokenNameIdentifier	 I Endpoint Lifecycle Subscriber
subscriber	TokenNameIdentifier	 subscriber
:	TokenNameCOLON	
lifecycleSubscribers	TokenNameIdentifier	 lifecycle Subscribers
)	TokenNameRPAREN	
subscriber	TokenNameIdentifier	 subscriber
.	TokenNameDOT	
onJoinCluster	TokenNameIdentifier	 on Join Cluster
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Order Matters, TM.updateHostID() should be called before TM.updateNormalToken(), (see CASSANDRA-4300). 	TokenNameCOMMENT_LINE	Order Matters, TM.updateHostID() should be called before TM.updateNormalToken(), (see CASSANDRA-4300). 
if	TokenNameif	
(	TokenNameLPAREN	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
usesHostId	TokenNameIdentifier	 uses Host Id
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
updateHostId	TokenNameIdentifier	 update Host Id
(	TokenNameLPAREN	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getHostId	TokenNameIdentifier	 get Host Id
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
tokensToUpdateInMetadata	TokenNameIdentifier	 tokens To Update In Metadata
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
tokensToUpdateInSystemTable	TokenNameIdentifier	 tokens To Update In System Table
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
localTokensToRemove	TokenNameIdentifier	 local Tokens To Remove
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
endpointsToRemove	TokenNameIdentifier	 endpoints To Remove
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
epToTokenCopy	TokenNameIdentifier	 ep To Token Copy
=	TokenNameEQUAL	
getTokenMetadata	TokenNameIdentifier	 get Token Metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getEndpointToTokenMapForReading	TokenNameIdentifier	 get Endpoint To Token Map For Reading
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
final	TokenNamefinal	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
:	TokenNameCOLON	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// we don't want to update if this node is responsible for the token and it has a later startup time than endpoint. 	TokenNameCOMMENT_LINE	we don't want to update if this node is responsible for the token and it has a later startup time than endpoint. 
InetAddress	TokenNameIdentifier	 Inet Address
currentOwner	TokenNameIdentifier	 current Owner
=	TokenNameEQUAL	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getEndpoint	TokenNameIdentifier	 get Endpoint
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
currentOwner	TokenNameIdentifier	 current Owner
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"New node "	TokenNameStringLiteral	New node 
+	TokenNamePLUS	
endpoint	TokenNameIdentifier	 endpoint
+	TokenNamePLUS	
" at token "	TokenNameStringLiteral	 at token 
+	TokenNamePLUS	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tokensToUpdateInMetadata	TokenNameIdentifier	 tokens To Update In Metadata
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isClientMode	TokenNameIdentifier	 is Client Mode
)	TokenNameRPAREN	
tokensToUpdateInSystemTable	TokenNameIdentifier	 tokens To Update In System Table
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
currentOwner	TokenNameIdentifier	 current Owner
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// set state back to normal, since the node may have tried to leave, but failed and is now back up 	TokenNameCOMMENT_LINE	set state back to normal, since the node may have tried to leave, but failed and is now back up 
// no need to persist, token/ip did not change 	TokenNameCOMMENT_LINE	no need to persist, token/ip did not change 
tokensToUpdateInMetadata	TokenNameIdentifier	 tokens To Update In Metadata
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
isRelocating	TokenNameIdentifier	 is Relocating
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getRelocatingRanges	TokenNameIdentifier	 get Relocating Ranges
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Token was relocating, this is the bookkeeping that makes it official. 	TokenNameCOMMENT_LINE	Token was relocating, this is the bookkeeping that makes it official. 
tokensToUpdateInMetadata	TokenNameIdentifier	 tokens To Update In Metadata
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isClientMode	TokenNameIdentifier	 is Client Mode
)	TokenNameRPAREN	
tokensToUpdateInSystemTable	TokenNameIdentifier	 tokens To Update In System Table
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
optionalTasks	TokenNameIdentifier	 optional Tasks
.	TokenNameDOT	
schedule	TokenNameIdentifier	 schedule
(	TokenNameLPAREN	
new	TokenNamenew	
Runnable	TokenNameIdentifier	 Runnable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
run	TokenNameIdentifier	 run
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Removing RELOCATION state for {} {}"	TokenNameStringLiteral	Removing RELOCATION state for {} {}
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
getTokenMetadata	TokenNameIdentifier	 get Token Metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
removeFromRelocating	TokenNameIdentifier	 remove From Relocating
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
RING_DELAY	TokenNameIdentifier	 RING  DELAY
,	TokenNameCOMMA	
TimeUnit	TokenNameIdentifier	 Time Unit
.	TokenNameDOT	
MILLISECONDS	TokenNameIdentifier	 MILLISECONDS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// We used to own this token; This token will need to be removed from system.local 	TokenNameCOMMENT_LINE	We used to own this token; This token will need to be removed from system.local 
if	TokenNameif	
(	TokenNameLPAREN	
currentOwner	TokenNameIdentifier	 current Owner
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
localTokensToRemove	TokenNameIdentifier	 local Tokens To Remove
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Token {} relocated to {}"	TokenNameStringLiteral	Token {} relocated to {}
,	TokenNameCOMMA	
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
isRelocating	TokenNameIdentifier	 is Relocating
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Token {} is relocating to {}, ignoring update from {}"	TokenNameStringLiteral	Token {} is relocating to {}, ignoring update from {}
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getRelocatingRanges	TokenNameIdentifier	 get Relocating Ranges
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
compareEndpointStartup	TokenNameIdentifier	 compare Endpoint Startup
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
currentOwner	TokenNameIdentifier	 current Owner
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tokensToUpdateInMetadata	TokenNameIdentifier	 tokens To Update In Metadata
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isClientMode	TokenNameIdentifier	 is Client Mode
)	TokenNameRPAREN	
tokensToUpdateInSystemTable	TokenNameIdentifier	 tokens To Update In System Table
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// currentOwner is no longer current, endpoint is. Keep track of these moves, because when 	TokenNameCOMMENT_LINE	currentOwner is no longer current, endpoint is. Keep track of these moves, because when 
// a host no longer has any tokens, we'll want to remove it. 	TokenNameCOMMENT_LINE	a host no longer has any tokens, we'll want to remove it. 
epToTokenCopy	TokenNameIdentifier	 ep To Token Copy
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
currentOwner	TokenNameIdentifier	 current Owner
)	TokenNameRPAREN	
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
epToTokenCopy	TokenNameIdentifier	 ep To Token Copy
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
currentOwner	TokenNameIdentifier	 current Owner
)	TokenNameRPAREN	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<	TokenNameLESS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
endpointsToRemove	TokenNameIdentifier	 endpoints To Remove
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
currentOwner	TokenNameIdentifier	 current Owner
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Nodes %s and %s have the same token %s. %s is the new owner"	TokenNameStringLiteral	Nodes %s and %s have the same token %s. %s is the new owner
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
currentOwner	TokenNameIdentifier	 current Owner
,	TokenNameCOMMA	
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Relocating ranges: {}"	TokenNameStringLiteral	Relocating ranges: {}
,	TokenNameCOMMA	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
printRelocatingRanges	TokenNameIdentifier	 print Relocating Ranges
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Nodes %s and %s have the same token %s. Ignoring %s"	TokenNameStringLiteral	Nodes %s and %s have the same token %s. Ignoring %s
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
currentOwner	TokenNameIdentifier	 current Owner
,	TokenNameCOMMA	
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Relocating ranges: {}"	TokenNameStringLiteral	Relocating ranges: {}
,	TokenNameCOMMA	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
printRelocatingRanges	TokenNameIdentifier	 print Relocating Ranges
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
updateNormalTokens	TokenNameIdentifier	 update Normal Tokens
(	TokenNameLPAREN	
tokensToUpdateInMetadata	TokenNameIdentifier	 tokens To Update In Metadata
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
ep	TokenNameIdentifier	 ep
:	TokenNameCOLON	
endpointsToRemove	TokenNameIdentifier	 endpoints To Remove
)	TokenNameRPAREN	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
removeEndpoint	TokenNameIdentifier	 remove Endpoint
(	TokenNameLPAREN	
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
updateTokens	TokenNameIdentifier	 update Tokens
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
tokensToUpdateInSystemTable	TokenNameIdentifier	 tokens To Update In System Table
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
updateLocalTokens	TokenNameIdentifier	 update Local Tokens
(	TokenNameLPAREN	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
emptyList	TokenNameIdentifier	 empty List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
localTokensToRemove	TokenNameIdentifier	 local Tokens To Remove
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
isMoving	TokenNameIdentifier	 is Moving
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
// if endpoint was moving to a new token 	TokenNameCOMMENT_LINE	if endpoint was moving to a new token 
{	TokenNameLBRACE	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
removeFromMoving	TokenNameIdentifier	 remove From Moving
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isClientMode	TokenNameIdentifier	 is Client Mode
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
IEndpointLifecycleSubscriber	TokenNameIdentifier	 I Endpoint Lifecycle Subscriber
subscriber	TokenNameIdentifier	 subscriber
:	TokenNameCOLON	
lifecycleSubscribers	TokenNameIdentifier	 lifecycle Subscribers
)	TokenNameRPAREN	
subscriber	TokenNameIdentifier	 subscriber
.	TokenNameDOT	
onMove	TokenNameIdentifier	 on Move
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
calculatePendingRanges	TokenNameIdentifier	 calculate Pending Ranges
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Handle node preparing to leave the ring * * @param endpoint node * @param pieces STATE_LEAVING,token */	TokenNameCOMMENT_JAVADOC	 Handle node preparing to leave the ring * @param endpoint node @param pieces STATE_LEAVING,token 
private	TokenNameprivate	
void	TokenNamevoid	
handleStateLeaving	TokenNameIdentifier	 handle State Leaving
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
pieces	TokenNameIdentifier	 pieces
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
pieces	TokenNameIdentifier	 pieces
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>=	TokenNameGREATER_EQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
tokens	TokenNameIdentifier	 tokens
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
usesHostId	TokenNameIdentifier	 uses Host Id
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
tokens	TokenNameIdentifier	 tokens
=	TokenNameEQUAL	
getTokensFor	TokenNameIdentifier	 get Tokens For
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
tokens	TokenNameIdentifier	 tokens
=	TokenNameEQUAL	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
asList	TokenNameIdentifier	 as List
(	TokenNameLPAREN	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getTokenFactory	TokenNameIdentifier	 get Token Factory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
fromString	TokenNameIdentifier	 from String
(	TokenNameLPAREN	
pieces	TokenNameIdentifier	 pieces
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Node "	TokenNameStringLiteral	Node 
+	TokenNamePLUS	
endpoint	TokenNameIdentifier	 endpoint
+	TokenNamePLUS	
" state leaving, tokens "	TokenNameStringLiteral	 state leaving, tokens 
+	TokenNamePLUS	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// If the node is previously unknown or tokens do not match, update tokenmetadata to 	TokenNameCOMMENT_LINE	If the node is previously unknown or tokens do not match, update tokenmetadata to 
// have this node as 'normal' (it must have been using this token before the 	TokenNameCOMMENT_LINE	have this node as 'normal' (it must have been using this token before the 
// leave). This way we'll get pending ranges right. 	TokenNameCOMMENT_LINE	leave). This way we'll get pending ranges right. 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
isMember	TokenNameIdentifier	 is Member
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Node "	TokenNameStringLiteral	Node 
+	TokenNamePLUS	
endpoint	TokenNameIdentifier	 endpoint
+	TokenNamePLUS	
" state jump to leaving"	TokenNameStringLiteral	 state jump to leaving
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
updateNormalTokens	TokenNameIdentifier	 update Normal Tokens
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getTokens	TokenNameIdentifier	 get Tokens
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
.	TokenNameDOT	
containsAll	TokenNameIdentifier	 contains All
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
"Node "	TokenNameStringLiteral	Node 
+	TokenNamePLUS	
endpoint	TokenNameIdentifier	 endpoint
+	TokenNamePLUS	
" 'leaving' token mismatch. Long network partition?"	TokenNameStringLiteral	 'leaving' token mismatch. Long network partition?
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
updateNormalTokens	TokenNameIdentifier	 update Normal Tokens
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// at this point the endpoint is certainly a member with this token, so let's proceed 	TokenNameCOMMENT_LINE	at this point the endpoint is certainly a member with this token, so let's proceed 
// normally 	TokenNameCOMMENT_LINE	normally 
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
addLeavingEndpoint	TokenNameIdentifier	 add Leaving Endpoint
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
calculatePendingRanges	TokenNameIdentifier	 calculate Pending Ranges
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Handle node leaving the ring. This will happen when a node is decommissioned * * @param endpoint If reason for leaving is decommission, endpoint is the leaving node. * @param pieces STATE_LEFT,token */	TokenNameCOMMENT_JAVADOC	 Handle node leaving the ring. This will happen when a node is decommissioned * @param endpoint If reason for leaving is decommission, endpoint is the leaving node. @param pieces STATE_LEFT,token 
private	TokenNameprivate	
void	TokenNamevoid	
handleStateLeft	TokenNameIdentifier	 handle State Left
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
pieces	TokenNameIdentifier	 pieces
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
pieces	TokenNameIdentifier	 pieces
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>=	TokenNameGREATER_EQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
tokens	TokenNameIdentifier	 tokens
;	TokenNameSEMICOLON	
Integer	TokenNameIdentifier	 Integer
version	TokenNameIdentifier	 version
=	TokenNameEQUAL	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getVersion	TokenNameIdentifier	 get Version
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
usesHostId	TokenNameIdentifier	 uses Host Id
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
tokens	TokenNameIdentifier	 tokens
=	TokenNameEQUAL	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
asList	TokenNameIdentifier	 as List
(	TokenNameLPAREN	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getTokenFactory	TokenNameIdentifier	 get Token Factory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
fromString	TokenNameIdentifier	 from String
(	TokenNameLPAREN	
pieces	TokenNameIdentifier	 pieces
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
tokens	TokenNameIdentifier	 tokens
=	TokenNameEQUAL	
getTokensFor	TokenNameIdentifier	 get Tokens For
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Node "	TokenNameStringLiteral	Node 
+	TokenNamePLUS	
endpoint	TokenNameIdentifier	 endpoint
+	TokenNamePLUS	
" state left, tokens "	TokenNameStringLiteral	 state left, tokens 
+	TokenNamePLUS	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
excise	TokenNameIdentifier	 excise
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
extractExpireTime	TokenNameIdentifier	 extract Expire Time
(	TokenNameLPAREN	
pieces	TokenNameIdentifier	 pieces
,	TokenNameCOMMA	
version	TokenNameIdentifier	 version
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Handle node moving inside the ring. * * @param endpoint moving endpoint address * @param pieces STATE_MOVING, token */	TokenNameCOMMENT_JAVADOC	 Handle node moving inside the ring. * @param endpoint moving endpoint address @param pieces STATE_MOVING, token 
private	TokenNameprivate	
void	TokenNamevoid	
handleStateMoving	TokenNameIdentifier	 handle State Moving
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
pieces	TokenNameIdentifier	 pieces
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
pieces	TokenNameIdentifier	 pieces
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>=	TokenNameGREATER_EQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getTokenFactory	TokenNameIdentifier	 get Token Factory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
fromString	TokenNameIdentifier	 from String
(	TokenNameLPAREN	
pieces	TokenNameIdentifier	 pieces
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Node "	TokenNameStringLiteral	Node 
+	TokenNamePLUS	
endpoint	TokenNameIdentifier	 endpoint
+	TokenNamePLUS	
" state moving, new token "	TokenNameStringLiteral	 state moving, new token 
+	TokenNamePLUS	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
addMovingEndpoint	TokenNameIdentifier	 add Moving Endpoint
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
calculatePendingRanges	TokenNameIdentifier	 calculate Pending Ranges
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Handle one or more ranges (tokens) moving from their respective endpoints, to another. * * @param endpoint the destination of the move * @param pieces STATE_RELOCATING,token,token,... */	TokenNameCOMMENT_JAVADOC	 Handle one or more ranges (tokens) moving from their respective endpoints, to another. * @param endpoint the destination of the move @param pieces STATE_RELOCATING,token,token,... 
private	TokenNameprivate	
void	TokenNamevoid	
handleStateRelocating	TokenNameIdentifier	 handle State Relocating
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
pieces	TokenNameIdentifier	 pieces
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
pieces	TokenNameIdentifier	 pieces
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>=	TokenNameGREATER_EQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
tokens	TokenNameIdentifier	 tokens
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
(	TokenNameLPAREN	
pieces	TokenNameIdentifier	 pieces
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
tStr	TokenNameIdentifier	 t Str
:	TokenNameCOLON	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
copyOfRange	TokenNameIdentifier	 copy Of Range
(	TokenNameLPAREN	
pieces	TokenNameIdentifier	 pieces
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
pieces	TokenNameIdentifier	 pieces
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
)	TokenNameRPAREN	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getTokenFactory	TokenNameIdentifier	 get Token Factory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
fromString	TokenNameIdentifier	 from String
(	TokenNameLPAREN	
tStr	TokenNameIdentifier	 t Str
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Tokens {} are relocating to {}"	TokenNameStringLiteral	Tokens {} are relocating to {}
,	TokenNameCOMMA	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
addRelocatingTokens	TokenNameIdentifier	 add Relocating Tokens
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
calculatePendingRanges	TokenNameIdentifier	 calculate Pending Ranges
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Handle notification that a node being actively removed from the ring via 'removetoken' * * @param endpoint node * @param pieces either REMOVED_TOKEN (node is gone) or REMOVING_TOKEN (replicas need to be restored) */	TokenNameCOMMENT_JAVADOC	 Handle notification that a node being actively removed from the ring via 'removetoken' * @param endpoint node @param pieces either REMOVED_TOKEN (node is gone) or REMOVING_TOKEN (replicas need to be restored) 
private	TokenNameprivate	
void	TokenNamevoid	
handleStateRemoving	TokenNameIdentifier	 handle State Removing
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
pieces	TokenNameIdentifier	 pieces
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
(	TokenNameLPAREN	
pieces	TokenNameIdentifier	 pieces
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Received removeToken gossip about myself. Is this node rejoining after an explicit removetoken?"	TokenNameStringLiteral	Received removeToken gossip about myself. Is this node rejoining after an explicit removetoken?
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
drain	TokenNameIdentifier	 drain
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
isMember	TokenNameIdentifier	 is Member
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
state	TokenNameIdentifier	 state
=	TokenNameEQUAL	
pieces	TokenNameIdentifier	 pieces
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
removeTokens	TokenNameIdentifier	 remove Tokens
=	TokenNameEQUAL	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getTokens	TokenNameIdentifier	 get Tokens
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VersionedValue	TokenNameIdentifier	 Versioned Value
.	TokenNameDOT	
REMOVED_TOKEN	TokenNameIdentifier	 REMOVED  TOKEN
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
excise	TokenNameIdentifier	 excise
(	TokenNameLPAREN	
removeTokens	TokenNameIdentifier	 remove Tokens
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
extractExpireTime	TokenNameIdentifier	 extract Expire Time
(	TokenNameLPAREN	
pieces	TokenNameIdentifier	 pieces
,	TokenNameCOMMA	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getVersion	TokenNameIdentifier	 get Version
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
VersionedValue	TokenNameIdentifier	 Versioned Value
.	TokenNameDOT	
REMOVING_TOKEN	TokenNameIdentifier	 REMOVING  TOKEN
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Tokens "	TokenNameStringLiteral	Tokens 
+	TokenNamePLUS	
removeTokens	TokenNameIdentifier	 remove Tokens
+	TokenNamePLUS	
" removed manually (endpoint was "	TokenNameStringLiteral	 removed manually (endpoint was 
+	TokenNamePLUS	
endpoint	TokenNameIdentifier	 endpoint
+	TokenNamePLUS	
")"	TokenNameStringLiteral	)
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Note that the endpoint is being removed 	TokenNameCOMMENT_LINE	Note that the endpoint is being removed 
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
addLeavingEndpoint	TokenNameIdentifier	 add Leaving Endpoint
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
calculatePendingRanges	TokenNameIdentifier	 calculate Pending Ranges
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// find the endpoint coordinating this removal that we need to notify when we're done 	TokenNameCOMMENT_LINE	find the endpoint coordinating this removal that we need to notify when we're done 
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
coordinator	TokenNameIdentifier	 coordinator
=	TokenNameEQUAL	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getEndpointStateForEndpoint	TokenNameIdentifier	 get Endpoint State For Endpoint
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
.	TokenNameDOT	
getApplicationState	TokenNameIdentifier	 get Application State
(	TokenNameLPAREN	
ApplicationState	TokenNameIdentifier	 Application State
.	TokenNameDOT	
REMOVAL_COORDINATOR	TokenNameIdentifier	 REMOVAL  COORDINATOR
)	TokenNameRPAREN	
.	TokenNameDOT	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
split	TokenNameIdentifier	 split
(	TokenNameLPAREN	
VersionedValue	TokenNameIdentifier	 Versioned Value
.	TokenNameDOT	
DELIMITER_STR	TokenNameIdentifier	 DELIMITER  STR
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
UUID	TokenNameIdentifier	 UUID
hostId	TokenNameIdentifier	 host Id
=	TokenNameEQUAL	
UUID	TokenNameIdentifier	 UUID
.	TokenNameDOT	
fromString	TokenNameIdentifier	 from String
(	TokenNameLPAREN	
coordinator	TokenNameIdentifier	 coordinator
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// grab any data we are now responsible for and notify responsible node 	TokenNameCOMMENT_LINE	grab any data we are now responsible for and notify responsible node 
restoreReplicaCount	TokenNameIdentifier	 restore Replica Count
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getEndpointForHostId	TokenNameIdentifier	 get Endpoint For Host Id
(	TokenNameLPAREN	
hostId	TokenNameIdentifier	 host Id
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
// now that the gossiper has told us about this nonexistent member, notify the gossiper to remove it 	TokenNameCOMMENT_LINE	now that the gossiper has told us about this nonexistent member, notify the gossiper to remove it 
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
removeEndpoint	TokenNameIdentifier	 remove Endpoint
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
excise	TokenNameIdentifier	 excise
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
{	TokenNameLBRACE	
HintedHandOffManager	TokenNameIdentifier	 Hinted Hand Off Manager
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
deleteHintsForEndpoint	TokenNameIdentifier	 delete Hints For Endpoint
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
removeEndpoint	TokenNameIdentifier	 remove Endpoint
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
removeEndpoint	TokenNameIdentifier	 remove Endpoint
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
removeBootstrapTokens	TokenNameIdentifier	 remove Bootstrap Tokens
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isClientMode	TokenNameIdentifier	 is Client Mode
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
IEndpointLifecycleSubscriber	TokenNameIdentifier	 I Endpoint Lifecycle Subscriber
subscriber	TokenNameIdentifier	 subscriber
:	TokenNameCOLON	
lifecycleSubscribers	TokenNameIdentifier	 lifecycle Subscribers
)	TokenNameRPAREN	
subscriber	TokenNameIdentifier	 subscriber
.	TokenNameDOT	
onLeaveCluster	TokenNameIdentifier	 on Leave Cluster
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
calculatePendingRanges	TokenNameIdentifier	 calculate Pending Ranges
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isClientMode	TokenNameIdentifier	 is Client Mode
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Removing tokens "	TokenNameStringLiteral	Removing tokens 
+	TokenNamePLUS	
tokens	TokenNameIdentifier	 tokens
+	TokenNamePLUS	
" for "	TokenNameStringLiteral	 for 
+	TokenNamePLUS	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
removeTokens	TokenNameIdentifier	 remove Tokens
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
excise	TokenNameIdentifier	 excise
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
long	TokenNamelong	
expireTime	TokenNameIdentifier	 expire Time
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addExpireTimeIfFound	TokenNameIdentifier	 add Expire Time If Found
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
expireTime	TokenNameIdentifier	 expire Time
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
excise	TokenNameIdentifier	 excise
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
addExpireTimeIfFound	TokenNameIdentifier	 add Expire Time If Found
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
long	TokenNamelong	
expireTime	TokenNameIdentifier	 expire Time
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
expireTime	TokenNameIdentifier	 expire Time
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
addExpireTimeForEndpoint	TokenNameIdentifier	 add Expire Time For Endpoint
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
expireTime	TokenNameIdentifier	 expire Time
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
protected	TokenNameprotected	
long	TokenNamelong	
extractExpireTime	TokenNameIdentifier	 extract Expire Time
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
pieces	TokenNameIdentifier	 pieces
,	TokenNameCOMMA	
int	TokenNameint	
version	TokenNameIdentifier	 version
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
version	TokenNameIdentifier	 version
<	TokenNameLESS	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
VERSION_12	TokenNameIdentifier	 VERSION 12
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
pieces	TokenNameIdentifier	 pieces
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>=	TokenNameGREATER_EQUAL	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
Long	TokenNameIdentifier	 Long
.	TokenNameDOT	
parseLong	TokenNameIdentifier	 parse Long
(	TokenNameLPAREN	
pieces	TokenNameIdentifier	 pieces
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
0L	TokenNameLongLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VersionedValue	TokenNameIdentifier	 Versioned Value
.	TokenNameDOT	
STATUS_LEFT	TokenNameIdentifier	 STATUS  LEFT
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
pieces	TokenNameIdentifier	 pieces
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
Long	TokenNameIdentifier	 Long
.	TokenNameDOT	
parseLong	TokenNameIdentifier	 parse Long
(	TokenNameLPAREN	
pieces	TokenNameIdentifier	 pieces
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
Long	TokenNameIdentifier	 Long
.	TokenNameDOT	
parseLong	TokenNameIdentifier	 parse Long
(	TokenNameLPAREN	
pieces	TokenNameIdentifier	 pieces
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Calculate pending ranges according to bootsrapping and leaving nodes. Reasoning is: * * (1) When in doubt, it is better to write too much to a node than too little. That is, if * there are multiple nodes moving, calculate the biggest ranges a node could have. Cleaning * up unneeded data afterwards is better than missing writes during movement. * (2) When a node leaves, ranges for other nodes can only grow (a node might get additional * ranges, but it will not lose any of its current ranges as a result of a leave). Therefore * we will first remove _all_ leaving tokens for the sake of calculation and then check what * ranges would go where if all nodes are to leave. This way we get the biggest possible * ranges with regard current leave operations, covering all subsets of possible final range * values. * (3) When a node bootstraps, ranges of other nodes can only get smaller. Without doing * complex calculations to see if multiple bootstraps overlap, we simply base calculations * on the same token ring used before (reflecting situation after all leave operations have * completed). Bootstrapping nodes will be added and removed one by one to that metadata and * checked what their ranges would be. This will give us the biggest possible ranges the * node could have. It might be that other bootstraps make our actual final ranges smaller, * but it does not matter as we can clean up the data afterwards. * * NOTE: This is heavy and ineffective operation. This will be done only once when a node * changes state in the cluster, so it should be manageable. */	TokenNameCOMMENT_JAVADOC	 Calculate pending ranges according to bootsrapping and leaving nodes. Reasoning is: * (1) When in doubt, it is better to write too much to a node than too little. That is, if there are multiple nodes moving, calculate the biggest ranges a node could have. Cleaning up unneeded data afterwards is better than missing writes during movement. (2) When a node leaves, ranges for other nodes can only grow (a node might get additional ranges, but it will not lose any of its current ranges as a result of a leave). Therefore we will first remove _all_ leaving tokens for the sake of calculation and then check what ranges would go where if all nodes are to leave. This way we get the biggest possible ranges with regard current leave operations, covering all subsets of possible final range values. (3) When a node bootstraps, ranges of other nodes can only get smaller. Without doing complex calculations to see if multiple bootstraps overlap, we simply base calculations on the same token ring used before (reflecting situation after all leave operations have completed). Bootstrapping nodes will be added and removed one by one to that metadata and checked what their ranges would be. This will give us the biggest possible ranges the node could have. It might be that other bootstraps make our actual final ranges smaller, but it does not matter as we can clean up the data afterwards. * NOTE: This is heavy and ineffective operation. This will be done only once when a node changes state in the cluster, so it should be manageable. 
private	TokenNameprivate	
void	TokenNamevoid	
calculatePendingRanges	TokenNameIdentifier	 calculate Pending Ranges
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
:	TokenNameCOLON	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getNonSystemTables	TokenNameIdentifier	 get Non System Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
calculatePendingRanges	TokenNameIdentifier	 calculate Pending Ranges
(	TokenNameLPAREN	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
.	TokenNameDOT	
getReplicationStrategy	TokenNameIdentifier	 get Replication Strategy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// public & static for testing purposes 	TokenNameCOMMENT_LINE	public & static for testing purposes 
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
calculatePendingRanges	TokenNameIdentifier	 calculate Pending Ranges
(	TokenNameLPAREN	
AbstractReplicationStrategy	TokenNameIdentifier	 Abstract Replication Strategy
strategy	TokenNameIdentifier	 strategy
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
{	TokenNameLBRACE	
TokenMetadata	TokenNameIdentifier	 Token Metadata
tm	TokenNameIdentifier	 tm
=	TokenNameEQUAL	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getTokenMetadata	TokenNameIdentifier	 get Token Metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
pendingRanges	TokenNameIdentifier	 pending Ranges
=	TokenNameEQUAL	
HashMultimap	TokenNameIdentifier	 Hash Multimap
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
BiMultiValMap	TokenNameIdentifier	 Bi Multi Val Map
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
bootstrapTokens	TokenNameIdentifier	 bootstrap Tokens
=	TokenNameEQUAL	
tm	TokenNameIdentifier	 tm
.	TokenNameDOT	
getBootstrapTokens	TokenNameIdentifier	 get Bootstrap Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
leavingEndpoints	TokenNameIdentifier	 leaving Endpoints
=	TokenNameEQUAL	
tm	TokenNameIdentifier	 tm
.	TokenNameDOT	
getLeavingEndpoints	TokenNameIdentifier	 get Leaving Endpoints
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
bootstrapTokens	TokenNameIdentifier	 bootstrap Tokens
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
leavingEndpoints	TokenNameIdentifier	 leaving Endpoints
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
tm	TokenNameIdentifier	 tm
.	TokenNameDOT	
getMovingEndpoints	TokenNameIdentifier	 get Moving Endpoints
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
tm	TokenNameIdentifier	 tm
.	TokenNameDOT	
getRelocatingRanges	TokenNameIdentifier	 get Relocating Ranges
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"No bootstrapping, leaving or moving nodes, and no relocating tokens -> empty pending ranges for {}"	TokenNameStringLiteral	No bootstrapping, leaving or moving nodes, and no relocating tokens -> empty pending ranges for {}
,	TokenNameCOMMA	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tm	TokenNameIdentifier	 tm
.	TokenNameDOT	
setPendingRanges	TokenNameIdentifier	 set Pending Ranges
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
pendingRanges	TokenNameIdentifier	 pending Ranges
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
addressRanges	TokenNameIdentifier	 address Ranges
=	TokenNameEQUAL	
strategy	TokenNameIdentifier	 strategy
.	TokenNameDOT	
getAddressRanges	TokenNameIdentifier	 get Address Ranges
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Copy of metadata reflecting the situation after all leave operations are finished. 	TokenNameCOMMENT_LINE	Copy of metadata reflecting the situation after all leave operations are finished. 
TokenMetadata	TokenNameIdentifier	 Token Metadata
allLeftMetadata	TokenNameIdentifier	 all Left Metadata
=	TokenNameEQUAL	
tm	TokenNameIdentifier	 tm
.	TokenNameDOT	
cloneAfterAllLeft	TokenNameIdentifier	 clone After All Left
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// get all ranges that will be affected by leaving nodes 	TokenNameCOMMENT_LINE	get all ranges that will be affected by leaving nodes 
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
affectedRanges	TokenNameIdentifier	 affected Ranges
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
:	TokenNameCOLON	
leavingEndpoints	TokenNameIdentifier	 leaving Endpoints
)	TokenNameRPAREN	
affectedRanges	TokenNameIdentifier	 affected Ranges
.	TokenNameDOT	
addAll	TokenNameIdentifier	 add All
(	TokenNameLPAREN	
addressRanges	TokenNameIdentifier	 address Ranges
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// for each of those ranges, find what new nodes will be responsible for the range when 	TokenNameCOMMENT_LINE	for each of those ranges, find what new nodes will be responsible for the range when 
// all leaving nodes are gone. 	TokenNameCOMMENT_LINE	all leaving nodes are gone. 
for	TokenNamefor	
(	TokenNameLPAREN	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
:	TokenNameCOLON	
affectedRanges	TokenNameIdentifier	 affected Ranges
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
currentEndpoints	TokenNameIdentifier	 current Endpoints
=	TokenNameEQUAL	
ImmutableSet	TokenNameIdentifier	 Immutable Set
.	TokenNameDOT	
copyOf	TokenNameIdentifier	 copy Of
(	TokenNameLPAREN	
strategy	TokenNameIdentifier	 strategy
.	TokenNameDOT	
calculateNaturalEndpoints	TokenNameIdentifier	 calculate Natural Endpoints
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
right	TokenNameIdentifier	 right
,	TokenNameCOMMA	
tm	TokenNameIdentifier	 tm
.	TokenNameDOT	
cloneOnlyTokenMap	TokenNameIdentifier	 clone Only Token Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
newEndpoints	TokenNameIdentifier	 new Endpoints
=	TokenNameEQUAL	
ImmutableSet	TokenNameIdentifier	 Immutable Set
.	TokenNameDOT	
copyOf	TokenNameIdentifier	 copy Of
(	TokenNameLPAREN	
strategy	TokenNameIdentifier	 strategy
.	TokenNameDOT	
calculateNaturalEndpoints	TokenNameIdentifier	 calculate Natural Endpoints
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
right	TokenNameIdentifier	 right
,	TokenNameCOMMA	
allLeftMetadata	TokenNameIdentifier	 all Left Metadata
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pendingRanges	TokenNameIdentifier	 pending Ranges
.	TokenNameDOT	
putAll	TokenNameIdentifier	 put All
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
Sets	TokenNameIdentifier	 Sets
.	TokenNameDOT	
difference	TokenNameIdentifier	 difference
(	TokenNameLPAREN	
newEndpoints	TokenNameIdentifier	 new Endpoints
,	TokenNameCOMMA	
currentEndpoints	TokenNameIdentifier	 current Endpoints
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// At this stage pendingRanges has been updated according to leave operations. We can 	TokenNameCOMMENT_LINE	At this stage pendingRanges has been updated according to leave operations. We can 
// now continue the calculation by checking bootstrapping nodes. 	TokenNameCOMMENT_LINE	now continue the calculation by checking bootstrapping nodes. 
// For each of the bootstrapping nodes, simply add and remove them one by one to 	TokenNameCOMMENT_LINE	For each of the bootstrapping nodes, simply add and remove them one by one to 
// allLeftMetadata and check in between what their ranges would be. 	TokenNameCOMMENT_LINE	allLeftMetadata and check in between what their ranges would be. 
for	TokenNamefor	
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
:	TokenNameCOLON	
bootstrapTokens	TokenNameIdentifier	 bootstrap Tokens
.	TokenNameDOT	
inverse	TokenNameIdentifier	 inverse
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
tokens	TokenNameIdentifier	 tokens
=	TokenNameEQUAL	
bootstrapTokens	TokenNameIdentifier	 bootstrap Tokens
.	TokenNameDOT	
inverse	TokenNameIdentifier	 inverse
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
allLeftMetadata	TokenNameIdentifier	 all Left Metadata
.	TokenNameDOT	
updateNormalTokens	TokenNameIdentifier	 update Normal Tokens
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
:	TokenNameCOLON	
strategy	TokenNameIdentifier	 strategy
.	TokenNameDOT	
getAddressRanges	TokenNameIdentifier	 get Address Ranges
(	TokenNameLPAREN	
allLeftMetadata	TokenNameIdentifier	 all Left Metadata
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
pendingRanges	TokenNameIdentifier	 pending Ranges
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
allLeftMetadata	TokenNameIdentifier	 all Left Metadata
.	TokenNameDOT	
removeEndpoint	TokenNameIdentifier	 remove Endpoint
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// At this stage pendingRanges has been updated according to leaving and bootstrapping nodes. 	TokenNameCOMMENT_LINE	At this stage pendingRanges has been updated according to leaving and bootstrapping nodes. 
// We can now finish the calculation by checking moving and relocating nodes. 	TokenNameCOMMENT_LINE	We can now finish the calculation by checking moving and relocating nodes. 
// For each of the moving nodes, we do the same thing we did for bootstrapping: 	TokenNameCOMMENT_LINE	For each of the moving nodes, we do the same thing we did for bootstrapping: 
// simply add and remove them one by one to allLeftMetadata and check in between what their ranges would be. 	TokenNameCOMMENT_LINE	simply add and remove them one by one to allLeftMetadata and check in between what their ranges would be. 
for	TokenNamefor	
(	TokenNameLPAREN	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
moving	TokenNameIdentifier	 moving
:	TokenNameCOLON	
tm	TokenNameIdentifier	 tm
.	TokenNameDOT	
getMovingEndpoints	TokenNameIdentifier	 get Moving Endpoints
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
=	TokenNameEQUAL	
moving	TokenNameIdentifier	 moving
.	TokenNameDOT	
right	TokenNameIdentifier	 right
;	TokenNameSEMICOLON	
// address of the moving node 	TokenNameCOMMENT_LINE	address of the moving node 
// moving.left is a new token of the endpoint 	TokenNameCOMMENT_LINE	moving.left is a new token of the endpoint 
allLeftMetadata	TokenNameIdentifier	 all Left Metadata
.	TokenNameDOT	
updateNormalToken	TokenNameIdentifier	 update Normal Token
(	TokenNameLPAREN	
moving	TokenNameIdentifier	 moving
.	TokenNameDOT	
left	TokenNameIdentifier	 left
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
:	TokenNameCOLON	
strategy	TokenNameIdentifier	 strategy
.	TokenNameDOT	
getAddressRanges	TokenNameIdentifier	 get Address Ranges
(	TokenNameLPAREN	
allLeftMetadata	TokenNameIdentifier	 all Left Metadata
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pendingRanges	TokenNameIdentifier	 pending Ranges
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
allLeftMetadata	TokenNameIdentifier	 all Left Metadata
.	TokenNameDOT	
removeEndpoint	TokenNameIdentifier	 remove Endpoint
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Ranges being relocated. 	TokenNameCOMMENT_LINE	Ranges being relocated. 
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
relocating	TokenNameIdentifier	 relocating
:	TokenNameCOLON	
tm	TokenNameIdentifier	 tm
.	TokenNameDOT	
getRelocatingRanges	TokenNameIdentifier	 get Relocating Ranges
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
=	TokenNameEQUAL	
relocating	TokenNameIdentifier	 relocating
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// address of the moving node 	TokenNameCOMMENT_LINE	address of the moving node 
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
relocating	TokenNameIdentifier	 relocating
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
allLeftMetadata	TokenNameIdentifier	 all Left Metadata
.	TokenNameDOT	
updateNormalToken	TokenNameIdentifier	 update Normal Token
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
:	TokenNameCOLON	
strategy	TokenNameIdentifier	 strategy
.	TokenNameDOT	
getAddressRanges	TokenNameIdentifier	 get Address Ranges
(	TokenNameLPAREN	
allLeftMetadata	TokenNameIdentifier	 all Left Metadata
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
pendingRanges	TokenNameIdentifier	 pending Ranges
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
allLeftMetadata	TokenNameIdentifier	 all Left Metadata
.	TokenNameDOT	
removeEndpoint	TokenNameIdentifier	 remove Endpoint
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
tm	TokenNameIdentifier	 tm
.	TokenNameDOT	
setPendingRanges	TokenNameIdentifier	 set Pending Ranges
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
pendingRanges	TokenNameIdentifier	 pending Ranges
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Pending ranges: "	TokenNameStringLiteral	Pending ranges: 
+	TokenNamePLUS	
(	TokenNameLPAREN	
pendingRanges	TokenNameIdentifier	 pending Ranges
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
"<empty>"	TokenNameStringLiteral	<empty>
:	TokenNameCOLON	
tm	TokenNameIdentifier	 tm
.	TokenNameDOT	
printPendingRanges	TokenNameIdentifier	 print Pending Ranges
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Finds living endpoints responsible for the given ranges * * @param table the table ranges belong to * @param ranges the ranges to find sources for * @return multimap of addresses to ranges the address is responsible for */	TokenNameCOMMENT_JAVADOC	 Finds living endpoints responsible for the given ranges * @param table the table ranges belong to @param ranges the ranges to find sources for @return multimap of addresses to ranges the address is responsible for 
private	TokenNameprivate	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
getNewSourceRanges	TokenNameIdentifier	 get New Source Ranges
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
ranges	TokenNameIdentifier	 ranges
)	TokenNameRPAREN	
{	TokenNameLBRACE	
InetAddress	TokenNameIdentifier	 Inet Address
myAddress	TokenNameIdentifier	 my Address
=	TokenNameEQUAL	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
rangeAddresses	TokenNameIdentifier	 range Addresses
=	TokenNameEQUAL	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
.	TokenNameDOT	
getReplicationStrategy	TokenNameIdentifier	 get Replication Strategy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getRangeAddresses	TokenNameIdentifier	 get Range Addresses
(	TokenNameLPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
cloneOnlyTokenMap	TokenNameIdentifier	 clone Only Token Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
sourceRanges	TokenNameIdentifier	 source Ranges
=	TokenNameEQUAL	
HashMultimap	TokenNameIdentifier	 Hash Multimap
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
IFailureDetector	TokenNameIdentifier	 I Failure Detector
failureDetector	TokenNameIdentifier	 failure Detector
=	TokenNameEQUAL	
FailureDetector	TokenNameIdentifier	 Failure Detector
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
;	TokenNameSEMICOLON	
// find alive sources for our new ranges 	TokenNameCOMMENT_LINE	find alive sources for our new ranges 
for	TokenNamefor	
(	TokenNameLPAREN	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
:	TokenNameCOLON	
ranges	TokenNameIdentifier	 ranges
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
possibleRanges	TokenNameIdentifier	 possible Ranges
=	TokenNameEQUAL	
rangeAddresses	TokenNameIdentifier	 range Addresses
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
IEndpointSnitch	TokenNameIdentifier	 I Endpoint Snitch
snitch	TokenNameIdentifier	 snitch
=	TokenNameEQUAL	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getEndpointSnitch	TokenNameIdentifier	 get Endpoint Snitch
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
sources	TokenNameIdentifier	 sources
=	TokenNameEQUAL	
snitch	TokenNameIdentifier	 snitch
.	TokenNameDOT	
getSortedListByProximity	TokenNameIdentifier	 get Sorted List By Proximity
(	TokenNameLPAREN	
myAddress	TokenNameIdentifier	 my Address
,	TokenNameCOMMA	
possibleRanges	TokenNameIdentifier	 possible Ranges
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
(	TokenNameLPAREN	
!	TokenNameNOT	
sources	TokenNameIdentifier	 sources
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
myAddress	TokenNameIdentifier	 my Address
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
source	TokenNameIdentifier	 source
:	TokenNameCOLON	
sources	TokenNameIdentifier	 sources
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
failureDetector	TokenNameIdentifier	 failure Detector
.	TokenNameDOT	
isAlive	TokenNameIdentifier	 is Alive
(	TokenNameLPAREN	
source	TokenNameIdentifier	 source
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sourceRanges	TokenNameIdentifier	 source Ranges
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
source	TokenNameIdentifier	 source
,	TokenNameCOMMA	
range	TokenNameIdentifier	 range
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
sourceRanges	TokenNameIdentifier	 source Ranges
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sends a notification to a node indicating we have finished replicating data. * * @param remote node to send notification to */	TokenNameCOMMENT_JAVADOC	 Sends a notification to a node indicating we have finished replicating data. * @param remote node to send notification to 
private	TokenNameprivate	
void	TokenNamevoid	
sendReplicationNotification	TokenNameIdentifier	 send Replication Notification
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
remote	TokenNameIdentifier	 remote
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// notify the remote token 	TokenNameCOMMENT_LINE	notify the remote token 
MessageOut	TokenNameIdentifier	 Message Out
msg	TokenNameIdentifier	 msg
=	TokenNameEQUAL	
new	TokenNamenew	
MessageOut	TokenNameIdentifier	 Message Out
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
REPLICATION_FINISHED	TokenNameIdentifier	 REPLICATION  FINISHED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
IFailureDetector	TokenNameIdentifier	 I Failure Detector
failureDetector	TokenNameIdentifier	 failure Detector
=	TokenNameEQUAL	
FailureDetector	TokenNameIdentifier	 Failure Detector
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Notifying "	TokenNameStringLiteral	Notifying 
+	TokenNamePLUS	
remote	TokenNameIdentifier	 remote
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" of replication completion "	TokenNameStringLiteral	 of replication completion 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
failureDetector	TokenNameIdentifier	 failure Detector
.	TokenNameDOT	
isAlive	TokenNameIdentifier	 is Alive
(	TokenNameLPAREN	
remote	TokenNameIdentifier	 remote
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
IAsyncResult	TokenNameIdentifier	 I Async Result
iar	TokenNameIdentifier	 iar
=	TokenNameEQUAL	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
sendRR	TokenNameIdentifier	 send RR
(	TokenNameLPAREN	
msg	TokenNameIdentifier	 msg
,	TokenNameCOMMA	
remote	TokenNameIdentifier	 remote
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
iar	TokenNameIdentifier	 iar
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getRpcTimeout	TokenNameIdentifier	 get Rpc Timeout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
TimeUnit	TokenNameIdentifier	 Time Unit
.	TokenNameDOT	
MILLISECONDS	TokenNameIdentifier	 MILLISECONDS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
// done 	TokenNameCOMMENT_LINE	done 
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
TimeoutException	TokenNameIdentifier	 Timeout Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// try again 	TokenNameCOMMENT_LINE	try again 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Called when an endpoint is removed from the ring. This function checks * whether this node becomes responsible for new ranges as a * consequence and streams data if needed. * * This is rather ineffective, but it does not matter so much * since this is called very seldom * * @param endpoint the node that left */	TokenNameCOMMENT_JAVADOC	 Called when an endpoint is removed from the ring. This function checks whether this node becomes responsible for new ranges as a consequence and streams data if needed. * This is rather ineffective, but it does not matter so much since this is called very seldom * @param endpoint the node that left 
private	TokenNameprivate	
void	TokenNamevoid	
restoreReplicaCount	TokenNameIdentifier	 restore Replica Count
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
final	TokenNamefinal	
InetAddress	TokenNameIdentifier	 Inet Address
notifyEndpoint	TokenNameIdentifier	 notify Endpoint
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
fetchSources	TokenNameIdentifier	 fetch Sources
=	TokenNameEQUAL	
HashMultimap	TokenNameIdentifier	 Hash Multimap
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
>	TokenNameGREATER	
rangesToFetch	TokenNameIdentifier	 ranges To Fetch
=	TokenNameEQUAL	
HashMultimap	TokenNameIdentifier	 Hash Multimap
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
InetAddress	TokenNameIdentifier	 Inet Address
myAddress	TokenNameIdentifier	 my Address
=	TokenNameEQUAL	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
:	TokenNameCOLON	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getNonSystemTables	TokenNameIdentifier	 get Non System Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
changedRanges	TokenNameIdentifier	 changed Ranges
=	TokenNameEQUAL	
getChangedRangesForLeaving	TokenNameIdentifier	 get Changed Ranges For Leaving
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
myNewRanges	TokenNameIdentifier	 my New Ranges
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
changedRanges	TokenNameIdentifier	 changed Ranges
.	TokenNameDOT	
entries	TokenNameIdentifier	 entries
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
myAddress	TokenNameIdentifier	 my Address
)	TokenNameRPAREN	
)	TokenNameRPAREN	
myNewRanges	TokenNameIdentifier	 my New Ranges
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
sourceRanges	TokenNameIdentifier	 source Ranges
=	TokenNameEQUAL	
getNewSourceRanges	TokenNameIdentifier	 get New Source Ranges
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
myNewRanges	TokenNameIdentifier	 my New Ranges
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
sourceRanges	TokenNameIdentifier	 source Ranges
.	TokenNameDOT	
asMap	TokenNameIdentifier	 as Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fetchSources	TokenNameIdentifier	 fetch Sources
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rangesToFetch	TokenNameIdentifier	 ranges To Fetch
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
entry	TokenNameIdentifier	 entry
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
:	TokenNameCOLON	
rangesToFetch	TokenNameIdentifier	 ranges To Fetch
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
rangesToFetch	TokenNameIdentifier	 ranges To Fetch
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
InetAddress	TokenNameIdentifier	 Inet Address
source	TokenNameIdentifier	 source
=	TokenNameEQUAL	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
ranges	TokenNameIdentifier	 ranges
=	TokenNameEQUAL	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
IStreamCallback	TokenNameIdentifier	 I Stream Callback
callback	TokenNameIdentifier	 callback
=	TokenNameEQUAL	
new	TokenNamenew	
IStreamCallback	TokenNameIdentifier	 I Stream Callback
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
onSuccess	TokenNameIdentifier	 on Success
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
fetchSources	TokenNameIdentifier	 fetch Sources
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fetchSources	TokenNameIdentifier	 fetch Sources
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
source	TokenNameIdentifier	 source
,	TokenNameCOMMA	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fetchSources	TokenNameIdentifier	 fetch Sources
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
sendReplicationNotification	TokenNameIdentifier	 send Replication Notification
(	TokenNameLPAREN	
notifyEndpoint	TokenNameIdentifier	 notify Endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
onFailure	TokenNameIdentifier	 on Failure
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
"Streaming from "	TokenNameStringLiteral	Streaming from 
+	TokenNamePLUS	
source	TokenNameIdentifier	 source
+	TokenNamePLUS	
" failed"	TokenNameStringLiteral	 failed
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
onSuccess	TokenNameIdentifier	 on Success
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// calling onSuccess to send notification 	TokenNameCOMMENT_LINE	calling onSuccess to send notification 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Requesting from "	TokenNameStringLiteral	Requesting from 
+	TokenNamePLUS	
source	TokenNameIdentifier	 source
+	TokenNamePLUS	
" ranges "	TokenNameStringLiteral	 ranges 
+	TokenNamePLUS	
StringUtils	TokenNameIdentifier	 String Utils
.	TokenNameDOT	
join	TokenNameIdentifier	 join
(	TokenNameLPAREN	
ranges	TokenNameIdentifier	 ranges
,	TokenNameCOMMA	
", "	TokenNameStringLiteral	, 
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
StreamIn	TokenNameIdentifier	 Stream In
.	TokenNameDOT	
requestRanges	TokenNameIdentifier	 request Ranges
(	TokenNameLPAREN	
source	TokenNameIdentifier	 source
,	TokenNameCOMMA	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
ranges	TokenNameIdentifier	 ranges
,	TokenNameCOMMA	
callback	TokenNameIdentifier	 callback
,	TokenNameCOMMA	
OperationType	TokenNameIdentifier	 Operation Type
.	TokenNameDOT	
RESTORE_REPLICA_COUNT	TokenNameIdentifier	 RESTORE  REPLICA  COUNT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// needs to be modified to accept either a table or ARS. 	TokenNameCOMMENT_LINE	needs to be modified to accept either a table or ARS. 
private	TokenNameprivate	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
getChangedRangesForLeaving	TokenNameIdentifier	 get Changed Ranges For Leaving
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// First get all ranges the leaving endpoint is responsible for 	TokenNameCOMMENT_LINE	First get all ranges the leaving endpoint is responsible for 
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
ranges	TokenNameIdentifier	 ranges
=	TokenNameEQUAL	
getRangesForEndpoint	TokenNameIdentifier	 get Ranges For Endpoint
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Node "	TokenNameStringLiteral	Node 
+	TokenNamePLUS	
endpoint	TokenNameIdentifier	 endpoint
+	TokenNamePLUS	
" ranges ["	TokenNameStringLiteral	 ranges [
+	TokenNamePLUS	
StringUtils	TokenNameIdentifier	 String Utils
.	TokenNameDOT	
join	TokenNameIdentifier	 join
(	TokenNameLPAREN	
ranges	TokenNameIdentifier	 ranges
,	TokenNameCOMMA	
", "	TokenNameStringLiteral	, 
)	TokenNameRPAREN	
+	TokenNamePLUS	
"]"	TokenNameStringLiteral	]
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
currentReplicaEndpoints	TokenNameIdentifier	 current Replica Endpoints
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Find (for each range) all nodes that store replicas for these ranges as well 	TokenNameCOMMENT_LINE	Find (for each range) all nodes that store replicas for these ranges as well 
for	TokenNamefor	
(	TokenNameLPAREN	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
:	TokenNameCOLON	
ranges	TokenNameIdentifier	 ranges
)	TokenNameRPAREN	
currentReplicaEndpoints	TokenNameIdentifier	 current Replica Endpoints
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
.	TokenNameDOT	
getReplicationStrategy	TokenNameIdentifier	 get Replication Strategy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
calculateNaturalEndpoints	TokenNameIdentifier	 calculate Natural Endpoints
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
right	TokenNameIdentifier	 right
,	TokenNameCOMMA	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
cloneOnlyTokenMap	TokenNameIdentifier	 clone Only Token Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TokenMetadata	TokenNameIdentifier	 Token Metadata
temp	TokenNameIdentifier	 temp
=	TokenNameEQUAL	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
cloneAfterAllLeft	TokenNameIdentifier	 clone After All Left
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// endpoint might or might not be 'leaving'. If it was not leaving (that is, removetoken 	TokenNameCOMMENT_LINE	endpoint might or might not be 'leaving'. If it was not leaving (that is, removetoken 
// command was used), it is still present in temp and must be removed. 	TokenNameCOMMENT_LINE	command was used), it is still present in temp and must be removed. 
if	TokenNameif	
(	TokenNameLPAREN	
temp	TokenNameIdentifier	 temp
.	TokenNameDOT	
isMember	TokenNameIdentifier	 is Member
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
temp	TokenNameIdentifier	 temp
.	TokenNameDOT	
removeEndpoint	TokenNameIdentifier	 remove Endpoint
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
changedRanges	TokenNameIdentifier	 changed Ranges
=	TokenNameEQUAL	
HashMultimap	TokenNameIdentifier	 Hash Multimap
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Go through the ranges and for each range check who will be 	TokenNameCOMMENT_LINE	Go through the ranges and for each range check who will be 
// storing replicas for these ranges when the leaving endpoint 	TokenNameCOMMENT_LINE	storing replicas for these ranges when the leaving endpoint 
// is gone. Whoever is present in newReplicaEndpoints list, but 	TokenNameCOMMENT_LINE	is gone. Whoever is present in newReplicaEndpoints list, but 
// not in the currentReplicaEndpoints list, will be needing the 	TokenNameCOMMENT_LINE	not in the currentReplicaEndpoints list, will be needing the 
// range. 	TokenNameCOMMENT_LINE	range. 
for	TokenNamefor	
(	TokenNameLPAREN	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
:	TokenNameCOLON	
ranges	TokenNameIdentifier	 ranges
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
newReplicaEndpoints	TokenNameIdentifier	 new Replica Endpoints
=	TokenNameEQUAL	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
.	TokenNameDOT	
getReplicationStrategy	TokenNameIdentifier	 get Replication Strategy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
calculateNaturalEndpoints	TokenNameIdentifier	 calculate Natural Endpoints
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
right	TokenNameIdentifier	 right
,	TokenNameCOMMA	
temp	TokenNameIdentifier	 temp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
newReplicaEndpoints	TokenNameIdentifier	 new Replica Endpoints
.	TokenNameDOT	
removeAll	TokenNameIdentifier	 remove All
(	TokenNameLPAREN	
currentReplicaEndpoints	TokenNameIdentifier	 current Replica Endpoints
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
if	TokenNameif	
(	TokenNameLPAREN	
newReplicaEndpoints	TokenNameIdentifier	 new Replica Endpoints
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Range "	TokenNameStringLiteral	Range 
+	TokenNamePLUS	
range	TokenNameIdentifier	 range
+	TokenNamePLUS	
" already in all replicas"	TokenNameStringLiteral	 already in all replicas
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Range "	TokenNameStringLiteral	Range 
+	TokenNamePLUS	
range	TokenNameIdentifier	 range
+	TokenNamePLUS	
" will be responsibility of "	TokenNameStringLiteral	 will be responsibility of 
+	TokenNamePLUS	
StringUtils	TokenNameIdentifier	 String Utils
.	TokenNameDOT	
join	TokenNameIdentifier	 join
(	TokenNameLPAREN	
newReplicaEndpoints	TokenNameIdentifier	 new Replica Endpoints
,	TokenNameCOMMA	
", "	TokenNameStringLiteral	, 
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
changedRanges	TokenNameIdentifier	 changed Ranges
.	TokenNameDOT	
putAll	TokenNameIdentifier	 put All
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
newReplicaEndpoints	TokenNameIdentifier	 new Replica Endpoints
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
changedRanges	TokenNameIdentifier	 changed Ranges
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
onJoin	TokenNameIdentifier	 on Join
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
EndpointState	TokenNameIdentifier	 Endpoint State
epState	TokenNameIdentifier	 ep State
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
ApplicationState	TokenNameIdentifier	 Application State
,	TokenNameCOMMA	
VersionedValue	TokenNameIdentifier	 Versioned Value
>	TokenNameGREATER	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
epState	TokenNameIdentifier	 ep State
.	TokenNameDOT	
getApplicationStateMap	TokenNameIdentifier	 get Application State Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
onChange	TokenNameIdentifier	 on Change
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
onAlive	TokenNameIdentifier	 on Alive
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
EndpointState	TokenNameIdentifier	 Endpoint State
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isClientMode	TokenNameIdentifier	 is Client Mode
&&	TokenNameAND_AND	
getTokenMetadata	TokenNameIdentifier	 get Token Metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
isMember	TokenNameIdentifier	 is Member
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
HintedHandOffManager	TokenNameIdentifier	 Hinted Hand Off Manager
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
scheduleHintDelivery	TokenNameIdentifier	 schedule Hint Delivery
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
onRemove	TokenNameIdentifier	 on Remove
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
removeEndpoint	TokenNameIdentifier	 remove Endpoint
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
calculatePendingRanges	TokenNameIdentifier	 calculate Pending Ranges
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
onDead	TokenNameIdentifier	 on Dead
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
EndpointState	TokenNameIdentifier	 Endpoint State
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
{	TokenNameLBRACE	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
convict	TokenNameIdentifier	 convict
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isClientMode	TokenNameIdentifier	 is Client Mode
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
IEndpointLifecycleSubscriber	TokenNameIdentifier	 I Endpoint Lifecycle Subscriber
subscriber	TokenNameIdentifier	 subscriber
:	TokenNameCOLON	
lifecycleSubscribers	TokenNameIdentifier	 lifecycle Subscribers
)	TokenNameRPAREN	
subscriber	TokenNameIdentifier	 subscriber
.	TokenNameDOT	
onDown	TokenNameIdentifier	 on Down
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
onRestart	TokenNameIdentifier	 on Restart
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
EndpointState	TokenNameIdentifier	 Endpoint State
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If we have restarted before the node was even marked down, we need to reset the connection pool 	TokenNameCOMMENT_LINE	If we have restarted before the node was even marked down, we need to reset the connection pool 
if	TokenNameif	
(	TokenNameLPAREN	
state	TokenNameIdentifier	 state
.	TokenNameDOT	
isAlive	TokenNameIdentifier	 is Alive
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
onDead	TokenNameIdentifier	 on Dead
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** raw load value */	TokenNameCOMMENT_JAVADOC	 raw load value 
public	TokenNamepublic	
double	TokenNamedouble	
getLoad	TokenNameIdentifier	 get Load
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
double	TokenNamedouble	
bytes	TokenNameIdentifier	 bytes
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
tableName	TokenNameIdentifier	 table Name
:	TokenNameCOLON	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getTables	TokenNameIdentifier	 get Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Table	TokenNameIdentifier	 Table
table	TokenNameIdentifier	 table
=	TokenNameEQUAL	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
tableName	TokenNameIdentifier	 table Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
:	TokenNameCOLON	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
getColumnFamilyStores	TokenNameIdentifier	 get Column Family Stores
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
bytes	TokenNameIdentifier	 bytes
+=	TokenNamePLUS_EQUAL	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
getLiveDiskSpaceUsed	TokenNameIdentifier	 get Live Disk Space Used
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
bytes	TokenNameIdentifier	 bytes
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getLoadString	TokenNameIdentifier	 get Load String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
stringifyFileSize	TokenNameIdentifier	 stringify File Size
(	TokenNameLPAREN	
getLoad	TokenNameIdentifier	 get Load
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
getLoadMap	TokenNameIdentifier	 get Load Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
map	TokenNameIdentifier	 map
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
Double	TokenNameIdentifier	 Double
>	TokenNameGREATER	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
LoadBroadcaster	TokenNameIdentifier	 Load Broadcaster
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getLoadInfo	TokenNameIdentifier	 get Load Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
map	TokenNameIdentifier	 map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getHostAddress	TokenNameIdentifier	 get Host Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
stringifyFileSize	TokenNameIdentifier	 stringify File Size
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// gossiper doesn't see its own updates, so we need to special-case the local node 	TokenNameCOMMENT_LINE	gossiper doesn't see its own updates, so we need to special-case the local node 
map	TokenNameIdentifier	 map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getHostAddress	TokenNameIdentifier	 get Host Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
getLoadString	TokenNameIdentifier	 get Load String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
map	TokenNameIdentifier	 map
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
final	TokenNamefinal	
void	TokenNamevoid	
deliverHints	TokenNameIdentifier	 deliver Hints
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
host	TokenNameIdentifier	 host
)	TokenNameRPAREN	
throws	TokenNamethrows	
UnknownHostException	TokenNameIdentifier	 Unknown Host Exception
{	TokenNameLBRACE	
HintedHandOffManager	TokenNameIdentifier	 Hinted Hand Off Manager
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
scheduleHintDelivery	TokenNameIdentifier	 schedule Hint Delivery
(	TokenNameLPAREN	
host	TokenNameIdentifier	 host
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
getLocalTokens	TokenNameIdentifier	 get Local Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
tokens	TokenNameIdentifier	 tokens
=	TokenNameEQUAL	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
getSavedTokens	TokenNameIdentifier	 get Saved Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
tokens	TokenNameIdentifier	 tokens
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// should not be called before initServer sets this 	TokenNameCOMMENT_LINE	should not be called before initServer sets this 
return	TokenNamereturn	
tokens	TokenNameIdentifier	 tokens
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* These methods belong to the MBean interface */	TokenNameCOMMENT_BLOCK	 These methods belong to the MBean interface 
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
getTokens	TokenNameIdentifier	 get Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getTokens	TokenNameIdentifier	 get Tokens
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
getTokens	TokenNameIdentifier	 get Tokens
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
throws	TokenNamethrows	
UnknownHostException	TokenNameIdentifier	 Unknown Host Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
getTokens	TokenNameIdentifier	 get Tokens
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
.	TokenNameDOT	
getByName	TokenNameIdentifier	 get By Name
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
getTokens	TokenNameIdentifier	 get Tokens
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
strTokens	TokenNameIdentifier	 str Tokens
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
tok	TokenNameIdentifier	 tok
:	TokenNameCOLON	
getTokenMetadata	TokenNameIdentifier	 get Token Metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getTokens	TokenNameIdentifier	 get Tokens
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
strTokens	TokenNameIdentifier	 str Tokens
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
tok	TokenNameIdentifier	 tok
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
strTokens	TokenNameIdentifier	 str Tokens
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getReleaseVersion	TokenNameIdentifier	 get Release Version
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getReleaseVersionString	TokenNameIdentifier	 get Release Version String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getSchemaVersion	TokenNameIdentifier	 get Schema Version
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getVersion	TokenNameIdentifier	 get Version
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
getLeavingNodes	TokenNameIdentifier	 get Leaving Nodes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
stringify	TokenNameIdentifier	 stringify
(	TokenNameLPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getLeavingEndpoints	TokenNameIdentifier	 get Leaving Endpoints
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
getMovingNodes	TokenNameIdentifier	 get Moving Nodes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
endpoints	TokenNameIdentifier	 endpoints
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
node	TokenNameIdentifier	 node
:	TokenNameCOLON	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getMovingEndpoints	TokenNameIdentifier	 get Moving Endpoints
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
endpoints	TokenNameIdentifier	 endpoints
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
right	TokenNameIdentifier	 right
.	TokenNameDOT	
getHostAddress	TokenNameIdentifier	 get Host Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
endpoints	TokenNameIdentifier	 endpoints
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
getJoiningNodes	TokenNameIdentifier	 get Joining Nodes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
stringify	TokenNameIdentifier	 stringify
(	TokenNameLPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getBootstrapTokens	TokenNameIdentifier	 get Bootstrap Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
values	TokenNameIdentifier	 values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
getLiveNodes	TokenNameIdentifier	 get Live Nodes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
stringify	TokenNameIdentifier	 stringify
(	TokenNameLPAREN	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getLiveMembers	TokenNameIdentifier	 get Live Members
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
getUnreachableNodes	TokenNameIdentifier	 get Unreachable Nodes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
stringify	TokenNameIdentifier	 stringify
(	TokenNameLPAREN	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getUnreachableMembers	TokenNameIdentifier	 get Unreachable Members
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getAllDataFileLocations	TokenNameIdentifier	 get All Data File Locations
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
locations	TokenNameIdentifier	 locations
=	TokenNameEQUAL	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getAllDataFileLocations	TokenNameIdentifier	 get All Data File Locations
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
locations	TokenNameIdentifier	 locations
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
locations	TokenNameIdentifier	 locations
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
getCanonicalPath	TokenNameIdentifier	 get Canonical Path
(	TokenNameLPAREN	
locations	TokenNameIdentifier	 locations
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
locations	TokenNameIdentifier	 locations
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getCommitLogLocation	TokenNameIdentifier	 get Commit Log Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
getCanonicalPath	TokenNameIdentifier	 get Canonical Path
(	TokenNameLPAREN	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getCommitLogLocation	TokenNameIdentifier	 get Commit Log Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getSavedCachesLocation	TokenNameIdentifier	 get Saved Caches Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
getCanonicalPath	TokenNameIdentifier	 get Canonical Path
(	TokenNameLPAREN	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getSavedCachesLocation	TokenNameIdentifier	 get Saved Caches Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
stringify	TokenNameIdentifier	 stringify
(	TokenNameLPAREN	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
endpoints	TokenNameIdentifier	 endpoints
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
stringEndpoints	TokenNameIdentifier	 string Endpoints
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
ep	TokenNameIdentifier	 ep
:	TokenNameCOLON	
endpoints	TokenNameIdentifier	 endpoints
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stringEndpoints	TokenNameIdentifier	 string Endpoints
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
ep	TokenNameIdentifier	 ep
.	TokenNameDOT	
getHostAddress	TokenNameIdentifier	 get Host Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
stringEndpoints	TokenNameIdentifier	 string Endpoints
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getCurrentGenerationNumber	TokenNameIdentifier	 get Current Generation Number
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getCurrentGenerationNumber	TokenNameIdentifier	 get Current Generation Number
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
forceTableCleanup	TokenNameIdentifier	 force Table Cleanup
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
tableName	TokenNameIdentifier	 table Name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
...	TokenNameELLIPSIS	
columnFamilies	TokenNameIdentifier	 column Families
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
ExecutionException	TokenNameIdentifier	 Execution Exception
,	TokenNameCOMMA	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
tableName	TokenNameIdentifier	 table Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
SYSTEM_KS	TokenNameIdentifier	 SYSTEM  KS
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"Cleanup of the system table is neither necessary nor wise"	TokenNameStringLiteral	Cleanup of the system table is neither necessary nor wise
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CounterId	TokenNameIdentifier	 Counter Id
.	TokenNameDOT	
OneShotRenewer	TokenNameIdentifier	 One Shot Renewer
counterIdRenewer	TokenNameIdentifier	 counter Id Renewer
=	TokenNameEQUAL	
new	TokenNamenew	
CounterId	TokenNameIdentifier	 Counter Id
.	TokenNameDOT	
OneShotRenewer	TokenNameIdentifier	 One Shot Renewer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfStore	TokenNameIdentifier	 cf Store
:	TokenNameCOLON	
getValidColumnFamilies	TokenNameIdentifier	 get Valid Column Families
(	TokenNameLPAREN	
tableName	TokenNameIdentifier	 table Name
,	TokenNameCOMMA	
columnFamilies	TokenNameIdentifier	 column Families
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
cfStore	TokenNameIdentifier	 cf Store
.	TokenNameDOT	
forceCleanup	TokenNameIdentifier	 force Cleanup
(	TokenNameLPAREN	
counterIdRenewer	TokenNameIdentifier	 counter Id Renewer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
scrub	TokenNameIdentifier	 scrub
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
tableName	TokenNameIdentifier	 table Name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
...	TokenNameELLIPSIS	
columnFamilies	TokenNameIdentifier	 column Families
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
ExecutionException	TokenNameIdentifier	 Execution Exception
,	TokenNameCOMMA	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfStore	TokenNameIdentifier	 cf Store
:	TokenNameCOLON	
getValidColumnFamilies	TokenNameIdentifier	 get Valid Column Families
(	TokenNameLPAREN	
tableName	TokenNameIdentifier	 table Name
,	TokenNameCOMMA	
columnFamilies	TokenNameIdentifier	 column Families
)	TokenNameRPAREN	
)	TokenNameRPAREN	
cfStore	TokenNameIdentifier	 cf Store
.	TokenNameDOT	
scrub	TokenNameIdentifier	 scrub
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
upgradeSSTables	TokenNameIdentifier	 upgrade SS Tables
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
tableName	TokenNameIdentifier	 table Name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
...	TokenNameELLIPSIS	
columnFamilies	TokenNameIdentifier	 column Families
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
ExecutionException	TokenNameIdentifier	 Execution Exception
,	TokenNameCOMMA	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfStore	TokenNameIdentifier	 cf Store
:	TokenNameCOLON	
getValidColumnFamilies	TokenNameIdentifier	 get Valid Column Families
(	TokenNameLPAREN	
tableName	TokenNameIdentifier	 table Name
,	TokenNameCOMMA	
columnFamilies	TokenNameIdentifier	 column Families
)	TokenNameRPAREN	
)	TokenNameRPAREN	
cfStore	TokenNameIdentifier	 cf Store
.	TokenNameDOT	
sstablesRewrite	TokenNameIdentifier	 sstables Rewrite
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
forceTableCompaction	TokenNameIdentifier	 force Table Compaction
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
tableName	TokenNameIdentifier	 table Name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
...	TokenNameELLIPSIS	
columnFamilies	TokenNameIdentifier	 column Families
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
ExecutionException	TokenNameIdentifier	 Execution Exception
,	TokenNameCOMMA	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfStore	TokenNameIdentifier	 cf Store
:	TokenNameCOLON	
getValidColumnFamilies	TokenNameIdentifier	 get Valid Column Families
(	TokenNameLPAREN	
tableName	TokenNameIdentifier	 table Name
,	TokenNameCOMMA	
columnFamilies	TokenNameIdentifier	 column Families
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
cfStore	TokenNameIdentifier	 cf Store
.	TokenNameDOT	
forceMajorCompaction	TokenNameIdentifier	 force Major Compaction
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Takes the snapshot for the given tables. A snapshot name must be specified. * * @param tag the tag given to the snapshot; may not be null or empty * @param tableNames the name of the tables to snapshot; empty means "all." */	TokenNameCOMMENT_JAVADOC	 Takes the snapshot for the given tables. A snapshot name must be specified. * @param tag the tag given to the snapshot; may not be null or empty @param tableNames the name of the tables to snapshot; empty means "all." 
public	TokenNamepublic	
void	TokenNamevoid	
takeSnapshot	TokenNameIdentifier	 take Snapshot
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
tag	TokenNameIdentifier	 tag
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
...	TokenNameELLIPSIS	
tableNames	TokenNameIdentifier	 table Names
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
tag	TokenNameIdentifier	 tag
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
tag	TokenNameIdentifier	 tag
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IOException	TokenNameIdentifier	 IO Exception
(	TokenNameLPAREN	
"You must supply a snapshot name."	TokenNameStringLiteral	You must supply a snapshot name.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
Table	TokenNameIdentifier	 Table
>	TokenNameGREATER	
tables	TokenNameIdentifier	 tables
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
tableNames	TokenNameIdentifier	 table Names
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tables	TokenNameIdentifier	 tables
=	TokenNameEQUAL	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
all	TokenNameIdentifier	 all
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Table	TokenNameIdentifier	 Table
>	TokenNameGREATER	
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Table	TokenNameIdentifier	 Table
>	TokenNameGREATER	
(	TokenNameLPAREN	
tableNames	TokenNameIdentifier	 table Names
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
:	TokenNameCOLON	
tableNames	TokenNameIdentifier	 table Names
)	TokenNameRPAREN	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
getValidTable	TokenNameIdentifier	 get Valid Table
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tables	TokenNameIdentifier	 tables
=	TokenNameEQUAL	
t	TokenNameIdentifier	 t
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Do a check to see if this snapshot exists before we actually snapshot 	TokenNameCOMMENT_LINE	Do a check to see if this snapshot exists before we actually snapshot 
for	TokenNamefor	
(	TokenNameLPAREN	
Table	TokenNameIdentifier	 Table
table	TokenNameIdentifier	 table
:	TokenNameCOLON	
tables	TokenNameIdentifier	 tables
)	TokenNameRPAREN	
if	TokenNameif	
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
snapshotExists	TokenNameIdentifier	 snapshot Exists
(	TokenNameLPAREN	
tag	TokenNameIdentifier	 tag
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IOException	TokenNameIdentifier	 IO Exception
(	TokenNameLPAREN	
"Snapshot "	TokenNameStringLiteral	Snapshot 
+	TokenNamePLUS	
tag	TokenNameIdentifier	 tag
+	TokenNamePLUS	
" already exists."	TokenNameStringLiteral	 already exists.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Table	TokenNameIdentifier	 Table
table	TokenNameIdentifier	 table
:	TokenNameCOLON	
tables	TokenNameIdentifier	 tables
)	TokenNameRPAREN	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
snapshot	TokenNameIdentifier	 snapshot
(	TokenNameLPAREN	
tag	TokenNameIdentifier	 tag
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Takes the snapshot of a specific column family. A snapshot name must be specified. * * @param tableName the keyspace which holds the specified column family * @param columnFamilyName the column family to snapshot * @param tag the tag given to the snapshot; may not be null or empty */	TokenNameCOMMENT_JAVADOC	 Takes the snapshot of a specific column family. A snapshot name must be specified. * @param tableName the keyspace which holds the specified column family @param columnFamilyName the column family to snapshot @param tag the tag given to the snapshot; may not be null or empty 
public	TokenNamepublic	
void	TokenNamevoid	
takeColumnFamilySnapshot	TokenNameIdentifier	 take Column Family Snapshot
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
tableName	TokenNameIdentifier	 table Name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
columnFamilyName	TokenNameIdentifier	 column Family Name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
tag	TokenNameIdentifier	 tag
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
tableName	TokenNameIdentifier	 table Name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IOException	TokenNameIdentifier	 IO Exception
(	TokenNameLPAREN	
"You must supply a table name"	TokenNameStringLiteral	You must supply a table name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
columnFamilyName	TokenNameIdentifier	 column Family Name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IOException	TokenNameIdentifier	 IO Exception
(	TokenNameLPAREN	
"You mus supply a column family name"	TokenNameStringLiteral	You mus supply a column family name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
tag	TokenNameIdentifier	 tag
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
tag	TokenNameIdentifier	 tag
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IOException	TokenNameIdentifier	 IO Exception
(	TokenNameLPAREN	
"You must supply a snapshot name."	TokenNameStringLiteral	You must supply a snapshot name.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Table	TokenNameIdentifier	 Table
table	TokenNameIdentifier	 table
=	TokenNameEQUAL	
getValidTable	TokenNameIdentifier	 get Valid Table
(	TokenNameLPAREN	
tableName	TokenNameIdentifier	 table Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
snapshotExists	TokenNameIdentifier	 snapshot Exists
(	TokenNameLPAREN	
tag	TokenNameIdentifier	 tag
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IOException	TokenNameIdentifier	 IO Exception
(	TokenNameLPAREN	
"Snapshot "	TokenNameStringLiteral	Snapshot 
+	TokenNamePLUS	
tag	TokenNameIdentifier	 tag
+	TokenNamePLUS	
" already exists."	TokenNameStringLiteral	 already exists.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
snapshot	TokenNameIdentifier	 snapshot
(	TokenNameLPAREN	
tag	TokenNameIdentifier	 tag
,	TokenNameCOMMA	
columnFamilyName	TokenNameIdentifier	 column Family Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
Table	TokenNameIdentifier	 Table
getValidTable	TokenNameIdentifier	 get Valid Table
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
tableName	TokenNameIdentifier	 table Name
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getTables	TokenNameIdentifier	 get Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
tableName	TokenNameIdentifier	 table Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IOException	TokenNameIdentifier	 IO Exception
(	TokenNameLPAREN	
"Table "	TokenNameStringLiteral	Table 
+	TokenNamePLUS	
tableName	TokenNameIdentifier	 table Name
+	TokenNamePLUS	
" does not exist"	TokenNameStringLiteral	 does not exist
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
tableName	TokenNameIdentifier	 table Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Remove the snapshot with the given name from the given tables. * If no tag is specified we will remove all snapshots. */	TokenNameCOMMENT_JAVADOC	 Remove the snapshot with the given name from the given tables. If no tag is specified we will remove all snapshots. 
public	TokenNamepublic	
void	TokenNamevoid	
clearSnapshot	TokenNameIdentifier	 clear Snapshot
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
tag	TokenNameIdentifier	 tag
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
...	TokenNameELLIPSIS	
tableNames	TokenNameIdentifier	 table Names
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
tag	TokenNameIdentifier	 tag
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
tag	TokenNameIdentifier	 tag
=	TokenNameEQUAL	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
Table	TokenNameIdentifier	 Table
>	TokenNameGREATER	
tables	TokenNameIdentifier	 tables
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
tableNames	TokenNameIdentifier	 table Names
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tables	TokenNameIdentifier	 tables
=	TokenNameEQUAL	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
all	TokenNameIdentifier	 all
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Table	TokenNameIdentifier	 Table
>	TokenNameGREATER	
tempTables	TokenNameIdentifier	 temp Tables
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Table	TokenNameIdentifier	 Table
>	TokenNameGREATER	
(	TokenNameLPAREN	
tableNames	TokenNameIdentifier	 table Names
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
:	TokenNameCOLON	
tableNames	TokenNameIdentifier	 table Names
)	TokenNameRPAREN	
tempTables	TokenNameIdentifier	 temp Tables
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
getValidTable	TokenNameIdentifier	 get Valid Table
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tables	TokenNameIdentifier	 tables
=	TokenNameEQUAL	
tempTables	TokenNameIdentifier	 temp Tables
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Table	TokenNameIdentifier	 Table
table	TokenNameIdentifier	 table
:	TokenNameCOLON	
tables	TokenNameIdentifier	 tables
)	TokenNameRPAREN	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
clearSnapshot	TokenNameIdentifier	 clear Snapshot
(	TokenNameLPAREN	
tag	TokenNameIdentifier	 tag
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Cleared out snapshot directories"	TokenNameStringLiteral	Cleared out snapshot directories
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
>	TokenNameGREATER	
getValidColumnFamilies	TokenNameIdentifier	 get Valid Column Families
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
tableName	TokenNameIdentifier	 table Name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
...	TokenNameELLIPSIS	
cfNames	TokenNameIdentifier	 cf Names
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
Table	TokenNameIdentifier	 Table
table	TokenNameIdentifier	 table
=	TokenNameEQUAL	
getValidTable	TokenNameIdentifier	 get Valid Table
(	TokenNameLPAREN	
tableName	TokenNameIdentifier	 table Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cfNames	TokenNameIdentifier	 cf Names
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
// all stores are interesting 	TokenNameCOMMENT_LINE	all stores are interesting 
return	TokenNamereturn	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
getColumnFamilyStores	TokenNameIdentifier	 get Column Family Stores
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// filter out interesting stores 	TokenNameCOMMENT_LINE	filter out interesting stores 
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
>	TokenNameGREATER	
valid	TokenNameIdentifier	 valid
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
cfName	TokenNameIdentifier	 cf Name
:	TokenNameCOLON	
cfNames	TokenNameIdentifier	 cf Names
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfStore	TokenNameIdentifier	 cf Store
=	TokenNameEQUAL	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
getColumnFamilyStore	TokenNameIdentifier	 get Column Family Store
(	TokenNameLPAREN	
cfName	TokenNameIdentifier	 cf Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cfStore	TokenNameIdentifier	 cf Store
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// this means there was a cf passed in that is not recognized in the keyspace. report it and continue. 	TokenNameCOMMENT_LINE	this means there was a cf passed in that is not recognized in the keyspace. report it and continue. 
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Invalid column family specified: %s. Proceeding with others."	TokenNameStringLiteral	Invalid column family specified: %s. Proceeding with others.
,	TokenNameCOMMA	
cfName	TokenNameIdentifier	 cf Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
valid	TokenNameIdentifier	 valid
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
cfStore	TokenNameIdentifier	 cf Store
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
valid	TokenNameIdentifier	 valid
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Flush all memtables for a table and column families. * @param tableName * @param columnFamilies * @throws IOException */	TokenNameCOMMENT_JAVADOC	 Flush all memtables for a table and column families. @param tableName @param columnFamilies @throws IOException 
public	TokenNamepublic	
void	TokenNamevoid	
forceTableFlush	TokenNameIdentifier	 force Table Flush
(	TokenNameLPAREN	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
tableName	TokenNameIdentifier	 table Name
,	TokenNameCOMMA	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
...	TokenNameELLIPSIS	
columnFamilies	TokenNameIdentifier	 column Families
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
ExecutionException	TokenNameIdentifier	 Execution Exception
,	TokenNameCOMMA	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfStore	TokenNameIdentifier	 cf Store
:	TokenNameCOLON	
getValidColumnFamilies	TokenNameIdentifier	 get Valid Column Families
(	TokenNameLPAREN	
tableName	TokenNameIdentifier	 table Name
,	TokenNameCOMMA	
columnFamilies	TokenNameIdentifier	 column Families
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Forcing flush on keyspace "	TokenNameStringLiteral	Forcing flush on keyspace 
+	TokenNamePLUS	
tableName	TokenNameIdentifier	 table Name
+	TokenNamePLUS	
", CF "	TokenNameStringLiteral	, CF 
+	TokenNamePLUS	
cfStore	TokenNameIdentifier	 cf Store
.	TokenNameDOT	
getColumnFamilyName	TokenNameIdentifier	 get Column Family Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cfStore	TokenNameIdentifier	 cf Store
.	TokenNameDOT	
forceBlockingFlush	TokenNameIdentifier	 force Blocking Flush
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Trigger proactive repair for a table and column families. * @param tableName * @param columnFamilies * @throws IOException */	TokenNameCOMMENT_JAVADOC	 Trigger proactive repair for a table and column families. @param tableName @param columnFamilies @throws IOException 
public	TokenNamepublic	
void	TokenNamevoid	
forceTableRepair	TokenNameIdentifier	 force Table Repair
(	TokenNameLPAREN	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
tableName	TokenNameIdentifier	 table Name
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isSequential	TokenNameIdentifier	 is Sequential
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isLocal	TokenNameIdentifier	 is Local
,	TokenNameCOMMA	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
...	TokenNameELLIPSIS	
columnFamilies	TokenNameIdentifier	 column Families
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
forceTableRepairRange	TokenNameIdentifier	 force Table Repair Range
(	TokenNameLPAREN	
tableName	TokenNameIdentifier	 table Name
,	TokenNameCOMMA	
getLocalRanges	TokenNameIdentifier	 get Local Ranges
(	TokenNameLPAREN	
tableName	TokenNameIdentifier	 table Name
)	TokenNameRPAREN	
,	TokenNameCOMMA	
isSequential	TokenNameIdentifier	 is Sequential
,	TokenNameCOMMA	
isLocal	TokenNameIdentifier	 is Local
,	TokenNameCOMMA	
columnFamilies	TokenNameIdentifier	 column Families
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
forceTableRepairPrimaryRange	TokenNameIdentifier	 force Table Repair Primary Range
(	TokenNameLPAREN	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
tableName	TokenNameIdentifier	 table Name
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isSequential	TokenNameIdentifier	 is Sequential
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isLocal	TokenNameIdentifier	 is Local
,	TokenNameCOMMA	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
...	TokenNameELLIPSIS	
columnFamilies	TokenNameIdentifier	 column Families
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
forceTableRepairRange	TokenNameIdentifier	 force Table Repair Range
(	TokenNameLPAREN	
tableName	TokenNameIdentifier	 table Name
,	TokenNameCOMMA	
getLocalPrimaryRanges	TokenNameIdentifier	 get Local Primary Ranges
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
isSequential	TokenNameIdentifier	 is Sequential
,	TokenNameCOMMA	
isLocal	TokenNameIdentifier	 is Local
,	TokenNameCOMMA	
columnFamilies	TokenNameIdentifier	 column Families
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
forceTableRepairRange	TokenNameIdentifier	 force Table Repair Range
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
beginToken	TokenNameIdentifier	 begin Token
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
endToken	TokenNameIdentifier	 end Token
,	TokenNameCOMMA	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
tableName	TokenNameIdentifier	 table Name
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isSequential	TokenNameIdentifier	 is Sequential
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isLocal	TokenNameIdentifier	 is Local
,	TokenNameCOMMA	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
...	TokenNameELLIPSIS	
columnFamilies	TokenNameIdentifier	 column Families
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
Token	TokenNameIdentifier	 Token
parsedBeginToken	TokenNameIdentifier	 parsed Begin Token
=	TokenNameEQUAL	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getTokenFactory	TokenNameIdentifier	 get Token Factory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
fromString	TokenNameIdentifier	 from String
(	TokenNameLPAREN	
beginToken	TokenNameIdentifier	 begin Token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Token	TokenNameIdentifier	 Token
parsedEndToken	TokenNameIdentifier	 parsed End Token
=	TokenNameEQUAL	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getTokenFactory	TokenNameIdentifier	 get Token Factory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
fromString	TokenNameIdentifier	 from String
(	TokenNameLPAREN	
endToken	TokenNameIdentifier	 end Token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"starting user-requested repair of range ({}, {}] for keyspace {} and column families {}"	TokenNameStringLiteral	starting user-requested repair of range ({}, {}] for keyspace {} and column families {}
,	TokenNameCOMMA	
parsedBeginToken	TokenNameIdentifier	 parsed Begin Token
,	TokenNameCOMMA	
parsedEndToken	TokenNameIdentifier	 parsed End Token
,	TokenNameCOMMA	
tableName	TokenNameIdentifier	 table Name
,	TokenNameCOMMA	
columnFamilies	TokenNameIdentifier	 column Families
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
forceTableRepairRange	TokenNameIdentifier	 force Table Repair Range
(	TokenNameLPAREN	
tableName	TokenNameIdentifier	 table Name
,	TokenNameCOMMA	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
singleton	TokenNameIdentifier	 singleton
(	TokenNameLPAREN	
new	TokenNamenew	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
(	TokenNameLPAREN	
parsedBeginToken	TokenNameIdentifier	 parsed Begin Token
,	TokenNameCOMMA	
parsedEndToken	TokenNameIdentifier	 parsed End Token
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
isSequential	TokenNameIdentifier	 is Sequential
,	TokenNameCOMMA	
isLocal	TokenNameIdentifier	 is Local
,	TokenNameCOMMA	
columnFamilies	TokenNameIdentifier	 column Families
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
forceTableRepairRange	TokenNameIdentifier	 force Table Repair Range
(	TokenNameLPAREN	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
tableName	TokenNameIdentifier	 table Name
,	TokenNameCOMMA	
final	TokenNamefinal	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
ranges	TokenNameIdentifier	 ranges
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isSequential	TokenNameIdentifier	 is Sequential
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isLocal	TokenNameIdentifier	 is Local
,	TokenNameCOMMA	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
...	TokenNameELLIPSIS	
columnFamilies	TokenNameIdentifier	 column Families
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
SYSTEM_KS	TokenNameIdentifier	 SYSTEM  KS
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
tableName	TokenNameIdentifier	 table Name
)	TokenNameRPAREN	
||	TokenNameOR_OR	
Tracing	TokenNameIdentifier	 Tracing
.	TokenNameDOT	
TRACE_KS	TokenNameIdentifier	 TRACE  KS
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
tableName	TokenNameIdentifier	 table Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
int	TokenNameint	
cmd	TokenNameIdentifier	 cmd
=	TokenNameEQUAL	
nextRepairCommand	TokenNameIdentifier	 next Repair Command
.	TokenNameDOT	
incrementAndGet	TokenNameIdentifier	 increment And Get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Starting repair command #{}, repairing {} ranges."	TokenNameStringLiteral	Starting repair command #{}, repairing {} ranges.
,	TokenNameCOMMA	
cmd	TokenNameIdentifier	 cmd
,	TokenNameCOMMA	
ranges	TokenNameIdentifier	 ranges
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
AntiEntropyService	TokenNameIdentifier	 Anti Entropy Service
.	TokenNameDOT	
RepairFuture	TokenNameIdentifier	 Repair Future
>	TokenNameGREATER	
futures	TokenNameIdentifier	 futures
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
AntiEntropyService	TokenNameIdentifier	 Anti Entropy Service
.	TokenNameDOT	
RepairFuture	TokenNameIdentifier	 Repair Future
>	TokenNameGREATER	
(	TokenNameLPAREN	
ranges	TokenNameIdentifier	 ranges
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
:	TokenNameCOLON	
ranges	TokenNameIdentifier	 ranges
)	TokenNameRPAREN	
{	TokenNameLBRACE	
AntiEntropyService	TokenNameIdentifier	 Anti Entropy Service
.	TokenNameDOT	
RepairFuture	TokenNameIdentifier	 Repair Future
future	TokenNameIdentifier	 future
=	TokenNameEQUAL	
forceTableRepair	TokenNameIdentifier	 force Table Repair
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
tableName	TokenNameIdentifier	 table Name
,	TokenNameCOMMA	
isSequential	TokenNameIdentifier	 is Sequential
,	TokenNameCOMMA	
isLocal	TokenNameIdentifier	 is Local
,	TokenNameCOMMA	
columnFamilies	TokenNameIdentifier	 column Families
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
future	TokenNameIdentifier	 future
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
futures	TokenNameIdentifier	 futures
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
future	TokenNameIdentifier	 future
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// wait for a session to be done with its differencing before starting the next one 	TokenNameCOMMENT_LINE	wait for a session to be done with its differencing before starting the next one 
try	TokenNametry	
{	TokenNameLBRACE	
future	TokenNameIdentifier	 future
.	TokenNameDOT	
session	TokenNameIdentifier	 session
.	TokenNameDOT	
differencingDone	TokenNameIdentifier	 differencing Done
.	TokenNameDOT	
await	TokenNameIdentifier	 await
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
error	TokenNameIdentifier	 error
(	TokenNameLPAREN	
"Interrupted while waiting for the differencing of repair session "	TokenNameStringLiteral	Interrupted while waiting for the differencing of repair session 
+	TokenNamePLUS	
future	TokenNameIdentifier	 future
.	TokenNameDOT	
session	TokenNameIdentifier	 session
+	TokenNamePLUS	
" to be done. Repair may be imprecise."	TokenNameStringLiteral	 to be done. Repair may be imprecise.
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
futures	TokenNameIdentifier	 futures
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Nothing to repair on {} for command #{}"	TokenNameStringLiteral	Nothing to repair on {} for command #{}
,	TokenNameCOMMA	
tableName	TokenNameIdentifier	 table Name
,	TokenNameCOMMA	
cmd	TokenNameIdentifier	 cmd
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
boolean	TokenNameboolean	
failedSession	TokenNameIdentifier	 failed Session
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// block until all repair sessions have completed 	TokenNameCOMMENT_LINE	block until all repair sessions have completed 
for	TokenNamefor	
(	TokenNameLPAREN	
AntiEntropyService	TokenNameIdentifier	 Anti Entropy Service
.	TokenNameDOT	
RepairFuture	TokenNameIdentifier	 Repair Future
future	TokenNameIdentifier	 future
:	TokenNameCOLON	
futures	TokenNameIdentifier	 futures
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
future	TokenNameIdentifier	 future
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
error	TokenNameIdentifier	 error
(	TokenNameLPAREN	
"Repair session "	TokenNameStringLiteral	Repair session 
+	TokenNamePLUS	
future	TokenNameIdentifier	 future
.	TokenNameDOT	
session	TokenNameIdentifier	 session
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" failed."	TokenNameStringLiteral	 failed.
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
failedSession	TokenNameIdentifier	 failed Session
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
failedSession	TokenNameIdentifier	 failed Session
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IOException	TokenNameIdentifier	 IO Exception
(	TokenNameLPAREN	
"Repair command #"	TokenNameStringLiteral	Repair command #
+	TokenNamePLUS	
cmd	TokenNameIdentifier	 cmd
+	TokenNamePLUS	
": some repair session(s) failed (see log for details)."	TokenNameStringLiteral	: some repair session(s) failed (see log for details).
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Repair command #{} completed successfully"	TokenNameStringLiteral	Repair command #{} completed successfully
,	TokenNameCOMMA	
cmd	TokenNameIdentifier	 cmd
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
AntiEntropyService	TokenNameIdentifier	 Anti Entropy Service
.	TokenNameDOT	
RepairFuture	TokenNameIdentifier	 Repair Future
forceTableRepair	TokenNameIdentifier	 force Table Repair
(	TokenNameLPAREN	
final	TokenNamefinal	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
tableName	TokenNameIdentifier	 table Name
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isSequential	TokenNameIdentifier	 is Sequential
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isLocal	TokenNameIdentifier	 is Local
,	TokenNameCOMMA	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
...	TokenNameELLIPSIS	
columnFamilies	TokenNameIdentifier	 column Families
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
names	TokenNameIdentifier	 names
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfStore	TokenNameIdentifier	 cf Store
:	TokenNameCOLON	
getValidColumnFamilies	TokenNameIdentifier	 get Valid Column Families
(	TokenNameLPAREN	
tableName	TokenNameIdentifier	 table Name
,	TokenNameCOMMA	
columnFamilies	TokenNameIdentifier	 column Families
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
names	TokenNameIdentifier	 names
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
cfStore	TokenNameIdentifier	 cf Store
.	TokenNameDOT	
getColumnFamilyName	TokenNameIdentifier	 get Column Family Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
names	TokenNameIdentifier	 names
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"No column family to repair for keyspace "	TokenNameStringLiteral	No column family to repair for keyspace 
+	TokenNamePLUS	
tableName	TokenNameIdentifier	 table Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
AntiEntropyService	TokenNameIdentifier	 Anti Entropy Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
submitRepairSession	TokenNameIdentifier	 submit Repair Session
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
tableName	TokenNameIdentifier	 table Name
,	TokenNameCOMMA	
isSequential	TokenNameIdentifier	 is Sequential
,	TokenNameCOMMA	
isLocal	TokenNameIdentifier	 is Local
,	TokenNameCOMMA	
names	TokenNameIdentifier	 names
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
names	TokenNameIdentifier	 names
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
forceTerminateAllRepairSessions	TokenNameIdentifier	 force Terminate All Repair Sessions
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
AntiEntropyService	TokenNameIdentifier	 Anti Entropy Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
terminateSessions	TokenNameIdentifier	 terminate Sessions
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* End of MBean interface methods */	TokenNameCOMMENT_BLOCK	 End of MBean interface methods 
/** * This method returns the predecessor of the endpoint ep on the identifier * space. */	TokenNameCOMMENT_JAVADOC	 This method returns the predecessor of the endpoint ep on the identifier space. 
InetAddress	TokenNameIdentifier	 Inet Address
getPredecessor	TokenNameIdentifier	 get Predecessor
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getEndpoint	TokenNameIdentifier	 get Endpoint
(	TokenNameLPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getPredecessor	TokenNameIdentifier	 get Predecessor
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* * This method returns the successor of the endpoint ep on the identifier * space. */	TokenNameCOMMENT_BLOCK	 This method returns the successor of the endpoint ep on the identifier space. 
public	TokenNamepublic	
InetAddress	TokenNameIdentifier	 Inet Address
getSuccessor	TokenNameIdentifier	 get Successor
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getEndpoint	TokenNameIdentifier	 get Endpoint
(	TokenNameLPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getSuccessor	TokenNameIdentifier	 get Successor
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the primary ranges for the specified endpoint. * @param ep endpoint we are interested in. * @return collection of ranges for the specified endpoint. */	TokenNameCOMMENT_JAVADOC	 Get the primary ranges for the specified endpoint. @param ep endpoint we are interested in. @return collection of ranges for the specified endpoint. 
public	TokenNamepublic	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
getPrimaryRangesForEndpoint	TokenNameIdentifier	 get Primary Ranges For Endpoint
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getPrimaryRangesFor	TokenNameIdentifier	 get Primary Ranges For
(	TokenNameLPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getTokens	TokenNameIdentifier	 get Tokens
(	TokenNameLPAREN	
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the primary range for the specified endpoint. * @param ep endpoint we are interested in. * @return range for the specified endpoint. */	TokenNameCOMMENT_JAVADOC	 Get the primary range for the specified endpoint. @param ep endpoint we are interested in. @return range for the specified endpoint. 
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
public	TokenNamepublic	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
getPrimaryRangeForEndpoint	TokenNameIdentifier	 get Primary Range For Endpoint
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getPrimaryRangeFor	TokenNameIdentifier	 get Primary Range For
(	TokenNameLPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getToken	TokenNameIdentifier	 get Token
(	TokenNameLPAREN	
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get all ranges an endpoint is responsible for (by table) * @param ep endpoint we are interested in. * @return ranges for the specified endpoint. */	TokenNameCOMMENT_JAVADOC	 Get all ranges an endpoint is responsible for (by table) @param ep endpoint we are interested in. @return ranges for the specified endpoint. 
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
getRangesForEndpoint	TokenNameIdentifier	 get Ranges For Endpoint
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
.	TokenNameDOT	
getReplicationStrategy	TokenNameIdentifier	 get Replication Strategy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getAddressRanges	TokenNameIdentifier	 get Address Ranges
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get all ranges that span the ring given a set * of tokens. All ranges are in sorted order of * ranges. * @return ranges in sorted order */	TokenNameCOMMENT_JAVADOC	 Get all ranges that span the ring given a set of tokens. All ranges are in sorted order of ranges. @return ranges in sorted order 
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
getAllRanges	TokenNameIdentifier	 get All Ranges
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
sortedTokens	TokenNameIdentifier	 sorted Tokens
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"computing ranges for "	TokenNameStringLiteral	computing ranges for 
+	TokenNamePLUS	
StringUtils	TokenNameIdentifier	 String Utils
.	TokenNameDOT	
join	TokenNameIdentifier	 join
(	TokenNameLPAREN	
sortedTokens	TokenNameIdentifier	 sorted Tokens
,	TokenNameCOMMA	
", "	TokenNameStringLiteral	, 
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sortedTokens	TokenNameIdentifier	 sorted Tokens
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
emptyList	TokenNameIdentifier	 empty List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
sortedTokens	TokenNameIdentifier	 sorted Tokens
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
ranges	TokenNameIdentifier	 ranges
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
size	TokenNameIdentifier	 size
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
=	TokenNameEQUAL	
new	TokenNamenew	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
(	TokenNameLPAREN	
sortedTokens	TokenNameIdentifier	 sorted Tokens
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
sortedTokens	TokenNameIdentifier	 sorted Tokens
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ranges	TokenNameIdentifier	 ranges
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
=	TokenNameEQUAL	
new	TokenNamenew	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
(	TokenNameLPAREN	
sortedTokens	TokenNameIdentifier	 sorted Tokens
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
size	TokenNameIdentifier	 size
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
sortedTokens	TokenNameIdentifier	 sorted Tokens
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ranges	TokenNameIdentifier	 ranges
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
ranges	TokenNameIdentifier	 ranges
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * This method returns the N endpoints that are responsible for storing the * specified key i.e for replication. * * @param table keyspace name also known as table * @param cf Column family name * @param key key for which we need to find the endpoint * @return the endpoint responsible for this key */	TokenNameCOMMENT_JAVADOC	 This method returns the N endpoints that are responsible for storing the specified key i.e for replication. * @param table keyspace name also known as table @param cf Column family name @param key key for which we need to find the endpoint @return the endpoint responsible for this key 
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
getNaturalEndpoints	TokenNameIdentifier	 get Natural Endpoints
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
cf	TokenNameIdentifier	 cf
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CFMetaData	TokenNameIdentifier	 CF Meta Data
cfMetaData	TokenNameIdentifier	 cf Meta Data
=	TokenNameEQUAL	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getTableDefinition	TokenNameIdentifier	 get Table Definition
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
.	TokenNameDOT	
cfMetaData	TokenNameIdentifier	 cf Meta Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
cf	TokenNameIdentifier	 cf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
getNaturalEndpoints	TokenNameIdentifier	 get Natural Endpoints
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getToken	TokenNameIdentifier	 get Token
(	TokenNameLPAREN	
cfMetaData	TokenNameIdentifier	 cf Meta Data
.	TokenNameDOT	
getKeyValidator	TokenNameIdentifier	 get Key Validator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
fromString	TokenNameIdentifier	 from String
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
getNaturalEndpoints	TokenNameIdentifier	 get Natural Endpoints
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getNaturalEndpoints	TokenNameIdentifier	 get Natural Endpoints
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getToken	TokenNameIdentifier	 get Token
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * This method returns the N endpoints that are responsible for storing the * specified key i.e for replication. * * @param table keyspace name also known as table * @param pos position for which we need to find the endpoint * @return the endpoint responsible for this token */	TokenNameCOMMENT_JAVADOC	 This method returns the N endpoints that are responsible for storing the specified key i.e for replication. * @param table keyspace name also known as table @param pos position for which we need to find the endpoint @return the endpoint responsible for this token 
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
getNaturalEndpoints	TokenNameIdentifier	 get Natural Endpoints
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
RingPosition	TokenNameIdentifier	 Ring Position
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
.	TokenNameDOT	
getReplicationStrategy	TokenNameIdentifier	 get Replication Strategy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getNaturalEndpoints	TokenNameIdentifier	 get Natural Endpoints
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * This method attempts to return N endpoints that are responsible for storing the * specified key i.e for replication. * * @param table keyspace name also known as table * @param key key for which we need to find the endpoint * @return the endpoint responsible for this key */	TokenNameCOMMENT_JAVADOC	 This method attempts to return N endpoints that are responsible for storing the specified key i.e for replication. * @param table keyspace name also known as table @param key key for which we need to find the endpoint @return the endpoint responsible for this key 
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
getLiveNaturalEndpoints	TokenNameIdentifier	 get Live Natural Endpoints
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getLiveNaturalEndpoints	TokenNameIdentifier	 get Live Natural Endpoints
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
decorateKey	TokenNameIdentifier	 decorate Key
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
getLiveNaturalEndpoints	TokenNameIdentifier	 get Live Natural Endpoints
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
RingPosition	TokenNameIdentifier	 Ring Position
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
endpoints	TokenNameIdentifier	 endpoints
=	TokenNameEQUAL	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
.	TokenNameDOT	
getReplicationStrategy	TokenNameIdentifier	 get Replication Strategy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getNaturalEndpoints	TokenNameIdentifier	 get Natural Endpoints
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
liveEps	TokenNameIdentifier	 live Eps
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
(	TokenNameLPAREN	
endpoints	TokenNameIdentifier	 endpoints
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
:	TokenNameCOLON	
endpoints	TokenNameIdentifier	 endpoints
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
FailureDetector	TokenNameIdentifier	 Failure Detector
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
isAlive	TokenNameIdentifier	 is Alive
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
liveEps	TokenNameIdentifier	 live Eps
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
liveEps	TokenNameIdentifier	 live Eps
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setLog4jLevel	TokenNameIdentifier	 set Log4j Level
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
classQualifier	TokenNameIdentifier	 class Qualifier
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
rawLevel	TokenNameIdentifier	 raw Level
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Level	TokenNameIdentifier	 Level
level	TokenNameIdentifier	 level
=	TokenNameEQUAL	
Level	TokenNameIdentifier	 Level
.	TokenNameDOT	
toLevel	TokenNameIdentifier	 to Level
(	TokenNameLPAREN	
rawLevel	TokenNameIdentifier	 raw Level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
log4j	TokenNameIdentifier	 log4j
.	TokenNameDOT	
Logger	TokenNameIdentifier	 Logger
.	TokenNameDOT	
getLogger	TokenNameIdentifier	 get Logger
(	TokenNameLPAREN	
classQualifier	TokenNameIdentifier	 class Qualifier
)	TokenNameRPAREN	
.	TokenNameDOT	
setLevel	TokenNameIdentifier	 set Level
(	TokenNameLPAREN	
level	TokenNameIdentifier	 level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"set log level to "	TokenNameStringLiteral	set log level to 
+	TokenNamePLUS	
level	TokenNameIdentifier	 level
+	TokenNamePLUS	
" for classes under '"	TokenNameStringLiteral	 for classes under '
+	TokenNamePLUS	
classQualifier	TokenNameIdentifier	 class Qualifier
+	TokenNamePLUS	
"' (if the level doesn't look like '"	TokenNameStringLiteral	' (if the level doesn't look like '
+	TokenNamePLUS	
rawLevel	TokenNameIdentifier	 raw Level
+	TokenNamePLUS	
"' then log4j couldn't parse '"	TokenNameStringLiteral	' then log4j couldn't parse '
+	TokenNamePLUS	
rawLevel	TokenNameIdentifier	 raw Level
+	TokenNamePLUS	
"')"	TokenNameStringLiteral	')
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @return list of Token ranges (_not_ keys!) together with estimated key count, * breaking up the data this node is responsible for into pieces of roughly keysPerSplit */	TokenNameCOMMENT_JAVADOC	 @return list of Token ranges (_not_ keys!) together with estimated key count, breaking up the data this node is responsible for into pieces of roughly keysPerSplit 
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
getSplits	TokenNameIdentifier	 get Splits
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
cfName	TokenNameIdentifier	 cf Name
,	TokenNameCOMMA	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
int	TokenNameint	
keysPerSplit	TokenNameIdentifier	 keys Per Split
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Table	TokenNameIdentifier	 Table
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
=	TokenNameEQUAL	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
getColumnFamilyStore	TokenNameIdentifier	 get Column Family Store
(	TokenNameLPAREN	
cfName	TokenNameIdentifier	 cf Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
DecoratedKey	TokenNameIdentifier	 Decorated Key
>	TokenNameGREATER	
keys	TokenNameIdentifier	 keys
=	TokenNameEQUAL	
keySamples	TokenNameIdentifier	 key Samples
(	TokenNameLPAREN	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
singleton	TokenNameIdentifier	 singleton
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
)	TokenNameRPAREN	
,	TokenNameCOMMA	
range	TokenNameIdentifier	 range
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
long	TokenNamelong	
totalRowCountEstimate	TokenNameIdentifier	 total Row Count Estimate
=	TokenNameEQUAL	
(	TokenNameLPAREN	
keys	TokenNameIdentifier	 keys
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getIndexInterval	TokenNameIdentifier	 get Index Interval
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// splitCount should be much smaller than number of key samples, to avoid huge sampling error 	TokenNameCOMMENT_LINE	splitCount should be much smaller than number of key samples, to avoid huge sampling error 
final	TokenNamefinal	
int	TokenNameint	
minSamplesPerSplit	TokenNameIdentifier	 min Samples Per Split
=	TokenNameEQUAL	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
maxSplitCount	TokenNameIdentifier	 max Split Count
=	TokenNameEQUAL	
keys	TokenNameIdentifier	 keys
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
minSamplesPerSplit	TokenNameIdentifier	 min Samples Per Split
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
splitCount	TokenNameIdentifier	 split Count
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
max	TokenNameIdentifier	 max
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
min	TokenNameIdentifier	 min
(	TokenNameLPAREN	
maxSplitCount	TokenNameIdentifier	 max Split Count
,	TokenNameCOMMA	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
totalRowCountEstimate	TokenNameIdentifier	 total Row Count Estimate
/	TokenNameDIVIDE	
keysPerSplit	TokenNameIdentifier	 keys Per Split
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
tokens	TokenNameIdentifier	 tokens
=	TokenNameEQUAL	
keysToTokens	TokenNameIdentifier	 keys To Tokens
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
keys	TokenNameIdentifier	 keys
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
getSplits	TokenNameIdentifier	 get Splits
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
splitCount	TokenNameIdentifier	 split Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
getSplits	TokenNameIdentifier	 get Splits
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
int	TokenNameint	
splitCount	TokenNameIdentifier	 split Count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
double	TokenNamedouble	
step	TokenNameIdentifier	 step
=	TokenNameEQUAL	
(	TokenNameLPAREN	
double	TokenNamedouble	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
splitCount	TokenNameIdentifier	 split Count
;	TokenNameSEMICOLON	
int	TokenNameint	
prevIndex	TokenNameIdentifier	 prev Index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
Token	TokenNameIdentifier	 Token
prevToken	TokenNameIdentifier	 prev Token
=	TokenNameEQUAL	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
splits	TokenNameIdentifier	 splits
=	TokenNameEQUAL	
Lists	TokenNameIdentifier	 Lists
.	TokenNameDOT	
newArrayListWithExpectedSize	TokenNameIdentifier	 new Array List With Expected Size
(	TokenNameLPAREN	
splitCount	TokenNameIdentifier	 split Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<=	TokenNameLESS_EQUAL	
splitCount	TokenNameIdentifier	 split Count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
round	TokenNameIdentifier	 round
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
*	TokenNameMULTIPLY	
step	TokenNameIdentifier	 step
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
rowCountEstimate	TokenNameIdentifier	 row Count Estimate
=	TokenNameEQUAL	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
-	TokenNameMINUS	
prevIndex	TokenNameIdentifier	 prev Index
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getIndexInterval	TokenNameIdentifier	 get Index Interval
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
splits	TokenNameIdentifier	 splits
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
Pair	TokenNameIdentifier	 Pair
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
new	TokenNamenew	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
(	TokenNameLPAREN	
prevToken	TokenNameIdentifier	 prev Token
,	TokenNameCOMMA	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
,	TokenNameCOMMA	
rowCountEstimate	TokenNameIdentifier	 row Count Estimate
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
prevIndex	TokenNameIdentifier	 prev Index
=	TokenNameEQUAL	
index	TokenNameIdentifier	 index
;	TokenNameSEMICOLON	
prevToken	TokenNameIdentifier	 prev Token
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
splits	TokenNameIdentifier	 splits
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
keysToTokens	TokenNameIdentifier	 keys To Tokens
(	TokenNameLPAREN	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
DecoratedKey	TokenNameIdentifier	 Decorated Key
>	TokenNameGREATER	
keys	TokenNameIdentifier	 keys
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
tokens	TokenNameIdentifier	 tokens
=	TokenNameEQUAL	
Lists	TokenNameIdentifier	 Lists
.	TokenNameDOT	
newArrayListWithExpectedSize	TokenNameIdentifier	 new Array List With Expected Size
(	TokenNameLPAREN	
keys	TokenNameIdentifier	 keys
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
left	TokenNameIdentifier	 left
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
DecoratedKey	TokenNameIdentifier	 Decorated Key
key	TokenNameIdentifier	 key
:	TokenNameCOLON	
keys	TokenNameIdentifier	 keys
)	TokenNameRPAREN	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
right	TokenNameIdentifier	 right
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
tokens	TokenNameIdentifier	 tokens
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
DecoratedKey	TokenNameIdentifier	 Decorated Key
>	TokenNameGREATER	
keySamples	TokenNameIdentifier	 key Samples
(	TokenNameLPAREN	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
>	TokenNameGREATER	
cfses	TokenNameIdentifier	 cfses
,	TokenNameCOMMA	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
DecoratedKey	TokenNameIdentifier	 Decorated Key
>	TokenNameGREATER	
keys	TokenNameIdentifier	 keys
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
DecoratedKey	TokenNameIdentifier	 Decorated Key
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
:	TokenNameCOLON	
cfses	TokenNameIdentifier	 cfses
)	TokenNameRPAREN	
Iterables	TokenNameIdentifier	 Iterables
.	TokenNameDOT	
addAll	TokenNameIdentifier	 add All
(	TokenNameLPAREN	
keys	TokenNameIdentifier	 keys
,	TokenNameCOMMA	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
keySamples	TokenNameIdentifier	 key Samples
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
sortSampledKeys	TokenNameIdentifier	 sort Sampled Keys
(	TokenNameLPAREN	
keys	TokenNameIdentifier	 keys
,	TokenNameCOMMA	
range	TokenNameIdentifier	 range
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
keys	TokenNameIdentifier	 keys
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** return a token to which if a node bootstraps it will get about 1/2 of this node's range */	TokenNameCOMMENT_JAVADOC	 return a token to which if a node bootstraps it will get about 1/2 of this node's range 
public	TokenNamepublic	
Token	TokenNameIdentifier	 Token
getBootstrapToken	TokenNameIdentifier	 get Bootstrap Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
=	TokenNameEQUAL	
getLocalPrimaryRange	TokenNameIdentifier	 get Local Primary Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
DecoratedKey	TokenNameIdentifier	 Decorated Key
>	TokenNameGREATER	
keys	TokenNameIdentifier	 keys
=	TokenNameEQUAL	
keySamples	TokenNameIdentifier	 key Samples
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
.	TokenNameDOT	
allUserDefined	TokenNameIdentifier	 all User Defined
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
range	TokenNameIdentifier	 range
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
keys	TokenNameIdentifier	 keys
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<	TokenNameLESS	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
midpoint	TokenNameIdentifier	 midpoint
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
left	TokenNameIdentifier	 left
,	TokenNameCOMMA	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
right	TokenNameIdentifier	 right
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Used midpoint to assign token "	TokenNameStringLiteral	Used midpoint to assign token 
+	TokenNamePLUS	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
keys	TokenNameIdentifier	 keys
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
keys	TokenNameIdentifier	 keys
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Used key sample of size "	TokenNameStringLiteral	Used key sample of size 
+	TokenNamePLUS	
keys	TokenNameIdentifier	 keys
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" to assign token "	TokenNameStringLiteral	 to assign token 
+	TokenNamePLUS	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getEndpoint	TokenNameIdentifier	 get Endpoint
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
isMember	TokenNameIdentifier	 is Member
(	TokenNameLPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getEndpoint	TokenNameIdentifier	 get Endpoint
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"Chose token "	TokenNameStringLiteral	Chose token 
+	TokenNamePLUS	
token	TokenNameIdentifier	 token
+	TokenNamePLUS	
" which is already in use by "	TokenNameStringLiteral	 which is already in use by 
+	TokenNamePLUS	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getEndpoint	TokenNameIdentifier	 get Endpoint
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
+	TokenNamePLUS	
" -- specify one manually with initial_token"	TokenNameStringLiteral	 -- specify one manually with initial_token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Hack to prevent giving nodes tokens with DELIMITER_STR in them (which is fine in a row key/token) 	TokenNameCOMMENT_LINE	Hack to prevent giving nodes tokens with DELIMITER_STR in them (which is fine in a row key/token) 
if	TokenNameif	
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
instanceof	TokenNameinstanceof	
StringToken	TokenNameIdentifier	 String Token
)	TokenNameRPAREN	
{	TokenNameLBRACE	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
new	TokenNamenew	
StringToken	TokenNameIdentifier	 String Token
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
.	TokenNameDOT	
replaceAll	TokenNameIdentifier	 replace All
(	TokenNameLPAREN	
VersionedValue	TokenNameIdentifier	 Versioned Value
.	TokenNameDOT	
DELIMITER_STR	TokenNameIdentifier	 DELIMITER  STR
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getNormalAndBootstrappingTokenToEndpointMap	TokenNameIdentifier	 get Normal And Bootstrapping Token To Endpoint Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
containsKey	TokenNameIdentifier	 contains Key
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"Unable to compute unique token for new node -- specify one manually with initial_token"	TokenNameStringLiteral	Unable to compute unique token for new node -- specify one manually with initial_token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Broadcast leaving status and update local tokenMetadata accordingly */	TokenNameCOMMENT_JAVADOC	 Broadcast leaving status and update local tokenMetadata accordingly 
private	TokenNameprivate	
void	TokenNamevoid	
startLeaving	TokenNameIdentifier	 start Leaving
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
addLocalApplicationState	TokenNameIdentifier	 add Local Application State
(	TokenNameLPAREN	
ApplicationState	TokenNameIdentifier	 Application State
.	TokenNameDOT	
STATUS	TokenNameIdentifier	 STATUS
,	TokenNameCOMMA	
valueFactory	TokenNameIdentifier	 value Factory
.	TokenNameDOT	
leaving	TokenNameIdentifier	 leaving
(	TokenNameLPAREN	
getLocalTokens	TokenNameIdentifier	 get Local Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
addLeavingEndpoint	TokenNameIdentifier	 add Leaving Endpoint
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
calculatePendingRanges	TokenNameIdentifier	 calculate Pending Ranges
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
decommission	TokenNameIdentifier	 decommission
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
isMember	TokenNameIdentifier	 is Member
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
UnsupportedOperationException	TokenNameIdentifier	 Unsupported Operation Exception
(	TokenNameLPAREN	
"local node is not a member of the token ring yet"	TokenNameStringLiteral	local node is not a member of the token ring yet
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
cloneAfterAllLeft	TokenNameIdentifier	 clone After All Left
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
sortedTokens	TokenNameIdentifier	 sorted Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<	TokenNameLESS	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
UnsupportedOperationException	TokenNameIdentifier	 Unsupported Operation Exception
(	TokenNameLPAREN	
"no other normal nodes in the ring; decommission would be pointless"	TokenNameStringLiteral	no other normal nodes in the ring; decommission would be pointless
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
:	TokenNameCOLON	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getNonSystemTables	TokenNameIdentifier	 get Non System Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getPendingRanges	TokenNameIdentifier	 get Pending Ranges
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
UnsupportedOperationException	TokenNameIdentifier	 Unsupported Operation Exception
(	TokenNameLPAREN	
"data is currently moving to this node; unable to leave the ring"	TokenNameStringLiteral	data is currently moving to this node; unable to leave the ring
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"DECOMMISSIONING"	TokenNameStringLiteral	DECOMMISSIONING
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
startLeaving	TokenNameIdentifier	 start Leaving
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setMode	TokenNameIdentifier	 set Mode
(	TokenNameLPAREN	
Mode	TokenNameIdentifier	 Mode
.	TokenNameDOT	
LEAVING	TokenNameIdentifier	 LEAVING
,	TokenNameCOMMA	
"sleeping "	TokenNameStringLiteral	sleeping 
+	TokenNamePLUS	
RING_DELAY	TokenNameIdentifier	 RING  DELAY
+	TokenNamePLUS	
" ms for pending range setup"	TokenNameStringLiteral	 ms for pending range setup
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
sleep	TokenNameIdentifier	 sleep
(	TokenNameLPAREN	
RING_DELAY	TokenNameIdentifier	 RING  DELAY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Runnable	TokenNameIdentifier	 Runnable
finishLeaving	TokenNameIdentifier	 finish Leaving
=	TokenNameEQUAL	
new	TokenNamenew	
Runnable	TokenNameIdentifier	 Runnable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
run	TokenNameIdentifier	 run
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stopRPCServer	TokenNameIdentifier	 stop RPC Server
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
stop	TokenNameIdentifier	 stop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
shutdown	TokenNameIdentifier	 shutdown
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
StageManager	TokenNameIdentifier	 Stage Manager
.	TokenNameDOT	
shutdownNow	TokenNameIdentifier	 shutdown Now
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setMode	TokenNameIdentifier	 set Mode
(	TokenNameLPAREN	
Mode	TokenNameIdentifier	 Mode
.	TokenNameDOT	
DECOMMISSIONED	TokenNameIdentifier	 DECOMMISSIONED
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// let op be responsible for killing the process 	TokenNameCOMMENT_LINE	let op be responsible for killing the process 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
unbootstrap	TokenNameIdentifier	 unbootstrap
(	TokenNameLPAREN	
finishLeaving	TokenNameIdentifier	 finish Leaving
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
leaveRing	TokenNameIdentifier	 leave Ring
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
setBootstrapState	TokenNameIdentifier	 set Bootstrap State
(	TokenNameLPAREN	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
BootstrapState	TokenNameIdentifier	 Bootstrap State
.	TokenNameDOT	
NEEDS_BOOTSTRAP	TokenNameIdentifier	 NEEDS  BOOTSTRAP
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
removeEndpoint	TokenNameIdentifier	 remove Endpoint
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
calculatePendingRanges	TokenNameIdentifier	 calculate Pending Ranges
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
addLocalApplicationState	TokenNameIdentifier	 add Local Application State
(	TokenNameLPAREN	
ApplicationState	TokenNameIdentifier	 Application State
.	TokenNameDOT	
STATUS	TokenNameIdentifier	 STATUS
,	TokenNameCOMMA	
valueFactory	TokenNameIdentifier	 value Factory
.	TokenNameDOT	
left	TokenNameIdentifier	 left
(	TokenNameLPAREN	
getLocalTokens	TokenNameIdentifier	 get Local Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
computeExpireTime	TokenNameIdentifier	 compute Expire Time
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
delay	TokenNameIdentifier	 delay
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
max	TokenNameIdentifier	 max
(	TokenNameLPAREN	
RING_DELAY	TokenNameIdentifier	 RING  DELAY
,	TokenNameCOMMA	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
intervalInMillis	TokenNameIdentifier	 interval In Millis
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Announcing that I have left the ring for "	TokenNameStringLiteral	Announcing that I have left the ring for 
+	TokenNamePLUS	
delay	TokenNameIdentifier	 delay
+	TokenNamePLUS	
"ms"	TokenNameStringLiteral	ms
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
sleep	TokenNameIdentifier	 sleep
(	TokenNameLPAREN	
delay	TokenNameIdentifier	 delay
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
AssertionError	TokenNameIdentifier	 Assertion Error
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
unbootstrap	TokenNameIdentifier	 unbootstrap
(	TokenNameLPAREN	
final	TokenNamefinal	
Runnable	TokenNameIdentifier	 Runnable
onFinish	TokenNameIdentifier	 on Finish
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
rangesToStream	TokenNameIdentifier	 ranges To Stream
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
:	TokenNameCOLON	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getNonSystemTables	TokenNameIdentifier	 get Non System Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
rangesMM	TokenNameIdentifier	 ranges MM
=	TokenNameEQUAL	
getChangedRangesForLeaving	TokenNameIdentifier	 get Changed Ranges For Leaving
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Ranges needing transfer are ["	TokenNameStringLiteral	Ranges needing transfer are [
+	TokenNamePLUS	
StringUtils	TokenNameIdentifier	 String Utils
.	TokenNameDOT	
join	TokenNameIdentifier	 join
(	TokenNameLPAREN	
rangesMM	TokenNameIdentifier	 ranges MM
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
","	TokenNameStringLiteral	,
)	TokenNameRPAREN	
+	TokenNamePLUS	
"]"	TokenNameStringLiteral	]
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rangesToStream	TokenNameIdentifier	 ranges To Stream
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
rangesMM	TokenNameIdentifier	 ranges MM
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
setMode	TokenNameIdentifier	 set Mode
(	TokenNameLPAREN	
Mode	TokenNameIdentifier	 Mode
.	TokenNameDOT	
LEAVING	TokenNameIdentifier	 LEAVING
,	TokenNameCOMMA	
"streaming data to other nodes"	TokenNameStringLiteral	streaming data to other nodes
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CountDownLatch	TokenNameIdentifier	 Count Down Latch
latch	TokenNameIdentifier	 latch
=	TokenNameEQUAL	
streamRanges	TokenNameIdentifier	 stream Ranges
(	TokenNameLPAREN	
rangesToStream	TokenNameIdentifier	 ranges To Stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// wait for the transfer runnables to signal the latch. 	TokenNameCOMMENT_LINE	wait for the transfer runnables to signal the latch. 
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"waiting for stream aks."	TokenNameStringLiteral	waiting for stream aks.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
latch	TokenNameIdentifier	 latch
.	TokenNameDOT	
await	TokenNameIdentifier	 await
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"stream acks all received."	TokenNameStringLiteral	stream acks all received.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
leaveRing	TokenNameIdentifier	 leave Ring
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
onFinish	TokenNameIdentifier	 on Finish
.	TokenNameDOT	
run	TokenNameIdentifier	 run
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
move	TokenNameIdentifier	 move
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
newToken	TokenNameIdentifier	 new Token
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getTokenFactory	TokenNameIdentifier	 get Token Factory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
newToken	TokenNameIdentifier	 new Token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ConfigurationException	TokenNameIdentifier	 Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IOException	TokenNameIdentifier	 IO Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
move	TokenNameIdentifier	 move
(	TokenNameLPAREN	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getTokenFactory	TokenNameIdentifier	 get Token Factory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
fromString	TokenNameIdentifier	 from String
(	TokenNameLPAREN	
newToken	TokenNameIdentifier	 new Token
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * move the node to new token or find a new token to boot to according to load * * @param newToken new token to boot to, or if null, find balanced token to boot to * * @throws IOException on any I/O operation error */	TokenNameCOMMENT_JAVADOC	 move the node to new token or find a new token to boot to according to load * @param newToken new token to boot to, or if null, find balanced token to boot to * @throws IOException on any I/O operation error 
private	TokenNameprivate	
void	TokenNamevoid	
move	TokenNameIdentifier	 move
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
newToken	TokenNameIdentifier	 new Token
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
newToken	TokenNameIdentifier	 new Token
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IOException	TokenNameIdentifier	 IO Exception
(	TokenNameLPAREN	
"Can't move to the undefined (null) token."	TokenNameStringLiteral	Can't move to the undefined (null) token.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
sortedTokens	TokenNameIdentifier	 sorted Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
newToken	TokenNameIdentifier	 new Token
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IOException	TokenNameIdentifier	 IO Exception
(	TokenNameLPAREN	
"target token "	TokenNameStringLiteral	target token 
+	TokenNamePLUS	
newToken	TokenNameIdentifier	 new Token
+	TokenNamePLUS	
" is already owned by another node."	TokenNameStringLiteral	 is already owned by another node.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// address of the current node 	TokenNameCOMMENT_LINE	address of the current node 
InetAddress	TokenNameIdentifier	 Inet Address
localAddress	TokenNameIdentifier	 local Address
=	TokenNameEQUAL	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// This doesn't make any sense in a vnodes environment. 	TokenNameCOMMENT_LINE	This doesn't make any sense in a vnodes environment. 
if	TokenNameif	
(	TokenNameLPAREN	
getTokenMetadata	TokenNameIdentifier	 get Token Metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getTokens	TokenNameIdentifier	 get Tokens
(	TokenNameLPAREN	
localAddress	TokenNameIdentifier	 local Address
)	TokenNameRPAREN	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
error	TokenNameIdentifier	 error
(	TokenNameLPAREN	
"Invalid request to move(Token); This node has more than one token and cannot be moved thusly."	TokenNameStringLiteral	Invalid request to move(Token); This node has more than one token and cannot be moved thusly.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
UnsupportedOperationException	TokenNameIdentifier	 Unsupported Operation Exception
(	TokenNameLPAREN	
"This node has more than one token and cannot be moved thusly."	TokenNameStringLiteral	This node has more than one token and cannot be moved thusly.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
tablesToProcess	TokenNameIdentifier	 tables To Process
=	TokenNameEQUAL	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getNonSystemTables	TokenNameIdentifier	 get Non System Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// checking if data is moving to this node 	TokenNameCOMMENT_LINE	checking if data is moving to this node 
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
:	TokenNameCOLON	
tablesToProcess	TokenNameIdentifier	 tables To Process
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getPendingRanges	TokenNameIdentifier	 get Pending Ranges
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
localAddress	TokenNameIdentifier	 local Address
)	TokenNameRPAREN	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
UnsupportedOperationException	TokenNameIdentifier	 Unsupported Operation Exception
(	TokenNameLPAREN	
"data is currently moving to this node; unable to leave the ring"	TokenNameStringLiteral	data is currently moving to this node; unable to leave the ring
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
addLocalApplicationState	TokenNameIdentifier	 add Local Application State
(	TokenNameLPAREN	
ApplicationState	TokenNameIdentifier	 Application State
.	TokenNameDOT	
STATUS	TokenNameIdentifier	 STATUS
,	TokenNameCOMMA	
valueFactory	TokenNameIdentifier	 value Factory
.	TokenNameDOT	
moving	TokenNameIdentifier	 moving
(	TokenNameLPAREN	
newToken	TokenNameIdentifier	 new Token
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setMode	TokenNameIdentifier	 set Mode
(	TokenNameLPAREN	
Mode	TokenNameIdentifier	 Mode
.	TokenNameDOT	
MOVING	TokenNameIdentifier	 MOVING
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Moving %s from %s to %s."	TokenNameStringLiteral	Moving %s from %s to %s.
,	TokenNameCOMMA	
localAddress	TokenNameIdentifier	 local Address
,	TokenNameCOMMA	
getLocalTokens	TokenNameIdentifier	 get Local Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
newToken	TokenNameIdentifier	 new Token
)	TokenNameRPAREN	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setMode	TokenNameIdentifier	 set Mode
(	TokenNameLPAREN	
Mode	TokenNameIdentifier	 Mode
.	TokenNameDOT	
MOVING	TokenNameIdentifier	 MOVING
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Sleeping %s ms before start streaming/fetching ranges"	TokenNameStringLiteral	Sleeping %s ms before start streaming/fetching ranges
,	TokenNameCOMMA	
RING_DELAY	TokenNameIdentifier	 RING  DELAY
)	TokenNameRPAREN	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
sleep	TokenNameIdentifier	 sleep
(	TokenNameLPAREN	
RING_DELAY	TokenNameIdentifier	 RING  DELAY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"Sleep interrupted "	TokenNameStringLiteral	Sleep interrupted 
+	TokenNamePLUS	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
RangeRelocator	TokenNameIdentifier	 Range Relocator
relocator	TokenNameIdentifier	 relocator
=	TokenNameEQUAL	
new	TokenNamenew	
RangeRelocator	TokenNameIdentifier	 Range Relocator
(	TokenNameLPAREN	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
singleton	TokenNameIdentifier	 singleton
(	TokenNameLPAREN	
newToken	TokenNameIdentifier	 new Token
)	TokenNameRPAREN	
,	TokenNameCOMMA	
tablesToProcess	TokenNameIdentifier	 tables To Process
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
relocator	TokenNameIdentifier	 relocator
.	TokenNameDOT	
streamsNeeded	TokenNameIdentifier	 streams Needed
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
setMode	TokenNameIdentifier	 set Mode
(	TokenNameLPAREN	
Mode	TokenNameIdentifier	 Mode
.	TokenNameDOT	
MOVING	TokenNameIdentifier	 MOVING
,	TokenNameCOMMA	
"fetching new ranges and streaming old ranges"	TokenNameStringLiteral	fetching new ranges and streaming old ranges
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
relocator	TokenNameIdentifier	 relocator
.	TokenNameDOT	
logStreamsMap	TokenNameIdentifier	 log Streams Map
(	TokenNameLPAREN	
"[Move->STREAMING]"	TokenNameStringLiteral	[Move->STREAMING]
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CountDownLatch	TokenNameIdentifier	 Count Down Latch
streamLatch	TokenNameIdentifier	 stream Latch
=	TokenNameEQUAL	
relocator	TokenNameIdentifier	 relocator
.	TokenNameDOT	
streams	TokenNameIdentifier	 streams
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
relocator	TokenNameIdentifier	 relocator
.	TokenNameDOT	
logRequestsMap	TokenNameIdentifier	 log Requests Map
(	TokenNameLPAREN	
"[Move->FETCHING]"	TokenNameStringLiteral	[Move->FETCHING]
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CountDownLatch	TokenNameIdentifier	 Count Down Latch
fetchLatch	TokenNameIdentifier	 fetch Latch
=	TokenNameEQUAL	
relocator	TokenNameIdentifier	 relocator
.	TokenNameDOT	
requests	TokenNameIdentifier	 requests
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
streamLatch	TokenNameIdentifier	 stream Latch
.	TokenNameDOT	
await	TokenNameIdentifier	 await
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fetchLatch	TokenNameIdentifier	 fetch Latch
.	TokenNameDOT	
await	TokenNameIdentifier	 await
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"Interrupted latch while waiting for stream/fetch ranges to finish: "	TokenNameStringLiteral	Interrupted latch while waiting for stream/fetch ranges to finish: 
+	TokenNamePLUS	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
setMode	TokenNameIdentifier	 set Mode
(	TokenNameLPAREN	
Mode	TokenNameIdentifier	 Mode
.	TokenNameDOT	
MOVING	TokenNameIdentifier	 MOVING
,	TokenNameCOMMA	
"No ranges to fetch/stream"	TokenNameStringLiteral	No ranges to fetch/stream
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setTokens	TokenNameIdentifier	 set Tokens
(	TokenNameLPAREN	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
singleton	TokenNameIdentifier	 singleton
(	TokenNameLPAREN	
newToken	TokenNameIdentifier	 new Token
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// setting new token as we have everything settled 	TokenNameCOMMENT_LINE	setting new token as we have everything settled 
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Successfully moved to new token {}"	TokenNameStringLiteral	Successfully moved to new token {}
,	TokenNameCOMMA	
getLocalTokens	TokenNameIdentifier	 get Local Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
class	TokenNameclass	
RangeRelocator	TokenNameIdentifier	 Range Relocator
{	TokenNameLBRACE	
private	TokenNameprivate	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
rangesToFetch	TokenNameIdentifier	 ranges To Fetch
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
rangesToStreamByTable	TokenNameIdentifier	 ranges To Stream By Table
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
RangeRelocator	TokenNameIdentifier	 Range Relocator
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
tables	TokenNameIdentifier	 tables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
calculateToFromStreams	TokenNameIdentifier	 calculate To From Streams
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
tables	TokenNameIdentifier	 tables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
calculateToFromStreams	TokenNameIdentifier	 calculate To From Streams
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
newTokens	TokenNameIdentifier	 new Tokens
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
tables	TokenNameIdentifier	 tables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
InetAddress	TokenNameIdentifier	 Inet Address
localAddress	TokenNameIdentifier	 local Address
=	TokenNameEQUAL	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
IEndpointSnitch	TokenNameIdentifier	 I Endpoint Snitch
snitch	TokenNameIdentifier	 snitch
=	TokenNameEQUAL	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getEndpointSnitch	TokenNameIdentifier	 get Endpoint Snitch
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TokenMetadata	TokenNameIdentifier	 Token Metadata
tokenMetaCloneAllSettled	TokenNameIdentifier	 token Meta Clone All Settled
=	TokenNameEQUAL	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
cloneAfterAllSettled	TokenNameIdentifier	 clone After All Settled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// clone to avoid concurrent modification in calculateNaturalEndpoints 	TokenNameCOMMENT_LINE	clone to avoid concurrent modification in calculateNaturalEndpoints 
TokenMetadata	TokenNameIdentifier	 Token Metadata
tokenMetaClone	TokenNameIdentifier	 token Meta Clone
=	TokenNameEQUAL	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
cloneOnlyTokenMap	TokenNameIdentifier	 clone Only Token Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
:	TokenNameCOLON	
tables	TokenNameIdentifier	 tables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
newToken	TokenNameIdentifier	 new Token
:	TokenNameCOLON	
newTokens	TokenNameIdentifier	 new Tokens
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// replication strategy of the current keyspace (aka table) 	TokenNameCOMMENT_LINE	replication strategy of the current keyspace (aka table) 
AbstractReplicationStrategy	TokenNameIdentifier	 Abstract Replication Strategy
strategy	TokenNameIdentifier	 strategy
=	TokenNameEQUAL	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
.	TokenNameDOT	
getReplicationStrategy	TokenNameIdentifier	 get Replication Strategy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// getting collection of the currently used ranges by this keyspace 	TokenNameCOMMENT_LINE	getting collection of the currently used ranges by this keyspace 
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
currentRanges	TokenNameIdentifier	 current Ranges
=	TokenNameEQUAL	
getRangesForEndpoint	TokenNameIdentifier	 get Ranges For Endpoint
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
localAddress	TokenNameIdentifier	 local Address
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// collection of ranges which this node will serve after move to the new token 	TokenNameCOMMENT_LINE	collection of ranges which this node will serve after move to the new token 
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
updatedRanges	TokenNameIdentifier	 updated Ranges
=	TokenNameEQUAL	
strategy	TokenNameIdentifier	 strategy
.	TokenNameDOT	
getPendingAddressRanges	TokenNameIdentifier	 get Pending Address Ranges
(	TokenNameLPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
,	TokenNameCOMMA	
newToken	TokenNameIdentifier	 new Token
,	TokenNameCOMMA	
localAddress	TokenNameIdentifier	 local Address
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// ring ranges and endpoints associated with them 	TokenNameCOMMENT_LINE	ring ranges and endpoints associated with them 
// this used to determine what nodes should we ping about range data 	TokenNameCOMMENT_LINE	this used to determine what nodes should we ping about range data 
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
rangeAddresses	TokenNameIdentifier	 range Addresses
=	TokenNameEQUAL	
strategy	TokenNameIdentifier	 strategy
.	TokenNameDOT	
getRangeAddresses	TokenNameIdentifier	 get Range Addresses
(	TokenNameLPAREN	
tokenMetaClone	TokenNameIdentifier	 token Meta Clone
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// calculated parts of the ranges to request/stream from/to nodes in the ring 	TokenNameCOMMENT_LINE	calculated parts of the ranges to request/stream from/to nodes in the ring 
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
,	TokenNameCOMMA	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
rangesPerTable	TokenNameIdentifier	 ranges Per Table
=	TokenNameEQUAL	
calculateStreamAndFetchRanges	TokenNameIdentifier	 calculate Stream And Fetch Ranges
(	TokenNameLPAREN	
currentRanges	TokenNameIdentifier	 current Ranges
,	TokenNameCOMMA	
updatedRanges	TokenNameIdentifier	 updated Ranges
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * In this loop we are going through all ranges "to fetch" and determining * nodes in the ring responsible for data we are interested in */	TokenNameCOMMENT_JAVADOC	 In this loop we are going through all ranges "to fetch" and determining nodes in the ring responsible for data we are interested in 
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
rangesToFetchWithPreferredEndpoints	TokenNameIdentifier	 ranges To Fetch With Preferred Endpoints
=	TokenNameEQUAL	
ArrayListMultimap	TokenNameIdentifier	 Array List Multimap
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
toFetch	TokenNameIdentifier	 to Fetch
:	TokenNameCOLON	
rangesPerTable	TokenNameIdentifier	 ranges Per Table
.	TokenNameDOT	
right	TokenNameIdentifier	 right
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
:	TokenNameCOLON	
rangeAddresses	TokenNameIdentifier	 range Addresses
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
toFetch	TokenNameIdentifier	 to Fetch
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
endpoints	TokenNameIdentifier	 endpoints
=	TokenNameEQUAL	
snitch	TokenNameIdentifier	 snitch
.	TokenNameDOT	
getSortedListByProximity	TokenNameIdentifier	 get Sorted List By Proximity
(	TokenNameLPAREN	
localAddress	TokenNameIdentifier	 local Address
,	TokenNameCOMMA	
rangeAddresses	TokenNameIdentifier	 range Addresses
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// storing range and preferred endpoint set 	TokenNameCOMMENT_LINE	storing range and preferred endpoint set 
rangesToFetchWithPreferredEndpoints	TokenNameIdentifier	 ranges To Fetch With Preferred Endpoints
.	TokenNameDOT	
putAll	TokenNameIdentifier	 put All
(	TokenNameLPAREN	
toFetch	TokenNameIdentifier	 to Fetch
,	TokenNameCOMMA	
endpoints	TokenNameIdentifier	 endpoints
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// calculating endpoints to stream current ranges to if needed 	TokenNameCOMMENT_LINE	calculating endpoints to stream current ranges to if needed 
// in some situations node will handle current ranges as part of the new ranges 	TokenNameCOMMENT_LINE	in some situations node will handle current ranges as part of the new ranges 
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
rangeWithEndpoints	TokenNameIdentifier	 range With Endpoints
=	TokenNameEQUAL	
HashMultimap	TokenNameIdentifier	 Hash Multimap
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
toStream	TokenNameIdentifier	 to Stream
:	TokenNameCOLON	
rangesPerTable	TokenNameIdentifier	 ranges Per Table
.	TokenNameDOT	
left	TokenNameIdentifier	 left
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
currentEndpoints	TokenNameIdentifier	 current Endpoints
=	TokenNameEQUAL	
ImmutableSet	TokenNameIdentifier	 Immutable Set
.	TokenNameDOT	
copyOf	TokenNameIdentifier	 copy Of
(	TokenNameLPAREN	
strategy	TokenNameIdentifier	 strategy
.	TokenNameDOT	
calculateNaturalEndpoints	TokenNameIdentifier	 calculate Natural Endpoints
(	TokenNameLPAREN	
toStream	TokenNameIdentifier	 to Stream
.	TokenNameDOT	
right	TokenNameIdentifier	 right
,	TokenNameCOMMA	
tokenMetaClone	TokenNameIdentifier	 token Meta Clone
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
newEndpoints	TokenNameIdentifier	 new Endpoints
=	TokenNameEQUAL	
ImmutableSet	TokenNameIdentifier	 Immutable Set
.	TokenNameDOT	
copyOf	TokenNameIdentifier	 copy Of
(	TokenNameLPAREN	
strategy	TokenNameIdentifier	 strategy
.	TokenNameDOT	
calculateNaturalEndpoints	TokenNameIdentifier	 calculate Natural Endpoints
(	TokenNameLPAREN	
toStream	TokenNameIdentifier	 to Stream
.	TokenNameDOT	
right	TokenNameIdentifier	 right
,	TokenNameCOMMA	
tokenMetaCloneAllSettled	TokenNameIdentifier	 token Meta Clone All Settled
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Range:"	TokenNameStringLiteral	Range:
+	TokenNamePLUS	
toStream	TokenNameIdentifier	 to Stream
+	TokenNamePLUS	
"Current endpoints: "	TokenNameStringLiteral	Current endpoints: 
+	TokenNamePLUS	
currentEndpoints	TokenNameIdentifier	 current Endpoints
+	TokenNamePLUS	
" New endpoints: "	TokenNameStringLiteral	 New endpoints: 
+	TokenNamePLUS	
newEndpoints	TokenNameIdentifier	 new Endpoints
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rangeWithEndpoints	TokenNameIdentifier	 range With Endpoints
.	TokenNameDOT	
putAll	TokenNameIdentifier	 put All
(	TokenNameLPAREN	
toStream	TokenNameIdentifier	 to Stream
,	TokenNameCOMMA	
Sets	TokenNameIdentifier	 Sets
.	TokenNameDOT	
difference	TokenNameIdentifier	 difference
(	TokenNameLPAREN	
newEndpoints	TokenNameIdentifier	 new Endpoints
,	TokenNameCOMMA	
currentEndpoints	TokenNameIdentifier	 current Endpoints
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// associating table with range-to-endpoints map 	TokenNameCOMMENT_LINE	associating table with range-to-endpoints map 
rangesToStreamByTable	TokenNameIdentifier	 ranges To Stream By Table
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
rangeWithEndpoints	TokenNameIdentifier	 range With Endpoints
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
workMap	TokenNameIdentifier	 work Map
=	TokenNameEQUAL	
RangeStreamer	TokenNameIdentifier	 Range Streamer
.	TokenNameDOT	
getWorkMap	TokenNameIdentifier	 get Work Map
(	TokenNameLPAREN	
rangesToFetchWithPreferredEndpoints	TokenNameIdentifier	 ranges To Fetch With Preferred Endpoints
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rangesToFetch	TokenNameIdentifier	 ranges To Fetch
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
workMap	TokenNameIdentifier	 work Map
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Table {}: work map {}."	TokenNameStringLiteral	Table {}: work map {}.
,	TokenNameCOMMA	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
workMap	TokenNameIdentifier	 work Map
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
logStreamsMap	TokenNameIdentifier	 log Streams Map
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
prefix	TokenNameIdentifier	 prefix
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"{} Work map: {}"	TokenNameStringLiteral	{} Work map: {}
,	TokenNameCOMMA	
prefix	TokenNameIdentifier	 prefix
,	TokenNameCOMMA	
rangesToStreamByTable	TokenNameIdentifier	 ranges To Stream By Table
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
logRequestsMap	TokenNameIdentifier	 log Requests Map
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
prefix	TokenNameIdentifier	 prefix
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"{} Work map: {}"	TokenNameStringLiteral	{} Work map: {}
,	TokenNameCOMMA	
prefix	TokenNameIdentifier	 prefix
,	TokenNameCOMMA	
rangesToFetch	TokenNameIdentifier	 ranges To Fetch
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
streamsNeeded	TokenNameIdentifier	 streams Needed
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
!	TokenNameNOT	
rangesToStreamByTable	TokenNameIdentifier	 ranges To Stream By Table
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
rangesToFetch	TokenNameIdentifier	 ranges To Fetch
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
CountDownLatch	TokenNameIdentifier	 Count Down Latch
streams	TokenNameIdentifier	 streams
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
streamRanges	TokenNameIdentifier	 stream Ranges
(	TokenNameLPAREN	
rangesToStreamByTable	TokenNameIdentifier	 ranges To Stream By Table
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
CountDownLatch	TokenNameIdentifier	 Count Down Latch
requests	TokenNameIdentifier	 requests
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
requestRanges	TokenNameIdentifier	 request Ranges
(	TokenNameLPAREN	
rangesToFetch	TokenNameIdentifier	 ranges To Fetch
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
relocate	TokenNameIdentifier	 relocate
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
srcTokens	TokenNameIdentifier	 src Tokens
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
tokens	TokenNameIdentifier	 tokens
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
(	TokenNameLPAREN	
srcTokens	TokenNameIdentifier	 src Tokens
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
srcT	TokenNameIdentifier	 src T
:	TokenNameCOLON	
srcTokens	TokenNameIdentifier	 src Tokens
)	TokenNameRPAREN	
{	TokenNameLBRACE	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getTokenFactory	TokenNameIdentifier	 get Token Factory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
srcT	TokenNameIdentifier	 src T
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getTokenFactory	TokenNameIdentifier	 get Token Factory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
fromString	TokenNameIdentifier	 from String
(	TokenNameLPAREN	
srcT	TokenNameIdentifier	 src T
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ConfigurationException	TokenNameIdentifier	 Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IOException	TokenNameIdentifier	 IO Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
relocateTokens	TokenNameIdentifier	 relocate Tokens
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
void	TokenNamevoid	
relocateTokens	TokenNameIdentifier	 relocate Tokens
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
srcTokens	TokenNameIdentifier	 src Tokens
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
srcTokens	TokenNameIdentifier	 src Tokens
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
InetAddress	TokenNameIdentifier	 Inet Address
localAddress	TokenNameIdentifier	 local Address
=	TokenNameEQUAL	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
localTokens	TokenNameIdentifier	 local Tokens
=	TokenNameEQUAL	
getTokenMetadata	TokenNameIdentifier	 get Token Metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getTokens	TokenNameIdentifier	 get Tokens
(	TokenNameLPAREN	
localAddress	TokenNameIdentifier	 local Address
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
tokens	TokenNameIdentifier	 tokens
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
(	TokenNameLPAREN	
srcTokens	TokenNameIdentifier	 src Tokens
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
it	TokenNameIdentifier	 it
=	TokenNameEQUAL	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
it	TokenNameIdentifier	 it
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Token	TokenNameIdentifier	 Token
srcT	TokenNameIdentifier	 src T
=	TokenNameEQUAL	
it	TokenNameIdentifier	 it
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
localTokens	TokenNameIdentifier	 local Tokens
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
srcT	TokenNameIdentifier	 src T
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
it	TokenNameIdentifier	 it
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
"cannot move {}; source and destination match"	TokenNameStringLiteral	cannot move {}; source and destination match
,	TokenNameCOMMA	
srcT	TokenNameIdentifier	 src T
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<	TokenNameLESS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
"no valid token arguments specified; nothing to relocate"	TokenNameStringLiteral	no valid token arguments specified; nothing to relocate
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
addLocalApplicationState	TokenNameIdentifier	 add Local Application State
(	TokenNameLPAREN	
ApplicationState	TokenNameIdentifier	 Application State
.	TokenNameDOT	
STATUS	TokenNameIdentifier	 STATUS
,	TokenNameCOMMA	
valueFactory	TokenNameIdentifier	 value Factory
.	TokenNameDOT	
relocating	TokenNameIdentifier	 relocating
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setMode	TokenNameIdentifier	 set Mode
(	TokenNameLPAREN	
Mode	TokenNameIdentifier	 Mode
.	TokenNameDOT	
RELOCATING	TokenNameIdentifier	 RELOCATING
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"relocating %s to %s"	TokenNameStringLiteral	relocating %s to %s
,	TokenNameCOMMA	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
localAddress	TokenNameIdentifier	 local Address
.	TokenNameDOT	
getHostAddress	TokenNameIdentifier	 get Host Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
tables	TokenNameIdentifier	 tables
=	TokenNameEQUAL	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getNonSystemTables	TokenNameIdentifier	 get Non System Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setMode	TokenNameIdentifier	 set Mode
(	TokenNameLPAREN	
Mode	TokenNameIdentifier	 Mode
.	TokenNameDOT	
RELOCATING	TokenNameIdentifier	 RELOCATING
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Sleeping %s ms before start streaming/fetching ranges"	TokenNameStringLiteral	Sleeping %s ms before start streaming/fetching ranges
,	TokenNameCOMMA	
RING_DELAY	TokenNameIdentifier	 RING  DELAY
)	TokenNameRPAREN	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
sleep	TokenNameIdentifier	 sleep
(	TokenNameLPAREN	
RING_DELAY	TokenNameIdentifier	 RING  DELAY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"Sleep interrupted "	TokenNameStringLiteral	Sleep interrupted 
+	TokenNamePLUS	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
RangeRelocator	TokenNameIdentifier	 Range Relocator
relocator	TokenNameIdentifier	 relocator
=	TokenNameEQUAL	
new	TokenNamenew	
RangeRelocator	TokenNameIdentifier	 Range Relocator
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
tables	TokenNameIdentifier	 tables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
relocator	TokenNameIdentifier	 relocator
.	TokenNameDOT	
streamsNeeded	TokenNameIdentifier	 streams Needed
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
setMode	TokenNameIdentifier	 set Mode
(	TokenNameLPAREN	
Mode	TokenNameIdentifier	 Mode
.	TokenNameDOT	
RELOCATING	TokenNameIdentifier	 RELOCATING
,	TokenNameCOMMA	
"fetching new ranges and streaming old ranges"	TokenNameStringLiteral	fetching new ranges and streaming old ranges
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
relocator	TokenNameIdentifier	 relocator
.	TokenNameDOT	
logStreamsMap	TokenNameIdentifier	 log Streams Map
(	TokenNameLPAREN	
"[Relocate->STREAMING]"	TokenNameStringLiteral	[Relocate->STREAMING]
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CountDownLatch	TokenNameIdentifier	 Count Down Latch
streamLatch	TokenNameIdentifier	 stream Latch
=	TokenNameEQUAL	
relocator	TokenNameIdentifier	 relocator
.	TokenNameDOT	
streams	TokenNameIdentifier	 streams
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
relocator	TokenNameIdentifier	 relocator
.	TokenNameDOT	
logRequestsMap	TokenNameIdentifier	 log Requests Map
(	TokenNameLPAREN	
"[Relocate->FETCHING]"	TokenNameStringLiteral	[Relocate->FETCHING]
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CountDownLatch	TokenNameIdentifier	 Count Down Latch
fetchLatch	TokenNameIdentifier	 fetch Latch
=	TokenNameEQUAL	
relocator	TokenNameIdentifier	 relocator
.	TokenNameDOT	
requests	TokenNameIdentifier	 requests
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
streamLatch	TokenNameIdentifier	 stream Latch
.	TokenNameDOT	
await	TokenNameIdentifier	 await
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fetchLatch	TokenNameIdentifier	 fetch Latch
.	TokenNameDOT	
await	TokenNameIdentifier	 await
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"Interrupted latch while waiting for stream/fetch ranges to finish: "	TokenNameStringLiteral	Interrupted latch while waiting for stream/fetch ranges to finish: 
+	TokenNamePLUS	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
setMode	TokenNameIdentifier	 set Mode
(	TokenNameLPAREN	
Mode	TokenNameIdentifier	 Mode
.	TokenNameDOT	
RELOCATING	TokenNameIdentifier	 RELOCATING
,	TokenNameCOMMA	
"no new ranges to stream/fetch"	TokenNameStringLiteral	no new ranges to stream/fetch
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
currentTokens	TokenNameIdentifier	 current Tokens
=	TokenNameEQUAL	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
updateLocalTokens	TokenNameIdentifier	 update Local Tokens
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
emptyList	TokenNameIdentifier	 empty List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
updateNormalTokens	TokenNameIdentifier	 update Normal Tokens
(	TokenNameLPAREN	
currentTokens	TokenNameIdentifier	 current Tokens
,	TokenNameCOMMA	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
addLocalApplicationState	TokenNameIdentifier	 add Local Application State
(	TokenNameLPAREN	
ApplicationState	TokenNameIdentifier	 Application State
.	TokenNameDOT	
TOKENS	TokenNameIdentifier	 TOKENS
,	TokenNameCOMMA	
valueFactory	TokenNameIdentifier	 value Factory
.	TokenNameDOT	
tokens	TokenNameIdentifier	 tokens
(	TokenNameLPAREN	
currentTokens	TokenNameIdentifier	 current Tokens
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
addLocalApplicationState	TokenNameIdentifier	 add Local Application State
(	TokenNameLPAREN	
ApplicationState	TokenNameIdentifier	 Application State
.	TokenNameDOT	
STATUS	TokenNameIdentifier	 STATUS
,	TokenNameCOMMA	
valueFactory	TokenNameIdentifier	 value Factory
.	TokenNameDOT	
normal	TokenNameIdentifier	 normal
(	TokenNameLPAREN	
currentTokens	TokenNameIdentifier	 current Tokens
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setMode	TokenNameIdentifier	 set Mode
(	TokenNameLPAREN	
Mode	TokenNameIdentifier	 Mode
.	TokenNameDOT	
NORMAL	TokenNameIdentifier	 NORMAL
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the status of a token removal. */	TokenNameCOMMENT_JAVADOC	 Get the status of a token removal. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getRemovalStatus	TokenNameIdentifier	 get Removal Status
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
removingNode	TokenNameIdentifier	 removing Node
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
"No token removals in process."	TokenNameStringLiteral	No token removals in process.
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Removing token (%s). Waiting for replication confirmation from [%s]."	TokenNameStringLiteral	Removing token (%s). Waiting for replication confirmation from [%s].
,	TokenNameCOMMA	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getToken	TokenNameIdentifier	 get Token
(	TokenNameLPAREN	
removingNode	TokenNameIdentifier	 removing Node
)	TokenNameRPAREN	
,	TokenNameCOMMA	
StringUtils	TokenNameIdentifier	 String Utils
.	TokenNameDOT	
join	TokenNameIdentifier	 join
(	TokenNameLPAREN	
replicatingNodes	TokenNameIdentifier	 replicating Nodes
,	TokenNameCOMMA	
","	TokenNameStringLiteral	,
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Force a remove operation to complete. This may be necessary if a remove operation * blocks forever due to node/stream failure. removeToken() must be called * first, this is a last resort measure. No further attempt will be made to restore replicas. */	TokenNameCOMMENT_JAVADOC	 Force a remove operation to complete. This may be necessary if a remove operation blocks forever due to node/stream failure. removeToken() must be called first, this is a last resort measure. No further attempt will be made to restore replicas. 
public	TokenNamepublic	
void	TokenNamevoid	
forceRemoveCompletion	TokenNameIdentifier	 force Remove Completion
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
replicatingNodes	TokenNameIdentifier	 replicating Nodes
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getLeavingEndpoints	TokenNameIdentifier	 get Leaving Endpoints
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
"Removal not confirmed for for "	TokenNameStringLiteral	Removal not confirmed for for 
+	TokenNamePLUS	
StringUtils	TokenNameIdentifier	 String Utils
.	TokenNameDOT	
join	TokenNameIdentifier	 join
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
replicatingNodes	TokenNameIdentifier	 replicating Nodes
,	TokenNameCOMMA	
","	TokenNameStringLiteral	,
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
:	TokenNameCOLON	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getLeavingEndpoints	TokenNameIdentifier	 get Leaving Endpoints
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
UUID	TokenNameIdentifier	 UUID
hostId	TokenNameIdentifier	 host Id
=	TokenNameEQUAL	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getHostId	TokenNameIdentifier	 get Host Id
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
advertiseTokenRemoved	TokenNameIdentifier	 advertise Token Removed
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
hostId	TokenNameIdentifier	 host Id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
excise	TokenNameIdentifier	 excise
(	TokenNameLPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getTokens	TokenNameIdentifier	 get Tokens
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
replicatingNodes	TokenNameIdentifier	 replicating Nodes
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
removingNode	TokenNameIdentifier	 removing Node
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
UnsupportedOperationException	TokenNameIdentifier	 Unsupported Operation Exception
(	TokenNameLPAREN	
"No tokens to force removal on, call 'removetoken' first"	TokenNameStringLiteral	No tokens to force removal on, call 'removetoken' first
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Remove a node that has died, attempting to restore the replica count. * If the node is alive, decommission should be attempted. If decommission * fails, then removeToken should be called. If we fail while trying to * restore the replica count, finally forceRemoveCompleteion should be * called to forcibly remove the node without regard to replica count. * * @param hostIdString token for the node */	TokenNameCOMMENT_JAVADOC	 Remove a node that has died, attempting to restore the replica count. If the node is alive, decommission should be attempted. If decommission fails, then removeToken should be called. If we fail while trying to restore the replica count, finally forceRemoveCompleteion should be called to forcibly remove the node without regard to replica count. * @param hostIdString token for the node 
public	TokenNamepublic	
void	TokenNamevoid	
removeNode	TokenNameIdentifier	 remove Node
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
hostIdString	TokenNameIdentifier	 host Id String
)	TokenNameRPAREN	
{	TokenNameLBRACE	
InetAddress	TokenNameIdentifier	 Inet Address
myAddress	TokenNameIdentifier	 my Address
=	TokenNameEQUAL	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
UUID	TokenNameIdentifier	 UUID
localHostId	TokenNameIdentifier	 local Host Id
=	TokenNameEQUAL	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getHostId	TokenNameIdentifier	 get Host Id
(	TokenNameLPAREN	
myAddress	TokenNameIdentifier	 my Address
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
UUID	TokenNameIdentifier	 UUID
hostId	TokenNameIdentifier	 host Id
=	TokenNameEQUAL	
UUID	TokenNameIdentifier	 UUID
.	TokenNameDOT	
fromString	TokenNameIdentifier	 from String
(	TokenNameLPAREN	
hostIdString	TokenNameIdentifier	 host Id String
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
=	TokenNameEQUAL	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getEndpointForHostId	TokenNameIdentifier	 get Endpoint For Host Id
(	TokenNameLPAREN	
hostId	TokenNameIdentifier	 host Id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
UnsupportedOperationException	TokenNameIdentifier	 Unsupported Operation Exception
(	TokenNameLPAREN	
"Host ID not found."	TokenNameStringLiteral	Host ID not found.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
tokens	TokenNameIdentifier	 tokens
=	TokenNameEQUAL	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getTokens	TokenNameIdentifier	 get Tokens
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
myAddress	TokenNameIdentifier	 my Address
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
UnsupportedOperationException	TokenNameIdentifier	 Unsupported Operation Exception
(	TokenNameLPAREN	
"Cannot remove self"	TokenNameStringLiteral	Cannot remove self
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getLiveMembers	TokenNameIdentifier	 get Live Members
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
UnsupportedOperationException	TokenNameIdentifier	 Unsupported Operation Exception
(	TokenNameLPAREN	
"Node "	TokenNameStringLiteral	Node 
+	TokenNamePLUS	
endpoint	TokenNameIdentifier	 endpoint
+	TokenNamePLUS	
" is alive and owns this ID. Use decommission command to remove it from the ring"	TokenNameStringLiteral	 is alive and owns this ID. Use decommission command to remove it from the ring
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// A leaving endpoint that is dead is already being removed. 	TokenNameCOMMENT_LINE	A leaving endpoint that is dead is already being removed. 
if	TokenNameif	
(	TokenNameLPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
isLeaving	TokenNameIdentifier	 is Leaving
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
"Node "	TokenNameStringLiteral	Node 
+	TokenNamePLUS	
endpoint	TokenNameIdentifier	 endpoint
+	TokenNamePLUS	
" is already being removed, continuing removal anyway"	TokenNameStringLiteral	 is already being removed, continuing removal anyway
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
replicatingNodes	TokenNameIdentifier	 replicating Nodes
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
UnsupportedOperationException	TokenNameIdentifier	 Unsupported Operation Exception
(	TokenNameLPAREN	
"This node is already processing a removal. Wait for it to complete, or use 'removetoken force' if this has failed."	TokenNameStringLiteral	This node is already processing a removal. Wait for it to complete, or use 'removetoken force' if this has failed.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Find the endpoints that are going to become responsible for data 	TokenNameCOMMENT_LINE	Find the endpoints that are going to become responsible for data 
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
:	TokenNameCOLON	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getNonSystemTables	TokenNameIdentifier	 get Non System Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if the replication factor is 1 the data is lost so we shouldn't wait for confirmation 	TokenNameCOMMENT_LINE	if the replication factor is 1 the data is lost so we shouldn't wait for confirmation 
if	TokenNameif	
(	TokenNameLPAREN	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
.	TokenNameDOT	
getReplicationStrategy	TokenNameIdentifier	 get Replication Strategy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getReplicationFactor	TokenNameIdentifier	 get Replication Factor
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
// get all ranges that change ownership (that is, a node needs 	TokenNameCOMMENT_LINE	get all ranges that change ownership (that is, a node needs 
// to take responsibility for new range) 	TokenNameCOMMENT_LINE	to take responsibility for new range) 
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
changedRanges	TokenNameIdentifier	 changed Ranges
=	TokenNameEQUAL	
getChangedRangesForLeaving	TokenNameIdentifier	 get Changed Ranges For Leaving
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
IFailureDetector	TokenNameIdentifier	 I Failure Detector
failureDetector	TokenNameIdentifier	 failure Detector
=	TokenNameEQUAL	
FailureDetector	TokenNameIdentifier	 Failure Detector
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
ep	TokenNameIdentifier	 ep
:	TokenNameCOLON	
changedRanges	TokenNameIdentifier	 changed Ranges
.	TokenNameDOT	
values	TokenNameIdentifier	 values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
failureDetector	TokenNameIdentifier	 failure Detector
.	TokenNameDOT	
isAlive	TokenNameIdentifier	 is Alive
(	TokenNameLPAREN	
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
)	TokenNameRPAREN	
replicatingNodes	TokenNameIdentifier	 replicating Nodes
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
"Endpoint "	TokenNameStringLiteral	Endpoint 
+	TokenNamePLUS	
ep	TokenNameIdentifier	 ep
+	TokenNamePLUS	
" is down and will not receive data for re-replication of "	TokenNameStringLiteral	 is down and will not receive data for re-replication of 
+	TokenNamePLUS	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
removingNode	TokenNameIdentifier	 removing Node
=	TokenNameEQUAL	
endpoint	TokenNameIdentifier	 endpoint
;	TokenNameSEMICOLON	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
addLeavingEndpoint	TokenNameIdentifier	 add Leaving Endpoint
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
calculatePendingRanges	TokenNameIdentifier	 calculate Pending Ranges
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// the gossiper will handle spoofing this node's state to REMOVING_TOKEN for us 	TokenNameCOMMENT_LINE	the gossiper will handle spoofing this node's state to REMOVING_TOKEN for us 
// we add our own token so other nodes to let us know when they're done 	TokenNameCOMMENT_LINE	we add our own token so other nodes to let us know when they're done 
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
advertiseRemoving	TokenNameIdentifier	 advertise Removing
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
hostId	TokenNameIdentifier	 host Id
,	TokenNameCOMMA	
localHostId	TokenNameIdentifier	 local Host Id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// kick off streaming commands 	TokenNameCOMMENT_LINE	kick off streaming commands 
restoreReplicaCount	TokenNameIdentifier	 restore Replica Count
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
myAddress	TokenNameIdentifier	 my Address
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// wait for ReplicationFinishedVerbHandler to signal we're done 	TokenNameCOMMENT_LINE	wait for ReplicationFinishedVerbHandler to signal we're done 
while	TokenNamewhile	
(	TokenNameLPAREN	
!	TokenNameNOT	
replicatingNodes	TokenNameIdentifier	 replicating Nodes
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
sleep	TokenNameIdentifier	 sleep
(	TokenNameLPAREN	
100	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
AssertionError	TokenNameIdentifier	 Assertion Error
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
excise	TokenNameIdentifier	 excise
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// gossiper will indicate the token has left 	TokenNameCOMMENT_LINE	gossiper will indicate the token has left 
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
advertiseTokenRemoved	TokenNameIdentifier	 advertise Token Removed
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
hostId	TokenNameIdentifier	 host Id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
replicatingNodes	TokenNameIdentifier	 replicating Nodes
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
removingNode	TokenNameIdentifier	 removing Node
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
confirmReplication	TokenNameIdentifier	 confirm Replication
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// replicatingNodes can be empty in the case where this node used to be a removal coordinator, 	TokenNameCOMMENT_LINE	replicatingNodes can be empty in the case where this node used to be a removal coordinator, 
// but restarted before all 'replication finished' messages arrived. In that case, we'll 	TokenNameCOMMENT_LINE	but restarted before all 'replication finished' messages arrived. In that case, we'll 
// still go ahead and acknowledge it. 	TokenNameCOMMENT_LINE	still go ahead and acknowledge it. 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
replicatingNodes	TokenNameIdentifier	 replicating Nodes
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
replicatingNodes	TokenNameIdentifier	 replicating Nodes
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Received unexpected REPLICATION_FINISHED message from "	TokenNameStringLiteral	Received unexpected REPLICATION_FINISHED message from 
+	TokenNamePLUS	
node	TokenNameIdentifier	 node
+	TokenNamePLUS	
". Was this node recently a removal coordinator?"	TokenNameStringLiteral	. Was this node recently a removal coordinator?
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isClientMode	TokenNameIdentifier	 is Client Mode
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
isClientMode	TokenNameIdentifier	 is Client Mode
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
requestGC	TokenNameIdentifier	 request GC
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
hasUnreclaimedSpace	TokenNameIdentifier	 has Unreclaimed Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"requesting GC to free disk space"	TokenNameStringLiteral	requesting GC to free disk space
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
gc	TokenNameIdentifier	 gc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
sleep	TokenNameIdentifier	 sleep
(	TokenNameLPAREN	
1000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
AssertionError	TokenNameIdentifier	 Assertion Error
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
hasUnreclaimedSpace	TokenNameIdentifier	 has Unreclaimed Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
:	TokenNameCOLON	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
.	TokenNameDOT	
all	TokenNameIdentifier	 all
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
hasUnreclaimedSpace	TokenNameIdentifier	 has Unreclaimed Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getOperationMode	TokenNameIdentifier	 get Operation Mode
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
operationMode	TokenNameIdentifier	 operation Mode
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getDrainProgress	TokenNameIdentifier	 get Drain Progress
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Drained %s/%s ColumnFamilies"	TokenNameStringLiteral	Drained %s/%s ColumnFamilies
,	TokenNameCOMMA	
remainingCFs	TokenNameIdentifier	 remaining C Fs
,	TokenNameCOMMA	
totalCFs	TokenNameIdentifier	 total C Fs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Shuts node off to writes, empties memtables and the commit log. * There are two differences between drain and the normal shutdown hook: * - Drain waits for in-progress streaming to complete * - Drain flushes *all* columnfamilies (shutdown hook only flushes non-durable CFs) */	TokenNameCOMMENT_JAVADOC	 Shuts node off to writes, empties memtables and the commit log. There are two differences between drain and the normal shutdown hook: - Drain waits for in-progress streaming to complete - Drain flushes *all* columnfamilies (shutdown hook only flushes non-durable CFs) 
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
drain	TokenNameIdentifier	 drain
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
,	TokenNameCOMMA	
ExecutionException	TokenNameIdentifier	 Execution Exception
{	TokenNameLBRACE	
ExecutorService	TokenNameIdentifier	 Executor Service
mutationStage	TokenNameIdentifier	 mutation Stage
=	TokenNameEQUAL	
StageManager	TokenNameIdentifier	 Stage Manager
.	TokenNameDOT	
getStage	TokenNameIdentifier	 get Stage
(	TokenNameLPAREN	
Stage	TokenNameIdentifier	 Stage
.	TokenNameDOT	
MUTATION	TokenNameIdentifier	 MUTATION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
mutationStage	TokenNameIdentifier	 mutation Stage
.	TokenNameDOT	
isTerminated	TokenNameIdentifier	 is Terminated
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
"Cannot drain node (did it already happen?)"	TokenNameStringLiteral	Cannot drain node (did it already happen?)
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
setMode	TokenNameIdentifier	 set Mode
(	TokenNameLPAREN	
Mode	TokenNameIdentifier	 Mode
.	TokenNameDOT	
DRAINING	TokenNameIdentifier	 DRAINING
,	TokenNameCOMMA	
"starting drain process"	TokenNameStringLiteral	starting drain process
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
stopRPCServer	TokenNameIdentifier	 stop RPC Server
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
optionalTasks	TokenNameIdentifier	 optional Tasks
.	TokenNameDOT	
shutdown	TokenNameIdentifier	 shutdown
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
stop	TokenNameIdentifier	 stop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setMode	TokenNameIdentifier	 set Mode
(	TokenNameLPAREN	
Mode	TokenNameIdentifier	 Mode
.	TokenNameDOT	
DRAINING	TokenNameIdentifier	 DRAINING
,	TokenNameCOMMA	
"shutting down MessageService"	TokenNameStringLiteral	shutting down MessageService
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
shutdown	TokenNameIdentifier	 shutdown
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setMode	TokenNameIdentifier	 set Mode
(	TokenNameLPAREN	
Mode	TokenNameIdentifier	 Mode
.	TokenNameDOT	
DRAINING	TokenNameIdentifier	 DRAINING
,	TokenNameCOMMA	
"waiting for streaming"	TokenNameStringLiteral	waiting for streaming
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
waitForStreaming	TokenNameIdentifier	 wait For Streaming
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setMode	TokenNameIdentifier	 set Mode
(	TokenNameLPAREN	
Mode	TokenNameIdentifier	 Mode
.	TokenNameDOT	
DRAINING	TokenNameIdentifier	 DRAINING
,	TokenNameCOMMA	
"clearing mutation stage"	TokenNameStringLiteral	clearing mutation stage
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
mutationStage	TokenNameIdentifier	 mutation Stage
.	TokenNameDOT	
shutdown	TokenNameIdentifier	 shutdown
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
mutationStage	TokenNameIdentifier	 mutation Stage
.	TokenNameDOT	
awaitTermination	TokenNameIdentifier	 await Termination
(	TokenNameLPAREN	
3600	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
TimeUnit	TokenNameIdentifier	 Time Unit
.	TokenNameDOT	
SECONDS	TokenNameIdentifier	 SECONDS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
StorageProxy	TokenNameIdentifier	 Storage Proxy
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
verifyNoHintsInProgress	TokenNameIdentifier	 verify No Hints In Progress
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setMode	TokenNameIdentifier	 set Mode
(	TokenNameLPAREN	
Mode	TokenNameIdentifier	 Mode
.	TokenNameDOT	
DRAINING	TokenNameIdentifier	 DRAINING
,	TokenNameCOMMA	
"flushing column families"	TokenNameStringLiteral	flushing column families
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
>	TokenNameGREATER	
cfses	TokenNameIdentifier	 cfses
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
tableName	TokenNameIdentifier	 table Name
:	TokenNameCOLON	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getNonSystemTables	TokenNameIdentifier	 get Non System Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Table	TokenNameIdentifier	 Table
table	TokenNameIdentifier	 table
=	TokenNameEQUAL	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
tableName	TokenNameIdentifier	 table Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cfses	TokenNameIdentifier	 cfses
.	TokenNameDOT	
addAll	TokenNameIdentifier	 add All
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
getColumnFamilyStores	TokenNameIdentifier	 get Column Family Stores
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
totalCFs	TokenNameIdentifier	 total C Fs
=	TokenNameEQUAL	
remainingCFs	TokenNameIdentifier	 remaining C Fs
=	TokenNameEQUAL	
cfses	TokenNameIdentifier	 cfses
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
:	TokenNameCOLON	
cfses	TokenNameIdentifier	 cfses
)	TokenNameRPAREN	
{	TokenNameLBRACE	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
forceBlockingFlush	TokenNameIdentifier	 force Blocking Flush
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
remainingCFs	TokenNameIdentifier	 remaining C Fs
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
.	TokenNameDOT	
postFlushExecutor	TokenNameIdentifier	 post Flush Executor
.	TokenNameDOT	
shutdown	TokenNameIdentifier	 shutdown
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
.	TokenNameDOT	
postFlushExecutor	TokenNameIdentifier	 post Flush Executor
.	TokenNameDOT	
awaitTermination	TokenNameIdentifier	 await Termination
(	TokenNameLPAREN	
60	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
TimeUnit	TokenNameIdentifier	 Time Unit
.	TokenNameDOT	
SECONDS	TokenNameIdentifier	 SECONDS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CommitLog	TokenNameIdentifier	 Commit Log
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
shutdownBlocking	TokenNameIdentifier	 shutdown Blocking
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// wait for miscellaneous tasks like sstable and commitlog segment deletion 	TokenNameCOMMENT_LINE	wait for miscellaneous tasks like sstable and commitlog segment deletion 
tasks	TokenNameIdentifier	 tasks
.	TokenNameDOT	
shutdown	TokenNameIdentifier	 shutdown
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
tasks	TokenNameIdentifier	 tasks
.	TokenNameDOT	
awaitTermination	TokenNameIdentifier	 await Termination
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
TimeUnit	TokenNameIdentifier	 Time Unit
.	TokenNameDOT	
MINUTES	TokenNameIdentifier	 MINUTES
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
"Miscellaneous task executor still busy after one minute; proceeding with shutdown"	TokenNameStringLiteral	Miscellaneous task executor still busy after one minute; proceeding with shutdown
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setMode	TokenNameIdentifier	 set Mode
(	TokenNameLPAREN	
Mode	TokenNameIdentifier	 Mode
.	TokenNameDOT	
DRAINED	TokenNameIdentifier	 DRAINED
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Never ever do this at home. Used by tests. 	TokenNameCOMMENT_LINE	Never ever do this at home. Used by tests. 
IPartitioner	TokenNameIdentifier	 I Partitioner
setPartitionerUnsafe	TokenNameIdentifier	 set Partitioner Unsafe
(	TokenNameLPAREN	
IPartitioner	TokenNameIdentifier	 I Partitioner
newPartitioner	TokenNameIdentifier	 new Partitioner
)	TokenNameRPAREN	
{	TokenNameLBRACE	
IPartitioner	TokenNameIdentifier	 I Partitioner
oldPartitioner	TokenNameIdentifier	 old Partitioner
=	TokenNameEQUAL	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
setPartitioner	TokenNameIdentifier	 set Partitioner
(	TokenNameLPAREN	
newPartitioner	TokenNameIdentifier	 new Partitioner
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
valueFactory	TokenNameIdentifier	 value Factory
=	TokenNameEQUAL	
new	TokenNamenew	
VersionedValue	TokenNameIdentifier	 Versioned Value
.	TokenNameDOT	
VersionedValueFactory	TokenNameIdentifier	 Versioned Value Factory
(	TokenNameLPAREN	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
oldPartitioner	TokenNameIdentifier	 old Partitioner
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
TokenMetadata	TokenNameIdentifier	 Token Metadata
setTokenMetadataUnsafe	TokenNameIdentifier	 set Token Metadata Unsafe
(	TokenNameLPAREN	
TokenMetadata	TokenNameIdentifier	 Token Metadata
tmd	TokenNameIdentifier	 tmd
)	TokenNameRPAREN	
{	TokenNameLBRACE	
TokenMetadata	TokenNameIdentifier	 Token Metadata
old	TokenNameIdentifier	 old
=	TokenNameEQUAL	
tokenMetadata	TokenNameIdentifier	 token Metadata
;	TokenNameSEMICOLON	
tokenMetadata	TokenNameIdentifier	 token Metadata
=	TokenNameEQUAL	
tmd	TokenNameIdentifier	 tmd
;	TokenNameSEMICOLON	
return	TokenNamereturn	
old	TokenNameIdentifier	 old
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
truncate	TokenNameIdentifier	 truncate
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
throws	TokenNamethrows	
TimeoutException	TokenNameIdentifier	 Timeout Exception
,	TokenNameCOMMA	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
StorageProxy	TokenNameIdentifier	 Storage Proxy
.	TokenNameDOT	
truncateBlocking	TokenNameIdentifier	 truncate Blocking
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
UnavailableException	TokenNameIdentifier	 Unavailable Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IOException	TokenNameIdentifier	 IO Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
Float	TokenNameIdentifier	 Float
>	TokenNameGREATER	
getOwnership	TokenNameIdentifier	 get Ownership
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
sortedTokens	TokenNameIdentifier	 sorted Tokens
=	TokenNameEQUAL	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
sortedTokens	TokenNameIdentifier	 sorted Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// describeOwnership returns tokens in an unspecified order, let's re-order them 	TokenNameCOMMENT_LINE	describeOwnership returns tokens in an unspecified order, let's re-order them 
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
Float	TokenNameIdentifier	 Float
>	TokenNameGREATER	
tokenMap	TokenNameIdentifier	 token Map
=	TokenNameEQUAL	
new	TokenNamenew	
TreeMap	TokenNameIdentifier	 Tree Map
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
Float	TokenNameIdentifier	 Float
>	TokenNameGREATER	
(	TokenNameLPAREN	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
describeOwnership	TokenNameIdentifier	 describe Ownership
(	TokenNameLPAREN	
sortedTokens	TokenNameIdentifier	 sorted Tokens
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
Float	TokenNameIdentifier	 Float
>	TokenNameGREATER	
nodeMap	TokenNameIdentifier	 node Map
=	TokenNameEQUAL	
new	TokenNamenew	
LinkedHashMap	TokenNameIdentifier	 Linked Hash Map
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
Float	TokenNameIdentifier	 Float
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
Float	TokenNameIdentifier	 Float
>	TokenNameGREATER	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
tokenMap	TokenNameIdentifier	 token Map
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
=	TokenNameEQUAL	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
getEndpoint	TokenNameIdentifier	 get Endpoint
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Float	TokenNameIdentifier	 Float
tokenOwnership	TokenNameIdentifier	 token Ownership
=	TokenNameEQUAL	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nodeMap	TokenNameIdentifier	 node Map
.	TokenNameDOT	
containsKey	TokenNameIdentifier	 contains Key
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
nodeMap	TokenNameIdentifier	 node Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
nodeMap	TokenNameIdentifier	 node Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
+	TokenNamePLUS	
tokenOwnership	TokenNameIdentifier	 token Ownership
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
nodeMap	TokenNameIdentifier	 node Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
tokenOwnership	TokenNameIdentifier	 token Ownership
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
nodeMap	TokenNameIdentifier	 node Map
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Calculates ownership. If there are multiple DC's and the replication strategy is DC aware then ownership will be * calculated per dc, i.e. each DC will have total ring ownership divided amongst its nodes. Without replication * total ownership will be a multiple of the number of DC's and this value will then go up within each DC depending * on the number of replicas within itself. For DC unaware replication strategies, ownership without replication * will be 100%. * * @throws IllegalStateException when node is not configured properly. */	TokenNameCOMMENT_JAVADOC	 Calculates ownership. If there are multiple DC's and the replication strategy is DC aware then ownership will be calculated per dc, i.e. each DC will have total ring ownership divided amongst its nodes. Without replication total ownership will be a multiple of the number of DC's and this value will then go up within each DC depending on the number of replicas within itself. For DC unaware replication strategies, ownership without replication will be 100%. * @throws IllegalStateException when node is not configured properly. 
public	TokenNamepublic	
LinkedHashMap	TokenNameIdentifier	 Linked Hash Map
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
Float	TokenNameIdentifier	 Float
>	TokenNameGREATER	
effectiveOwnership	TokenNameIdentifier	 effective Ownership
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
throws	TokenNamethrows	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getNonSystemTables	TokenNameIdentifier	 get Non System Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
"Couldn't find any Non System Keyspaces to infer replication topology"	TokenNameStringLiteral	Couldn't find any Non System Keyspaces to infer replication topology
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
hasSameReplication	TokenNameIdentifier	 has Same Replication
(	TokenNameLPAREN	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getNonSystemTables	TokenNameIdentifier	 get Non System Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
"Non System keyspaces doesnt have the same topology"	TokenNameStringLiteral	Non System keyspaces doesnt have the same topology
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TokenMetadata	TokenNameIdentifier	 Token Metadata
metadata	TokenNameIdentifier	 metadata
=	TokenNameEQUAL	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
cloneOnlyTokenMap	TokenNameIdentifier	 clone Only Token Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
keyspace	TokenNameIdentifier	 keyspace
=	TokenNameEQUAL	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getNonSystemTables	TokenNameIdentifier	 get Non System Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
endpointsGroupedByDc	TokenNameIdentifier	 endpoints Grouped By Dc
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// mapping of dc's to nodes, use sorted map so that we get dcs sorted 	TokenNameCOMMENT_LINE	mapping of dc's to nodes, use sorted map so that we get dcs sorted 
SortedMap	TokenNameIdentifier	 Sorted Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
sortedDcsToEndpoints	TokenNameIdentifier	 sorted Dcs To Endpoints
=	TokenNameEQUAL	
new	TokenNamenew	
TreeMap	TokenNameIdentifier	 Tree Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sortedDcsToEndpoints	TokenNameIdentifier	 sorted Dcs To Endpoints
.	TokenNameDOT	
putAll	TokenNameIdentifier	 put All
(	TokenNameLPAREN	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
getTopology	TokenNameIdentifier	 get Topology
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getDatacenterEndpoints	TokenNameIdentifier	 get Datacenter Endpoints
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
asMap	TokenNameIdentifier	 as Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
endpoints	TokenNameIdentifier	 endpoints
:	TokenNameCOLON	
sortedDcsToEndpoints	TokenNameIdentifier	 sorted Dcs To Endpoints
.	TokenNameDOT	
values	TokenNameIdentifier	 values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
endpointsGroupedByDc	TokenNameIdentifier	 endpoints Grouped By Dc
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
endpoints	TokenNameIdentifier	 endpoints
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
Float	TokenNameIdentifier	 Float
>	TokenNameGREATER	
tokenOwnership	TokenNameIdentifier	 token Ownership
=	TokenNameEQUAL	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
describeOwnership	TokenNameIdentifier	 describe Ownership
(	TokenNameLPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
sortedTokens	TokenNameIdentifier	 sorted Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
LinkedHashMap	TokenNameIdentifier	 Linked Hash Map
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
Float	TokenNameIdentifier	 Float
>	TokenNameGREATER	
finalOwnership	TokenNameIdentifier	 final Ownership
=	TokenNameEQUAL	
Maps	TokenNameIdentifier	 Maps
.	TokenNameDOT	
newLinkedHashMap	TokenNameIdentifier	 new Linked Hash Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// calculate ownership per dc 	TokenNameCOMMENT_LINE	calculate ownership per dc 
for	TokenNamefor	
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
endpoints	TokenNameIdentifier	 endpoints
:	TokenNameCOLON	
endpointsGroupedByDc	TokenNameIdentifier	 endpoints Grouped By Dc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// calculate the ownership with replication and add the endpoint to the final ownership map 	TokenNameCOMMENT_LINE	calculate the ownership with replication and add the endpoint to the final ownership map 
for	TokenNamefor	
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
:	TokenNameCOLON	
endpoints	TokenNameIdentifier	 endpoints
)	TokenNameRPAREN	
{	TokenNameLBRACE	
float	TokenNamefloat	
ownership	TokenNameIdentifier	 ownership
=	TokenNameEQUAL	
0.0f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
:	TokenNameCOLON	
getRangesForEndpoint	TokenNameIdentifier	 get Ranges For Endpoint
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
tokenOwnership	TokenNameIdentifier	 token Ownership
.	TokenNameDOT	
containsKey	TokenNameIdentifier	 contains Key
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
right	TokenNameIdentifier	 right
)	TokenNameRPAREN	
)	TokenNameRPAREN	
ownership	TokenNameIdentifier	 ownership
+=	TokenNamePLUS_EQUAL	
tokenOwnership	TokenNameIdentifier	 token Ownership
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
right	TokenNameIdentifier	 right
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finalOwnership	TokenNameIdentifier	 final Ownership
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
ownership	TokenNameIdentifier	 ownership
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
finalOwnership	TokenNameIdentifier	 final Ownership
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
hasSameReplication	TokenNameIdentifier	 has Same Replication
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
list	TokenNameIdentifier	 list
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
list	TokenNameIdentifier	 list
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
list	TokenNameIdentifier	 list
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
KSMetaData	TokenNameIdentifier	 KS Meta Data
ksm1	TokenNameIdentifier	 ksm1
=	TokenNameEQUAL	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getKSMetaData	TokenNameIdentifier	 get KS Meta Data
(	TokenNameLPAREN	
list	TokenNameIdentifier	 list
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
KSMetaData	TokenNameIdentifier	 KS Meta Data
ksm2	TokenNameIdentifier	 ksm2
=	TokenNameEQUAL	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getKSMetaData	TokenNameIdentifier	 get KS Meta Data
(	TokenNameLPAREN	
list	TokenNameIdentifier	 list
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
ksm1	TokenNameIdentifier	 ksm1
.	TokenNameDOT	
strategyClass	TokenNameIdentifier	 strategy Class
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
ksm2	TokenNameIdentifier	 ksm2
.	TokenNameDOT	
strategyClass	TokenNameIdentifier	 strategy Class
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
Iterators	TokenNameIdentifier	 Iterators
.	TokenNameDOT	
elementsEqual	TokenNameIdentifier	 elements Equal
(	TokenNameLPAREN	
ksm1	TokenNameIdentifier	 ksm1
.	TokenNameDOT	
strategyOptions	TokenNameIdentifier	 strategy Options
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ksm2	TokenNameIdentifier	 ksm2
.	TokenNameDOT	
strategyOptions	TokenNameIdentifier	 strategy Options
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
getKeyspaces	TokenNameIdentifier	 get Keyspaces
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
tableslist	TokenNameIdentifier	 tableslist
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getTables	TokenNameIdentifier	 get Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
unmodifiableList	TokenNameIdentifier	 unmodifiable List
(	TokenNameLPAREN	
tableslist	TokenNameIdentifier	 tableslist
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
updateSnitch	TokenNameIdentifier	 update Snitch
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
epSnitchClassName	TokenNameIdentifier	 ep Snitch Class Name
,	TokenNameCOMMA	
Boolean	TokenNameIdentifier	 Boolean
dynamic	TokenNameIdentifier	 dynamic
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
dynamicUpdateInterval	TokenNameIdentifier	 dynamic Update Interval
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
dynamicResetInterval	TokenNameIdentifier	 dynamic Reset Interval
,	TokenNameCOMMA	
Double	TokenNameIdentifier	 Double
dynamicBadnessThreshold	TokenNameIdentifier	 dynamic Badness Threshold
)	TokenNameRPAREN	
throws	TokenNamethrows	
ClassNotFoundException	TokenNameIdentifier	 Class Not Found Exception
{	TokenNameLBRACE	
IEndpointSnitch	TokenNameIdentifier	 I Endpoint Snitch
oldSnitch	TokenNameIdentifier	 old Snitch
=	TokenNameEQUAL	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getEndpointSnitch	TokenNameIdentifier	 get Endpoint Snitch
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// new snitch registers mbean during construction 	TokenNameCOMMENT_LINE	new snitch registers mbean during construction 
IEndpointSnitch	TokenNameIdentifier	 I Endpoint Snitch
newSnitch	TokenNameIdentifier	 new Snitch
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
newSnitch	TokenNameIdentifier	 new Snitch
=	TokenNameEQUAL	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
construct	TokenNameIdentifier	 construct
(	TokenNameLPAREN	
epSnitchClassName	TokenNameIdentifier	 ep Snitch Class Name
,	TokenNameCOMMA	
"snitch"	TokenNameStringLiteral	snitch
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ConfigurationException	TokenNameIdentifier	 Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
ClassNotFoundException	TokenNameIdentifier	 Class Not Found Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
dynamic	TokenNameIdentifier	 dynamic
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
setDynamicUpdateInterval	TokenNameIdentifier	 set Dynamic Update Interval
(	TokenNameLPAREN	
dynamicUpdateInterval	TokenNameIdentifier	 dynamic Update Interval
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
setDynamicResetInterval	TokenNameIdentifier	 set Dynamic Reset Interval
(	TokenNameLPAREN	
dynamicResetInterval	TokenNameIdentifier	 dynamic Reset Interval
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
setDynamicBadnessThreshold	TokenNameIdentifier	 set Dynamic Badness Threshold
(	TokenNameLPAREN	
dynamicBadnessThreshold	TokenNameIdentifier	 dynamic Badness Threshold
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
newSnitch	TokenNameIdentifier	 new Snitch
=	TokenNameEQUAL	
new	TokenNamenew	
DynamicEndpointSnitch	TokenNameIdentifier	 Dynamic Endpoint Snitch
(	TokenNameLPAREN	
newSnitch	TokenNameIdentifier	 new Snitch
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// point snitch references to the new instance 	TokenNameCOMMENT_LINE	point snitch references to the new instance 
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
setEndpointSnitch	TokenNameIdentifier	 set Endpoint Snitch
(	TokenNameLPAREN	
newSnitch	TokenNameIdentifier	 new Snitch
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
ks	TokenNameIdentifier	 ks
:	TokenNameCOLON	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getTables	TokenNameIdentifier	 get Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
ks	TokenNameIdentifier	 ks
)	TokenNameRPAREN	
.	TokenNameDOT	
getReplicationStrategy	TokenNameIdentifier	 get Replication Strategy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
snitch	TokenNameIdentifier	 snitch
=	TokenNameEQUAL	
newSnitch	TokenNameIdentifier	 new Snitch
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
oldSnitch	TokenNameIdentifier	 old Snitch
instanceof	TokenNameinstanceof	
DynamicEndpointSnitch	TokenNameIdentifier	 Dynamic Endpoint Snitch
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
DynamicEndpointSnitch	TokenNameIdentifier	 Dynamic Endpoint Snitch
)	TokenNameRPAREN	
oldSnitch	TokenNameIdentifier	 old Snitch
)	TokenNameRPAREN	
.	TokenNameDOT	
unregisterMBean	TokenNameIdentifier	 unregister M Bean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Flushes the two largest memtables by ops and by throughput */	TokenNameCOMMENT_JAVADOC	 Flushes the two largest memtables by ops and by throughput 
public	TokenNamepublic	
void	TokenNamevoid	
flushLargestMemtables	TokenNameIdentifier	 flush Largest Memtables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
largest	TokenNameIdentifier	 largest
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
:	TokenNameCOLON	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
.	TokenNameDOT	
all	TokenNameIdentifier	 all
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
total	TokenNameIdentifier	 total
=	TokenNameEQUAL	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
getTotalMemtableLiveSize	TokenNameIdentifier	 get Total Memtable Live Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
total	TokenNameIdentifier	 total
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
largest	TokenNameIdentifier	 largest
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
total	TokenNameIdentifier	 total
>	TokenNameGREATER	
largest	TokenNameIdentifier	 largest
.	TokenNameDOT	
getTotalMemtableLiveSize	TokenNameIdentifier	 get Total Memtable Live Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
total	TokenNameIdentifier	 total
+	TokenNamePLUS	
" estimated memtable size for "	TokenNameStringLiteral	 estimated memtable size for 
+	TokenNamePLUS	
cfs	TokenNameIdentifier	 cfs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
largest	TokenNameIdentifier	 largest
=	TokenNameEQUAL	
cfs	TokenNameIdentifier	 cfs
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
largest	TokenNameIdentifier	 largest
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Unable to reduce heap usage since there are no dirty column families"	TokenNameStringLiteral	Unable to reduce heap usage since there are no dirty column families
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
"Flushing "	TokenNameStringLiteral	Flushing 
+	TokenNamePLUS	
largest	TokenNameIdentifier	 largest
+	TokenNamePLUS	
" to relieve memory pressure"	TokenNameStringLiteral	 to relieve memory pressure
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
largest	TokenNameIdentifier	 largest
.	TokenNameDOT	
forceFlush	TokenNameIdentifier	 force Flush
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Seed data to the endpoints that will be responsible for it at the future * * @param rangesToStreamByTable tables and data ranges with endpoints included for each * @return latch to count down */	TokenNameCOMMENT_JAVADOC	 Seed data to the endpoints that will be responsible for it at the future * @param rangesToStreamByTable tables and data ranges with endpoints included for each @return latch to count down 
private	TokenNameprivate	
CountDownLatch	TokenNameIdentifier	 Count Down Latch
streamRanges	TokenNameIdentifier	 stream Ranges
(	TokenNameLPAREN	
final	TokenNamefinal	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
rangesToStreamByTable	TokenNameIdentifier	 ranges To Stream By Table
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// First, we build a list of ranges to stream to each host, per table 	TokenNameCOMMENT_LINE	First, we build a list of ranges to stream to each host, per table 
final	TokenNamefinal	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
>	TokenNameGREATER	
sessionsToStreamByTable	TokenNameIdentifier	 sessions To Stream By Table
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// The number of stream out sessions we need to start, to be built up as we build sessionsToStreamByTable 	TokenNameCOMMENT_LINE	The number of stream out sessions we need to start, to be built up as we build sessionsToStreamByTable 
int	TokenNameint	
sessionCount	TokenNameIdentifier	 session Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
rangesToStreamByTable	TokenNameIdentifier	 ranges To Stream By Table
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
rangesWithEndpoints	TokenNameIdentifier	 ranges With Endpoints
=	TokenNameEQUAL	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
rangesWithEndpoints	TokenNameIdentifier	 ranges With Endpoints
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
=	TokenNameEQUAL	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
rangesPerEndpoint	TokenNameIdentifier	 ranges Per Endpoint
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
final	TokenNamefinal	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
endPointEntry	TokenNameIdentifier	 end Point Entry
:	TokenNameCOLON	
rangesWithEndpoints	TokenNameIdentifier	 ranges With Endpoints
.	TokenNameDOT	
entries	TokenNameIdentifier	 entries
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
=	TokenNameEQUAL	
endPointEntry	TokenNameIdentifier	 end Point Entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
=	TokenNameEQUAL	
endPointEntry	TokenNameIdentifier	 end Point Entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
curRanges	TokenNameIdentifier	 cur Ranges
=	TokenNameEQUAL	
rangesPerEndpoint	TokenNameIdentifier	 ranges Per Endpoint
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curRanges	TokenNameIdentifier	 cur Ranges
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
curRanges	TokenNameIdentifier	 cur Ranges
=	TokenNameEQUAL	
new	TokenNamenew	
LinkedList	TokenNameIdentifier	 Linked List
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rangesPerEndpoint	TokenNameIdentifier	 ranges Per Endpoint
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
curRanges	TokenNameIdentifier	 cur Ranges
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
curRanges	TokenNameIdentifier	 cur Ranges
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
sessionCount	TokenNameIdentifier	 session Count
+=	TokenNamePLUS_EQUAL	
rangesPerEndpoint	TokenNameIdentifier	 ranges Per Endpoint
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionsToStreamByTable	TokenNameIdentifier	 sessions To Stream By Table
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
rangesPerEndpoint	TokenNameIdentifier	 ranges Per Endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
CountDownLatch	TokenNameIdentifier	 Count Down Latch
latch	TokenNameIdentifier	 latch
=	TokenNameEQUAL	
new	TokenNamenew	
CountDownLatch	TokenNameIdentifier	 Count Down Latch
(	TokenNameLPAREN	
sessionCount	TokenNameIdentifier	 session Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
>	TokenNameGREATER	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
sessionsToStreamByTable	TokenNameIdentifier	 sessions To Stream By Table
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
=	TokenNameEQUAL	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
rangesPerEndpoint	TokenNameIdentifier	 ranges Per Endpoint
=	TokenNameEQUAL	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
final	TokenNamefinal	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
rangesEntry	TokenNameIdentifier	 ranges Entry
:	TokenNameCOLON	
rangesPerEndpoint	TokenNameIdentifier	 ranges Per Endpoint
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
ranges	TokenNameIdentifier	 ranges
=	TokenNameEQUAL	
rangesEntry	TokenNameIdentifier	 ranges Entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
InetAddress	TokenNameIdentifier	 Inet Address
newEndpoint	TokenNameIdentifier	 new Endpoint
=	TokenNameEQUAL	
rangesEntry	TokenNameIdentifier	 ranges Entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
IStreamCallback	TokenNameIdentifier	 I Stream Callback
callback	TokenNameIdentifier	 callback
=	TokenNameEQUAL	
new	TokenNamenew	
IStreamCallback	TokenNameIdentifier	 I Stream Callback
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
onSuccess	TokenNameIdentifier	 on Success
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
latch	TokenNameIdentifier	 latch
.	TokenNameDOT	
countDown	TokenNameIdentifier	 count Down
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
onFailure	TokenNameIdentifier	 on Failure
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
"Streaming to "	TokenNameStringLiteral	Streaming to 
+	TokenNamePLUS	
newEndpoint	TokenNameIdentifier	 new Endpoint
+	TokenNamePLUS	
" failed"	TokenNameStringLiteral	 failed
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
onSuccess	TokenNameIdentifier	 on Success
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// calling onSuccess for latch countdown 	TokenNameCOMMENT_LINE	calling onSuccess for latch countdown 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
// TODO each call to transferRanges re-flushes, this is potentially a lot of waste 	TokenNameCOMMENT_LINE	TODO each call to transferRanges re-flushes, this is potentially a lot of waste 
StreamOut	TokenNameIdentifier	 Stream Out
.	TokenNameDOT	
transferRanges	TokenNameIdentifier	 transfer Ranges
(	TokenNameLPAREN	
newEndpoint	TokenNameIdentifier	 new Endpoint
,	TokenNameCOMMA	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ranges	TokenNameIdentifier	 ranges
,	TokenNameCOMMA	
callback	TokenNameIdentifier	 callback
,	TokenNameCOMMA	
OperationType	TokenNameIdentifier	 Operation Type
.	TokenNameDOT	
UNBOOTSTRAP	TokenNameIdentifier	 UNBOOTSTRAP
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
latch	TokenNameIdentifier	 latch
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Used to request ranges from endpoints in the ring (will block until all data is fetched and ready) * @param ranges ranges to fetch as map of the preferred address and range collection * @return latch to count down */	TokenNameCOMMENT_JAVADOC	 Used to request ranges from endpoints in the ring (will block until all data is fetched and ready) @param ranges ranges to fetch as map of the preferred address and range collection @return latch to count down 
private	TokenNameprivate	
CountDownLatch	TokenNameIdentifier	 Count Down Latch
requestRanges	TokenNameIdentifier	 request Ranges
(	TokenNameLPAREN	
final	TokenNamefinal	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
ranges	TokenNameIdentifier	 ranges
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
CountDownLatch	TokenNameIdentifier	 Count Down Latch
latch	TokenNameIdentifier	 latch
=	TokenNameEQUAL	
new	TokenNamenew	
CountDownLatch	TokenNameIdentifier	 Count Down Latch
(	TokenNameLPAREN	
ranges	TokenNameIdentifier	 ranges
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
ranges	TokenNameIdentifier	 ranges
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
endpointWithRanges	TokenNameIdentifier	 endpoint With Ranges
=	TokenNameEQUAL	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
endpointWithRanges	TokenNameIdentifier	 endpoint With Ranges
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
latch	TokenNameIdentifier	 latch
.	TokenNameDOT	
countDown	TokenNameIdentifier	 count Down
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
=	TokenNameEQUAL	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
pending	TokenNameIdentifier	 pending
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
(	TokenNameLPAREN	
endpointWithRanges	TokenNameIdentifier	 endpoint With Ranges
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Send messages to respective folks to stream data over to me 	TokenNameCOMMENT_LINE	Send messages to respective folks to stream data over to me 
for	TokenNamefor	
(	TokenNameLPAREN	
final	TokenNamefinal	
InetAddress	TokenNameIdentifier	 Inet Address
source	TokenNameIdentifier	 source
:	TokenNameCOLON	
endpointWithRanges	TokenNameIdentifier	 endpoint With Ranges
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
toFetch	TokenNameIdentifier	 to Fetch
=	TokenNameEQUAL	
endpointWithRanges	TokenNameIdentifier	 endpoint With Ranges
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
source	TokenNameIdentifier	 source
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
IStreamCallback	TokenNameIdentifier	 I Stream Callback
callback	TokenNameIdentifier	 callback
=	TokenNameEQUAL	
new	TokenNamenew	
IStreamCallback	TokenNameIdentifier	 I Stream Callback
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
onSuccess	TokenNameIdentifier	 on Success
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pending	TokenNameIdentifier	 pending
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
source	TokenNameIdentifier	 source
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
pending	TokenNameIdentifier	 pending
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
latch	TokenNameIdentifier	 latch
.	TokenNameDOT	
countDown	TokenNameIdentifier	 count Down
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
onFailure	TokenNameIdentifier	 on Failure
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
"Streaming from "	TokenNameStringLiteral	Streaming from 
+	TokenNamePLUS	
source	TokenNameIdentifier	 source
+	TokenNamePLUS	
" failed"	TokenNameStringLiteral	 failed
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
onSuccess	TokenNameIdentifier	 on Success
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// calling onSuccess for latch countdown 	TokenNameCOMMENT_LINE	calling onSuccess for latch countdown 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Requesting from "	TokenNameStringLiteral	Requesting from 
+	TokenNamePLUS	
source	TokenNameIdentifier	 source
+	TokenNamePLUS	
" ranges "	TokenNameStringLiteral	 ranges 
+	TokenNamePLUS	
StringUtils	TokenNameIdentifier	 String Utils
.	TokenNameDOT	
join	TokenNameIdentifier	 join
(	TokenNameLPAREN	
toFetch	TokenNameIdentifier	 to Fetch
,	TokenNameCOMMA	
", "	TokenNameStringLiteral	, 
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// sending actual request 	TokenNameCOMMENT_LINE	sending actual request 
StreamIn	TokenNameIdentifier	 Stream In
.	TokenNameDOT	
requestRanges	TokenNameIdentifier	 request Ranges
(	TokenNameLPAREN	
source	TokenNameIdentifier	 source
,	TokenNameCOMMA	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
toFetch	TokenNameIdentifier	 to Fetch
,	TokenNameCOMMA	
callback	TokenNameIdentifier	 callback
,	TokenNameCOMMA	
OperationType	TokenNameIdentifier	 Operation Type
.	TokenNameDOT	
BOOTSTRAP	TokenNameIdentifier	 BOOTSTRAP
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
latch	TokenNameIdentifier	 latch
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Calculate pair of ranges to stream/fetch for given two range collections * (current ranges for table and ranges after move to new token) * * @param current collection of the ranges by current token * @param updated collection of the ranges after token is changed * @return pair of ranges to stream/fetch for given current and updated range collections */	TokenNameCOMMENT_JAVADOC	 Calculate pair of ranges to stream/fetch for given two range collections (current ranges for table and ranges after move to new token) * @param current collection of the ranges by current token @param updated collection of the ranges after token is changed @return pair of ranges to stream/fetch for given current and updated range collections 
public	TokenNamepublic	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
,	TokenNameCOMMA	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
calculateStreamAndFetchRanges	TokenNameIdentifier	 calculate Stream And Fetch Ranges
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
current	TokenNameIdentifier	 current
,	TokenNameCOMMA	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
updated	TokenNameIdentifier	 updated
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
toStream	TokenNameIdentifier	 to Stream
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
toFetch	TokenNameIdentifier	 to Fetch
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Range	TokenNameIdentifier	 Range
r1	TokenNameIdentifier	 r1
:	TokenNameCOLON	
current	TokenNameIdentifier	 current
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
intersect	TokenNameIdentifier	 intersect
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Range	TokenNameIdentifier	 Range
r2	TokenNameIdentifier	 r2
:	TokenNameCOLON	
updated	TokenNameIdentifier	 updated
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
r1	TokenNameIdentifier	 r1
.	TokenNameDOT	
intersects	TokenNameIdentifier	 intersects
(	TokenNameLPAREN	
r2	TokenNameIdentifier	 r2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// adding difference ranges to fetch from a ring 	TokenNameCOMMENT_LINE	adding difference ranges to fetch from a ring 
toStream	TokenNameIdentifier	 to Stream
.	TokenNameDOT	
addAll	TokenNameIdentifier	 add All
(	TokenNameLPAREN	
r1	TokenNameIdentifier	 r1
.	TokenNameDOT	
subtract	TokenNameIdentifier	 subtract
(	TokenNameLPAREN	
r2	TokenNameIdentifier	 r2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
intersect	TokenNameIdentifier	 intersect
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
intersect	TokenNameIdentifier	 intersect
)	TokenNameRPAREN	
{	TokenNameLBRACE	
toStream	TokenNameIdentifier	 to Stream
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
r1	TokenNameIdentifier	 r1
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// should seed whole old range 	TokenNameCOMMENT_LINE	should seed whole old range 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Range	TokenNameIdentifier	 Range
r2	TokenNameIdentifier	 r2
:	TokenNameCOLON	
updated	TokenNameIdentifier	 updated
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
intersect	TokenNameIdentifier	 intersect
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Range	TokenNameIdentifier	 Range
r1	TokenNameIdentifier	 r1
:	TokenNameCOLON	
current	TokenNameIdentifier	 current
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
r2	TokenNameIdentifier	 r2
.	TokenNameDOT	
intersects	TokenNameIdentifier	 intersects
(	TokenNameLPAREN	
r1	TokenNameIdentifier	 r1
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// adding difference ranges to fetch from a ring 	TokenNameCOMMENT_LINE	adding difference ranges to fetch from a ring 
toFetch	TokenNameIdentifier	 to Fetch
.	TokenNameDOT	
addAll	TokenNameIdentifier	 add All
(	TokenNameLPAREN	
r2	TokenNameIdentifier	 r2
.	TokenNameDOT	
subtract	TokenNameIdentifier	 subtract
(	TokenNameLPAREN	
r1	TokenNameIdentifier	 r1
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
intersect	TokenNameIdentifier	 intersect
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
intersect	TokenNameIdentifier	 intersect
)	TokenNameRPAREN	
{	TokenNameLBRACE	
toFetch	TokenNameIdentifier	 to Fetch
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
r2	TokenNameIdentifier	 r2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// should fetch whole old range 	TokenNameCOMMENT_LINE	should fetch whole old range 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
Pair	TokenNameIdentifier	 Pair
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
toStream	TokenNameIdentifier	 to Stream
,	TokenNameCOMMA	
toFetch	TokenNameIdentifier	 to Fetch
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
bulkLoad	TokenNameIdentifier	 bulk Load
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
directory	TokenNameIdentifier	 directory
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
directory	TokenNameIdentifier	 directory
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
isDirectory	TokenNameIdentifier	 is Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"Invalid directory "	TokenNameStringLiteral	Invalid directory 
+	TokenNamePLUS	
directory	TokenNameIdentifier	 directory
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SSTableLoader	TokenNameIdentifier	 SS Table Loader
.	TokenNameDOT	
Client	TokenNameIdentifier	 Client
client	TokenNameIdentifier	 client
=	TokenNameEQUAL	
new	TokenNamenew	
SSTableLoader	TokenNameIdentifier	 SS Table Loader
.	TokenNameDOT	
Client	TokenNameIdentifier	 Client
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
init	TokenNameIdentifier	 init
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
setPartitioner	TokenNameIdentifier	 set Partitioner
(	TokenNameLPAREN	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getRangeToAddressMap	TokenNameIdentifier	 get Range To Address Map
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
=	TokenNameEQUAL	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
:	TokenNameCOLON	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
addRangeForEndpoint	TokenNameIdentifier	 add Range For Endpoint
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
boolean	TokenNameboolean	
validateColumnFamily	TokenNameIdentifier	 validate Column Family
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
cfName	TokenNameIdentifier	 cf Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getCFMetaData	TokenNameIdentifier	 get CF Meta Data
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
cfName	TokenNameIdentifier	 cf Name
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
SSTableLoader	TokenNameIdentifier	 SS Table Loader
loader	TokenNameIdentifier	 loader
=	TokenNameEQUAL	
new	TokenNamenew	
SSTableLoader	TokenNameIdentifier	 SS Table Loader
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
client	TokenNameIdentifier	 client
,	TokenNameCOMMA	
new	TokenNamenew	
OutputHandler	TokenNameIdentifier	 Output Handler
.	TokenNameDOT	
LogOutput	TokenNameIdentifier	 Log Output
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
loader	TokenNameIdentifier	 loader
.	TokenNameDOT	
stream	TokenNameIdentifier	 stream
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getExceptionCount	TokenNameIdentifier	 get Exception Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
CassandraDaemon	TokenNameIdentifier	 Cassandra Daemon
.	TokenNameDOT	
exceptions	TokenNameIdentifier	 exceptions
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
rescheduleFailedDeletions	TokenNameIdentifier	 reschedule Failed Deletions
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SSTableDeletingTask	TokenNameIdentifier	 SS Table Deleting Task
.	TokenNameDOT	
rescheduleFailedTasks	TokenNameIdentifier	 reschedule Failed Tasks
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * #{@inheritDoc} */	TokenNameCOMMENT_JAVADOC	 #{@inheritDoc} 
public	TokenNamepublic	
void	TokenNamevoid	
loadNewSSTables	TokenNameIdentifier	 load New SS Tables
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
ksName	TokenNameIdentifier	 ks Name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
cfName	TokenNameIdentifier	 cf Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
.	TokenNameDOT	
loadNewSSTables	TokenNameIdentifier	 load New SS Tables
(	TokenNameLPAREN	
ksName	TokenNameIdentifier	 ks Name
,	TokenNameCOMMA	
cfName	TokenNameIdentifier	 cf Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * #{@inheritDoc} */	TokenNameCOMMENT_JAVADOC	 #{@inheritDoc} 
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
sampleKeyRange	TokenNameIdentifier	 sample Key Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
// do not rename to getter - see CASSANDRA-4452 for details 	TokenNameCOMMENT_LINE	do not rename to getter - see CASSANDRA-4452 for details 
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
DecoratedKey	TokenNameIdentifier	 Decorated Key
>	TokenNameGREATER	
keys	TokenNameIdentifier	 keys
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
DecoratedKey	TokenNameIdentifier	 Decorated Key
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
:	TokenNameCOLON	
getLocalPrimaryRanges	TokenNameIdentifier	 get Local Primary Ranges
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
keys	TokenNameIdentifier	 keys
.	TokenNameDOT	
addAll	TokenNameIdentifier	 add All
(	TokenNameLPAREN	
keySamples	TokenNameIdentifier	 key Samples
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
.	TokenNameDOT	
allUserDefined	TokenNameIdentifier	 all User Defined
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
range	TokenNameIdentifier	 range
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
sampledKeys	TokenNameIdentifier	 sampled Keys
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
keys	TokenNameIdentifier	 keys
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
DecoratedKey	TokenNameIdentifier	 Decorated Key
key	TokenNameIdentifier	 key
:	TokenNameCOLON	
keys	TokenNameIdentifier	 keys
)	TokenNameRPAREN	
sampledKeys	TokenNameIdentifier	 sampled Keys
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
getToken	TokenNameIdentifier	 get Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
sampledKeys	TokenNameIdentifier	 sampled Keys
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
rebuildSecondaryIndex	TokenNameIdentifier	 rebuild Secondary Index
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
ksName	TokenNameIdentifier	 ks Name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
cfName	TokenNameIdentifier	 cf Name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
...	TokenNameELLIPSIS	
idxNames	TokenNameIdentifier	 idx Names
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
.	TokenNameDOT	
rebuildSecondaryIndex	TokenNameIdentifier	 rebuild Secondary Index
(	TokenNameLPAREN	
ksName	TokenNameIdentifier	 ks Name
,	TokenNameCOMMA	
cfName	TokenNameIdentifier	 cf Name
,	TokenNameCOMMA	
idxNames	TokenNameIdentifier	 idx Names
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
resetLocalSchema	TokenNameIdentifier	 reset Local Schema
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
MigrationManager	TokenNameIdentifier	 Migration Manager
.	TokenNameDOT	
resetLocalSchema	TokenNameIdentifier	 reset Local Schema
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setTraceProbability	TokenNameIdentifier	 set Trace Probability
(	TokenNameLPAREN	
double	TokenNamedouble	
probability	TokenNameIdentifier	 probability
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
tracingProbability	TokenNameIdentifier	 tracing Probability
=	TokenNameEQUAL	
probability	TokenNameIdentifier	 probability
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
double	TokenNamedouble	
getTracingProbability	TokenNameIdentifier	 get Tracing Probability
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
tracingProbability	TokenNameIdentifier	 tracing Probability
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
enableScheduledRangeXfers	TokenNameIdentifier	 enable Scheduled Range Xfers
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
rangeXferExecutor	TokenNameIdentifier	 range Xfer Executor
.	TokenNameDOT	
setup	TokenNameIdentifier	 setup
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
disableScheduledRangeXfers	TokenNameIdentifier	 disable Scheduled Range Xfers
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
rangeXferExecutor	TokenNameIdentifier	 range Xfer Executor
.	TokenNameDOT	
tearDown	TokenNameIdentifier	 tear Down
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
