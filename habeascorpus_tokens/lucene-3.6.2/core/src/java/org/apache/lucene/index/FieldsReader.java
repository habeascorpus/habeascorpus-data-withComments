package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
;	TokenNameSEMICOLON	
/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_JAVADOC	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
Closeable	TokenNameIdentifier	 Closeable
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
Reader	TokenNameIdentifier	 Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
zip	TokenNameIdentifier	 zip
.	TokenNameDOT	
DataFormatException	TokenNameIdentifier	 Data Format Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
TokenStream	TokenNameIdentifier	 Token Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
document	TokenNameIdentifier	 document
.	TokenNameDOT	
AbstractField	TokenNameIdentifier	 Abstract Field
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
document	TokenNameIdentifier	 document
.	TokenNameDOT	
CompressionTools	TokenNameIdentifier	 Compression Tools
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
document	TokenNameIdentifier	 document
.	TokenNameDOT	
Document	TokenNameIdentifier	 Document
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
document	TokenNameIdentifier	 document
.	TokenNameDOT	
Field	TokenNameIdentifier	 Field
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
document	TokenNameIdentifier	 document
.	TokenNameDOT	
FieldSelector	TokenNameIdentifier	 Field Selector
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
document	TokenNameIdentifier	 document
.	TokenNameDOT	
FieldSelectorResult	TokenNameIdentifier	 Field Selector Result
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
document	TokenNameIdentifier	 document
.	TokenNameDOT	
Fieldable	TokenNameIdentifier	 Fieldable
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
document	TokenNameIdentifier	 document
.	TokenNameDOT	
NumericField	TokenNameIdentifier	 Numeric Field
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
AlreadyClosedException	TokenNameIdentifier	 Already Closed Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
BufferedIndexInput	TokenNameIdentifier	 Buffered Index Input
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
Directory	TokenNameIdentifier	 Directory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
IndexInput	TokenNameIdentifier	 Index Input
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
CloseableThreadLocal	TokenNameIdentifier	 Closeable Thread Local
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
IOUtils	TokenNameIdentifier	 IO Utils
;	TokenNameSEMICOLON	
/** * Class responsible for access to stored document fields. * <p/> * It uses &lt;segment&gt;.fdt and &lt;segment&gt;.fdx; files. */	TokenNameCOMMENT_JAVADOC	 Class responsible for access to stored document fields. <p/> It uses &lt;segment&gt;.fdt and &lt;segment&gt;.fdx; files. 
final	TokenNamefinal	
class	TokenNameclass	
FieldsReader	TokenNameIdentifier	 Fields Reader
implements	TokenNameimplements	
Cloneable	TokenNameIdentifier	 Cloneable
,	TokenNameCOMMA	
Closeable	TokenNameIdentifier	 Closeable
{	TokenNameLBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
FieldInfos	TokenNameIdentifier	 Field Infos
fieldInfos	TokenNameIdentifier	 field Infos
;	TokenNameSEMICOLON	
// The main fieldStream, used only for cloning. 	TokenNameCOMMENT_LINE	The main fieldStream, used only for cloning. 
private	TokenNameprivate	
final	TokenNamefinal	
IndexInput	TokenNameIdentifier	 Index Input
cloneableFieldsStream	TokenNameIdentifier	 cloneable Fields Stream
;	TokenNameSEMICOLON	
// This is a clone of cloneableFieldsStream used for reading documents. 	TokenNameCOMMENT_LINE	This is a clone of cloneableFieldsStream used for reading documents. 
// It should not be cloned outside of a synchronized context. 	TokenNameCOMMENT_LINE	It should not be cloned outside of a synchronized context. 
private	TokenNameprivate	
final	TokenNamefinal	
IndexInput	TokenNameIdentifier	 Index Input
fieldsStream	TokenNameIdentifier	 fields Stream
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
IndexInput	TokenNameIdentifier	 Index Input
cloneableIndexStream	TokenNameIdentifier	 cloneable Index Stream
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
IndexInput	TokenNameIdentifier	 Index Input
indexStream	TokenNameIdentifier	 index Stream
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
numTotalDocs	TokenNameIdentifier	 num Total Docs
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
closed	TokenNameIdentifier	 closed
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
format	TokenNameIdentifier	 format
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
formatSize	TokenNameIdentifier	 format Size
;	TokenNameSEMICOLON	
// The docID offset where our docs begin in the index 	TokenNameCOMMENT_LINE	The docID offset where our docs begin in the index 
// file. This will be 0 if we have our own private file. 	TokenNameCOMMENT_LINE	file. This will be 0 if we have our own private file. 
private	TokenNameprivate	
int	TokenNameint	
docStoreOffset	TokenNameIdentifier	 doc Store Offset
;	TokenNameSEMICOLON	
private	TokenNameprivate	
CloseableThreadLocal	TokenNameIdentifier	 Closeable Thread Local
<	TokenNameLESS	
IndexInput	TokenNameIdentifier	 Index Input
>	TokenNameGREATER	
fieldsStreamTL	TokenNameIdentifier	 fields Stream TL
=	TokenNameEQUAL	
new	TokenNamenew	
CloseableThreadLocal	TokenNameIdentifier	 Closeable Thread Local
<	TokenNameLESS	
IndexInput	TokenNameIdentifier	 Index Input
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
isOriginal	TokenNameIdentifier	 is Original
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** Returns a cloned FieldsReader that shares open * IndexInputs with the original one. It is the caller's * job not to close the original FieldsReader until all * clones are called (eg, currently SegmentReader manages * this logic). */	TokenNameCOMMENT_JAVADOC	 Returns a cloned FieldsReader that shares open IndexInputs with the original one. It is the caller's job not to close the original FieldsReader until all clones are called (eg, currently SegmentReader manages this logic). 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
Object	TokenNameIdentifier	 Object
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ensureOpen	TokenNameIdentifier	 ensure Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
FieldsReader	TokenNameIdentifier	 Fields Reader
(	TokenNameLPAREN	
fieldInfos	TokenNameIdentifier	 field Infos
,	TokenNameCOMMA	
numTotalDocs	TokenNameIdentifier	 num Total Docs
,	TokenNameCOMMA	
size	TokenNameIdentifier	 size
,	TokenNameCOMMA	
format	TokenNameIdentifier	 format
,	TokenNameCOMMA	
formatSize	TokenNameIdentifier	 format Size
,	TokenNameCOMMA	
docStoreOffset	TokenNameIdentifier	 doc Store Offset
,	TokenNameCOMMA	
cloneableFieldsStream	TokenNameIdentifier	 cloneable Fields Stream
,	TokenNameCOMMA	
cloneableIndexStream	TokenNameIdentifier	 cloneable Index Stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Detects the code version this segment was written with. Returns either * "2.x" for all pre-3.0 segments, or "3.0" for 3.0 segments. This method * should not be called for 3.1+ segments since they already record their code * version. */	TokenNameCOMMENT_JAVADOC	 Detects the code version this segment was written with. Returns either "2.x" for all pre-3.0 segments, or "3.0" for 3.0 segments. This method should not be called for 3.1+ segments since they already record their code version. 
static	TokenNamestatic	
String	TokenNameIdentifier	 String
detectCodeVersion	TokenNameIdentifier	 detect Code Version
(	TokenNameLPAREN	
Directory	TokenNameIdentifier	 Directory
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
segment	TokenNameIdentifier	 segment
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
IndexInput	TokenNameIdentifier	 Index Input
idxStream	TokenNameIdentifier	 idx Stream
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
openInput	TokenNameIdentifier	 open Input
(	TokenNameLPAREN	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
segmentFileName	TokenNameIdentifier	 segment File Name
(	TokenNameLPAREN	
segment	TokenNameIdentifier	 segment
,	TokenNameCOMMA	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
FIELDS_INDEX_EXTENSION	TokenNameIdentifier	 FIELDS  INDEX  EXTENSION
)	TokenNameRPAREN	
,	TokenNameCOMMA	
1024	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
int	TokenNameint	
format	TokenNameIdentifier	 format
=	TokenNameEQUAL	
idxStream	TokenNameIdentifier	 idx Stream
.	TokenNameDOT	
readInt	TokenNameIdentifier	 read Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
format	TokenNameIdentifier	 format
<	TokenNameLESS	
FieldsWriter	TokenNameIdentifier	 Fields Writer
.	TokenNameDOT	
FORMAT_LUCENE_3_0_NO_COMPRESSED_FIELDS	TokenNameIdentifier	 FORMAT  LUCENE 3 0  NO  COMPRESSED  FIELDS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
"2.x"	TokenNameStringLiteral	2.x
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
"3.0"	TokenNameStringLiteral	3.0
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
idxStream	TokenNameIdentifier	 idx Stream
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Used only by clone 	TokenNameCOMMENT_LINE	Used only by clone 
private	TokenNameprivate	
FieldsReader	TokenNameIdentifier	 Fields Reader
(	TokenNameLPAREN	
FieldInfos	TokenNameIdentifier	 Field Infos
fieldInfos	TokenNameIdentifier	 field Infos
,	TokenNameCOMMA	
int	TokenNameint	
numTotalDocs	TokenNameIdentifier	 num Total Docs
,	TokenNameCOMMA	
int	TokenNameint	
size	TokenNameIdentifier	 size
,	TokenNameCOMMA	
int	TokenNameint	
format	TokenNameIdentifier	 format
,	TokenNameCOMMA	
int	TokenNameint	
formatSize	TokenNameIdentifier	 format Size
,	TokenNameCOMMA	
int	TokenNameint	
docStoreOffset	TokenNameIdentifier	 doc Store Offset
,	TokenNameCOMMA	
IndexInput	TokenNameIdentifier	 Index Input
cloneableFieldsStream	TokenNameIdentifier	 cloneable Fields Stream
,	TokenNameCOMMA	
IndexInput	TokenNameIdentifier	 Index Input
cloneableIndexStream	TokenNameIdentifier	 cloneable Index Stream
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fieldInfos	TokenNameIdentifier	 field Infos
=	TokenNameEQUAL	
fieldInfos	TokenNameIdentifier	 field Infos
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
numTotalDocs	TokenNameIdentifier	 num Total Docs
=	TokenNameEQUAL	
numTotalDocs	TokenNameIdentifier	 num Total Docs
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
format	TokenNameIdentifier	 format
=	TokenNameEQUAL	
format	TokenNameIdentifier	 format
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
formatSize	TokenNameIdentifier	 format Size
=	TokenNameEQUAL	
formatSize	TokenNameIdentifier	 format Size
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
docStoreOffset	TokenNameIdentifier	 doc Store Offset
=	TokenNameEQUAL	
docStoreOffset	TokenNameIdentifier	 doc Store Offset
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
cloneableFieldsStream	TokenNameIdentifier	 cloneable Fields Stream
=	TokenNameEQUAL	
cloneableFieldsStream	TokenNameIdentifier	 cloneable Fields Stream
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
cloneableIndexStream	TokenNameIdentifier	 cloneable Index Stream
=	TokenNameEQUAL	
cloneableIndexStream	TokenNameIdentifier	 cloneable Index Stream
;	TokenNameSEMICOLON	
fieldsStream	TokenNameIdentifier	 fields Stream
=	TokenNameEQUAL	
(	TokenNameLPAREN	
IndexInput	TokenNameIdentifier	 Index Input
)	TokenNameRPAREN	
cloneableFieldsStream	TokenNameIdentifier	 cloneable Fields Stream
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
indexStream	TokenNameIdentifier	 index Stream
=	TokenNameEQUAL	
(	TokenNameLPAREN	
IndexInput	TokenNameIdentifier	 Index Input
)	TokenNameRPAREN	
cloneableIndexStream	TokenNameIdentifier	 cloneable Index Stream
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
FieldsReader	TokenNameIdentifier	 Fields Reader
(	TokenNameLPAREN	
Directory	TokenNameIdentifier	 Directory
d	TokenNameIdentifier	 d
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
segment	TokenNameIdentifier	 segment
,	TokenNameCOMMA	
FieldInfos	TokenNameIdentifier	 Field Infos
fn	TokenNameIdentifier	 fn
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
this	TokenNamethis	
(	TokenNameLPAREN	
d	TokenNameIdentifier	 d
,	TokenNameCOMMA	
segment	TokenNameIdentifier	 segment
,	TokenNameCOMMA	
fn	TokenNameIdentifier	 fn
,	TokenNameCOMMA	
BufferedIndexInput	TokenNameIdentifier	 Buffered Index Input
.	TokenNameDOT	
BUFFER_SIZE	TokenNameIdentifier	 BUFFER  SIZE
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
FieldsReader	TokenNameIdentifier	 Fields Reader
(	TokenNameLPAREN	
Directory	TokenNameIdentifier	 Directory
d	TokenNameIdentifier	 d
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
segment	TokenNameIdentifier	 segment
,	TokenNameCOMMA	
FieldInfos	TokenNameIdentifier	 Field Infos
fn	TokenNameIdentifier	 fn
,	TokenNameCOMMA	
int	TokenNameint	
readBufferSize	TokenNameIdentifier	 read Buffer Size
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
this	TokenNamethis	
(	TokenNameLPAREN	
d	TokenNameIdentifier	 d
,	TokenNameCOMMA	
segment	TokenNameIdentifier	 segment
,	TokenNameCOMMA	
fn	TokenNameIdentifier	 fn
,	TokenNameCOMMA	
readBufferSize	TokenNameIdentifier	 read Buffer Size
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
FieldsReader	TokenNameIdentifier	 Fields Reader
(	TokenNameLPAREN	
Directory	TokenNameIdentifier	 Directory
d	TokenNameIdentifier	 d
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
segment	TokenNameIdentifier	 segment
,	TokenNameCOMMA	
FieldInfos	TokenNameIdentifier	 Field Infos
fn	TokenNameIdentifier	 fn
,	TokenNameCOMMA	
int	TokenNameint	
readBufferSize	TokenNameIdentifier	 read Buffer Size
,	TokenNameCOMMA	
int	TokenNameint	
docStoreOffset	TokenNameIdentifier	 doc Store Offset
,	TokenNameCOMMA	
int	TokenNameint	
size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
boolean	TokenNameboolean	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
isOriginal	TokenNameIdentifier	 is Original
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
fieldInfos	TokenNameIdentifier	 field Infos
=	TokenNameEQUAL	
fn	TokenNameIdentifier	 fn
;	TokenNameSEMICOLON	
cloneableFieldsStream	TokenNameIdentifier	 cloneable Fields Stream
=	TokenNameEQUAL	
d	TokenNameIdentifier	 d
.	TokenNameDOT	
openInput	TokenNameIdentifier	 open Input
(	TokenNameLPAREN	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
segmentFileName	TokenNameIdentifier	 segment File Name
(	TokenNameLPAREN	
segment	TokenNameIdentifier	 segment
,	TokenNameCOMMA	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
FIELDS_EXTENSION	TokenNameIdentifier	 FIELDS  EXTENSION
)	TokenNameRPAREN	
,	TokenNameCOMMA	
readBufferSize	TokenNameIdentifier	 read Buffer Size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
indexStreamFN	TokenNameIdentifier	 index Stream FN
=	TokenNameEQUAL	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
segmentFileName	TokenNameIdentifier	 segment File Name
(	TokenNameLPAREN	
segment	TokenNameIdentifier	 segment
,	TokenNameCOMMA	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
FIELDS_INDEX_EXTENSION	TokenNameIdentifier	 FIELDS  INDEX  EXTENSION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cloneableIndexStream	TokenNameIdentifier	 cloneable Index Stream
=	TokenNameEQUAL	
d	TokenNameIdentifier	 d
.	TokenNameDOT	
openInput	TokenNameIdentifier	 open Input
(	TokenNameLPAREN	
indexStreamFN	TokenNameIdentifier	 index Stream FN
,	TokenNameCOMMA	
readBufferSize	TokenNameIdentifier	 read Buffer Size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// First version of fdx did not include a format 	TokenNameCOMMENT_LINE	First version of fdx did not include a format 
// header, but, the first int will always be 0 in that 	TokenNameCOMMENT_LINE	header, but, the first int will always be 0 in that 
// case 	TokenNameCOMMENT_LINE	case 
int	TokenNameint	
firstInt	TokenNameIdentifier	 first Int
=	TokenNameEQUAL	
cloneableIndexStream	TokenNameIdentifier	 cloneable Index Stream
.	TokenNameDOT	
readInt	TokenNameIdentifier	 read Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
firstInt	TokenNameIdentifier	 first Int
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
format	TokenNameIdentifier	 format
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
else	TokenNameelse	
format	TokenNameIdentifier	 format
=	TokenNameEQUAL	
firstInt	TokenNameIdentifier	 first Int
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
format	TokenNameIdentifier	 format
>	TokenNameGREATER	
FieldsWriter	TokenNameIdentifier	 Fields Writer
.	TokenNameDOT	
FORMAT_CURRENT	TokenNameIdentifier	 FORMAT  CURRENT
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IndexFormatTooNewException	TokenNameIdentifier	 Index Format Too New Exception
(	TokenNameLPAREN	
cloneableIndexStream	TokenNameIdentifier	 cloneable Index Stream
,	TokenNameCOMMA	
format	TokenNameIdentifier	 format
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
FieldsWriter	TokenNameIdentifier	 Fields Writer
.	TokenNameDOT	
FORMAT_CURRENT	TokenNameIdentifier	 FORMAT  CURRENT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
format	TokenNameIdentifier	 format
>	TokenNameGREATER	
FieldsWriter	TokenNameIdentifier	 Fields Writer
.	TokenNameDOT	
FORMAT	TokenNameIdentifier	 FORMAT
)	TokenNameRPAREN	
formatSize	TokenNameIdentifier	 format Size
=	TokenNameEQUAL	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
else	TokenNameelse	
formatSize	TokenNameIdentifier	 format Size
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
format	TokenNameIdentifier	 format
<	TokenNameLESS	
FieldsWriter	TokenNameIdentifier	 Fields Writer
.	TokenNameDOT	
FORMAT_VERSION_UTF8_LENGTH_IN_BYTES	TokenNameIdentifier	 FORMAT  VERSION  UT F8  LENGTH  IN  BYTES
)	TokenNameRPAREN	
cloneableFieldsStream	TokenNameIdentifier	 cloneable Fields Stream
.	TokenNameDOT	
setModifiedUTF8StringsMode	TokenNameIdentifier	 set Modified UT F8 Strings Mode
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fieldsStream	TokenNameIdentifier	 fields Stream
=	TokenNameEQUAL	
(	TokenNameLPAREN	
IndexInput	TokenNameIdentifier	 Index Input
)	TokenNameRPAREN	
cloneableFieldsStream	TokenNameIdentifier	 cloneable Fields Stream
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
long	TokenNamelong	
indexSize	TokenNameIdentifier	 index Size
=	TokenNameEQUAL	
cloneableIndexStream	TokenNameIdentifier	 cloneable Index Stream
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
formatSize	TokenNameIdentifier	 format Size
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
docStoreOffset	TokenNameIdentifier	 doc Store Offset
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// We read only a slice out of this shared fields file 	TokenNameCOMMENT_LINE	We read only a slice out of this shared fields file 
this	TokenNamethis	
.	TokenNameDOT	
docStoreOffset	TokenNameIdentifier	 doc Store Offset
=	TokenNameEQUAL	
docStoreOffset	TokenNameIdentifier	 doc Store Offset
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
// Verify the file is long enough to hold all of our 	TokenNameCOMMENT_LINE	Verify the file is long enough to hold all of our 
// docs 	TokenNameCOMMENT_LINE	docs 
assert	TokenNameassert	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
indexSize	TokenNameIdentifier	 index Size
/	TokenNameDIVIDE	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
>=	TokenNameGREATER_EQUAL	
size	TokenNameIdentifier	 size
+	TokenNamePLUS	
this	TokenNamethis	
.	TokenNameDOT	
docStoreOffset	TokenNameIdentifier	 doc Store Offset
:	TokenNameCOLON	
"indexSize="	TokenNameStringLiteral	indexSize=
+	TokenNamePLUS	
indexSize	TokenNameIdentifier	 index Size
+	TokenNamePLUS	
" size="	TokenNameStringLiteral	 size=
+	TokenNamePLUS	
size	TokenNameIdentifier	 size
+	TokenNamePLUS	
" docStoreOffset="	TokenNameStringLiteral	 docStoreOffset=
+	TokenNamePLUS	
docStoreOffset	TokenNameIdentifier	 doc Store Offset
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
docStoreOffset	TokenNameIdentifier	 doc Store Offset
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
indexSize	TokenNameIdentifier	 index Size
>>	TokenNameRIGHT_SHIFT	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
indexStream	TokenNameIdentifier	 index Stream
=	TokenNameEQUAL	
(	TokenNameLPAREN	
IndexInput	TokenNameIdentifier	 Index Input
)	TokenNameRPAREN	
cloneableIndexStream	TokenNameIdentifier	 cloneable Index Stream
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
numTotalDocs	TokenNameIdentifier	 num Total Docs
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
indexSize	TokenNameIdentifier	 index Size
>>	TokenNameRIGHT_SHIFT	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
// With lock-less commits, it's entirely possible (and 	TokenNameCOMMENT_LINE	With lock-less commits, it's entirely possible (and 
// fine) to hit a FileNotFound exception above. In 	TokenNameCOMMENT_LINE	fine) to hit a FileNotFound exception above. In 
// this case, we want to explicitly close any subset 	TokenNameCOMMENT_LINE	this case, we want to explicitly close any subset 
// of things that were opened so that we don't have to 	TokenNameCOMMENT_LINE	of things that were opened so that we don't have to 
// wait for a GC to do so. 	TokenNameCOMMENT_LINE	wait for a GC to do so. 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
success	TokenNameIdentifier	 success
)	TokenNameRPAREN	
{	TokenNameLBRACE	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * @throws AlreadyClosedException if this FieldsReader is closed */	TokenNameCOMMENT_JAVADOC	 @throws AlreadyClosedException if this FieldsReader is closed 
private	TokenNameprivate	
void	TokenNamevoid	
ensureOpen	TokenNameIdentifier	 ensure Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
AlreadyClosedException	TokenNameIdentifier	 Already Closed Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
closed	TokenNameIdentifier	 closed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
AlreadyClosedException	TokenNameIdentifier	 Already Closed Exception
(	TokenNameLPAREN	
"this FieldsReader is closed"	TokenNameStringLiteral	this FieldsReader is closed
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Closes the underlying {@link org.apache.lucene.store.IndexInput} streams, including any ones associated with a * lazy implementation of a Field. This means that the Fields values will not be accessible. * * @throws IOException */	TokenNameCOMMENT_JAVADOC	 Closes the underlying {@link org.apache.lucene.store.IndexInput} streams, including any ones associated with a lazy implementation of a Field. This means that the Fields values will not be accessible. * @throws IOException 
public	TokenNamepublic	
final	TokenNamefinal	
void	TokenNamevoid	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
closed	TokenNameIdentifier	 closed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isOriginal	TokenNameIdentifier	 is Original
)	TokenNameRPAREN	
{	TokenNameLBRACE	
IOUtils	TokenNameIdentifier	 IO Utils
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
fieldsStream	TokenNameIdentifier	 fields Stream
,	TokenNameCOMMA	
indexStream	TokenNameIdentifier	 index Stream
,	TokenNameCOMMA	
fieldsStreamTL	TokenNameIdentifier	 fields Stream TL
,	TokenNameCOMMA	
cloneableFieldsStream	TokenNameIdentifier	 cloneable Fields Stream
,	TokenNameCOMMA	
cloneableIndexStream	TokenNameIdentifier	 cloneable Index Stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
IOUtils	TokenNameIdentifier	 IO Utils
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
fieldsStream	TokenNameIdentifier	 fields Stream
,	TokenNameCOMMA	
indexStream	TokenNameIdentifier	 index Stream
,	TokenNameCOMMA	
fieldsStreamTL	TokenNameIdentifier	 fields Stream TL
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
closed	TokenNameIdentifier	 closed
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
final	TokenNamefinal	
int	TokenNameint	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
void	TokenNamevoid	
seekIndex	TokenNameIdentifier	 seek Index
(	TokenNameLPAREN	
int	TokenNameint	
docID	TokenNameIdentifier	 doc ID
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
indexStream	TokenNameIdentifier	 index Stream
.	TokenNameDOT	
seek	TokenNameIdentifier	 seek
(	TokenNameLPAREN	
formatSize	TokenNameIdentifier	 format Size
+	TokenNamePLUS	
(	TokenNameLPAREN	
docID	TokenNameIdentifier	 doc ID
+	TokenNamePLUS	
docStoreOffset	TokenNameIdentifier	 doc Store Offset
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
8L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
boolean	TokenNameboolean	
canReadRawDocs	TokenNameIdentifier	 can Read Raw Docs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Disable reading raw docs in 2.x format, because of the removal of compressed 	TokenNameCOMMENT_LINE	Disable reading raw docs in 2.x format, because of the removal of compressed 
// fields in 3.0. We don't want rawDocs() to decode field bits to figure out 	TokenNameCOMMENT_LINE	fields in 3.0. We don't want rawDocs() to decode field bits to figure out 
// if a field was compressed, hence we enforce ordinary (non-raw) stored field merges 	TokenNameCOMMENT_LINE	if a field was compressed, hence we enforce ordinary (non-raw) stored field merges 
// for <3.0 indexes. 	TokenNameCOMMENT_LINE	for <3.0 indexes. 
return	TokenNamereturn	
format	TokenNameIdentifier	 format
>=	TokenNameGREATER_EQUAL	
FieldsWriter	TokenNameIdentifier	 Fields Writer
.	TokenNameDOT	
FORMAT_LUCENE_3_0_NO_COMPRESSED_FIELDS	TokenNameIdentifier	 FORMAT  LUCENE 3 0  NO  COMPRESSED  FIELDS
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
Document	TokenNameIdentifier	 Document
doc	TokenNameIdentifier	 doc
(	TokenNameLPAREN	
int	TokenNameint	
n	TokenNameIdentifier	 n
,	TokenNameCOMMA	
FieldSelector	TokenNameIdentifier	 Field Selector
fieldSelector	TokenNameIdentifier	 field Selector
)	TokenNameRPAREN	
throws	TokenNamethrows	
CorruptIndexException	TokenNameIdentifier	 Corrupt Index Exception
,	TokenNameCOMMA	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
seekIndex	TokenNameIdentifier	 seek Index
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
position	TokenNameIdentifier	 position
=	TokenNameEQUAL	
indexStream	TokenNameIdentifier	 index Stream
.	TokenNameDOT	
readLong	TokenNameIdentifier	 read Long
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fieldsStream	TokenNameIdentifier	 fields Stream
.	TokenNameDOT	
seek	TokenNameIdentifier	 seek
(	TokenNameLPAREN	
position	TokenNameIdentifier	 position
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Document	TokenNameIdentifier	 Document
doc	TokenNameIdentifier	 doc
=	TokenNameEQUAL	
new	TokenNamenew	
Document	TokenNameIdentifier	 Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
numFields	TokenNameIdentifier	 num Fields
=	TokenNameEQUAL	
fieldsStream	TokenNameIdentifier	 fields Stream
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
out	TokenNameIdentifier	 out
:	TokenNameCOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numFields	TokenNameIdentifier	 num Fields
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
fieldNumber	TokenNameIdentifier	 field Number
=	TokenNameEQUAL	
fieldsStream	TokenNameIdentifier	 fields Stream
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
FieldInfo	TokenNameIdentifier	 Field Info
fi	TokenNameIdentifier	 fi
=	TokenNameEQUAL	
fieldInfos	TokenNameIdentifier	 field Infos
.	TokenNameDOT	
fieldInfo	TokenNameIdentifier	 field Info
(	TokenNameLPAREN	
fieldNumber	TokenNameIdentifier	 field Number
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
FieldSelectorResult	TokenNameIdentifier	 Field Selector Result
acceptField	TokenNameIdentifier	 accept Field
=	TokenNameEQUAL	
fieldSelector	TokenNameIdentifier	 field Selector
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
FieldSelectorResult	TokenNameIdentifier	 Field Selector Result
.	TokenNameDOT	
LOAD	TokenNameIdentifier	 LOAD
:	TokenNameCOLON	
fieldSelector	TokenNameIdentifier	 field Selector
.	TokenNameDOT	
accept	TokenNameIdentifier	 accept
(	TokenNameLPAREN	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
bits	TokenNameIdentifier	 bits
=	TokenNameEQUAL	
fieldsStream	TokenNameIdentifier	 fields Stream
.	TokenNameDOT	
readByte	TokenNameIdentifier	 read Byte
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
bits	TokenNameIdentifier	 bits
<=	TokenNameLESS_EQUAL	
(	TokenNameLPAREN	
FieldsWriter	TokenNameIdentifier	 Fields Writer
.	TokenNameDOT	
FIELD_IS_NUMERIC_MASK	TokenNameIdentifier	 FIELD  IS  NUMERIC  MASK
|	TokenNameOR	
FieldsWriter	TokenNameIdentifier	 Fields Writer
.	TokenNameDOT	
FIELD_IS_COMPRESSED	TokenNameIdentifier	 FIELD  IS  COMPRESSED
|	TokenNameOR	
FieldsWriter	TokenNameIdentifier	 Fields Writer
.	TokenNameDOT	
FIELD_IS_TOKENIZED	TokenNameIdentifier	 FIELD  IS  TOKENIZED
|	TokenNameOR	
FieldsWriter	TokenNameIdentifier	 Fields Writer
.	TokenNameDOT	
FIELD_IS_BINARY	TokenNameIdentifier	 FIELD  IS  BINARY
)	TokenNameRPAREN	
:	TokenNameCOLON	
"bits="	TokenNameStringLiteral	bits=
+	TokenNamePLUS	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toHexString	TokenNameIdentifier	 to Hex String
(	TokenNameLPAREN	
bits	TokenNameIdentifier	 bits
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
compressed	TokenNameIdentifier	 compressed
=	TokenNameEQUAL	
(	TokenNameLPAREN	
bits	TokenNameIdentifier	 bits
&	TokenNameAND	
FieldsWriter	TokenNameIdentifier	 Fields Writer
.	TokenNameDOT	
FIELD_IS_COMPRESSED	TokenNameIdentifier	 FIELD  IS  COMPRESSED
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
(	TokenNameLPAREN	
compressed	TokenNameIdentifier	 compressed
?	TokenNameQUESTION	
(	TokenNameLPAREN	
format	TokenNameIdentifier	 format
<	TokenNameLESS	
FieldsWriter	TokenNameIdentifier	 Fields Writer
.	TokenNameDOT	
FORMAT_LUCENE_3_0_NO_COMPRESSED_FIELDS	TokenNameIdentifier	 FORMAT  LUCENE 3 0  NO  COMPRESSED  FIELDS
)	TokenNameRPAREN	
:	TokenNameCOLON	
true	TokenNametrue	
)	TokenNameRPAREN	
:	TokenNameCOLON	
"compressed fields are only allowed in indexes of version <= 2.9"	TokenNameStringLiteral	compressed fields are only allowed in indexes of version <= 2.9
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
tokenize	TokenNameIdentifier	 tokenize
=	TokenNameEQUAL	
(	TokenNameLPAREN	
bits	TokenNameIdentifier	 bits
&	TokenNameAND	
FieldsWriter	TokenNameIdentifier	 Fields Writer
.	TokenNameDOT	
FIELD_IS_TOKENIZED	TokenNameIdentifier	 FIELD  IS  TOKENIZED
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
binary	TokenNameIdentifier	 binary
=	TokenNameEQUAL	
(	TokenNameLPAREN	
bits	TokenNameIdentifier	 bits
&	TokenNameAND	
FieldsWriter	TokenNameIdentifier	 Fields Writer
.	TokenNameDOT	
FIELD_IS_BINARY	TokenNameIdentifier	 FIELD  IS  BINARY
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
numeric	TokenNameIdentifier	 numeric
=	TokenNameEQUAL	
bits	TokenNameIdentifier	 bits
&	TokenNameAND	
FieldsWriter	TokenNameIdentifier	 Fields Writer
.	TokenNameDOT	
FIELD_IS_NUMERIC_MASK	TokenNameIdentifier	 FIELD  IS  NUMERIC  MASK
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
acceptField	TokenNameIdentifier	 accept Field
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
LOAD	TokenNameIdentifier	 LOAD
:	TokenNameCOLON	
addField	TokenNameIdentifier	 add Field
(	TokenNameLPAREN	
doc	TokenNameIdentifier	 doc
,	TokenNameCOMMA	
fi	TokenNameIdentifier	 fi
,	TokenNameCOMMA	
binary	TokenNameIdentifier	 binary
,	TokenNameCOMMA	
compressed	TokenNameIdentifier	 compressed
,	TokenNameCOMMA	
tokenize	TokenNameIdentifier	 tokenize
,	TokenNameCOMMA	
numeric	TokenNameIdentifier	 numeric
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
LOAD_AND_BREAK	TokenNameIdentifier	 LOAD  AND  BREAK
:	TokenNameCOLON	
addField	TokenNameIdentifier	 add Field
(	TokenNameLPAREN	
doc	TokenNameIdentifier	 doc
,	TokenNameCOMMA	
fi	TokenNameIdentifier	 fi
,	TokenNameCOMMA	
binary	TokenNameIdentifier	 binary
,	TokenNameCOMMA	
compressed	TokenNameIdentifier	 compressed
,	TokenNameCOMMA	
tokenize	TokenNameIdentifier	 tokenize
,	TokenNameCOMMA	
numeric	TokenNameIdentifier	 numeric
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
out	TokenNameIdentifier	 out
;	TokenNameSEMICOLON	
//Get out of this loop 	TokenNameCOMMENT_LINE	Get out of this loop 
case	TokenNamecase	
LAZY_LOAD	TokenNameIdentifier	 LAZY  LOAD
:	TokenNameCOLON	
addFieldLazy	TokenNameIdentifier	 add Field Lazy
(	TokenNameLPAREN	
doc	TokenNameIdentifier	 doc
,	TokenNameCOMMA	
fi	TokenNameIdentifier	 fi
,	TokenNameCOMMA	
binary	TokenNameIdentifier	 binary
,	TokenNameCOMMA	
compressed	TokenNameIdentifier	 compressed
,	TokenNameCOMMA	
tokenize	TokenNameIdentifier	 tokenize
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
numeric	TokenNameIdentifier	 numeric
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
LATENT	TokenNameIdentifier	 LATENT
:	TokenNameCOLON	
addFieldLazy	TokenNameIdentifier	 add Field Lazy
(	TokenNameLPAREN	
doc	TokenNameIdentifier	 doc
,	TokenNameCOMMA	
fi	TokenNameIdentifier	 fi
,	TokenNameCOMMA	
binary	TokenNameIdentifier	 binary
,	TokenNameCOMMA	
compressed	TokenNameIdentifier	 compressed
,	TokenNameCOMMA	
tokenize	TokenNameIdentifier	 tokenize
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
numeric	TokenNameIdentifier	 numeric
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
SIZE	TokenNameIdentifier	 SIZE
:	TokenNameCOLON	
skipFieldBytes	TokenNameIdentifier	 skip Field Bytes
(	TokenNameLPAREN	
binary	TokenNameIdentifier	 binary
,	TokenNameCOMMA	
compressed	TokenNameIdentifier	 compressed
,	TokenNameCOMMA	
addFieldSize	TokenNameIdentifier	 add Field Size
(	TokenNameLPAREN	
doc	TokenNameIdentifier	 doc
,	TokenNameCOMMA	
fi	TokenNameIdentifier	 fi
,	TokenNameCOMMA	
binary	TokenNameIdentifier	 binary
,	TokenNameCOMMA	
compressed	TokenNameIdentifier	 compressed
,	TokenNameCOMMA	
numeric	TokenNameIdentifier	 numeric
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
SIZE_AND_BREAK	TokenNameIdentifier	 SIZE  AND  BREAK
:	TokenNameCOLON	
addFieldSize	TokenNameIdentifier	 add Field Size
(	TokenNameLPAREN	
doc	TokenNameIdentifier	 doc
,	TokenNameCOMMA	
fi	TokenNameIdentifier	 fi
,	TokenNameCOMMA	
binary	TokenNameIdentifier	 binary
,	TokenNameCOMMA	
compressed	TokenNameIdentifier	 compressed
,	TokenNameCOMMA	
numeric	TokenNameIdentifier	 numeric
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
out	TokenNameIdentifier	 out
;	TokenNameSEMICOLON	
//Get out of this loop 	TokenNameCOMMENT_LINE	Get out of this loop 
default	TokenNamedefault	
:	TokenNameCOLON	
skipField	TokenNameIdentifier	 skip Field
(	TokenNameLPAREN	
binary	TokenNameIdentifier	 binary
,	TokenNameCOMMA	
compressed	TokenNameIdentifier	 compressed
,	TokenNameCOMMA	
numeric	TokenNameIdentifier	 numeric
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
doc	TokenNameIdentifier	 doc
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Returns the length in bytes of each raw document in a * contiguous range of length numDocs starting with * startDocID. Returns the IndexInput (the fieldStream), * already seeked to the starting point for startDocID.*/	TokenNameCOMMENT_JAVADOC	 Returns the length in bytes of each raw document in a contiguous range of length numDocs starting with startDocID. Returns the IndexInput (the fieldStream), already seeked to the starting point for startDocID.
final	TokenNamefinal	
IndexInput	TokenNameIdentifier	 Index Input
rawDocs	TokenNameIdentifier	 raw Docs
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
lengths	TokenNameIdentifier	 lengths
,	TokenNameCOMMA	
int	TokenNameint	
startDocID	TokenNameIdentifier	 start Doc ID
,	TokenNameCOMMA	
int	TokenNameint	
numDocs	TokenNameIdentifier	 num Docs
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
seekIndex	TokenNameIdentifier	 seek Index
(	TokenNameLPAREN	
startDocID	TokenNameIdentifier	 start Doc ID
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
startOffset	TokenNameIdentifier	 start Offset
=	TokenNameEQUAL	
indexStream	TokenNameIdentifier	 index Stream
.	TokenNameDOT	
readLong	TokenNameIdentifier	 read Long
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
lastOffset	TokenNameIdentifier	 last Offset
=	TokenNameEQUAL	
startOffset	TokenNameIdentifier	 start Offset
;	TokenNameSEMICOLON	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
<	TokenNameLESS	
numDocs	TokenNameIdentifier	 num Docs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
long	TokenNamelong	
offset	TokenNameIdentifier	 offset
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
docID	TokenNameIdentifier	 doc ID
=	TokenNameEQUAL	
docStoreOffset	TokenNameIdentifier	 doc Store Offset
+	TokenNamePLUS	
startDocID	TokenNameIdentifier	 start Doc ID
+	TokenNamePLUS	
count	TokenNameIdentifier	 count
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
docID	TokenNameIdentifier	 doc ID
<=	TokenNameLESS_EQUAL	
numTotalDocs	TokenNameIdentifier	 num Total Docs
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
docID	TokenNameIdentifier	 doc ID
<	TokenNameLESS	
numTotalDocs	TokenNameIdentifier	 num Total Docs
)	TokenNameRPAREN	
offset	TokenNameIdentifier	 offset
=	TokenNameEQUAL	
indexStream	TokenNameIdentifier	 index Stream
.	TokenNameDOT	
readLong	TokenNameIdentifier	 read Long
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
offset	TokenNameIdentifier	 offset
=	TokenNameEQUAL	
fieldsStream	TokenNameIdentifier	 fields Stream
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
lengths	TokenNameIdentifier	 lengths
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
offset	TokenNameIdentifier	 offset
-	TokenNameMINUS	
lastOffset	TokenNameIdentifier	 last Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
lastOffset	TokenNameIdentifier	 last Offset
=	TokenNameEQUAL	
offset	TokenNameIdentifier	 offset
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fieldsStream	TokenNameIdentifier	 fields Stream
.	TokenNameDOT	
seek	TokenNameIdentifier	 seek
(	TokenNameLPAREN	
startOffset	TokenNameIdentifier	 start Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
fieldsStream	TokenNameIdentifier	 fields Stream
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Skip the field. We still have to read some of the information about the field, but can skip past the actual content. * This will have the most payoff on large fields. */	TokenNameCOMMENT_JAVADOC	 Skip the field. We still have to read some of the information about the field, but can skip past the actual content. This will have the most payoff on large fields. 
private	TokenNameprivate	
void	TokenNamevoid	
skipField	TokenNameIdentifier	 skip Field
(	TokenNameLPAREN	
boolean	TokenNameboolean	
binary	TokenNameIdentifier	 binary
,	TokenNameCOMMA	
boolean	TokenNameboolean	
compressed	TokenNameIdentifier	 compressed
,	TokenNameCOMMA	
int	TokenNameint	
numeric	TokenNameIdentifier	 numeric
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
numBytes	TokenNameIdentifier	 num Bytes
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
numeric	TokenNameIdentifier	 numeric
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
numBytes	TokenNameIdentifier	 num Bytes
=	TokenNameEQUAL	
fieldsStream	TokenNameIdentifier	 fields Stream
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
FieldsWriter	TokenNameIdentifier	 Fields Writer
.	TokenNameDOT	
FIELD_IS_NUMERIC_INT	TokenNameIdentifier	 FIELD  IS  NUMERIC  INT
:	TokenNameCOLON	
case	TokenNamecase	
FieldsWriter	TokenNameIdentifier	 Fields Writer
.	TokenNameDOT	
FIELD_IS_NUMERIC_FLOAT	TokenNameIdentifier	 FIELD  IS  NUMERIC  FLOAT
:	TokenNameCOLON	
numBytes	TokenNameIdentifier	 num Bytes
=	TokenNameEQUAL	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
FieldsWriter	TokenNameIdentifier	 Fields Writer
.	TokenNameDOT	
FIELD_IS_NUMERIC_LONG	TokenNameIdentifier	 FIELD  IS  NUMERIC  LONG
:	TokenNameCOLON	
case	TokenNamecase	
FieldsWriter	TokenNameIdentifier	 Fields Writer
.	TokenNameDOT	
FIELD_IS_NUMERIC_DOUBLE	TokenNameIdentifier	 FIELD  IS  NUMERIC  DOUBLE
:	TokenNameCOLON	
numBytes	TokenNameIdentifier	 num Bytes
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
throw	TokenNamethrow	
new	TokenNamenew	
CorruptIndexException	TokenNameIdentifier	 Corrupt Index Exception
(	TokenNameLPAREN	
"Invalid numeric type: "	TokenNameStringLiteral	Invalid numeric type: 
+	TokenNamePLUS	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toHexString	TokenNameIdentifier	 to Hex String
(	TokenNameLPAREN	
numeric	TokenNameIdentifier	 numeric
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
skipFieldBytes	TokenNameIdentifier	 skip Field Bytes
(	TokenNameLPAREN	
binary	TokenNameIdentifier	 binary
,	TokenNameCOMMA	
compressed	TokenNameIdentifier	 compressed
,	TokenNameCOMMA	
numBytes	TokenNameIdentifier	 num Bytes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
skipFieldBytes	TokenNameIdentifier	 skip Field Bytes
(	TokenNameLPAREN	
boolean	TokenNameboolean	
binary	TokenNameIdentifier	 binary
,	TokenNameCOMMA	
boolean	TokenNameboolean	
compressed	TokenNameIdentifier	 compressed
,	TokenNameCOMMA	
int	TokenNameint	
toRead	TokenNameIdentifier	 to Read
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
format	TokenNameIdentifier	 format
>=	TokenNameGREATER_EQUAL	
FieldsWriter	TokenNameIdentifier	 Fields Writer
.	TokenNameDOT	
FORMAT_VERSION_UTF8_LENGTH_IN_BYTES	TokenNameIdentifier	 FORMAT  VERSION  UT F8  LENGTH  IN  BYTES
||	TokenNameOR_OR	
binary	TokenNameIdentifier	 binary
||	TokenNameOR_OR	
compressed	TokenNameIdentifier	 compressed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fieldsStream	TokenNameIdentifier	 fields Stream
.	TokenNameDOT	
seek	TokenNameIdentifier	 seek
(	TokenNameLPAREN	
fieldsStream	TokenNameIdentifier	 fields Stream
.	TokenNameDOT	
getFilePointer	TokenNameIdentifier	 get File Pointer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
toRead	TokenNameIdentifier	 to Read
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// We need to skip chars. This will slow us down, but still better 	TokenNameCOMMENT_LINE	We need to skip chars. This will slow us down, but still better 
fieldsStream	TokenNameIdentifier	 fields Stream
.	TokenNameDOT	
skipChars	TokenNameIdentifier	 skip Chars
(	TokenNameLPAREN	
toRead	TokenNameIdentifier	 to Read
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
NumericField	TokenNameIdentifier	 Numeric Field
loadNumericField	TokenNameIdentifier	 load Numeric Field
(	TokenNameLPAREN	
FieldInfo	TokenNameIdentifier	 Field Info
fi	TokenNameIdentifier	 fi
,	TokenNameCOMMA	
int	TokenNameint	
numeric	TokenNameIdentifier	 numeric
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
assert	TokenNameassert	
numeric	TokenNameIdentifier	 numeric
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
numeric	TokenNameIdentifier	 numeric
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
FieldsWriter	TokenNameIdentifier	 Fields Writer
.	TokenNameDOT	
FIELD_IS_NUMERIC_INT	TokenNameIdentifier	 FIELD  IS  NUMERIC  INT
:	TokenNameCOLON	
return	TokenNamereturn	
new	TokenNamenew	
NumericField	TokenNameIdentifier	 Numeric Field
(	TokenNameLPAREN	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Store	TokenNameIdentifier	 Store
.	TokenNameDOT	
YES	TokenNameIdentifier	 YES
,	TokenNameCOMMA	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
isIndexed	TokenNameIdentifier	 is Indexed
)	TokenNameRPAREN	
.	TokenNameDOT	
setIntValue	TokenNameIdentifier	 set Int Value
(	TokenNameLPAREN	
fieldsStream	TokenNameIdentifier	 fields Stream
.	TokenNameDOT	
readInt	TokenNameIdentifier	 read Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
FieldsWriter	TokenNameIdentifier	 Fields Writer
.	TokenNameDOT	
FIELD_IS_NUMERIC_LONG	TokenNameIdentifier	 FIELD  IS  NUMERIC  LONG
:	TokenNameCOLON	
return	TokenNamereturn	
new	TokenNamenew	
NumericField	TokenNameIdentifier	 Numeric Field
(	TokenNameLPAREN	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Store	TokenNameIdentifier	 Store
.	TokenNameDOT	
YES	TokenNameIdentifier	 YES
,	TokenNameCOMMA	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
isIndexed	TokenNameIdentifier	 is Indexed
)	TokenNameRPAREN	
.	TokenNameDOT	
setLongValue	TokenNameIdentifier	 set Long Value
(	TokenNameLPAREN	
fieldsStream	TokenNameIdentifier	 fields Stream
.	TokenNameDOT	
readLong	TokenNameIdentifier	 read Long
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
FieldsWriter	TokenNameIdentifier	 Fields Writer
.	TokenNameDOT	
FIELD_IS_NUMERIC_FLOAT	TokenNameIdentifier	 FIELD  IS  NUMERIC  FLOAT
:	TokenNameCOLON	
return	TokenNamereturn	
new	TokenNamenew	
NumericField	TokenNameIdentifier	 Numeric Field
(	TokenNameLPAREN	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Store	TokenNameIdentifier	 Store
.	TokenNameDOT	
YES	TokenNameIdentifier	 YES
,	TokenNameCOMMA	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
isIndexed	TokenNameIdentifier	 is Indexed
)	TokenNameRPAREN	
.	TokenNameDOT	
setFloatValue	TokenNameIdentifier	 set Float Value
(	TokenNameLPAREN	
Float	TokenNameIdentifier	 Float
.	TokenNameDOT	
intBitsToFloat	TokenNameIdentifier	 int Bits To Float
(	TokenNameLPAREN	
fieldsStream	TokenNameIdentifier	 fields Stream
.	TokenNameDOT	
readInt	TokenNameIdentifier	 read Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
FieldsWriter	TokenNameIdentifier	 Fields Writer
.	TokenNameDOT	
FIELD_IS_NUMERIC_DOUBLE	TokenNameIdentifier	 FIELD  IS  NUMERIC  DOUBLE
:	TokenNameCOLON	
return	TokenNamereturn	
new	TokenNamenew	
NumericField	TokenNameIdentifier	 Numeric Field
(	TokenNameLPAREN	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Store	TokenNameIdentifier	 Store
.	TokenNameDOT	
YES	TokenNameIdentifier	 YES
,	TokenNameCOMMA	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
isIndexed	TokenNameIdentifier	 is Indexed
)	TokenNameRPAREN	
.	TokenNameDOT	
setDoubleValue	TokenNameIdentifier	 set Double Value
(	TokenNameLPAREN	
Double	TokenNameIdentifier	 Double
.	TokenNameDOT	
longBitsToDouble	TokenNameIdentifier	 long Bits To Double
(	TokenNameLPAREN	
fieldsStream	TokenNameIdentifier	 fields Stream
.	TokenNameDOT	
readLong	TokenNameIdentifier	 read Long
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
throw	TokenNamethrow	
new	TokenNamenew	
CorruptIndexException	TokenNameIdentifier	 Corrupt Index Exception
(	TokenNameLPAREN	
"Invalid numeric type: "	TokenNameStringLiteral	Invalid numeric type: 
+	TokenNamePLUS	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toHexString	TokenNameIdentifier	 to Hex String
(	TokenNameLPAREN	
numeric	TokenNameIdentifier	 numeric
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
addFieldLazy	TokenNameIdentifier	 add Field Lazy
(	TokenNameLPAREN	
Document	TokenNameIdentifier	 Document
doc	TokenNameIdentifier	 doc
,	TokenNameCOMMA	
FieldInfo	TokenNameIdentifier	 Field Info
fi	TokenNameIdentifier	 fi
,	TokenNameCOMMA	
boolean	TokenNameboolean	
binary	TokenNameIdentifier	 binary
,	TokenNameCOMMA	
boolean	TokenNameboolean	
compressed	TokenNameIdentifier	 compressed
,	TokenNameCOMMA	
boolean	TokenNameboolean	
tokenize	TokenNameIdentifier	 tokenize
,	TokenNameCOMMA	
boolean	TokenNameboolean	
cacheResult	TokenNameIdentifier	 cache Result
,	TokenNameCOMMA	
int	TokenNameint	
numeric	TokenNameIdentifier	 numeric
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
final	TokenNamefinal	
AbstractField	TokenNameIdentifier	 Abstract Field
f	TokenNameIdentifier	 f
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
binary	TokenNameIdentifier	 binary
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
toRead	TokenNameIdentifier	 to Read
=	TokenNameEQUAL	
fieldsStream	TokenNameIdentifier	 fields Stream
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
pointer	TokenNameIdentifier	 pointer
=	TokenNameEQUAL	
fieldsStream	TokenNameIdentifier	 fields Stream
.	TokenNameDOT	
getFilePointer	TokenNameIdentifier	 get File Pointer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
new	TokenNamenew	
LazyField	TokenNameIdentifier	 Lazy Field
(	TokenNameLPAREN	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Store	TokenNameIdentifier	 Store
.	TokenNameDOT	
YES	TokenNameIdentifier	 YES
,	TokenNameCOMMA	
toRead	TokenNameIdentifier	 to Read
,	TokenNameCOMMA	
pointer	TokenNameIdentifier	 pointer
,	TokenNameCOMMA	
binary	TokenNameIdentifier	 binary
,	TokenNameCOMMA	
compressed	TokenNameIdentifier	 compressed
,	TokenNameCOMMA	
cacheResult	TokenNameIdentifier	 cache Result
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//Need to move the pointer ahead by toRead positions 	TokenNameCOMMENT_LINE	Need to move the pointer ahead by toRead positions 
fieldsStream	TokenNameIdentifier	 fields Stream
.	TokenNameDOT	
seek	TokenNameIdentifier	 seek
(	TokenNameLPAREN	
pointer	TokenNameIdentifier	 pointer
+	TokenNamePLUS	
toRead	TokenNameIdentifier	 to Read
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
numeric	TokenNameIdentifier	 numeric
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
loadNumericField	TokenNameIdentifier	 load Numeric Field
(	TokenNameLPAREN	
fi	TokenNameIdentifier	 fi
,	TokenNameCOMMA	
numeric	TokenNameIdentifier	 numeric
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Store	TokenNameIdentifier	 Store
store	TokenNameIdentifier	 store
=	TokenNameEQUAL	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Store	TokenNameIdentifier	 Store
.	TokenNameDOT	
YES	TokenNameIdentifier	 YES
;	TokenNameSEMICOLON	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Index	TokenNameIdentifier	 Index
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Index	TokenNameIdentifier	 Index
.	TokenNameDOT	
toIndex	TokenNameIdentifier	 to Index
(	TokenNameLPAREN	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
isIndexed	TokenNameIdentifier	 is Indexed
,	TokenNameCOMMA	
tokenize	TokenNameIdentifier	 tokenize
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
TermVector	TokenNameIdentifier	 Term Vector
termVector	TokenNameIdentifier	 term Vector
=	TokenNameEQUAL	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
TermVector	TokenNameIdentifier	 Term Vector
.	TokenNameDOT	
toTermVector	TokenNameIdentifier	 to Term Vector
(	TokenNameLPAREN	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
storeTermVector	TokenNameIdentifier	 store Term Vector
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
compressed	TokenNameIdentifier	 compressed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
toRead	TokenNameIdentifier	 to Read
=	TokenNameEQUAL	
fieldsStream	TokenNameIdentifier	 fields Stream
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
pointer	TokenNameIdentifier	 pointer
=	TokenNameEQUAL	
fieldsStream	TokenNameIdentifier	 fields Stream
.	TokenNameDOT	
getFilePointer	TokenNameIdentifier	 get File Pointer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
new	TokenNamenew	
LazyField	TokenNameIdentifier	 Lazy Field
(	TokenNameLPAREN	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
store	TokenNameIdentifier	 store
,	TokenNameCOMMA	
toRead	TokenNameIdentifier	 to Read
,	TokenNameCOMMA	
pointer	TokenNameIdentifier	 pointer
,	TokenNameCOMMA	
binary	TokenNameIdentifier	 binary
,	TokenNameCOMMA	
compressed	TokenNameIdentifier	 compressed
,	TokenNameCOMMA	
cacheResult	TokenNameIdentifier	 cache Result
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//skip over the part that we aren't loading 	TokenNameCOMMENT_LINE	skip over the part that we aren't loading 
fieldsStream	TokenNameIdentifier	 fields Stream
.	TokenNameDOT	
seek	TokenNameIdentifier	 seek
(	TokenNameLPAREN	
pointer	TokenNameIdentifier	 pointer
+	TokenNamePLUS	
toRead	TokenNameIdentifier	 to Read
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
fieldsStream	TokenNameIdentifier	 fields Stream
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
pointer	TokenNameIdentifier	 pointer
=	TokenNameEQUAL	
fieldsStream	TokenNameIdentifier	 fields Stream
.	TokenNameDOT	
getFilePointer	TokenNameIdentifier	 get File Pointer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//Skip ahead of where we are by the length of what is stored 	TokenNameCOMMENT_LINE	Skip ahead of where we are by the length of what is stored 
if	TokenNameif	
(	TokenNameLPAREN	
format	TokenNameIdentifier	 format
>=	TokenNameGREATER_EQUAL	
FieldsWriter	TokenNameIdentifier	 Fields Writer
.	TokenNameDOT	
FORMAT_VERSION_UTF8_LENGTH_IN_BYTES	TokenNameIdentifier	 FORMAT  VERSION  UT F8  LENGTH  IN  BYTES
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fieldsStream	TokenNameIdentifier	 fields Stream
.	TokenNameDOT	
seek	TokenNameIdentifier	 seek
(	TokenNameLPAREN	
pointer	TokenNameIdentifier	 pointer
+	TokenNamePLUS	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fieldsStream	TokenNameIdentifier	 fields Stream
.	TokenNameDOT	
skipChars	TokenNameIdentifier	 skip Chars
(	TokenNameLPAREN	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
new	TokenNamenew	
LazyField	TokenNameIdentifier	 Lazy Field
(	TokenNameLPAREN	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
store	TokenNameIdentifier	 store
,	TokenNameCOMMA	
index	TokenNameIdentifier	 index
,	TokenNameCOMMA	
termVector	TokenNameIdentifier	 term Vector
,	TokenNameCOMMA	
length	TokenNameIdentifier	 length
,	TokenNameCOMMA	
pointer	TokenNameIdentifier	 pointer
,	TokenNameCOMMA	
binary	TokenNameIdentifier	 binary
,	TokenNameCOMMA	
compressed	TokenNameIdentifier	 compressed
,	TokenNameCOMMA	
cacheResult	TokenNameIdentifier	 cache Result
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
f	TokenNameIdentifier	 f
.	TokenNameDOT	
setOmitNorms	TokenNameIdentifier	 set Omit Norms
(	TokenNameLPAREN	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
omitNorms	TokenNameIdentifier	 omit Norms
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
f	TokenNameIdentifier	 f
.	TokenNameDOT	
setIndexOptions	TokenNameIdentifier	 set Index Options
(	TokenNameLPAREN	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
indexOptions	TokenNameIdentifier	 index Options
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
doc	TokenNameIdentifier	 doc
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
f	TokenNameIdentifier	 f
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
addField	TokenNameIdentifier	 add Field
(	TokenNameLPAREN	
Document	TokenNameIdentifier	 Document
doc	TokenNameIdentifier	 doc
,	TokenNameCOMMA	
FieldInfo	TokenNameIdentifier	 Field Info
fi	TokenNameIdentifier	 fi
,	TokenNameCOMMA	
boolean	TokenNameboolean	
binary	TokenNameIdentifier	 binary
,	TokenNameCOMMA	
boolean	TokenNameboolean	
compressed	TokenNameIdentifier	 compressed
,	TokenNameCOMMA	
boolean	TokenNameboolean	
tokenize	TokenNameIdentifier	 tokenize
,	TokenNameCOMMA	
int	TokenNameint	
numeric	TokenNameIdentifier	 numeric
)	TokenNameRPAREN	
throws	TokenNamethrows	
CorruptIndexException	TokenNameIdentifier	 Corrupt Index Exception
,	TokenNameCOMMA	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
final	TokenNamefinal	
AbstractField	TokenNameIdentifier	 Abstract Field
f	TokenNameIdentifier	 f
;	TokenNameSEMICOLON	
//we have a binary stored field, and it may be compressed 	TokenNameCOMMENT_LINE	we have a binary stored field, and it may be compressed 
if	TokenNameif	
(	TokenNameLPAREN	
binary	TokenNameIdentifier	 binary
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
toRead	TokenNameIdentifier	 to Read
=	TokenNameEQUAL	
fieldsStream	TokenNameIdentifier	 fields Stream
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
toRead	TokenNameIdentifier	 to Read
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fieldsStream	TokenNameIdentifier	 fields Stream
.	TokenNameDOT	
readBytes	TokenNameIdentifier	 read Bytes
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
compressed	TokenNameIdentifier	 compressed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
new	TokenNamenew	
Field	TokenNameIdentifier	 Field
(	TokenNameLPAREN	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
uncompress	TokenNameIdentifier	 uncompress
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
new	TokenNamenew	
Field	TokenNameIdentifier	 Field
(	TokenNameLPAREN	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
numeric	TokenNameIdentifier	 numeric
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
loadNumericField	TokenNameIdentifier	 load Numeric Field
(	TokenNameLPAREN	
fi	TokenNameIdentifier	 fi
,	TokenNameCOMMA	
numeric	TokenNameIdentifier	 numeric
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Store	TokenNameIdentifier	 Store
store	TokenNameIdentifier	 store
=	TokenNameEQUAL	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Store	TokenNameIdentifier	 Store
.	TokenNameDOT	
YES	TokenNameIdentifier	 YES
;	TokenNameSEMICOLON	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Index	TokenNameIdentifier	 Index
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Index	TokenNameIdentifier	 Index
.	TokenNameDOT	
toIndex	TokenNameIdentifier	 to Index
(	TokenNameLPAREN	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
isIndexed	TokenNameIdentifier	 is Indexed
,	TokenNameCOMMA	
tokenize	TokenNameIdentifier	 tokenize
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
TermVector	TokenNameIdentifier	 Term Vector
termVector	TokenNameIdentifier	 term Vector
=	TokenNameEQUAL	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
TermVector	TokenNameIdentifier	 Term Vector
.	TokenNameDOT	
toTermVector	TokenNameIdentifier	 to Term Vector
(	TokenNameLPAREN	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
storeTermVector	TokenNameIdentifier	 store Term Vector
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
compressed	TokenNameIdentifier	 compressed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
toRead	TokenNameIdentifier	 to Read
=	TokenNameEQUAL	
fieldsStream	TokenNameIdentifier	 fields Stream
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
toRead	TokenNameIdentifier	 to Read
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fieldsStream	TokenNameIdentifier	 fields Stream
.	TokenNameDOT	
readBytes	TokenNameIdentifier	 read Bytes
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
new	TokenNamenew	
Field	TokenNameIdentifier	 Field
(	TokenNameLPAREN	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
// field name 	TokenNameCOMMENT_LINE	field name 
false	TokenNamefalse	
,	TokenNameCOMMA	
new	TokenNamenew	
String	TokenNameIdentifier	 String
(	TokenNameLPAREN	
uncompress	TokenNameIdentifier	 uncompress
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
,	TokenNameCOMMA	
"UTF-8"	TokenNameStringLiteral	UTF-8
)	TokenNameRPAREN	
,	TokenNameCOMMA	
// uncompress the value and add as string 	TokenNameCOMMENT_LINE	uncompress the value and add as string 
store	TokenNameIdentifier	 store
,	TokenNameCOMMA	
index	TokenNameIdentifier	 index
,	TokenNameCOMMA	
termVector	TokenNameIdentifier	 term Vector
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
new	TokenNamenew	
Field	TokenNameIdentifier	 Field
(	TokenNameLPAREN	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
// name 	TokenNameCOMMENT_LINE	name 
false	TokenNamefalse	
,	TokenNameCOMMA	
fieldsStream	TokenNameIdentifier	 fields Stream
.	TokenNameDOT	
readString	TokenNameIdentifier	 read String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
// read value 	TokenNameCOMMENT_LINE	read value 
store	TokenNameIdentifier	 store
,	TokenNameCOMMA	
index	TokenNameIdentifier	 index
,	TokenNameCOMMA	
termVector	TokenNameIdentifier	 term Vector
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
f	TokenNameIdentifier	 f
.	TokenNameDOT	
setIndexOptions	TokenNameIdentifier	 set Index Options
(	TokenNameLPAREN	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
indexOptions	TokenNameIdentifier	 index Options
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
f	TokenNameIdentifier	 f
.	TokenNameDOT	
setOmitNorms	TokenNameIdentifier	 set Omit Norms
(	TokenNameLPAREN	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
omitNorms	TokenNameIdentifier	 omit Norms
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
doc	TokenNameIdentifier	 doc
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
f	TokenNameIdentifier	 f
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Add the size of field as a byte[] containing the 4 bytes of the integer byte size (high order byte first; char = 2 bytes) 	TokenNameCOMMENT_LINE	Add the size of field as a byte[] containing the 4 bytes of the integer byte size (high order byte first; char = 2 bytes) 
// Read just the size -- caller must skip the field content to continue reading fields 	TokenNameCOMMENT_LINE	Read just the size -- caller must skip the field content to continue reading fields 
// Return the size in bytes or chars, depending on field type 	TokenNameCOMMENT_LINE	Return the size in bytes or chars, depending on field type 
private	TokenNameprivate	
int	TokenNameint	
addFieldSize	TokenNameIdentifier	 add Field Size
(	TokenNameLPAREN	
Document	TokenNameIdentifier	 Document
doc	TokenNameIdentifier	 doc
,	TokenNameCOMMA	
FieldInfo	TokenNameIdentifier	 Field Info
fi	TokenNameIdentifier	 fi
,	TokenNameCOMMA	
boolean	TokenNameboolean	
binary	TokenNameIdentifier	 binary
,	TokenNameCOMMA	
boolean	TokenNameboolean	
compressed	TokenNameIdentifier	 compressed
,	TokenNameCOMMA	
int	TokenNameint	
numeric	TokenNameIdentifier	 numeric
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
bytesize	TokenNameIdentifier	 bytesize
,	TokenNameCOMMA	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
numeric	TokenNameIdentifier	 numeric
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
fieldsStream	TokenNameIdentifier	 fields Stream
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bytesize	TokenNameIdentifier	 bytesize
=	TokenNameEQUAL	
(	TokenNameLPAREN	
binary	TokenNameIdentifier	 binary
||	TokenNameOR_OR	
compressed	TokenNameIdentifier	 compressed
)	TokenNameRPAREN	
?	TokenNameQUESTION	
size	TokenNameIdentifier	 size
:	TokenNameCOLON	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
FieldsWriter	TokenNameIdentifier	 Fields Writer
.	TokenNameDOT	
FIELD_IS_NUMERIC_INT	TokenNameIdentifier	 FIELD  IS  NUMERIC  INT
:	TokenNameCOLON	
case	TokenNamecase	
FieldsWriter	TokenNameIdentifier	 Fields Writer
.	TokenNameDOT	
FIELD_IS_NUMERIC_FLOAT	TokenNameIdentifier	 FIELD  IS  NUMERIC  FLOAT
:	TokenNameCOLON	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
bytesize	TokenNameIdentifier	 bytesize
=	TokenNameEQUAL	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
FieldsWriter	TokenNameIdentifier	 Fields Writer
.	TokenNameDOT	
FIELD_IS_NUMERIC_LONG	TokenNameIdentifier	 FIELD  IS  NUMERIC  LONG
:	TokenNameCOLON	
case	TokenNamecase	
FieldsWriter	TokenNameIdentifier	 Fields Writer
.	TokenNameDOT	
FIELD_IS_NUMERIC_DOUBLE	TokenNameIdentifier	 FIELD  IS  NUMERIC  DOUBLE
:	TokenNameCOLON	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
bytesize	TokenNameIdentifier	 bytesize
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
throw	TokenNamethrow	
new	TokenNamenew	
CorruptIndexException	TokenNameIdentifier	 Corrupt Index Exception
(	TokenNameLPAREN	
"Invalid numeric type: "	TokenNameStringLiteral	Invalid numeric type: 
+	TokenNamePLUS	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toHexString	TokenNameIdentifier	 to Hex String
(	TokenNameLPAREN	
numeric	TokenNameIdentifier	 numeric
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
sizebytes	TokenNameIdentifier	 sizebytes
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
4	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
sizebytes	TokenNameIdentifier	 sizebytes
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
bytesize	TokenNameIdentifier	 bytesize
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sizebytes	TokenNameIdentifier	 sizebytes
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
bytesize	TokenNameIdentifier	 bytesize
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sizebytes	TokenNameIdentifier	 sizebytes
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
bytesize	TokenNameIdentifier	 bytesize
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sizebytes	TokenNameIdentifier	 sizebytes
[	TokenNameLBRACKET	
3	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
bytesize	TokenNameIdentifier	 bytesize
;	TokenNameSEMICOLON	
doc	TokenNameIdentifier	 doc
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
Field	TokenNameIdentifier	 Field
(	TokenNameLPAREN	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
sizebytes	TokenNameIdentifier	 sizebytes
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * A Lazy implementation of Fieldable that defers loading of fields until asked for, instead of when the Document is * loaded. */	TokenNameCOMMENT_JAVADOC	 A Lazy implementation of Fieldable that defers loading of fields until asked for, instead of when the Document is loaded. 
private	TokenNameprivate	
class	TokenNameclass	
LazyField	TokenNameIdentifier	 Lazy Field
extends	TokenNameextends	
AbstractField	TokenNameIdentifier	 Abstract Field
implements	TokenNameimplements	
Fieldable	TokenNameIdentifier	 Fieldable
{	TokenNameLBRACE	
private	TokenNameprivate	
int	TokenNameint	
toRead	TokenNameIdentifier	 to Read
;	TokenNameSEMICOLON	
private	TokenNameprivate	
long	TokenNamelong	
pointer	TokenNameIdentifier	 pointer
;	TokenNameSEMICOLON	
/** @deprecated Only kept for backward-compatbility with <3.0 indexes. Will be removed in 4.0. */	TokenNameCOMMENT_JAVADOC	 @deprecated Only kept for backward-compatbility with <3.0 indexes. Will be removed in 4.0. 
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
private	TokenNameprivate	
boolean	TokenNameboolean	
isCompressed	TokenNameIdentifier	 is Compressed
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
cacheResult	TokenNameIdentifier	 cache Result
;	TokenNameSEMICOLON	
public	TokenNamepublic	
LazyField	TokenNameIdentifier	 Lazy Field
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Store	TokenNameIdentifier	 Store
store	TokenNameIdentifier	 store
,	TokenNameCOMMA	
int	TokenNameint	
toRead	TokenNameIdentifier	 to Read
,	TokenNameCOMMA	
long	TokenNamelong	
pointer	TokenNameIdentifier	 pointer
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isBinary	TokenNameIdentifier	 is Binary
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isCompressed	TokenNameIdentifier	 is Compressed
,	TokenNameCOMMA	
boolean	TokenNameboolean	
cacheResult	TokenNameIdentifier	 cache Result
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
store	TokenNameIdentifier	 store
,	TokenNameCOMMA	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Index	TokenNameIdentifier	 Index
.	TokenNameDOT	
NO	TokenNameIdentifier	 NO
,	TokenNameCOMMA	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
TermVector	TokenNameIdentifier	 Term Vector
.	TokenNameDOT	
NO	TokenNameIdentifier	 NO
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
toRead	TokenNameIdentifier	 to Read
=	TokenNameEQUAL	
toRead	TokenNameIdentifier	 to Read
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
pointer	TokenNameIdentifier	 pointer
=	TokenNameEQUAL	
pointer	TokenNameIdentifier	 pointer
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
isBinary	TokenNameIdentifier	 is Binary
=	TokenNameEQUAL	
isBinary	TokenNameIdentifier	 is Binary
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
cacheResult	TokenNameIdentifier	 cache Result
=	TokenNameEQUAL	
cacheResult	TokenNameIdentifier	 cache Result
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBinary	TokenNameIdentifier	 is Binary
)	TokenNameRPAREN	
binaryLength	TokenNameIdentifier	 binary Length
=	TokenNameEQUAL	
toRead	TokenNameIdentifier	 to Read
;	TokenNameSEMICOLON	
lazy	TokenNameIdentifier	 lazy
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
isCompressed	TokenNameIdentifier	 is Compressed
=	TokenNameEQUAL	
isCompressed	TokenNameIdentifier	 is Compressed
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
LazyField	TokenNameIdentifier	 Lazy Field
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Store	TokenNameIdentifier	 Store
store	TokenNameIdentifier	 store
,	TokenNameCOMMA	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Index	TokenNameIdentifier	 Index
index	TokenNameIdentifier	 index
,	TokenNameCOMMA	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
TermVector	TokenNameIdentifier	 Term Vector
termVector	TokenNameIdentifier	 term Vector
,	TokenNameCOMMA	
int	TokenNameint	
toRead	TokenNameIdentifier	 to Read
,	TokenNameCOMMA	
long	TokenNamelong	
pointer	TokenNameIdentifier	 pointer
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isBinary	TokenNameIdentifier	 is Binary
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isCompressed	TokenNameIdentifier	 is Compressed
,	TokenNameCOMMA	
boolean	TokenNameboolean	
cacheResult	TokenNameIdentifier	 cache Result
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
store	TokenNameIdentifier	 store
,	TokenNameCOMMA	
index	TokenNameIdentifier	 index
,	TokenNameCOMMA	
termVector	TokenNameIdentifier	 term Vector
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
toRead	TokenNameIdentifier	 to Read
=	TokenNameEQUAL	
toRead	TokenNameIdentifier	 to Read
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
pointer	TokenNameIdentifier	 pointer
=	TokenNameEQUAL	
pointer	TokenNameIdentifier	 pointer
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
isBinary	TokenNameIdentifier	 is Binary
=	TokenNameEQUAL	
isBinary	TokenNameIdentifier	 is Binary
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
cacheResult	TokenNameIdentifier	 cache Result
=	TokenNameEQUAL	
cacheResult	TokenNameIdentifier	 cache Result
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBinary	TokenNameIdentifier	 is Binary
)	TokenNameRPAREN	
binaryLength	TokenNameIdentifier	 binary Length
=	TokenNameEQUAL	
toRead	TokenNameIdentifier	 to Read
;	TokenNameSEMICOLON	
lazy	TokenNameIdentifier	 lazy
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
isCompressed	TokenNameIdentifier	 is Compressed
=	TokenNameEQUAL	
isCompressed	TokenNameIdentifier	 is Compressed
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
IndexInput	TokenNameIdentifier	 Index Input
getFieldStream	TokenNameIdentifier	 get Field Stream
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
IndexInput	TokenNameIdentifier	 Index Input
localFieldsStream	TokenNameIdentifier	 local Fields Stream
=	TokenNameEQUAL	
fieldsStreamTL	TokenNameIdentifier	 fields Stream TL
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
localFieldsStream	TokenNameIdentifier	 local Fields Stream
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
localFieldsStream	TokenNameIdentifier	 local Fields Stream
=	TokenNameEQUAL	
(	TokenNameLPAREN	
IndexInput	TokenNameIdentifier	 Index Input
)	TokenNameRPAREN	
cloneableFieldsStream	TokenNameIdentifier	 cloneable Fields Stream
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fieldsStreamTL	TokenNameIdentifier	 fields Stream TL
.	TokenNameDOT	
set	TokenNameIdentifier	 set
(	TokenNameLPAREN	
localFieldsStream	TokenNameIdentifier	 local Fields Stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
localFieldsStream	TokenNameIdentifier	 local Fields Stream
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** The value of the field as a Reader, or null. If null, the String value, * binary value, or TokenStream value is used. Exactly one of stringValue(), * readerValue(), getBinaryValue(), and tokenStreamValue() must be set. */	TokenNameCOMMENT_JAVADOC	 The value of the field as a Reader, or null. If null, the String value, binary value, or TokenStream value is used. Exactly one of stringValue(), readerValue(), getBinaryValue(), and tokenStreamValue() must be set. 
public	TokenNamepublic	
Reader	TokenNameIdentifier	 Reader
readerValue	TokenNameIdentifier	 reader Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ensureOpen	TokenNameIdentifier	 ensure Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** The value of the field as a TokenStream, or null. If null, the Reader value, * String value, or binary value is used. Exactly one of stringValue(), * readerValue(), getBinaryValue(), and tokenStreamValue() must be set. */	TokenNameCOMMENT_JAVADOC	 The value of the field as a TokenStream, or null. If null, the Reader value, String value, or binary value is used. Exactly one of stringValue(), readerValue(), getBinaryValue(), and tokenStreamValue() must be set. 
public	TokenNamepublic	
TokenStream	TokenNameIdentifier	 Token Stream
tokenStreamValue	TokenNameIdentifier	 token Stream Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ensureOpen	TokenNameIdentifier	 ensure Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** The value of the field as a String, or null. If null, the Reader value, * binary value, or TokenStream value is used. Exactly one of stringValue(), * readerValue(), getBinaryValue(), and tokenStreamValue() must be set. */	TokenNameCOMMENT_JAVADOC	 The value of the field as a String, or null. If null, the Reader value, binary value, or TokenStream value is used. Exactly one of stringValue(), readerValue(), getBinaryValue(), and tokenStreamValue() must be set. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
stringValue	TokenNameIdentifier	 string Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ensureOpen	TokenNameIdentifier	 ensure Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBinary	TokenNameIdentifier	 is Binary
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fieldsData	TokenNameIdentifier	 fields Data
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
IndexInput	TokenNameIdentifier	 Index Input
localFieldsStream	TokenNameIdentifier	 local Fields Stream
=	TokenNameEQUAL	
getFieldStream	TokenNameIdentifier	 get Field Stream
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
localFieldsStream	TokenNameIdentifier	 local Fields Stream
.	TokenNameDOT	
seek	TokenNameIdentifier	 seek
(	TokenNameLPAREN	
pointer	TokenNameIdentifier	 pointer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isCompressed	TokenNameIdentifier	 is Compressed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
toRead	TokenNameIdentifier	 to Read
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
localFieldsStream	TokenNameIdentifier	 local Fields Stream
.	TokenNameDOT	
readBytes	TokenNameIdentifier	 read Bytes
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
(	TokenNameLPAREN	
uncompress	TokenNameIdentifier	 uncompress
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
,	TokenNameCOMMA	
"UTF-8"	TokenNameStringLiteral	UTF-8
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
format	TokenNameIdentifier	 format
>=	TokenNameGREATER_EQUAL	
FieldsWriter	TokenNameIdentifier	 Fields Writer
.	TokenNameDOT	
FORMAT_VERSION_UTF8_LENGTH_IN_BYTES	TokenNameIdentifier	 FORMAT  VERSION  UT F8  LENGTH  IN  BYTES
)	TokenNameRPAREN	
{	TokenNameLBRACE	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bytes	TokenNameIdentifier	 bytes
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
toRead	TokenNameIdentifier	 to Read
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
localFieldsStream	TokenNameIdentifier	 local Fields Stream
.	TokenNameDOT	
readBytes	TokenNameIdentifier	 read Bytes
(	TokenNameLPAREN	
bytes	TokenNameIdentifier	 bytes
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
toRead	TokenNameIdentifier	 to Read
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
(	TokenNameLPAREN	
bytes	TokenNameIdentifier	 bytes
,	TokenNameCOMMA	
"UTF-8"	TokenNameStringLiteral	UTF-8
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
//read in chars b/c we already know the length we need to read 	TokenNameCOMMENT_LINE	read in chars b/c we already know the length we need to read 
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
chars	TokenNameIdentifier	 chars
=	TokenNameEQUAL	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
toRead	TokenNameIdentifier	 to Read
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
localFieldsStream	TokenNameIdentifier	 local Fields Stream
.	TokenNameDOT	
readChars	TokenNameIdentifier	 read Chars
(	TokenNameLPAREN	
chars	TokenNameIdentifier	 chars
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
toRead	TokenNameIdentifier	 to Read
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
(	TokenNameLPAREN	
chars	TokenNameIdentifier	 chars
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
FieldReaderException	TokenNameIdentifier	 Field Reader Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
cacheResult	TokenNameIdentifier	 cache Result
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fieldsData	TokenNameIdentifier	 fields Data
=	TokenNameEQUAL	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
fieldsData	TokenNameIdentifier	 fields Data
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getBinaryValue	TokenNameIdentifier	 get Binary Value
(	TokenNameLPAREN	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
result	TokenNameIdentifier	 result
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ensureOpen	TokenNameIdentifier	 ensure Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBinary	TokenNameIdentifier	 is Binary
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fieldsData	TokenNameIdentifier	 fields Data
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Allocate new buffer if result is null or too small 	TokenNameCOMMENT_LINE	Allocate new buffer if result is null or too small 
final	TokenNamefinal	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
length	TokenNameIdentifier	 length
<	TokenNameLESS	
toRead	TokenNameIdentifier	 to Read
)	TokenNameRPAREN	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
toRead	TokenNameIdentifier	 to Read
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
else	TokenNameelse	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
result	TokenNameIdentifier	 result
;	TokenNameSEMICOLON	
IndexInput	TokenNameIdentifier	 Index Input
localFieldsStream	TokenNameIdentifier	 local Fields Stream
=	TokenNameEQUAL	
getFieldStream	TokenNameIdentifier	 get Field Stream
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Throw this IOException since IndexReader.document does so anyway, so probably not that big of a change for people 	TokenNameCOMMENT_LINE	Throw this IOException since IndexReader.document does so anyway, so probably not that big of a change for people 
// since they are already handling this exception when getting the document 	TokenNameCOMMENT_LINE	since they are already handling this exception when getting the document 
try	TokenNametry	
{	TokenNameLBRACE	
localFieldsStream	TokenNameIdentifier	 local Fields Stream
.	TokenNameDOT	
seek	TokenNameIdentifier	 seek
(	TokenNameLPAREN	
pointer	TokenNameIdentifier	 pointer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
localFieldsStream	TokenNameIdentifier	 local Fields Stream
.	TokenNameDOT	
readBytes	TokenNameIdentifier	 read Bytes
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
toRead	TokenNameIdentifier	 to Read
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isCompressed	TokenNameIdentifier	 is Compressed
==	TokenNameEQUAL_EQUAL	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
uncompress	TokenNameIdentifier	 uncompress
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
FieldReaderException	TokenNameIdentifier	 Field Reader Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
binaryOffset	TokenNameIdentifier	 binary Offset
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
binaryLength	TokenNameIdentifier	 binary Length
=	TokenNameEQUAL	
toRead	TokenNameIdentifier	 to Read
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cacheResult	TokenNameIdentifier	 cache Result
==	TokenNameEQUAL_EQUAL	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fieldsData	TokenNameIdentifier	 fields Data
=	TokenNameEQUAL	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
fieldsData	TokenNameIdentifier	 fields Data
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
uncompress	TokenNameIdentifier	 uncompress
(	TokenNameLPAREN	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
throws	TokenNamethrows	
CorruptIndexException	TokenNameIdentifier	 Corrupt Index Exception
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
return	TokenNamereturn	
CompressionTools	TokenNameIdentifier	 Compression Tools
.	TokenNameDOT	
decompress	TokenNameIdentifier	 decompress
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
DataFormatException	TokenNameIdentifier	 Data Format Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// this will happen if the field is not compressed 	TokenNameCOMMENT_LINE	this will happen if the field is not compressed 
CorruptIndexException	TokenNameIdentifier	 Corrupt Index Exception
newException	TokenNameIdentifier	 new Exception
=	TokenNameEQUAL	
new	TokenNamenew	
CorruptIndexException	TokenNameIdentifier	 Corrupt Index Exception
(	TokenNameLPAREN	
"field data are in wrong format: "	TokenNameStringLiteral	field data are in wrong format: 
+	TokenNamePLUS	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
newException	TokenNameIdentifier	 new Exception
.	TokenNameDOT	
initCause	TokenNameIdentifier	 init Cause
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
newException	TokenNameIdentifier	 new Exception
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
