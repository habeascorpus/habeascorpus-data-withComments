/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Collections	TokenNameIdentifier	 Collections
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Comparator	TokenNameIdentifier	 Comparator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Vector	TokenNameIdentifier	 Vector
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
ValidatedInfo	TokenNameIdentifier	 Validated Info
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
ValidationContext	TokenNameIdentifier	 Validation Context
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
models	TokenNameIdentifier	 models
.	TokenNameDOT	
CMBuilder	TokenNameIdentifier	 CM Builder
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
models	TokenNameIdentifier	 models
.	TokenNameDOT	
XSCMValidator	TokenNameIdentifier	 XSCM Validator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
SimpleLocator	TokenNameIdentifier	 Simple Locator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
SymbolHash	TokenNameIdentifier	 Symbol Hash
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSConstants	TokenNameIdentifier	 XS Constants
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSObjectList	TokenNameIdentifier	 XS Object List
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
;	TokenNameSEMICOLON	
/** * Constraints shared by traversers and validator * * @xerces.internal * * @author Sandy Gao, IBM * * @version $Id: XSConstraints.java 774786 2009-05-14 14:31:10Z sandygao $ */	TokenNameCOMMENT_JAVADOC	 Constraints shared by traversers and validator * @xerces.internal * @author Sandy Gao, IBM * @version $Id: XSConstraints.java 774786 2009-05-14 14:31:10Z sandygao $ 
public	TokenNamepublic	
class	TokenNameclass	
XSConstraints	TokenNameIdentifier	 XS Constraints
{	TokenNameLBRACE	
// IHR: Visited on 2006-11-17 	TokenNameCOMMENT_LINE	IHR: Visited on 2006-11-17 
// Added a boolean return value to particleValidRestriction (it was a void function) 	TokenNameCOMMENT_LINE	Added a boolean return value to particleValidRestriction (it was a void function) 
// to help the checkRecurseLax to know when expansion has happened and no order is required 	TokenNameCOMMENT_LINE	to help the checkRecurseLax to know when expansion has happened and no order is required 
// (IHR@xbrl.org) (Ignacio@Hernandez-Ros.com) 	TokenNameCOMMENT_LINE	(IHR@xbrl.org) (Ignacio@Hernandez-Ros.com) 
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
OCCURRENCE_UNKNOWN	TokenNameIdentifier	 OCCURRENCE  UNKNOWN
=	TokenNameEQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
OCCURRENCE_UNBOUNDED	TokenNameIdentifier	 OCCURRENCE  UNBOUNDED
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
STRING_TYPE	TokenNameIdentifier	 STRING  TYPE
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
)	TokenNameRPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
SG_SchemaNS	TokenNameIdentifier	 SG  Schema NS
.	TokenNameDOT	
getGlobalTypeDecl	TokenNameIdentifier	 get Global Type Decl
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATTVAL_STRING	TokenNameIdentifier	 ATTVAL  STRING
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
fEmptyParticle	TokenNameIdentifier	 f Empty Particle
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
getEmptySequence	TokenNameIdentifier	 get Empty Sequence
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fEmptyParticle	TokenNameIdentifier	 f Empty Particle
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
group	TokenNameIdentifier	 group
=	TokenNameEQUAL	
new	TokenNamenew	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
group	TokenNameIdentifier	 group
.	TokenNameDOT	
fCompositor	TokenNameIdentifier	 f Compositor
=	TokenNameEQUAL	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_SEQUENCE	TokenNameIdentifier	 MODELGROUP  SEQUENCE
;	TokenNameSEMICOLON	
group	TokenNameIdentifier	 group
.	TokenNameDOT	
fParticleCount	TokenNameIdentifier	 f Particle Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
group	TokenNameIdentifier	 group
.	TokenNameDOT	
fParticles	TokenNameIdentifier	 f Particles
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
group	TokenNameIdentifier	 group
.	TokenNameDOT	
fAnnotations	TokenNameIdentifier	 f Annotations
=	TokenNameEQUAL	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
.	TokenNameDOT	
EMPTY_LIST	TokenNameIdentifier	 EMPTY  LIST
;	TokenNameSEMICOLON	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
particle	TokenNameIdentifier	 particle
=	TokenNameEQUAL	
new	TokenNamenew	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
particle	TokenNameIdentifier	 particle
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
=	TokenNameEQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_MODELGROUP	TokenNameIdentifier	 PARTICLE  MODELGROUP
;	TokenNameSEMICOLON	
particle	TokenNameIdentifier	 particle
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
=	TokenNameEQUAL	
group	TokenNameIdentifier	 group
;	TokenNameSEMICOLON	
particle	TokenNameIdentifier	 particle
.	TokenNameDOT	
fAnnotations	TokenNameIdentifier	 f Annotations
=	TokenNameEQUAL	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
.	TokenNameDOT	
EMPTY_LIST	TokenNameIdentifier	 EMPTY  LIST
;	TokenNameSEMICOLON	
fEmptyParticle	TokenNameIdentifier	 f Empty Particle
=	TokenNameEQUAL	
particle	TokenNameIdentifier	 particle
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
fEmptyParticle	TokenNameIdentifier	 f Empty Particle
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Comparator	TokenNameIdentifier	 Comparator
ELEMENT_PARTICLE_COMPARATOR	TokenNameIdentifier	 ELEMENT  PARTICLE  COMPARATOR
=	TokenNameEQUAL	
new	TokenNamenew	
Comparator	TokenNameIdentifier	 Comparator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
int	TokenNameint	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
o1	TokenNameIdentifier	 o1
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
o2	TokenNameIdentifier	 o2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
pDecl1	TokenNameIdentifier	 p Decl1
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
)	TokenNameRPAREN	
o1	TokenNameIdentifier	 o1
;	TokenNameSEMICOLON	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
pDecl2	TokenNameIdentifier	 p Decl2
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
)	TokenNameRPAREN	
o2	TokenNameIdentifier	 o2
;	TokenNameSEMICOLON	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
decl1	TokenNameIdentifier	 decl1
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
pDecl1	TokenNameIdentifier	 p Decl1
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
;	TokenNameSEMICOLON	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
decl2	TokenNameIdentifier	 decl2
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
pDecl2	TokenNameIdentifier	 p Decl2
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
namespace1	TokenNameIdentifier	 namespace1
=	TokenNameEQUAL	
decl1	TokenNameIdentifier	 decl1
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
namespace2	TokenNameIdentifier	 namespace2
=	TokenNameEQUAL	
decl2	TokenNameIdentifier	 decl2
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
name1	TokenNameIdentifier	 name1
=	TokenNameEQUAL	
decl1	TokenNameIdentifier	 decl1
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
name2	TokenNameIdentifier	 name2
=	TokenNameEQUAL	
decl2	TokenNameIdentifier	 decl2
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
sameNamespace	TokenNameIdentifier	 same Namespace
=	TokenNameEQUAL	
(	TokenNameLPAREN	
namespace1	TokenNameIdentifier	 namespace1
==	TokenNameEQUAL_EQUAL	
namespace2	TokenNameIdentifier	 namespace2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
namespaceComparison	TokenNameIdentifier	 namespace Comparison
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
sameNamespace	TokenNameIdentifier	 same Namespace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
namespace1	TokenNameIdentifier	 namespace1
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
namespace2	TokenNameIdentifier	 namespace2
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
namespaceComparison	TokenNameIdentifier	 namespace Comparison
=	TokenNameEQUAL	
namespace1	TokenNameIdentifier	 namespace1
.	TokenNameDOT	
compareTo	TokenNameIdentifier	 compare To
(	TokenNameLPAREN	
namespace2	TokenNameIdentifier	 namespace2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
namespaceComparison	TokenNameIdentifier	 namespace Comparison
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
namespaceComparison	TokenNameIdentifier	 namespace Comparison
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//This assumes that the names are never null. 	TokenNameCOMMENT_LINE	This assumes that the names are never null. 
return	TokenNamereturn	
namespaceComparison	TokenNameIdentifier	 namespace Comparison
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
namespaceComparison	TokenNameIdentifier	 namespace Comparison
:	TokenNameCOLON	
name1	TokenNameIdentifier	 name1
.	TokenNameDOT	
compareTo	TokenNameIdentifier	 compare To
(	TokenNameLPAREN	
name2	TokenNameIdentifier	 name2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** * check whether derived is valid derived from base, given a subset * of {restriction, extension}.B */	TokenNameCOMMENT_JAVADOC	 check whether derived is valid derived from base, given a subset of {restriction, extension}.B 
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
checkTypeDerivationOk	TokenNameIdentifier	 check Type Derivation Ok
(	TokenNameLPAREN	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
derived	TokenNameIdentifier	 derived
,	TokenNameCOMMA	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
short	TokenNameshort	
block	TokenNameIdentifier	 block
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if derived is anyType, then it's valid only if base is anyType too 	TokenNameCOMMENT_LINE	if derived is anyType, then it's valid only if base is anyType too 
if	TokenNameif	
(	TokenNameLPAREN	
derived	TokenNameIdentifier	 derived
==	TokenNameEQUAL_EQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnyType	TokenNameIdentifier	 f Any Type
)	TokenNameRPAREN	
return	TokenNamereturn	
derived	TokenNameIdentifier	 derived
==	TokenNameEQUAL_EQUAL	
base	TokenNameIdentifier	 base
;	TokenNameSEMICOLON	
// if derived is anySimpleType, then it's valid only if the base 	TokenNameCOMMENT_LINE	if derived is anySimpleType, then it's valid only if the base 
// is ur-type 	TokenNameCOMMENT_LINE	is ur-type 
if	TokenNameif	
(	TokenNameLPAREN	
derived	TokenNameIdentifier	 derived
==	TokenNameEQUAL_EQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnySimpleType	TokenNameIdentifier	 f Any Simple Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
==	TokenNameEQUAL_EQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnyType	TokenNameIdentifier	 f Any Type
||	TokenNameOR_OR	
base	TokenNameIdentifier	 base
==	TokenNameEQUAL_EQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnySimpleType	TokenNameIdentifier	 f Any Simple Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if derived is simple type 	TokenNameCOMMENT_LINE	if derived is simple type 
if	TokenNameif	
(	TokenNameLPAREN	
derived	TokenNameIdentifier	 derived
.	TokenNameDOT	
getTypeCategory	TokenNameIdentifier	 get Type Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
.	TokenNameDOT	
SIMPLE_TYPE	TokenNameIdentifier	 SIMPLE  TYPE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if base is complex type 	TokenNameCOMMENT_LINE	if base is complex type 
if	TokenNameif	
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
.	TokenNameDOT	
getTypeCategory	TokenNameIdentifier	 get Type Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
.	TokenNameDOT	
COMPLEX_TYPE	TokenNameIdentifier	 COMPLEX  TYPE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if base is anyType, change base to anySimpleType, 	TokenNameCOMMENT_LINE	if base is anyType, change base to anySimpleType, 
// otherwise, not valid 	TokenNameCOMMENT_LINE	otherwise, not valid 
if	TokenNameif	
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
==	TokenNameEQUAL_EQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnyType	TokenNameIdentifier	 f Any Type
)	TokenNameRPAREN	
base	TokenNameIdentifier	 base
=	TokenNameEQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnySimpleType	TokenNameIdentifier	 f Any Simple Type
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
checkSimpleDerivation	TokenNameIdentifier	 check Simple Derivation
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
)	TokenNameRPAREN	
derived	TokenNameIdentifier	 derived
,	TokenNameCOMMA	
(	TokenNameLPAREN	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
)	TokenNameRPAREN	
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
block	TokenNameIdentifier	 block
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
checkComplexDerivation	TokenNameIdentifier	 check Complex Derivation
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
derived	TokenNameIdentifier	 derived
,	TokenNameCOMMA	
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
block	TokenNameIdentifier	 block
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * check whether simple type derived is valid derived from base, * given a subset of {restriction, extension}. */	TokenNameCOMMENT_JAVADOC	 check whether simple type derived is valid derived from base, given a subset of {restriction, extension}. 
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
checkSimpleDerivationOk	TokenNameIdentifier	 check Simple Derivation Ok
(	TokenNameLPAREN	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
derived	TokenNameIdentifier	 derived
,	TokenNameCOMMA	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
short	TokenNameshort	
block	TokenNameIdentifier	 block
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if derived is anySimpleType, then it's valid only if the base 	TokenNameCOMMENT_LINE	if derived is anySimpleType, then it's valid only if the base 
// is ur-type 	TokenNameCOMMENT_LINE	is ur-type 
if	TokenNameif	
(	TokenNameLPAREN	
derived	TokenNameIdentifier	 derived
==	TokenNameEQUAL_EQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnySimpleType	TokenNameIdentifier	 f Any Simple Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
==	TokenNameEQUAL_EQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnyType	TokenNameIdentifier	 f Any Type
||	TokenNameOR_OR	
base	TokenNameIdentifier	 base
==	TokenNameEQUAL_EQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnySimpleType	TokenNameIdentifier	 f Any Simple Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if base is complex type 	TokenNameCOMMENT_LINE	if base is complex type 
if	TokenNameif	
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
.	TokenNameDOT	
getTypeCategory	TokenNameIdentifier	 get Type Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
.	TokenNameDOT	
COMPLEX_TYPE	TokenNameIdentifier	 COMPLEX  TYPE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if base is anyType, change base to anySimpleType, 	TokenNameCOMMENT_LINE	if base is anyType, change base to anySimpleType, 
// otherwise, not valid 	TokenNameCOMMENT_LINE	otherwise, not valid 
if	TokenNameif	
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
==	TokenNameEQUAL_EQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnyType	TokenNameIdentifier	 f Any Type
)	TokenNameRPAREN	
base	TokenNameIdentifier	 base
=	TokenNameEQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnySimpleType	TokenNameIdentifier	 f Any Simple Type
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
checkSimpleDerivation	TokenNameIdentifier	 check Simple Derivation
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
)	TokenNameRPAREN	
derived	TokenNameIdentifier	 derived
,	TokenNameCOMMA	
(	TokenNameLPAREN	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
)	TokenNameRPAREN	
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
block	TokenNameIdentifier	 block
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * check whether complex type derived is valid derived from base, * given a subset of {restriction, extension}. */	TokenNameCOMMENT_JAVADOC	 check whether complex type derived is valid derived from base, given a subset of {restriction, extension}. 
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
checkComplexDerivationOk	TokenNameIdentifier	 check Complex Derivation Ok
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
derived	TokenNameIdentifier	 derived
,	TokenNameCOMMA	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
short	TokenNameshort	
block	TokenNameIdentifier	 block
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if derived is anyType, then it's valid only if base is anyType too 	TokenNameCOMMENT_LINE	if derived is anyType, then it's valid only if base is anyType too 
if	TokenNameif	
(	TokenNameLPAREN	
derived	TokenNameIdentifier	 derived
==	TokenNameEQUAL_EQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnyType	TokenNameIdentifier	 f Any Type
)	TokenNameRPAREN	
return	TokenNamereturn	
derived	TokenNameIdentifier	 derived
==	TokenNameEQUAL_EQUAL	
base	TokenNameIdentifier	 base
;	TokenNameSEMICOLON	
return	TokenNamereturn	
checkComplexDerivation	TokenNameIdentifier	 check Complex Derivation
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
derived	TokenNameIdentifier	 derived
,	TokenNameCOMMA	
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
block	TokenNameIdentifier	 block
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Note: this will be a private method, and it assumes that derived is not * anySimpleType, and base is not anyType. Another method will be * introduced for public use, which will call this method. */	TokenNameCOMMENT_JAVADOC	 Note: this will be a private method, and it assumes that derived is not anySimpleType, and base is not anyType. Another method will be introduced for public use, which will call this method. 
private	TokenNameprivate	
static	TokenNamestatic	
boolean	TokenNameboolean	
checkSimpleDerivation	TokenNameIdentifier	 check Simple Derivation
(	TokenNameLPAREN	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
derived	TokenNameIdentifier	 derived
,	TokenNameCOMMA	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
short	TokenNameshort	
block	TokenNameIdentifier	 block
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 1 They are the same type definition. 	TokenNameCOMMENT_LINE	1 They are the same type definition. 
if	TokenNameif	
(	TokenNameLPAREN	
derived	TokenNameIdentifier	 derived
==	TokenNameEQUAL_EQUAL	
base	TokenNameIdentifier	 base
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// 2 All of the following must be true: 	TokenNameCOMMENT_LINE	2 All of the following must be true: 
// 2.1 restriction is not in the subset, or in the {final} of its own {base type definition}; 	TokenNameCOMMENT_LINE	2.1 restriction is not in the subset, or in the {final} of its own {base type definition}; 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
block	TokenNameIdentifier	 block
&	TokenNameAND	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
derived	TokenNameIdentifier	 derived
.	TokenNameDOT	
getBaseType	TokenNameIdentifier	 get Base Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getFinal	TokenNameIdentifier	 get Final
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&	TokenNameAND	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 2.2 One of the following must be true: 	TokenNameCOMMENT_LINE	2.2 One of the following must be true: 
// 2.2.1 D's base type definition is B. 	TokenNameCOMMENT_LINE	2.2.1 D's base type definition is B. 
XSSimpleType	TokenNameIdentifier	 XS Simple Type
directBase	TokenNameIdentifier	 direct Base
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
)	TokenNameRPAREN	
derived	TokenNameIdentifier	 derived
.	TokenNameDOT	
getBaseType	TokenNameIdentifier	 get Base Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
directBase	TokenNameIdentifier	 direct Base
==	TokenNameEQUAL_EQUAL	
base	TokenNameIdentifier	 base
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// 2.2.2 D's base type definition is not the simple ur-type definition and is validly derived from B given the subset, as defined by this constraint. 	TokenNameCOMMENT_LINE	2.2.2 D's base type definition is not the simple ur-type definition and is validly derived from B given the subset, as defined by this constraint. 
if	TokenNameif	
(	TokenNameLPAREN	
directBase	TokenNameIdentifier	 direct Base
!=	TokenNameNOT_EQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnySimpleType	TokenNameIdentifier	 f Any Simple Type
&&	TokenNameAND_AND	
checkSimpleDerivation	TokenNameIdentifier	 check Simple Derivation
(	TokenNameLPAREN	
directBase	TokenNameIdentifier	 direct Base
,	TokenNameCOMMA	
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
block	TokenNameIdentifier	 block
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 2.2.3 D's {variety} is list or union and B is the simple ur-type definition. 	TokenNameCOMMENT_LINE	2.2.3 D's {variety} is list or union and B is the simple ur-type definition. 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
derived	TokenNameIdentifier	 derived
.	TokenNameDOT	
getVariety	TokenNameIdentifier	 get Variety
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
.	TokenNameDOT	
VARIETY_LIST	TokenNameIdentifier	 VARIETY  LIST
||	TokenNameOR_OR	
derived	TokenNameIdentifier	 derived
.	TokenNameDOT	
getVariety	TokenNameIdentifier	 get Variety
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
.	TokenNameDOT	
VARIETY_UNION	TokenNameIdentifier	 VARIETY  UNION
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
base	TokenNameIdentifier	 base
==	TokenNameEQUAL_EQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnySimpleType	TokenNameIdentifier	 f Any Simple Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 2.2.4 B's {variety} is union and D is validly derived from a type definition in B's {member type definitions} given the subset, as defined by this constraint. 	TokenNameCOMMENT_LINE	2.2.4 B's {variety} is union and D is validly derived from a type definition in B's {member type definitions} given the subset, as defined by this constraint. 
if	TokenNameif	
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
.	TokenNameDOT	
getVariety	TokenNameIdentifier	 get Variety
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
.	TokenNameDOT	
VARIETY_UNION	TokenNameIdentifier	 VARIETY  UNION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSObjectList	TokenNameIdentifier	 XS Object List
subUnionMemberDV	TokenNameIdentifier	 sub Union Member DV
=	TokenNameEQUAL	
base	TokenNameIdentifier	 base
.	TokenNameDOT	
getMemberTypes	TokenNameIdentifier	 get Member Types
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
subUnionSize	TokenNameIdentifier	 sub Union Size
=	TokenNameEQUAL	
subUnionMemberDV	TokenNameIdentifier	 sub Union Member DV
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
subUnionSize	TokenNameIdentifier	 sub Union Size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
base	TokenNameIdentifier	 base
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
)	TokenNameRPAREN	
subUnionMemberDV	TokenNameIdentifier	 sub Union Member DV
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
checkSimpleDerivation	TokenNameIdentifier	 check Simple Derivation
(	TokenNameLPAREN	
derived	TokenNameIdentifier	 derived
,	TokenNameCOMMA	
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
block	TokenNameIdentifier	 block
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Note: this will be a private method, and it assumes that derived is not * anyType. Another method will be introduced for public use, * which will call this method. */	TokenNameCOMMENT_JAVADOC	 Note: this will be a private method, and it assumes that derived is not anyType. Another method will be introduced for public use, which will call this method. 
private	TokenNameprivate	
static	TokenNamestatic	
boolean	TokenNameboolean	
checkComplexDerivation	TokenNameIdentifier	 check Complex Derivation
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
derived	TokenNameIdentifier	 derived
,	TokenNameCOMMA	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
short	TokenNameshort	
block	TokenNameIdentifier	 block
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 2.1 B and D must be the same type definition. 	TokenNameCOMMENT_LINE	2.1 B and D must be the same type definition. 
if	TokenNameif	
(	TokenNameLPAREN	
derived	TokenNameIdentifier	 derived
==	TokenNameEQUAL_EQUAL	
base	TokenNameIdentifier	 base
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// 1 If B and D are not the same type definition, then the {derivation method} of D must not be in the subset. 	TokenNameCOMMENT_LINE	1 If B and D are not the same type definition, then the {derivation method} of D must not be in the subset. 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
derived	TokenNameIdentifier	 derived
.	TokenNameDOT	
fDerivedBy	TokenNameIdentifier	 f Derived By
&	TokenNameAND	
block	TokenNameIdentifier	 block
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// 2 One of the following must be true: 	TokenNameCOMMENT_LINE	2 One of the following must be true: 
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
directBase	TokenNameIdentifier	 direct Base
=	TokenNameEQUAL	
derived	TokenNameIdentifier	 derived
.	TokenNameDOT	
fBaseType	TokenNameIdentifier	 f Base Type
;	TokenNameSEMICOLON	
// 2.2 B must be D's {base type definition}. 	TokenNameCOMMENT_LINE	2.2 B must be D's {base type definition}. 
if	TokenNameif	
(	TokenNameLPAREN	
directBase	TokenNameIdentifier	 direct Base
==	TokenNameEQUAL_EQUAL	
base	TokenNameIdentifier	 base
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// 2.3 All of the following must be true: 	TokenNameCOMMENT_LINE	2.3 All of the following must be true: 
// 2.3.1 D's {base type definition} must not be the ur-type definition. 	TokenNameCOMMENT_LINE	2.3.1 D's {base type definition} must not be the ur-type definition. 
if	TokenNameif	
(	TokenNameLPAREN	
directBase	TokenNameIdentifier	 direct Base
==	TokenNameEQUAL_EQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnyType	TokenNameIdentifier	 f Any Type
||	TokenNameOR_OR	
directBase	TokenNameIdentifier	 direct Base
==	TokenNameEQUAL_EQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnySimpleType	TokenNameIdentifier	 f Any Simple Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 2.3.2 The appropriate case among the following must be true: 	TokenNameCOMMENT_LINE	2.3.2 The appropriate case among the following must be true: 
// 2.3.2.1 If D's {base type definition} is complex, then it must be validly derived from B given the subset as defined by this constraint. 	TokenNameCOMMENT_LINE	2.3.2.1 If D's {base type definition} is complex, then it must be validly derived from B given the subset as defined by this constraint. 
if	TokenNameif	
(	TokenNameLPAREN	
directBase	TokenNameIdentifier	 direct Base
.	TokenNameDOT	
getTypeCategory	TokenNameIdentifier	 get Type Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
.	TokenNameDOT	
COMPLEX_TYPE	TokenNameIdentifier	 COMPLEX  TYPE
)	TokenNameRPAREN	
return	TokenNamereturn	
checkComplexDerivation	TokenNameIdentifier	 check Complex Derivation
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
directBase	TokenNameIdentifier	 direct Base
,	TokenNameCOMMA	
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
block	TokenNameIdentifier	 block
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 2.3.2.2 If D's {base type definition} is simple, then it must be validly derived from B given the subset as defined in Type Derivation OK (Simple) (3.14.6). 	TokenNameCOMMENT_LINE	2.3.2.2 If D's {base type definition} is simple, then it must be validly derived from B given the subset as defined in Type Derivation OK (Simple) (3.14.6). 
if	TokenNameif	
(	TokenNameLPAREN	
directBase	TokenNameIdentifier	 direct Base
.	TokenNameDOT	
getTypeCategory	TokenNameIdentifier	 get Type Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
.	TokenNameDOT	
SIMPLE_TYPE	TokenNameIdentifier	 SIMPLE  TYPE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if base is complex type 	TokenNameCOMMENT_LINE	if base is complex type 
if	TokenNameif	
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
.	TokenNameDOT	
getTypeCategory	TokenNameIdentifier	 get Type Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
.	TokenNameDOT	
COMPLEX_TYPE	TokenNameIdentifier	 COMPLEX  TYPE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if base is anyType, change base to anySimpleType, 	TokenNameCOMMENT_LINE	if base is anyType, change base to anySimpleType, 
// otherwise, not valid 	TokenNameCOMMENT_LINE	otherwise, not valid 
if	TokenNameif	
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
==	TokenNameEQUAL_EQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnyType	TokenNameIdentifier	 f Any Type
)	TokenNameRPAREN	
base	TokenNameIdentifier	 base
=	TokenNameEQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnySimpleType	TokenNameIdentifier	 f Any Simple Type
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
checkSimpleDerivation	TokenNameIdentifier	 check Simple Derivation
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
)	TokenNameRPAREN	
directBase	TokenNameIdentifier	 direct Base
,	TokenNameCOMMA	
(	TokenNameLPAREN	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
)	TokenNameRPAREN	
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
block	TokenNameIdentifier	 block
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * check whether a value is a valid default for some type * returns the compiled form of the value * The parameter value could be either a String or a ValidatedInfo object */	TokenNameCOMMENT_JAVADOC	 check whether a value is a valid default for some type returns the compiled form of the value The parameter value could be either a String or a ValidatedInfo object 
public	TokenNamepublic	
static	TokenNamestatic	
Object	TokenNameIdentifier	 Object
ElementDefaultValidImmediate	TokenNameIdentifier	 Element Default Valid Immediate
(	TokenNameLPAREN	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
ValidationContext	TokenNameIdentifier	 Validation Context
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
ValidatedInfo	TokenNameIdentifier	 Validated Info
vinfo	TokenNameIdentifier	 vinfo
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
dv	TokenNameIdentifier	 dv
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// e-props-correct 	TokenNameCOMMENT_LINE	e-props-correct 
// For a string to be a valid default with respect to a type definition the appropriate case among the following must be true: 	TokenNameCOMMENT_LINE	For a string to be a valid default with respect to a type definition the appropriate case among the following must be true: 
// 1 If the type definition is a simple type definition, then the string must be valid with respect to that definition as defined by String Valid (3.14.4). 	TokenNameCOMMENT_LINE	1 If the type definition is a simple type definition, then the string must be valid with respect to that definition as defined by String Valid (3.14.4). 
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getTypeCategory	TokenNameIdentifier	 get Type Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
.	TokenNameDOT	
SIMPLE_TYPE	TokenNameIdentifier	 SIMPLE  TYPE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dv	TokenNameIdentifier	 dv
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 2 If the type definition is a complex type definition, then all of the following must be true: 	TokenNameCOMMENT_LINE	2 If the type definition is a complex type definition, then all of the following must be true: 
else	TokenNameelse	
{	TokenNameLBRACE	
// 2.1 its {content type} must be a simple type definition or mixed. 	TokenNameCOMMENT_LINE	2.1 its {content type} must be a simple type definition or mixed. 
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
ctype	TokenNameIdentifier	 ctype
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
// 2.2 The appropriate case among the following must be true: 	TokenNameCOMMENT_LINE	2.2 The appropriate case among the following must be true: 
// 2.2.1 If the {content type} is a simple type definition, then the string must be valid with respect to that simple type definition as defined by String Valid (3.14.4). 	TokenNameCOMMENT_LINE	2.2.1 If the {content type} is a simple type definition, then the string must be valid with respect to that simple type definition as defined by String Valid (3.14.4). 
if	TokenNameif	
(	TokenNameLPAREN	
ctype	TokenNameIdentifier	 ctype
.	TokenNameDOT	
fContentType	TokenNameIdentifier	 f Content Type
==	TokenNameEQUAL_EQUAL	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
.	TokenNameDOT	
CONTENTTYPE_SIMPLE	TokenNameIdentifier	 CONTENTTYPE  SIMPLE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dv	TokenNameIdentifier	 dv
=	TokenNameEQUAL	
ctype	TokenNameIdentifier	 ctype
.	TokenNameDOT	
fXSSimpleType	TokenNameIdentifier	 f XS Simple Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 2.2.2 If the {content type} is mixed, then the {content type}'s particle must be emptiable as defined by Particle Emptiable (3.9.6). 	TokenNameCOMMENT_LINE	2.2.2 If the {content type} is mixed, then the {content type}'s particle must be emptiable as defined by Particle Emptiable (3.9.6). 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
ctype	TokenNameIdentifier	 ctype
.	TokenNameDOT	
fContentType	TokenNameIdentifier	 f Content Type
==	TokenNameEQUAL_EQUAL	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
.	TokenNameDOT	
CONTENTTYPE_MIXED	TokenNameIdentifier	 CONTENTTYPE  MIXED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
)	TokenNameRPAREN	
ctype	TokenNameIdentifier	 ctype
.	TokenNameDOT	
getParticle	TokenNameIdentifier	 get Particle
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
emptiable	TokenNameIdentifier	 emptiable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// get the simple type declaration, and validate 	TokenNameCOMMENT_LINE	get the simple type declaration, and validate 
Object	TokenNameIdentifier	 Object
actualValue	TokenNameIdentifier	 actual Value
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dv	TokenNameIdentifier	 dv
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// complex type with mixed. to make sure that we store correct 	TokenNameCOMMENT_LINE	complex type with mixed. to make sure that we store correct 
// information in vinfo and return the correct value, we use 	TokenNameCOMMENT_LINE	information in vinfo and return the correct value, we use 
// "string" type for validation 	TokenNameCOMMENT_LINE	"string" type for validation 
dv	TokenNameIdentifier	 dv
=	TokenNameEQUAL	
STRING_TYPE	TokenNameIdentifier	 STRING  TYPE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
// validate the original lexical rep, and set the actual value 	TokenNameCOMMENT_LINE	validate the original lexical rep, and set the actual value 
actualValue	TokenNameIdentifier	 actual Value
=	TokenNameEQUAL	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
vinfo	TokenNameIdentifier	 vinfo
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// validate the canonical lexical rep 	TokenNameCOMMENT_LINE	validate the canonical lexical rep 
if	TokenNameif	
(	TokenNameLPAREN	
vinfo	TokenNameIdentifier	 vinfo
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
actualValue	TokenNameIdentifier	 actual Value
=	TokenNameEQUAL	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
vinfo	TokenNameIdentifier	 vinfo
.	TokenNameDOT	
stringValue	TokenNameIdentifier	 string Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
vinfo	TokenNameIdentifier	 vinfo
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
ide	TokenNameIdentifier	 ide
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
actualValue	TokenNameIdentifier	 actual Value
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
static	TokenNamestatic	
void	TokenNamevoid	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
errorReporter	TokenNameIdentifier	 error Reporter
,	TokenNameCOMMA	
SimpleLocator	TokenNameIdentifier	 Simple Locator
loc	TokenNameIdentifier	 loc
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
args	TokenNameIdentifier	 args
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
loc	TokenNameIdentifier	 loc
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
errorReporter	TokenNameIdentifier	 error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
loc	TokenNameIdentifier	 loc
,	TokenNameCOMMA	
XSMessageFormatter	TokenNameIdentifier	 XS Message Formatter
.	TokenNameDOT	
SCHEMA_DOMAIN	TokenNameIdentifier	 SCHEMA  DOMAIN
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
args	TokenNameIdentifier	 args
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
errorReporter	TokenNameIdentifier	 error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XSMessageFormatter	TokenNameIdentifier	 XS Message Formatter
.	TokenNameDOT	
SCHEMA_DOMAIN	TokenNameIdentifier	 SCHEMA  DOMAIN
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
args	TokenNameIdentifier	 args
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * used to check the 3 constraints against each complex type * (should be each model group): * Unique Particle Attribution, Particle Derivation (Restriction), * Element Declrations Consistent. */	TokenNameCOMMENT_JAVADOC	 used to check the 3 constraints against each complex type (should be each model group): Unique Particle Attribution, Particle Derivation (Restriction), Element Declrations Consistent. 
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
fullSchemaChecking	TokenNameIdentifier	 full Schema Checking
(	TokenNameLPAREN	
XSGrammarBucket	TokenNameIdentifier	 XS Grammar Bucket
grammarBucket	TokenNameIdentifier	 grammar Bucket
,	TokenNameCOMMA	
SubstitutionGroupHandler	TokenNameIdentifier	 Substitution Group Handler
SGHandler	TokenNameIdentifier	 SG Handler
,	TokenNameCOMMA	
CMBuilder	TokenNameIdentifier	 CM Builder
cmBuilder	TokenNameIdentifier	 cm Builder
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
errorReporter	TokenNameIdentifier	 error Reporter
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// get all grammars, and put all substitution group information 	TokenNameCOMMENT_LINE	get all grammars, and put all substitution group information 
// in the substitution group handler 	TokenNameCOMMENT_LINE	in the substitution group handler 
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
grammars	TokenNameIdentifier	 grammars
=	TokenNameEQUAL	
grammarBucket	TokenNameIdentifier	 grammar Bucket
.	TokenNameDOT	
getGrammars	TokenNameIdentifier	 get Grammars
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
grammars	TokenNameIdentifier	 grammars
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SGHandler	TokenNameIdentifier	 SG Handler
.	TokenNameDOT	
addSubstitutionGroup	TokenNameIdentifier	 add Substitution Group
(	TokenNameLPAREN	
grammars	TokenNameIdentifier	 grammars
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
getSubstitutionGroups	TokenNameIdentifier	 get Substitution Groups
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
fakeDerived	TokenNameIdentifier	 fake Derived
=	TokenNameEQUAL	
new	TokenNamenew	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
fakeBase	TokenNameIdentifier	 fake Base
=	TokenNameEQUAL	
new	TokenNamenew	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fakeDerived	TokenNameIdentifier	 fake Derived
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
=	TokenNameEQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_MODELGROUP	TokenNameIdentifier	 PARTICLE  MODELGROUP
;	TokenNameSEMICOLON	
fakeBase	TokenNameIdentifier	 fake Base
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
=	TokenNameEQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_MODELGROUP	TokenNameIdentifier	 PARTICLE  MODELGROUP
;	TokenNameSEMICOLON	
// before worrying about complexTypes, let's get 	TokenNameCOMMENT_LINE	before worrying about complexTypes, let's get 
// groups redefined by restriction out of the way. 	TokenNameCOMMENT_LINE	groups redefined by restriction out of the way. 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
grammars	TokenNameIdentifier	 grammars
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
g	TokenNameIdentifier	 g
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
g	TokenNameIdentifier	 g
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSGroupDecl	TokenNameIdentifier	 XS Group Decl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
redefinedGroups	TokenNameIdentifier	 redefined Groups
=	TokenNameEQUAL	
grammars	TokenNameIdentifier	 grammars
[	TokenNameLBRACKET	
g	TokenNameIdentifier	 g
]	TokenNameRBRACKET	
.	TokenNameDOT	
getRedefinedGroupDecls	TokenNameIdentifier	 get Redefined Group Decls
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SimpleLocator	TokenNameIdentifier	 Simple Locator
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
rgLocators	TokenNameIdentifier	 rg Locators
=	TokenNameEQUAL	
grammars	TokenNameIdentifier	 grammars
[	TokenNameLBRACKET	
g	TokenNameIdentifier	 g
]	TokenNameRBRACKET	
.	TokenNameDOT	
getRGLocators	TokenNameIdentifier	 get RG Locators
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
redefinedGroups	TokenNameIdentifier	 redefined Groups
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSGroupDecl	TokenNameIdentifier	 XS Group Decl
derivedGrp	TokenNameIdentifier	 derived Grp
=	TokenNameEQUAL	
redefinedGroups	TokenNameIdentifier	 redefined Groups
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
derivedMG	TokenNameIdentifier	 derived MG
=	TokenNameEQUAL	
derivedGrp	TokenNameIdentifier	 derived Grp
.	TokenNameDOT	
fModelGroup	TokenNameIdentifier	 f Model Group
;	TokenNameSEMICOLON	
XSGroupDecl	TokenNameIdentifier	 XS Group Decl
baseGrp	TokenNameIdentifier	 base Grp
=	TokenNameEQUAL	
redefinedGroups	TokenNameIdentifier	 redefined Groups
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
baseMG	TokenNameIdentifier	 base MG
=	TokenNameEQUAL	
baseGrp	TokenNameIdentifier	 base Grp
.	TokenNameDOT	
fModelGroup	TokenNameIdentifier	 f Model Group
;	TokenNameSEMICOLON	
fakeDerived	TokenNameIdentifier	 fake Derived
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
=	TokenNameEQUAL	
derivedMG	TokenNameIdentifier	 derived MG
;	TokenNameSEMICOLON	
fakeBase	TokenNameIdentifier	 fake Base
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
=	TokenNameEQUAL	
baseMG	TokenNameIdentifier	 base MG
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
baseMG	TokenNameIdentifier	 base MG
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
derivedMG	TokenNameIdentifier	 derived MG
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// can't be a restriction! 	TokenNameCOMMENT_LINE	can't be a restriction! 
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
errorReporter	TokenNameIdentifier	 error Reporter
,	TokenNameCOMMA	
rgLocators	TokenNameIdentifier	 rg Locators
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
"src-redefine.6.2.2"	TokenNameStringLiteral	src-redefine.6.2.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
derivedGrp	TokenNameIdentifier	 derived Grp
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
"rcase-Recurse.2"	TokenNameStringLiteral	rcase-Recurse.2
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
derivedMG	TokenNameIdentifier	 derived MG
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fakeBase	TokenNameIdentifier	 fake Base
.	TokenNameDOT	
emptiable	TokenNameIdentifier	 emptiable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
errorReporter	TokenNameIdentifier	 error Reporter
,	TokenNameCOMMA	
rgLocators	TokenNameIdentifier	 rg Locators
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
"src-redefine.6.2.2"	TokenNameStringLiteral	src-redefine.6.2.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
derivedGrp	TokenNameIdentifier	 derived Grp
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
"rcase-Recurse.2"	TokenNameStringLiteral	rcase-Recurse.2
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
particleValidRestriction	TokenNameIdentifier	 particle Valid Restriction
(	TokenNameLPAREN	
fakeDerived	TokenNameIdentifier	 fake Derived
,	TokenNameCOMMA	
SGHandler	TokenNameIdentifier	 SG Handler
,	TokenNameCOMMA	
fakeBase	TokenNameIdentifier	 fake Base
,	TokenNameCOMMA	
SGHandler	TokenNameIdentifier	 SG Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
errorReporter	TokenNameIdentifier	 error Reporter
,	TokenNameCOMMA	
rgLocators	TokenNameIdentifier	 rg Locators
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getArgs	TokenNameIdentifier	 get Args
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
errorReporter	TokenNameIdentifier	 error Reporter
,	TokenNameCOMMA	
rgLocators	TokenNameIdentifier	 rg Locators
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
"src-redefine.6.2.2"	TokenNameStringLiteral	src-redefine.6.2.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
derivedGrp	TokenNameIdentifier	 derived Grp
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// for each complex type, check the 3 constraints. 	TokenNameCOMMENT_LINE	for each complex type, check the 3 constraints. 
// types need to be checked 	TokenNameCOMMENT_LINE	types need to be checked 
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
types	TokenNameIdentifier	 types
;	TokenNameSEMICOLON	
SimpleLocator	TokenNameIdentifier	 Simple Locator
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
ctLocators	TokenNameIdentifier	 ct Locators
;	TokenNameSEMICOLON	
// to hold the errors 	TokenNameCOMMENT_LINE	to hold the errors 
// REVISIT: do we want to report all errors? or just one? 	TokenNameCOMMENT_LINE	REVISIT: do we want to report all errors? or just one? 
//XMLSchemaError1D errors = new XMLSchemaError1D(); 	TokenNameCOMMENT_LINE	XMLSchemaError1D errors = new XMLSchemaError1D(); 
// whether need to check this type again; 	TokenNameCOMMENT_LINE	whether need to check this type again; 
// whether only do UPA checking 	TokenNameCOMMENT_LINE	whether only do UPA checking 
boolean	TokenNameboolean	
further	TokenNameIdentifier	 further
,	TokenNameCOMMA	
fullChecked	TokenNameIdentifier	 full Checked
;	TokenNameSEMICOLON	
// if do all checkings, how many need to be checked again. 	TokenNameCOMMENT_LINE	if do all checkings, how many need to be checked again. 
int	TokenNameint	
keepType	TokenNameIdentifier	 keep Type
;	TokenNameSEMICOLON	
// i: grammar; j: type; k: error 	TokenNameCOMMENT_LINE	i: grammar; j: type; k: error 
// for all grammars 	TokenNameCOMMENT_LINE	for all grammars 
SymbolHash	TokenNameIdentifier	 Symbol Hash
elemTable	TokenNameIdentifier	 elem Table
=	TokenNameEQUAL	
new	TokenNamenew	
SymbolHash	TokenNameIdentifier	 Symbol Hash
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
grammars	TokenNameIdentifier	 grammars
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
j	TokenNameIdentifier	 j
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// get whether to skip EDC, and types need to be checked 	TokenNameCOMMENT_LINE	get whether to skip EDC, and types need to be checked 
keepType	TokenNameIdentifier	 keep Type
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fullChecked	TokenNameIdentifier	 full Checked
=	TokenNameEQUAL	
grammars	TokenNameIdentifier	 grammars
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
fFullChecked	TokenNameIdentifier	 f Full Checked
;	TokenNameSEMICOLON	
types	TokenNameIdentifier	 types
=	TokenNameEQUAL	
grammars	TokenNameIdentifier	 grammars
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
getUncheckedComplexTypeDecls	TokenNameIdentifier	 get Unchecked Complex Type Decls
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ctLocators	TokenNameIdentifier	 ct Locators
=	TokenNameEQUAL	
grammars	TokenNameIdentifier	 grammars
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
getUncheckedCTLocators	TokenNameIdentifier	 get Unchecked CT Locators
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// for each type 	TokenNameCOMMENT_LINE	for each type 
for	TokenNamefor	
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if we've already full-checked this grammar, then 	TokenNameCOMMENT_LINE	if we've already full-checked this grammar, then 
// skip the EDC constraint 	TokenNameCOMMENT_LINE	skip the EDC constraint 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fullChecked	TokenNameIdentifier	 full Checked
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 1. Element Decl Consistent 	TokenNameCOMMENT_LINE	1. Element Decl Consistent 
if	TokenNameif	
(	TokenNameLPAREN	
types	TokenNameIdentifier	 types
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
.	TokenNameDOT	
fParticle	TokenNameIdentifier	 f Particle
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
elemTable	TokenNameIdentifier	 elem Table
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
checkElementDeclsConsistent	TokenNameIdentifier	 check Element Decls Consistent
(	TokenNameLPAREN	
types	TokenNameIdentifier	 types
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
types	TokenNameIdentifier	 types
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
.	TokenNameDOT	
fParticle	TokenNameIdentifier	 f Particle
,	TokenNameCOMMA	
elemTable	TokenNameIdentifier	 elem Table
,	TokenNameCOMMA	
SGHandler	TokenNameIdentifier	 SG Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
errorReporter	TokenNameIdentifier	 error Reporter
,	TokenNameCOMMA	
ctLocators	TokenNameIdentifier	 ct Locators
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getArgs	TokenNameIdentifier	 get Args
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// 2. Particle Derivation 	TokenNameCOMMENT_LINE	2. Particle Derivation 
if	TokenNameif	
(	TokenNameLPAREN	
types	TokenNameIdentifier	 types
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
.	TokenNameDOT	
fBaseType	TokenNameIdentifier	 f Base Type
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
types	TokenNameIdentifier	 types
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
.	TokenNameDOT	
fBaseType	TokenNameIdentifier	 f Base Type
!=	TokenNameNOT_EQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnyType	TokenNameIdentifier	 f Any Type
&&	TokenNameAND_AND	
types	TokenNameIdentifier	 types
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
.	TokenNameDOT	
fDerivedBy	TokenNameIdentifier	 f Derived By
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
types	TokenNameIdentifier	 types
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
.	TokenNameDOT	
fBaseType	TokenNameIdentifier	 f Base Type
instanceof	TokenNameinstanceof	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
derivedParticle	TokenNameIdentifier	 derived Particle
=	TokenNameEQUAL	
types	TokenNameIdentifier	 types
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
.	TokenNameDOT	
fParticle	TokenNameIdentifier	 f Particle
;	TokenNameSEMICOLON	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
baseParticle	TokenNameIdentifier	 base Particle
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
(	TokenNameLPAREN	
types	TokenNameIdentifier	 types
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
.	TokenNameDOT	
fBaseType	TokenNameIdentifier	 f Base Type
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
fParticle	TokenNameIdentifier	 f Particle
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
derivedParticle	TokenNameIdentifier	 derived Particle
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
baseParticle	TokenNameIdentifier	 base Particle
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
baseParticle	TokenNameIdentifier	 base Particle
.	TokenNameDOT	
emptiable	TokenNameIdentifier	 emptiable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
errorReporter	TokenNameIdentifier	 error Reporter
,	TokenNameCOMMA	
ctLocators	TokenNameIdentifier	 ct Locators
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
"derivation-ok-restriction.5.3.2"	TokenNameStringLiteral	derivation-ok-restriction.5.3.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
types	TokenNameIdentifier	 types
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
types	TokenNameIdentifier	 types
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
.	TokenNameDOT	
fBaseType	TokenNameIdentifier	 f Base Type
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
baseParticle	TokenNameIdentifier	 base Particle
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
particleValidRestriction	TokenNameIdentifier	 particle Valid Restriction
(	TokenNameLPAREN	
types	TokenNameIdentifier	 types
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
.	TokenNameDOT	
fParticle	TokenNameIdentifier	 f Particle
,	TokenNameCOMMA	
SGHandler	TokenNameIdentifier	 SG Handler
,	TokenNameCOMMA	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
(	TokenNameLPAREN	
types	TokenNameIdentifier	 types
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
.	TokenNameDOT	
fBaseType	TokenNameIdentifier	 f Base Type
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
fParticle	TokenNameIdentifier	 f Particle
,	TokenNameCOMMA	
SGHandler	TokenNameIdentifier	 SG Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
errorReporter	TokenNameIdentifier	 error Reporter
,	TokenNameCOMMA	
ctLocators	TokenNameIdentifier	 ct Locators
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getArgs	TokenNameIdentifier	 get Args
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
errorReporter	TokenNameIdentifier	 error Reporter
,	TokenNameCOMMA	
ctLocators	TokenNameIdentifier	 ct Locators
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
"derivation-ok-restriction.5.4.2"	TokenNameStringLiteral	derivation-ok-restriction.5.4.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
types	TokenNameIdentifier	 types
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
errorReporter	TokenNameIdentifier	 error Reporter
,	TokenNameCOMMA	
ctLocators	TokenNameIdentifier	 ct Locators
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
"derivation-ok-restriction.5.4.2"	TokenNameStringLiteral	derivation-ok-restriction.5.4.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
types	TokenNameIdentifier	 types
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// 3. UPA 	TokenNameCOMMENT_LINE	3. UPA 
// get the content model and check UPA 	TokenNameCOMMENT_LINE	get the content model and check UPA 
XSCMValidator	TokenNameIdentifier	 XSCM Validator
cm	TokenNameIdentifier	 cm
=	TokenNameEQUAL	
types	TokenNameIdentifier	 types
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
.	TokenNameDOT	
getContentModel	TokenNameIdentifier	 get Content Model
(	TokenNameLPAREN	
cmBuilder	TokenNameIdentifier	 cm Builder
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
further	TokenNameIdentifier	 further
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cm	TokenNameIdentifier	 cm
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
further	TokenNameIdentifier	 further
=	TokenNameEQUAL	
cm	TokenNameIdentifier	 cm
.	TokenNameDOT	
checkUniqueParticleAttribution	TokenNameIdentifier	 check Unique Particle Attribution
(	TokenNameLPAREN	
SGHandler	TokenNameIdentifier	 SG Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
errorReporter	TokenNameIdentifier	 error Reporter
,	TokenNameCOMMA	
ctLocators	TokenNameIdentifier	 ct Locators
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getArgs	TokenNameIdentifier	 get Args
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// now report all errors 	TokenNameCOMMENT_LINE	now report all errors 
// REVISIT: do we want to report all errors? or just one? 	TokenNameCOMMENT_LINE	REVISIT: do we want to report all errors? or just one? 
/*for (k = errors.getErrorCodeNum()-1; k >= 0; k--) { reportSchemaError(errorReporter, ctLocators[j], errors.getErrorCode(k), errors.getArgs(k)); }*/	TokenNameCOMMENT_BLOCK	for (k = errors.getErrorCodeNum()-1; k >= 0; k--) { reportSchemaError(errorReporter, ctLocators[j], errors.getErrorCode(k), errors.getArgs(k)); }
// if we are doing all checkings, and this one needs further 	TokenNameCOMMENT_LINE	if we are doing all checkings, and this one needs further 
// checking, store it in the type array. 	TokenNameCOMMENT_LINE	checking, store it in the type array. 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fullChecked	TokenNameIdentifier	 full Checked
&&	TokenNameAND_AND	
further	TokenNameIdentifier	 further
)	TokenNameRPAREN	
types	TokenNameIdentifier	 types
[	TokenNameLBRACKET	
keepType	TokenNameIdentifier	 keep Type
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
types	TokenNameIdentifier	 types
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// clear errors for the next type. 	TokenNameCOMMENT_LINE	clear errors for the next type. 
// REVISIT: do we want to report all errors? or just one? 	TokenNameCOMMENT_LINE	REVISIT: do we want to report all errors? or just one? 
//errors.clear(); 	TokenNameCOMMENT_LINE	errors.clear(); 
}	TokenNameRBRACE	
// we've done with the types in this grammar. if we are checking 	TokenNameCOMMENT_LINE	we've done with the types in this grammar. if we are checking 
// all constraints, need to trim type array to a proper size: 	TokenNameCOMMENT_LINE	all constraints, need to trim type array to a proper size: 
// only contain those need further checking. 	TokenNameCOMMENT_LINE	only contain those need further checking. 
// and mark this grammar that it only needs UPA checking. 	TokenNameCOMMENT_LINE	and mark this grammar that it only needs UPA checking. 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fullChecked	TokenNameIdentifier	 full Checked
)	TokenNameRPAREN	
{	TokenNameLBRACE	
grammars	TokenNameIdentifier	 grammars
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
setUncheckedTypeNum	TokenNameIdentifier	 set Unchecked Type Num
(	TokenNameLPAREN	
keepType	TokenNameIdentifier	 keep Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
grammars	TokenNameIdentifier	 grammars
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
fFullChecked	TokenNameIdentifier	 f Full Checked
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* Check that a given particle is a valid restriction of a base particle. */	TokenNameCOMMENT_BLOCK	 Check that a given particle is a valid restriction of a base particle. 
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
checkElementDeclsConsistent	TokenNameIdentifier	 check Element Decls Consistent
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
particle	TokenNameIdentifier	 particle
,	TokenNameCOMMA	
SymbolHash	TokenNameIdentifier	 Symbol Hash
elemDeclHash	TokenNameIdentifier	 elem Decl Hash
,	TokenNameCOMMA	
SubstitutionGroupHandler	TokenNameIdentifier	 Substitution Group Handler
sgHandler	TokenNameIdentifier	 sg Handler
)	TokenNameRPAREN	
throws	TokenNamethrows	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
{	TokenNameLBRACE	
// check for elements in the tree with the same name and namespace 	TokenNameCOMMENT_LINE	check for elements in the tree with the same name and namespace 
int	TokenNameint	
pType	TokenNameIdentifier	 p Type
=	TokenNameEQUAL	
particle	TokenNameIdentifier	 particle
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
pType	TokenNameIdentifier	 p Type
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_WILDCARD	TokenNameIdentifier	 PARTICLE  WILDCARD
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
pType	TokenNameIdentifier	 p Type
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ELEMENT	TokenNameIdentifier	 PARTICLE  ELEMENT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
elem	TokenNameIdentifier	 elem
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
(	TokenNameLPAREN	
particle	TokenNameIdentifier	 particle
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
findElemInTable	TokenNameIdentifier	 find Elem In Table
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
elem	TokenNameIdentifier	 elem
,	TokenNameCOMMA	
elemDeclHash	TokenNameIdentifier	 elem Decl Hash
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
elem	TokenNameIdentifier	 elem
.	TokenNameDOT	
fScope	TokenNameIdentifier	 f Scope
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
SCOPE_GLOBAL	TokenNameIdentifier	 SCOPE  GLOBAL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Check for subsitution groups. 	TokenNameCOMMENT_LINE	Check for subsitution groups. 
XSElementDecl	TokenNameIdentifier	 XS Element Decl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
subGroup	TokenNameIdentifier	 sub Group
=	TokenNameEQUAL	
sgHandler	TokenNameIdentifier	 sg Handler
.	TokenNameDOT	
getSubstitutionGroup	TokenNameIdentifier	 get Substitution Group
(	TokenNameLPAREN	
elem	TokenNameIdentifier	 elem
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
subGroup	TokenNameIdentifier	 sub Group
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
findElemInTable	TokenNameIdentifier	 find Elem In Table
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
subGroup	TokenNameIdentifier	 sub Group
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
elemDeclHash	TokenNameIdentifier	 elem Decl Hash
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
group	TokenNameIdentifier	 group
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
)	TokenNameRPAREN	
particle	TokenNameIdentifier	 particle
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
group	TokenNameIdentifier	 group
.	TokenNameDOT	
fParticleCount	TokenNameIdentifier	 f Particle Count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
checkElementDeclsConsistent	TokenNameIdentifier	 check Element Decls Consistent
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
group	TokenNameIdentifier	 group
.	TokenNameDOT	
fParticles	TokenNameIdentifier	 f Particles
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
elemDeclHash	TokenNameIdentifier	 elem Decl Hash
,	TokenNameCOMMA	
sgHandler	TokenNameIdentifier	 sg Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
findElemInTable	TokenNameIdentifier	 find Elem In Table
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
elem	TokenNameIdentifier	 elem
,	TokenNameCOMMA	
SymbolHash	TokenNameIdentifier	 Symbol Hash
elemDeclHash	TokenNameIdentifier	 elem Decl Hash
)	TokenNameRPAREN	
throws	TokenNamethrows	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
{	TokenNameLBRACE	
// How can we avoid this concat? LM. 	TokenNameCOMMENT_LINE	How can we avoid this concat? LM. 
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
elem	TokenNameIdentifier	 elem
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
elem	TokenNameIdentifier	 elem
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
;	TokenNameSEMICOLON	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
existingElem	TokenNameIdentifier	 existing Elem
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
existingElem	TokenNameIdentifier	 existing Elem
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
(	TokenNameLPAREN	
elemDeclHash	TokenNameIdentifier	 elem Decl Hash
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// just add it in 	TokenNameCOMMENT_LINE	just add it in 
elemDeclHash	TokenNameIdentifier	 elem Decl Hash
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
elem	TokenNameIdentifier	 elem
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// If this is the same check element, we're O.K. 	TokenNameCOMMENT_LINE	If this is the same check element, we're O.K. 
if	TokenNameif	
(	TokenNameLPAREN	
elem	TokenNameIdentifier	 elem
==	TokenNameEQUAL_EQUAL	
existingElem	TokenNameIdentifier	 existing Elem
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
elem	TokenNameIdentifier	 elem
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
!=	TokenNameNOT_EQUAL	
existingElem	TokenNameIdentifier	 existing Elem
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Types are not the same 	TokenNameCOMMENT_LINE	Types are not the same 
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"cos-element-consistent"	TokenNameStringLiteral	cos-element-consistent
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
elem	TokenNameIdentifier	 elem
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Check that a given particle is a valid restriction of a base particle. 	TokenNameCOMMENT_LINE	Check that a given particle is a valid restriction of a base particle. 
// 	TokenNameCOMMENT_LINE	 
// IHR: 2006/11/17 	TokenNameCOMMENT_LINE	IHR: 2006/11/17 
// Returns a boolean indicating if there has been expansion of substitution group 	TokenNameCOMMENT_LINE	Returns a boolean indicating if there has been expansion of substitution group 
// in the bParticle. 	TokenNameCOMMENT_LINE	in the bParticle. 
// With this information the checkRecurseLax function knows when is 	TokenNameCOMMENT_LINE	With this information the checkRecurseLax function knows when is 
// to keep the order and when to ignore it. 	TokenNameCOMMENT_LINE	to keep the order and when to ignore it. 
private	TokenNameprivate	
static	TokenNamestatic	
boolean	TokenNameboolean	
particleValidRestriction	TokenNameIdentifier	 particle Valid Restriction
(	TokenNameLPAREN	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
dParticle	TokenNameIdentifier	 d Particle
,	TokenNameCOMMA	
SubstitutionGroupHandler	TokenNameIdentifier	 Substitution Group Handler
dSGHandler	TokenNameIdentifier	 d SG Handler
,	TokenNameCOMMA	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
bParticle	TokenNameIdentifier	 b Particle
,	TokenNameCOMMA	
SubstitutionGroupHandler	TokenNameIdentifier	 Substitution Group Handler
bSGHandler	TokenNameIdentifier	 b SG Handler
)	TokenNameRPAREN	
throws	TokenNamethrows	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
particleValidRestriction	TokenNameIdentifier	 particle Valid Restriction
(	TokenNameLPAREN	
dParticle	TokenNameIdentifier	 d Particle
,	TokenNameCOMMA	
dSGHandler	TokenNameIdentifier	 d SG Handler
,	TokenNameCOMMA	
bParticle	TokenNameIdentifier	 b Particle
,	TokenNameCOMMA	
bSGHandler	TokenNameIdentifier	 b SG Handler
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
boolean	TokenNameboolean	
particleValidRestriction	TokenNameIdentifier	 particle Valid Restriction
(	TokenNameLPAREN	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
dParticle	TokenNameIdentifier	 d Particle
,	TokenNameCOMMA	
SubstitutionGroupHandler	TokenNameIdentifier	 Substitution Group Handler
dSGHandler	TokenNameIdentifier	 d SG Handler
,	TokenNameCOMMA	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
bParticle	TokenNameIdentifier	 b Particle
,	TokenNameCOMMA	
SubstitutionGroupHandler	TokenNameIdentifier	 Substitution Group Handler
bSGHandler	TokenNameIdentifier	 b SG Handler
,	TokenNameCOMMA	
boolean	TokenNameboolean	
checkWCOccurrence	TokenNameIdentifier	 check WC Occurrence
)	TokenNameRPAREN	
throws	TokenNamethrows	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
{	TokenNameLBRACE	
Vector	TokenNameIdentifier	 Vector
dChildren	TokenNameIdentifier	 d Children
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
Vector	TokenNameIdentifier	 Vector
bChildren	TokenNameIdentifier	 b Children
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
dMinEffectiveTotalRange	TokenNameIdentifier	 d Min Effective Total Range
=	TokenNameEQUAL	
OCCURRENCE_UNKNOWN	TokenNameIdentifier	 OCCURRENCE  UNKNOWN
;	TokenNameSEMICOLON	
int	TokenNameint	
dMaxEffectiveTotalRange	TokenNameIdentifier	 d Max Effective Total Range
=	TokenNameEQUAL	
OCCURRENCE_UNKNOWN	TokenNameIdentifier	 OCCURRENCE  UNKNOWN
;	TokenNameSEMICOLON	
// By default there has been no expansion 	TokenNameCOMMENT_LINE	By default there has been no expansion 
boolean	TokenNameboolean	
bExpansionHappened	TokenNameIdentifier	 b Expansion Happened
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// Check for empty particles. If either base or derived particle is empty, 	TokenNameCOMMENT_LINE	Check for empty particles. If either base or derived particle is empty, 
// (and the other isn't) it's an error. 	TokenNameCOMMENT_LINE	(and the other isn't) it's an error. 
if	TokenNameif	
(	TokenNameLPAREN	
dParticle	TokenNameIdentifier	 d Particle
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
bParticle	TokenNameIdentifier	 b Particle
.	TokenNameDOT	
emptiable	TokenNameIdentifier	 emptiable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"cos-particle-restrict.a"	TokenNameStringLiteral	cos-particle-restrict.a
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
dParticle	TokenNameIdentifier	 d Particle
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
bParticle	TokenNameIdentifier	 b Particle
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"cos-particle-restrict.b"	TokenNameStringLiteral	cos-particle-restrict.b
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// Do setup prior to invoking the Particle (Restriction) cases. 	TokenNameCOMMENT_LINE	Do setup prior to invoking the Particle (Restriction) cases. 
// This involves: 	TokenNameCOMMENT_LINE	This involves: 
// - removing pointless occurrences for groups, and retrieving a vector of 	TokenNameCOMMENT_LINE	- removing pointless occurrences for groups, and retrieving a vector of 
// non-pointless children 	TokenNameCOMMENT_LINE	non-pointless children 
// - turning top-level elements with substitution groups into CHOICE groups. 	TokenNameCOMMENT_LINE	- turning top-level elements with substitution groups into CHOICE groups. 
// 	TokenNameCOMMENT_LINE	 
short	TokenNameshort	
dType	TokenNameIdentifier	 d Type
=	TokenNameEQUAL	
dParticle	TokenNameIdentifier	 d Particle
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Handle pointless groups for the derived particle 	TokenNameCOMMENT_LINE	Handle pointless groups for the derived particle 
// 	TokenNameCOMMENT_LINE	 
if	TokenNameif	
(	TokenNameLPAREN	
dType	TokenNameIdentifier	 d Type
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_MODELGROUP	TokenNameIdentifier	 PARTICLE  MODELGROUP
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dType	TokenNameIdentifier	 d Type
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
)	TokenNameRPAREN	
dParticle	TokenNameIdentifier	 d Particle
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
)	TokenNameRPAREN	
.	TokenNameDOT	
fCompositor	TokenNameIdentifier	 f Compositor
;	TokenNameSEMICOLON	
// Find a group, starting with this particle, with more than 1 child. There 	TokenNameCOMMENT_LINE	Find a group, starting with this particle, with more than 1 child. There 
// may be none, and the particle of interest trivially becomes an element or 	TokenNameCOMMENT_LINE	may be none, and the particle of interest trivially becomes an element or 
// wildcard. 	TokenNameCOMMENT_LINE	wildcard. 
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
dtmp	TokenNameIdentifier	 dtmp
=	TokenNameEQUAL	
getNonUnaryGroup	TokenNameIdentifier	 get Non Unary Group
(	TokenNameLPAREN	
dParticle	TokenNameIdentifier	 d Particle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dtmp	TokenNameIdentifier	 dtmp
!=	TokenNameNOT_EQUAL	
dParticle	TokenNameIdentifier	 d Particle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Particle has been replaced. Retrieve new type info. 	TokenNameCOMMENT_LINE	Particle has been replaced. Retrieve new type info. 
dParticle	TokenNameIdentifier	 d Particle
=	TokenNameEQUAL	
dtmp	TokenNameIdentifier	 dtmp
;	TokenNameSEMICOLON	
dType	TokenNameIdentifier	 d Type
=	TokenNameEQUAL	
dParticle	TokenNameIdentifier	 d Particle
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dType	TokenNameIdentifier	 d Type
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_MODELGROUP	TokenNameIdentifier	 PARTICLE  MODELGROUP
)	TokenNameRPAREN	
dType	TokenNameIdentifier	 d Type
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
)	TokenNameRPAREN	
dParticle	TokenNameIdentifier	 d Particle
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
)	TokenNameRPAREN	
.	TokenNameDOT	
fCompositor	TokenNameIdentifier	 f Compositor
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Fill in a vector with the children of the particle, removing any 	TokenNameCOMMENT_LINE	Fill in a vector with the children of the particle, removing any 
// pointless model groups in the process. 	TokenNameCOMMENT_LINE	pointless model groups in the process. 
dChildren	TokenNameIdentifier	 d Children
=	TokenNameEQUAL	
removePointlessChildren	TokenNameIdentifier	 remove Pointless Children
(	TokenNameLPAREN	
dParticle	TokenNameIdentifier	 d Particle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
dMinOccurs	TokenNameIdentifier	 d Min Occurs
=	TokenNameEQUAL	
dParticle	TokenNameIdentifier	 d Particle
.	TokenNameDOT	
fMinOccurs	TokenNameIdentifier	 f Min Occurs
;	TokenNameSEMICOLON	
int	TokenNameint	
dMaxOccurs	TokenNameIdentifier	 d Max Occurs
=	TokenNameEQUAL	
dParticle	TokenNameIdentifier	 d Particle
.	TokenNameDOT	
fMaxOccurs	TokenNameIdentifier	 f Max Occurs
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// For elements which are the heads of substitution groups, treat as CHOICE 	TokenNameCOMMENT_LINE	For elements which are the heads of substitution groups, treat as CHOICE 
// 	TokenNameCOMMENT_LINE	 
if	TokenNameif	
(	TokenNameLPAREN	
dSGHandler	TokenNameIdentifier	 d SG Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
dType	TokenNameIdentifier	 d Type
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ELEMENT	TokenNameIdentifier	 PARTICLE  ELEMENT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
dElement	TokenNameIdentifier	 d Element
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
dParticle	TokenNameIdentifier	 d Particle
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dElement	TokenNameIdentifier	 d Element
.	TokenNameDOT	
fScope	TokenNameIdentifier	 f Scope
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
SCOPE_GLOBAL	TokenNameIdentifier	 SCOPE  GLOBAL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Check for subsitution groups. Treat any element that has a 	TokenNameCOMMENT_LINE	Check for subsitution groups. Treat any element that has a 
// subsitution group as a choice. Fill in the children vector with the 	TokenNameCOMMENT_LINE	subsitution group as a choice. Fill in the children vector with the 
// members of the substitution group 	TokenNameCOMMENT_LINE	members of the substitution group 
XSElementDecl	TokenNameIdentifier	 XS Element Decl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
subGroup	TokenNameIdentifier	 sub Group
=	TokenNameEQUAL	
dSGHandler	TokenNameIdentifier	 d SG Handler
.	TokenNameDOT	
getSubstitutionGroup	TokenNameIdentifier	 get Substitution Group
(	TokenNameLPAREN	
dElement	TokenNameIdentifier	 d Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
subGroup	TokenNameIdentifier	 sub Group
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Now, set the type to be CHOICE. The "group" will have the same 	TokenNameCOMMENT_LINE	Now, set the type to be CHOICE. The "group" will have the same 
// occurrence information as the original particle. 	TokenNameCOMMENT_LINE	occurrence information as the original particle. 
dType	TokenNameIdentifier	 d Type
=	TokenNameEQUAL	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_CHOICE	TokenNameIdentifier	 MODELGROUP  CHOICE
;	TokenNameSEMICOLON	
dMinEffectiveTotalRange	TokenNameIdentifier	 d Min Effective Total Range
=	TokenNameEQUAL	
dMinOccurs	TokenNameIdentifier	 d Min Occurs
;	TokenNameSEMICOLON	
dMaxEffectiveTotalRange	TokenNameIdentifier	 d Max Effective Total Range
=	TokenNameEQUAL	
dMaxOccurs	TokenNameIdentifier	 d Max Occurs
;	TokenNameSEMICOLON	
// Fill in the vector of children 	TokenNameCOMMENT_LINE	Fill in the vector of children 
dChildren	TokenNameIdentifier	 d Children
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
subGroup	TokenNameIdentifier	 sub Group
.	TokenNameDOT	
length	TokenNameIdentifier	 length
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
subGroup	TokenNameIdentifier	 sub Group
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addElementToParticleVector	TokenNameIdentifier	 add Element To Particle Vector
(	TokenNameLPAREN	
dChildren	TokenNameIdentifier	 d Children
,	TokenNameCOMMA	
subGroup	TokenNameIdentifier	 sub Group
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
addElementToParticleVector	TokenNameIdentifier	 add Element To Particle Vector
(	TokenNameLPAREN	
dChildren	TokenNameIdentifier	 d Children
,	TokenNameCOMMA	
dElement	TokenNameIdentifier	 d Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
dChildren	TokenNameIdentifier	 d Children
,	TokenNameCOMMA	
ELEMENT_PARTICLE_COMPARATOR	TokenNameIdentifier	 ELEMENT  PARTICLE  COMPARATOR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Set the handler to null, to indicate that we've finished handling 	TokenNameCOMMENT_LINE	Set the handler to null, to indicate that we've finished handling 
// substitution groups for this particle. 	TokenNameCOMMENT_LINE	substitution groups for this particle. 
dSGHandler	TokenNameIdentifier	 d SG Handler
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
short	TokenNameshort	
bType	TokenNameIdentifier	 b Type
=	TokenNameEQUAL	
bParticle	TokenNameIdentifier	 b Particle
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Handle pointless groups for the base particle 	TokenNameCOMMENT_LINE	Handle pointless groups for the base particle 
// 	TokenNameCOMMENT_LINE	 
if	TokenNameif	
(	TokenNameLPAREN	
bType	TokenNameIdentifier	 b Type
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_MODELGROUP	TokenNameIdentifier	 PARTICLE  MODELGROUP
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bType	TokenNameIdentifier	 b Type
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
)	TokenNameRPAREN	
bParticle	TokenNameIdentifier	 b Particle
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
)	TokenNameRPAREN	
.	TokenNameDOT	
fCompositor	TokenNameIdentifier	 f Compositor
;	TokenNameSEMICOLON	
// Find a group, starting with this particle, with more than 1 child. There 	TokenNameCOMMENT_LINE	Find a group, starting with this particle, with more than 1 child. There 
// may be none, and the particle of interest trivially becomes an element or 	TokenNameCOMMENT_LINE	may be none, and the particle of interest trivially becomes an element or 
// wildcard. 	TokenNameCOMMENT_LINE	wildcard. 
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
btmp	TokenNameIdentifier	 btmp
=	TokenNameEQUAL	
getNonUnaryGroup	TokenNameIdentifier	 get Non Unary Group
(	TokenNameLPAREN	
bParticle	TokenNameIdentifier	 b Particle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
btmp	TokenNameIdentifier	 btmp
!=	TokenNameNOT_EQUAL	
bParticle	TokenNameIdentifier	 b Particle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Particle has been replaced. Retrieve new type info. 	TokenNameCOMMENT_LINE	Particle has been replaced. Retrieve new type info. 
bParticle	TokenNameIdentifier	 b Particle
=	TokenNameEQUAL	
btmp	TokenNameIdentifier	 btmp
;	TokenNameSEMICOLON	
bType	TokenNameIdentifier	 b Type
=	TokenNameEQUAL	
bParticle	TokenNameIdentifier	 b Particle
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
bType	TokenNameIdentifier	 b Type
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_MODELGROUP	TokenNameIdentifier	 PARTICLE  MODELGROUP
)	TokenNameRPAREN	
bType	TokenNameIdentifier	 b Type
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
)	TokenNameRPAREN	
bParticle	TokenNameIdentifier	 b Particle
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
)	TokenNameRPAREN	
.	TokenNameDOT	
fCompositor	TokenNameIdentifier	 f Compositor
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Fill in a vector with the children of the particle, removing any 	TokenNameCOMMENT_LINE	Fill in a vector with the children of the particle, removing any 
// pointless model groups in the process. 	TokenNameCOMMENT_LINE	pointless model groups in the process. 
bChildren	TokenNameIdentifier	 b Children
=	TokenNameEQUAL	
removePointlessChildren	TokenNameIdentifier	 remove Pointless Children
(	TokenNameLPAREN	
bParticle	TokenNameIdentifier	 b Particle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
bMinOccurs	TokenNameIdentifier	 b Min Occurs
=	TokenNameEQUAL	
bParticle	TokenNameIdentifier	 b Particle
.	TokenNameDOT	
fMinOccurs	TokenNameIdentifier	 f Min Occurs
;	TokenNameSEMICOLON	
int	TokenNameint	
bMaxOccurs	TokenNameIdentifier	 b Max Occurs
=	TokenNameEQUAL	
bParticle	TokenNameIdentifier	 b Particle
.	TokenNameDOT	
fMaxOccurs	TokenNameIdentifier	 f Max Occurs
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
bSGHandler	TokenNameIdentifier	 b SG Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
bType	TokenNameIdentifier	 b Type
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ELEMENT	TokenNameIdentifier	 PARTICLE  ELEMENT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
bElement	TokenNameIdentifier	 b Element
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
bParticle	TokenNameIdentifier	 b Particle
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
bElement	TokenNameIdentifier	 b Element
.	TokenNameDOT	
fScope	TokenNameIdentifier	 f Scope
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
SCOPE_GLOBAL	TokenNameIdentifier	 SCOPE  GLOBAL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Check for subsitution groups. Treat any element that has a 	TokenNameCOMMENT_LINE	Check for subsitution groups. Treat any element that has a 
// subsitution group as a choice. Fill in the children vector with the 	TokenNameCOMMENT_LINE	subsitution group as a choice. Fill in the children vector with the 
// members of the substitution group 	TokenNameCOMMENT_LINE	members of the substitution group 
XSElementDecl	TokenNameIdentifier	 XS Element Decl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bsubGroup	TokenNameIdentifier	 bsub Group
=	TokenNameEQUAL	
bSGHandler	TokenNameIdentifier	 b SG Handler
.	TokenNameDOT	
getSubstitutionGroup	TokenNameIdentifier	 get Substitution Group
(	TokenNameLPAREN	
bElement	TokenNameIdentifier	 b Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
bsubGroup	TokenNameIdentifier	 bsub Group
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Now, set the type to be CHOICE 	TokenNameCOMMENT_LINE	Now, set the type to be CHOICE 
bType	TokenNameIdentifier	 b Type
=	TokenNameEQUAL	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_CHOICE	TokenNameIdentifier	 MODELGROUP  CHOICE
;	TokenNameSEMICOLON	
bChildren	TokenNameIdentifier	 b Children
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
bsubGroup	TokenNameIdentifier	 bsub Group
.	TokenNameDOT	
length	TokenNameIdentifier	 length
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
bsubGroup	TokenNameIdentifier	 bsub Group
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addElementToParticleVector	TokenNameIdentifier	 add Element To Particle Vector
(	TokenNameLPAREN	
bChildren	TokenNameIdentifier	 b Children
,	TokenNameCOMMA	
bsubGroup	TokenNameIdentifier	 bsub Group
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
addElementToParticleVector	TokenNameIdentifier	 add Element To Particle Vector
(	TokenNameLPAREN	
bChildren	TokenNameIdentifier	 b Children
,	TokenNameCOMMA	
bElement	TokenNameIdentifier	 b Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
bChildren	TokenNameIdentifier	 b Children
,	TokenNameCOMMA	
ELEMENT_PARTICLE_COMPARATOR	TokenNameIdentifier	 ELEMENT  PARTICLE  COMPARATOR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Set the handler to null, to indicate that we've finished handling 	TokenNameCOMMENT_LINE	Set the handler to null, to indicate that we've finished handling 
// substitution groups for this particle. 	TokenNameCOMMENT_LINE	substitution groups for this particle. 
bSGHandler	TokenNameIdentifier	 b SG Handler
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// if we are here expansion of bParticle happened 	TokenNameCOMMENT_LINE	if we are here expansion of bParticle happened 
bExpansionHappened	TokenNameIdentifier	 b Expansion Happened
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// O.K. - Figure out which particle derivation rule applies and call it 	TokenNameCOMMENT_LINE	O.K. - Figure out which particle derivation rule applies and call it 
// 	TokenNameCOMMENT_LINE	 
switch	TokenNameswitch	
(	TokenNameLPAREN	
dType	TokenNameIdentifier	 d Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ELEMENT	TokenNameIdentifier	 PARTICLE  ELEMENT
:	TokenNameCOLON	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
bType	TokenNameIdentifier	 b Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Elt:Elt NameAndTypeOK 	TokenNameCOMMENT_LINE	Elt:Elt NameAndTypeOK 
case	TokenNamecase	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ELEMENT	TokenNameIdentifier	 PARTICLE  ELEMENT
:	TokenNameCOLON	
{	TokenNameLBRACE	
checkNameAndTypeOK	TokenNameIdentifier	 check Name And Type OK
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
dParticle	TokenNameIdentifier	 d Particle
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
,	TokenNameCOMMA	
dMinOccurs	TokenNameIdentifier	 d Min Occurs
,	TokenNameCOMMA	
dMaxOccurs	TokenNameIdentifier	 d Max Occurs
,	TokenNameCOMMA	
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
bParticle	TokenNameIdentifier	 b Particle
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
,	TokenNameCOMMA	
bMinOccurs	TokenNameIdentifier	 b Min Occurs
,	TokenNameCOMMA	
bMaxOccurs	TokenNameIdentifier	 b Max Occurs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
bExpansionHappened	TokenNameIdentifier	 b Expansion Happened
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Elt:Any NSCompat 	TokenNameCOMMENT_LINE	Elt:Any NSCompat 
case	TokenNamecase	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_WILDCARD	TokenNameIdentifier	 PARTICLE  WILDCARD
:	TokenNameCOLON	
{	TokenNameLBRACE	
checkNSCompat	TokenNameIdentifier	 check NS Compat
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
dParticle	TokenNameIdentifier	 d Particle
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
,	TokenNameCOMMA	
dMinOccurs	TokenNameIdentifier	 d Min Occurs
,	TokenNameCOMMA	
dMaxOccurs	TokenNameIdentifier	 d Max Occurs
,	TokenNameCOMMA	
(	TokenNameLPAREN	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
)	TokenNameRPAREN	
bParticle	TokenNameIdentifier	 b Particle
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
,	TokenNameCOMMA	
bMinOccurs	TokenNameIdentifier	 b Min Occurs
,	TokenNameCOMMA	
bMaxOccurs	TokenNameIdentifier	 b Max Occurs
,	TokenNameCOMMA	
checkWCOccurrence	TokenNameIdentifier	 check WC Occurrence
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
bExpansionHappened	TokenNameIdentifier	 b Expansion Happened
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Elt:All RecurseAsIfGroup 	TokenNameCOMMENT_LINE	Elt:All RecurseAsIfGroup 
case	TokenNamecase	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_CHOICE	TokenNameIdentifier	 MODELGROUP  CHOICE
:	TokenNameCOLON	
{	TokenNameLBRACE	
// Treat the element as if it were in a group of the same type 	TokenNameCOMMENT_LINE	Treat the element as if it were in a group of the same type 
// as the base Particle 	TokenNameCOMMENT_LINE	as the base Particle 
dChildren	TokenNameIdentifier	 d Children
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dChildren	TokenNameIdentifier	 d Children
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
dParticle	TokenNameIdentifier	 d Particle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
checkRecurseLax	TokenNameIdentifier	 check Recurse Lax
(	TokenNameLPAREN	
dChildren	TokenNameIdentifier	 d Children
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
dSGHandler	TokenNameIdentifier	 d SG Handler
,	TokenNameCOMMA	
bChildren	TokenNameIdentifier	 b Children
,	TokenNameCOMMA	
bMinOccurs	TokenNameIdentifier	 b Min Occurs
,	TokenNameCOMMA	
bMaxOccurs	TokenNameIdentifier	 b Max Occurs
,	TokenNameCOMMA	
bSGHandler	TokenNameIdentifier	 b SG Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
bExpansionHappened	TokenNameIdentifier	 b Expansion Happened
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_SEQUENCE	TokenNameIdentifier	 MODELGROUP  SEQUENCE
:	TokenNameCOLON	
case	TokenNamecase	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_ALL	TokenNameIdentifier	 MODELGROUP  ALL
:	TokenNameCOLON	
{	TokenNameLBRACE	
// Treat the element as if it were in a group of the same type 	TokenNameCOMMENT_LINE	Treat the element as if it were in a group of the same type 
// as the base Particle 	TokenNameCOMMENT_LINE	as the base Particle 
dChildren	TokenNameIdentifier	 d Children
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dChildren	TokenNameIdentifier	 d Children
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
dParticle	TokenNameIdentifier	 d Particle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
checkRecurse	TokenNameIdentifier	 check Recurse
(	TokenNameLPAREN	
dChildren	TokenNameIdentifier	 d Children
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
dSGHandler	TokenNameIdentifier	 d SG Handler
,	TokenNameCOMMA	
bChildren	TokenNameIdentifier	 b Children
,	TokenNameCOMMA	
bMinOccurs	TokenNameIdentifier	 b Min Occurs
,	TokenNameCOMMA	
bMaxOccurs	TokenNameIdentifier	 b Max Occurs
,	TokenNameCOMMA	
bSGHandler	TokenNameIdentifier	 b SG Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
bExpansionHappened	TokenNameIdentifier	 b Expansion Happened
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
default	TokenNamedefault	
:	TokenNameCOLON	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"Internal-Error"	TokenNameStringLiteral	Internal-Error
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"in particleValidRestriction"	TokenNameStringLiteral	in particleValidRestriction
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
case	TokenNamecase	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_WILDCARD	TokenNameIdentifier	 PARTICLE  WILDCARD
:	TokenNameCOLON	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
bType	TokenNameIdentifier	 b Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Any:Any NSSubset 	TokenNameCOMMENT_LINE	Any:Any NSSubset 
case	TokenNamecase	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_WILDCARD	TokenNameIdentifier	 PARTICLE  WILDCARD
:	TokenNameCOLON	
{	TokenNameLBRACE	
checkNSSubset	TokenNameIdentifier	 check NS Subset
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
)	TokenNameRPAREN	
dParticle	TokenNameIdentifier	 d Particle
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
,	TokenNameCOMMA	
dMinOccurs	TokenNameIdentifier	 d Min Occurs
,	TokenNameCOMMA	
dMaxOccurs	TokenNameIdentifier	 d Max Occurs
,	TokenNameCOMMA	
(	TokenNameLPAREN	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
)	TokenNameRPAREN	
bParticle	TokenNameIdentifier	 b Particle
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
,	TokenNameCOMMA	
bMinOccurs	TokenNameIdentifier	 b Min Occurs
,	TokenNameCOMMA	
bMaxOccurs	TokenNameIdentifier	 b Max Occurs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
bExpansionHappened	TokenNameIdentifier	 b Expansion Happened
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_CHOICE	TokenNameIdentifier	 MODELGROUP  CHOICE
:	TokenNameCOLON	
case	TokenNamecase	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_SEQUENCE	TokenNameIdentifier	 MODELGROUP  SEQUENCE
:	TokenNameCOLON	
case	TokenNamecase	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_ALL	TokenNameIdentifier	 MODELGROUP  ALL
:	TokenNameCOLON	
case	TokenNamecase	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ELEMENT	TokenNameIdentifier	 PARTICLE  ELEMENT
:	TokenNameCOLON	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"cos-particle-restrict.2"	TokenNameStringLiteral	cos-particle-restrict.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"any:choice,sequence,all,elt"	TokenNameStringLiteral	any:choice,sequence,all,elt
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
default	TokenNamedefault	
:	TokenNameCOLON	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"Internal-Error"	TokenNameStringLiteral	Internal-Error
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"in particleValidRestriction"	TokenNameStringLiteral	in particleValidRestriction
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
case	TokenNamecase	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_ALL	TokenNameIdentifier	 MODELGROUP  ALL
:	TokenNameCOLON	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
bType	TokenNameIdentifier	 b Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// All:Any NSRecurseCheckCardinality 	TokenNameCOMMENT_LINE	All:Any NSRecurseCheckCardinality 
case	TokenNamecase	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_WILDCARD	TokenNameIdentifier	 PARTICLE  WILDCARD
:	TokenNameCOLON	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
dMinEffectiveTotalRange	TokenNameIdentifier	 d Min Effective Total Range
==	TokenNameEQUAL_EQUAL	
OCCURRENCE_UNKNOWN	TokenNameIdentifier	 OCCURRENCE  UNKNOWN
)	TokenNameRPAREN	
dMinEffectiveTotalRange	TokenNameIdentifier	 d Min Effective Total Range
=	TokenNameEQUAL	
dParticle	TokenNameIdentifier	 d Particle
.	TokenNameDOT	
minEffectiveTotalRange	TokenNameIdentifier	 min Effective Total Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dMaxEffectiveTotalRange	TokenNameIdentifier	 d Max Effective Total Range
==	TokenNameEQUAL_EQUAL	
OCCURRENCE_UNKNOWN	TokenNameIdentifier	 OCCURRENCE  UNKNOWN
)	TokenNameRPAREN	
dMaxEffectiveTotalRange	TokenNameIdentifier	 d Max Effective Total Range
=	TokenNameEQUAL	
dParticle	TokenNameIdentifier	 d Particle
.	TokenNameDOT	
maxEffectiveTotalRange	TokenNameIdentifier	 max Effective Total Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
checkNSRecurseCheckCardinality	TokenNameIdentifier	 check NS Recurse Check Cardinality
(	TokenNameLPAREN	
dChildren	TokenNameIdentifier	 d Children
,	TokenNameCOMMA	
dMinEffectiveTotalRange	TokenNameIdentifier	 d Min Effective Total Range
,	TokenNameCOMMA	
dMaxEffectiveTotalRange	TokenNameIdentifier	 d Max Effective Total Range
,	TokenNameCOMMA	
dSGHandler	TokenNameIdentifier	 d SG Handler
,	TokenNameCOMMA	
bParticle	TokenNameIdentifier	 b Particle
,	TokenNameCOMMA	
bMinOccurs	TokenNameIdentifier	 b Min Occurs
,	TokenNameCOMMA	
bMaxOccurs	TokenNameIdentifier	 b Max Occurs
,	TokenNameCOMMA	
checkWCOccurrence	TokenNameIdentifier	 check WC Occurrence
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
bExpansionHappened	TokenNameIdentifier	 b Expansion Happened
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_ALL	TokenNameIdentifier	 MODELGROUP  ALL
:	TokenNameCOLON	
{	TokenNameLBRACE	
checkRecurse	TokenNameIdentifier	 check Recurse
(	TokenNameLPAREN	
dChildren	TokenNameIdentifier	 d Children
,	TokenNameCOMMA	
dMinOccurs	TokenNameIdentifier	 d Min Occurs
,	TokenNameCOMMA	
dMaxOccurs	TokenNameIdentifier	 d Max Occurs
,	TokenNameCOMMA	
dSGHandler	TokenNameIdentifier	 d SG Handler
,	TokenNameCOMMA	
bChildren	TokenNameIdentifier	 b Children
,	TokenNameCOMMA	
bMinOccurs	TokenNameIdentifier	 b Min Occurs
,	TokenNameCOMMA	
bMaxOccurs	TokenNameIdentifier	 b Max Occurs
,	TokenNameCOMMA	
bSGHandler	TokenNameIdentifier	 b SG Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
bExpansionHappened	TokenNameIdentifier	 b Expansion Happened
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_CHOICE	TokenNameIdentifier	 MODELGROUP  CHOICE
:	TokenNameCOLON	
case	TokenNamecase	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_SEQUENCE	TokenNameIdentifier	 MODELGROUP  SEQUENCE
:	TokenNameCOLON	
case	TokenNamecase	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ELEMENT	TokenNameIdentifier	 PARTICLE  ELEMENT
:	TokenNameCOLON	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"cos-particle-restrict.2"	TokenNameStringLiteral	cos-particle-restrict.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"all:choice,sequence,elt"	TokenNameStringLiteral	all:choice,sequence,elt
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
default	TokenNamedefault	
:	TokenNameCOLON	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"Internal-Error"	TokenNameStringLiteral	Internal-Error
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"in particleValidRestriction"	TokenNameStringLiteral	in particleValidRestriction
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
case	TokenNamecase	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_CHOICE	TokenNameIdentifier	 MODELGROUP  CHOICE
:	TokenNameCOLON	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
bType	TokenNameIdentifier	 b Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Choice:Any NSRecurseCheckCardinality 	TokenNameCOMMENT_LINE	Choice:Any NSRecurseCheckCardinality 
case	TokenNamecase	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_WILDCARD	TokenNameIdentifier	 PARTICLE  WILDCARD
:	TokenNameCOLON	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
dMinEffectiveTotalRange	TokenNameIdentifier	 d Min Effective Total Range
==	TokenNameEQUAL_EQUAL	
OCCURRENCE_UNKNOWN	TokenNameIdentifier	 OCCURRENCE  UNKNOWN
)	TokenNameRPAREN	
dMinEffectiveTotalRange	TokenNameIdentifier	 d Min Effective Total Range
=	TokenNameEQUAL	
dParticle	TokenNameIdentifier	 d Particle
.	TokenNameDOT	
minEffectiveTotalRange	TokenNameIdentifier	 min Effective Total Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dMaxEffectiveTotalRange	TokenNameIdentifier	 d Max Effective Total Range
==	TokenNameEQUAL_EQUAL	
OCCURRENCE_UNKNOWN	TokenNameIdentifier	 OCCURRENCE  UNKNOWN
)	TokenNameRPAREN	
dMaxEffectiveTotalRange	TokenNameIdentifier	 d Max Effective Total Range
=	TokenNameEQUAL	
dParticle	TokenNameIdentifier	 d Particle
.	TokenNameDOT	
maxEffectiveTotalRange	TokenNameIdentifier	 max Effective Total Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
checkNSRecurseCheckCardinality	TokenNameIdentifier	 check NS Recurse Check Cardinality
(	TokenNameLPAREN	
dChildren	TokenNameIdentifier	 d Children
,	TokenNameCOMMA	
dMinEffectiveTotalRange	TokenNameIdentifier	 d Min Effective Total Range
,	TokenNameCOMMA	
dMaxEffectiveTotalRange	TokenNameIdentifier	 d Max Effective Total Range
,	TokenNameCOMMA	
dSGHandler	TokenNameIdentifier	 d SG Handler
,	TokenNameCOMMA	
bParticle	TokenNameIdentifier	 b Particle
,	TokenNameCOMMA	
bMinOccurs	TokenNameIdentifier	 b Min Occurs
,	TokenNameCOMMA	
bMaxOccurs	TokenNameIdentifier	 b Max Occurs
,	TokenNameCOMMA	
checkWCOccurrence	TokenNameIdentifier	 check WC Occurrence
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
bExpansionHappened	TokenNameIdentifier	 b Expansion Happened
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_CHOICE	TokenNameIdentifier	 MODELGROUP  CHOICE
:	TokenNameCOLON	
{	TokenNameLBRACE	
checkRecurseLax	TokenNameIdentifier	 check Recurse Lax
(	TokenNameLPAREN	
dChildren	TokenNameIdentifier	 d Children
,	TokenNameCOMMA	
dMinOccurs	TokenNameIdentifier	 d Min Occurs
,	TokenNameCOMMA	
dMaxOccurs	TokenNameIdentifier	 d Max Occurs
,	TokenNameCOMMA	
dSGHandler	TokenNameIdentifier	 d SG Handler
,	TokenNameCOMMA	
bChildren	TokenNameIdentifier	 b Children
,	TokenNameCOMMA	
bMinOccurs	TokenNameIdentifier	 b Min Occurs
,	TokenNameCOMMA	
bMaxOccurs	TokenNameIdentifier	 b Max Occurs
,	TokenNameCOMMA	
bSGHandler	TokenNameIdentifier	 b SG Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
bExpansionHappened	TokenNameIdentifier	 b Expansion Happened
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_ALL	TokenNameIdentifier	 MODELGROUP  ALL
:	TokenNameCOLON	
case	TokenNamecase	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_SEQUENCE	TokenNameIdentifier	 MODELGROUP  SEQUENCE
:	TokenNameCOLON	
case	TokenNamecase	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ELEMENT	TokenNameIdentifier	 PARTICLE  ELEMENT
:	TokenNameCOLON	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"cos-particle-restrict.2"	TokenNameStringLiteral	cos-particle-restrict.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"choice:all,sequence,elt"	TokenNameStringLiteral	choice:all,sequence,elt
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
default	TokenNamedefault	
:	TokenNameCOLON	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"Internal-Error"	TokenNameStringLiteral	Internal-Error
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"in particleValidRestriction"	TokenNameStringLiteral	in particleValidRestriction
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
case	TokenNamecase	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_SEQUENCE	TokenNameIdentifier	 MODELGROUP  SEQUENCE
:	TokenNameCOLON	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
bType	TokenNameIdentifier	 b Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Choice:Any NSRecurseCheckCardinality 	TokenNameCOMMENT_LINE	Choice:Any NSRecurseCheckCardinality 
case	TokenNamecase	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_WILDCARD	TokenNameIdentifier	 PARTICLE  WILDCARD
:	TokenNameCOLON	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
dMinEffectiveTotalRange	TokenNameIdentifier	 d Min Effective Total Range
==	TokenNameEQUAL_EQUAL	
OCCURRENCE_UNKNOWN	TokenNameIdentifier	 OCCURRENCE  UNKNOWN
)	TokenNameRPAREN	
dMinEffectiveTotalRange	TokenNameIdentifier	 d Min Effective Total Range
=	TokenNameEQUAL	
dParticle	TokenNameIdentifier	 d Particle
.	TokenNameDOT	
minEffectiveTotalRange	TokenNameIdentifier	 min Effective Total Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dMaxEffectiveTotalRange	TokenNameIdentifier	 d Max Effective Total Range
==	TokenNameEQUAL_EQUAL	
OCCURRENCE_UNKNOWN	TokenNameIdentifier	 OCCURRENCE  UNKNOWN
)	TokenNameRPAREN	
dMaxEffectiveTotalRange	TokenNameIdentifier	 d Max Effective Total Range
=	TokenNameEQUAL	
dParticle	TokenNameIdentifier	 d Particle
.	TokenNameDOT	
maxEffectiveTotalRange	TokenNameIdentifier	 max Effective Total Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
checkNSRecurseCheckCardinality	TokenNameIdentifier	 check NS Recurse Check Cardinality
(	TokenNameLPAREN	
dChildren	TokenNameIdentifier	 d Children
,	TokenNameCOMMA	
dMinEffectiveTotalRange	TokenNameIdentifier	 d Min Effective Total Range
,	TokenNameCOMMA	
dMaxEffectiveTotalRange	TokenNameIdentifier	 d Max Effective Total Range
,	TokenNameCOMMA	
dSGHandler	TokenNameIdentifier	 d SG Handler
,	TokenNameCOMMA	
bParticle	TokenNameIdentifier	 b Particle
,	TokenNameCOMMA	
bMinOccurs	TokenNameIdentifier	 b Min Occurs
,	TokenNameCOMMA	
bMaxOccurs	TokenNameIdentifier	 b Max Occurs
,	TokenNameCOMMA	
checkWCOccurrence	TokenNameIdentifier	 check WC Occurrence
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
bExpansionHappened	TokenNameIdentifier	 b Expansion Happened
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_ALL	TokenNameIdentifier	 MODELGROUP  ALL
:	TokenNameCOLON	
{	TokenNameLBRACE	
checkRecurseUnordered	TokenNameIdentifier	 check Recurse Unordered
(	TokenNameLPAREN	
dChildren	TokenNameIdentifier	 d Children
,	TokenNameCOMMA	
dMinOccurs	TokenNameIdentifier	 d Min Occurs
,	TokenNameCOMMA	
dMaxOccurs	TokenNameIdentifier	 d Max Occurs
,	TokenNameCOMMA	
dSGHandler	TokenNameIdentifier	 d SG Handler
,	TokenNameCOMMA	
bChildren	TokenNameIdentifier	 b Children
,	TokenNameCOMMA	
bMinOccurs	TokenNameIdentifier	 b Min Occurs
,	TokenNameCOMMA	
bMaxOccurs	TokenNameIdentifier	 b Max Occurs
,	TokenNameCOMMA	
bSGHandler	TokenNameIdentifier	 b SG Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
bExpansionHappened	TokenNameIdentifier	 b Expansion Happened
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_SEQUENCE	TokenNameIdentifier	 MODELGROUP  SEQUENCE
:	TokenNameCOLON	
{	TokenNameLBRACE	
checkRecurse	TokenNameIdentifier	 check Recurse
(	TokenNameLPAREN	
dChildren	TokenNameIdentifier	 d Children
,	TokenNameCOMMA	
dMinOccurs	TokenNameIdentifier	 d Min Occurs
,	TokenNameCOMMA	
dMaxOccurs	TokenNameIdentifier	 d Max Occurs
,	TokenNameCOMMA	
dSGHandler	TokenNameIdentifier	 d SG Handler
,	TokenNameCOMMA	
bChildren	TokenNameIdentifier	 b Children
,	TokenNameCOMMA	
bMinOccurs	TokenNameIdentifier	 b Min Occurs
,	TokenNameCOMMA	
bMaxOccurs	TokenNameIdentifier	 b Max Occurs
,	TokenNameCOMMA	
bSGHandler	TokenNameIdentifier	 b SG Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
bExpansionHappened	TokenNameIdentifier	 b Expansion Happened
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_CHOICE	TokenNameIdentifier	 MODELGROUP  CHOICE
:	TokenNameCOLON	
{	TokenNameLBRACE	
int	TokenNameint	
min1	TokenNameIdentifier	 min1
=	TokenNameEQUAL	
dMinOccurs	TokenNameIdentifier	 d Min Occurs
*	TokenNameMULTIPLY	
dChildren	TokenNameIdentifier	 d Children
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
max1	TokenNameIdentifier	 max1
=	TokenNameEQUAL	
(	TokenNameLPAREN	
dMaxOccurs	TokenNameIdentifier	 d Max Occurs
==	TokenNameEQUAL_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
OCCURRENCE_UNBOUNDED	TokenNameIdentifier	 OCCURRENCE  UNBOUNDED
)	TokenNameRPAREN	
?	TokenNameQUESTION	
dMaxOccurs	TokenNameIdentifier	 d Max Occurs
:	TokenNameCOLON	
dMaxOccurs	TokenNameIdentifier	 d Max Occurs
*	TokenNameMULTIPLY	
dChildren	TokenNameIdentifier	 d Children
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
checkMapAndSum	TokenNameIdentifier	 check Map And Sum
(	TokenNameLPAREN	
dChildren	TokenNameIdentifier	 d Children
,	TokenNameCOMMA	
min1	TokenNameIdentifier	 min1
,	TokenNameCOMMA	
max1	TokenNameIdentifier	 max1
,	TokenNameCOMMA	
dSGHandler	TokenNameIdentifier	 d SG Handler
,	TokenNameCOMMA	
bChildren	TokenNameIdentifier	 b Children
,	TokenNameCOMMA	
bMinOccurs	TokenNameIdentifier	 b Min Occurs
,	TokenNameCOMMA	
bMaxOccurs	TokenNameIdentifier	 b Max Occurs
,	TokenNameCOMMA	
bSGHandler	TokenNameIdentifier	 b SG Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
bExpansionHappened	TokenNameIdentifier	 b Expansion Happened
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ELEMENT	TokenNameIdentifier	 PARTICLE  ELEMENT
:	TokenNameCOLON	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"cos-particle-restrict.2"	TokenNameStringLiteral	cos-particle-restrict.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"seq:elt"	TokenNameStringLiteral	seq:elt
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
default	TokenNamedefault	
:	TokenNameCOLON	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"Internal-Error"	TokenNameStringLiteral	Internal-Error
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"in particleValidRestriction"	TokenNameStringLiteral	in particleValidRestriction
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
bExpansionHappened	TokenNameIdentifier	 b Expansion Happened
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
addElementToParticleVector	TokenNameIdentifier	 add Element To Particle Vector
(	TokenNameLPAREN	
Vector	TokenNameIdentifier	 Vector
v	TokenNameIdentifier	 v
,	TokenNameCOMMA	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
d	TokenNameIdentifier	 d
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
new	TokenNamenew	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
=	TokenNameEQUAL	
d	TokenNameIdentifier	 d
;	TokenNameSEMICOLON	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
=	TokenNameEQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ELEMENT	TokenNameIdentifier	 PARTICLE  ELEMENT
;	TokenNameSEMICOLON	
v	TokenNameIdentifier	 v
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
getNonUnaryGroup	TokenNameIdentifier	 get Non Unary Group
(	TokenNameLPAREN	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
p	TokenNameIdentifier	 p
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ELEMENT	TokenNameIdentifier	 PARTICLE  ELEMENT
||	TokenNameOR_OR	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_WILDCARD	TokenNameIdentifier	 PARTICLE  WILDCARD
)	TokenNameRPAREN	
return	TokenNamereturn	
p	TokenNameIdentifier	 p
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
fMinOccurs	TokenNameIdentifier	 f Min Occurs
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
fMaxOccurs	TokenNameIdentifier	 f Max Occurs
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
)	TokenNameRPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
)	TokenNameRPAREN	
.	TokenNameDOT	
fParticleCount	TokenNameIdentifier	 f Particle Count
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
getNonUnaryGroup	TokenNameIdentifier	 get Non Unary Group
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
)	TokenNameRPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
)	TokenNameRPAREN	
.	TokenNameDOT	
fParticles	TokenNameIdentifier	 f Particles
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
p	TokenNameIdentifier	 p
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
Vector	TokenNameIdentifier	 Vector
removePointlessChildren	TokenNameIdentifier	 remove Pointless Children
(	TokenNameLPAREN	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
p	TokenNameIdentifier	 p
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ELEMENT	TokenNameIdentifier	 PARTICLE  ELEMENT
||	TokenNameOR_OR	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_WILDCARD	TokenNameIdentifier	 PARTICLE  WILDCARD
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
Vector	TokenNameIdentifier	 Vector
children	TokenNameIdentifier	 children
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
group	TokenNameIdentifier	 group
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
)	TokenNameRPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
group	TokenNameIdentifier	 group
.	TokenNameDOT	
fParticleCount	TokenNameIdentifier	 f Particle Count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
gatherChildren	TokenNameIdentifier	 gather Children
(	TokenNameLPAREN	
group	TokenNameIdentifier	 group
.	TokenNameDOT	
fCompositor	TokenNameIdentifier	 f Compositor
,	TokenNameCOMMA	
group	TokenNameIdentifier	 group
.	TokenNameDOT	
fParticles	TokenNameIdentifier	 f Particles
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
children	TokenNameIdentifier	 children
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
children	TokenNameIdentifier	 children
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
gatherChildren	TokenNameIdentifier	 gather Children
(	TokenNameLPAREN	
int	TokenNameint	
parentType	TokenNameIdentifier	 parent Type
,	TokenNameCOMMA	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
p	TokenNameIdentifier	 p
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
children	TokenNameIdentifier	 children
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
min	TokenNameIdentifier	 min
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
fMinOccurs	TokenNameIdentifier	 f Min Occurs
;	TokenNameSEMICOLON	
int	TokenNameint	
max	TokenNameIdentifier	 max
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
fMaxOccurs	TokenNameIdentifier	 f Max Occurs
;	TokenNameSEMICOLON	
int	TokenNameint	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_MODELGROUP	TokenNameIdentifier	 PARTICLE  MODELGROUP
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
)	TokenNameRPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
)	TokenNameRPAREN	
.	TokenNameDOT	
fCompositor	TokenNameIdentifier	 f Compositor
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ELEMENT	TokenNameIdentifier	 PARTICLE  ELEMENT
||	TokenNameOR_OR	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_WILDCARD	TokenNameIdentifier	 PARTICLE  WILDCARD
)	TokenNameRPAREN	
{	TokenNameLBRACE	
children	TokenNameIdentifier	 children
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
min	TokenNameIdentifier	 min
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
max	TokenNameIdentifier	 max
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
children	TokenNameIdentifier	 children
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
parentType	TokenNameIdentifier	 parent Type
==	TokenNameEQUAL_EQUAL	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
group	TokenNameIdentifier	 group
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
)	TokenNameRPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
group	TokenNameIdentifier	 group
.	TokenNameDOT	
fParticleCount	TokenNameIdentifier	 f Particle Count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
gatherChildren	TokenNameIdentifier	 gather Children
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
group	TokenNameIdentifier	 group
.	TokenNameDOT	
fParticles	TokenNameIdentifier	 f Particles
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
children	TokenNameIdentifier	 children
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
children	TokenNameIdentifier	 children
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
checkNameAndTypeOK	TokenNameIdentifier	 check Name And Type OK
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
dElement	TokenNameIdentifier	 d Element
,	TokenNameCOMMA	
int	TokenNameint	
dMin	TokenNameIdentifier	 d Min
,	TokenNameCOMMA	
int	TokenNameint	
dMax	TokenNameIdentifier	 d Max
,	TokenNameCOMMA	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
bElement	TokenNameIdentifier	 b Element
,	TokenNameCOMMA	
int	TokenNameint	
bMin	TokenNameIdentifier	 b Min
,	TokenNameCOMMA	
int	TokenNameint	
bMax	TokenNameIdentifier	 b Max
)	TokenNameRPAREN	
throws	TokenNamethrows	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// Check that the names are the same 	TokenNameCOMMENT_LINE	Check that the names are the same 
// 	TokenNameCOMMENT_LINE	 
if	TokenNameif	
(	TokenNameLPAREN	
dElement	TokenNameIdentifier	 d Element
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
!=	TokenNameNOT_EQUAL	
bElement	TokenNameIdentifier	 b Element
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
||	TokenNameOR_OR	
dElement	TokenNameIdentifier	 d Element
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
!=	TokenNameNOT_EQUAL	
bElement	TokenNameIdentifier	 b Element
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"rcase-NameAndTypeOK.1"	TokenNameStringLiteral	rcase-NameAndTypeOK.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
dElement	TokenNameIdentifier	 d Element
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
dElement	TokenNameIdentifier	 d Element
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
,	TokenNameCOMMA	
bElement	TokenNameIdentifier	 b Element
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
bElement	TokenNameIdentifier	 b Element
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// Check nillable 	TokenNameCOMMENT_LINE	Check nillable 
// 	TokenNameCOMMENT_LINE	 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
bElement	TokenNameIdentifier	 b Element
.	TokenNameDOT	
getNillable	TokenNameIdentifier	 get Nillable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
dElement	TokenNameIdentifier	 d Element
.	TokenNameDOT	
getNillable	TokenNameIdentifier	 get Nillable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"rcase-NameAndTypeOK.2"	TokenNameStringLiteral	rcase-NameAndTypeOK.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
dElement	TokenNameIdentifier	 d Element
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// Check occurrence range 	TokenNameCOMMENT_LINE	Check occurrence range 
// 	TokenNameCOMMENT_LINE	 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
checkOccurrenceRange	TokenNameIdentifier	 check Occurrence Range
(	TokenNameLPAREN	
dMin	TokenNameIdentifier	 d Min
,	TokenNameCOMMA	
dMax	TokenNameIdentifier	 d Max
,	TokenNameCOMMA	
bMin	TokenNameIdentifier	 b Min
,	TokenNameCOMMA	
bMax	TokenNameIdentifier	 b Max
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"rcase-NameAndTypeOK.3"	TokenNameStringLiteral	rcase-NameAndTypeOK.3
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
dElement	TokenNameIdentifier	 d Element
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
dMin	TokenNameIdentifier	 d Min
)	TokenNameRPAREN	
,	TokenNameCOMMA	
dMax	TokenNameIdentifier	 d Max
==	TokenNameEQUAL_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
OCCURRENCE_UNBOUNDED	TokenNameIdentifier	 OCCURRENCE  UNBOUNDED
?	TokenNameQUESTION	
"unbounded"	TokenNameStringLiteral	unbounded
:	TokenNameCOLON	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
dMax	TokenNameIdentifier	 d Max
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
bMin	TokenNameIdentifier	 b Min
)	TokenNameRPAREN	
,	TokenNameCOMMA	
bMax	TokenNameIdentifier	 b Max
==	TokenNameEQUAL_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
OCCURRENCE_UNBOUNDED	TokenNameIdentifier	 OCCURRENCE  UNBOUNDED
?	TokenNameQUESTION	
"unbounded"	TokenNameStringLiteral	unbounded
:	TokenNameCOLON	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
bMax	TokenNameIdentifier	 b Max
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// Check for consistent fixed values 	TokenNameCOMMENT_LINE	Check for consistent fixed values 
// 	TokenNameCOMMENT_LINE	 
if	TokenNameif	
(	TokenNameLPAREN	
bElement	TokenNameIdentifier	 b Element
.	TokenNameDOT	
getConstraintType	TokenNameIdentifier	 get Constraint Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
VC_FIXED	TokenNameIdentifier	 VC  FIXED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// derived one has to have a fixed value 	TokenNameCOMMENT_LINE	derived one has to have a fixed value 
if	TokenNameif	
(	TokenNameLPAREN	
dElement	TokenNameIdentifier	 d Element
.	TokenNameDOT	
getConstraintType	TokenNameIdentifier	 get Constraint Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
VC_FIXED	TokenNameIdentifier	 VC  FIXED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"rcase-NameAndTypeOK.4.a"	TokenNameStringLiteral	rcase-NameAndTypeOK.4.a
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
dElement	TokenNameIdentifier	 d Element
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
bElement	TokenNameIdentifier	 b Element
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
.	TokenNameDOT	
stringValue	TokenNameIdentifier	 string Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// get simple type 	TokenNameCOMMENT_LINE	get simple type 
boolean	TokenNameboolean	
isSimple	TokenNameIdentifier	 is Simple
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dElement	TokenNameIdentifier	 d Element
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
.	TokenNameDOT	
getTypeCategory	TokenNameIdentifier	 get Type Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
.	TokenNameDOT	
SIMPLE_TYPE	TokenNameIdentifier	 SIMPLE  TYPE
||	TokenNameOR_OR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
dElement	TokenNameIdentifier	 d Element
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
)	TokenNameRPAREN	
.	TokenNameDOT	
fContentType	TokenNameIdentifier	 f Content Type
==	TokenNameEQUAL_EQUAL	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
.	TokenNameDOT	
CONTENTTYPE_SIMPLE	TokenNameIdentifier	 CONTENTTYPE  SIMPLE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
isSimple	TokenNameIdentifier	 is Simple
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if there is no simple type, then compare based on string 	TokenNameCOMMENT_LINE	if there is no simple type, then compare based on string 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isSimple	TokenNameIdentifier	 is Simple
&&	TokenNameAND_AND	
!	TokenNameNOT	
bElement	TokenNameIdentifier	 b Element
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
.	TokenNameDOT	
normalizedValue	TokenNameIdentifier	 normalized Value
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
dElement	TokenNameIdentifier	 d Element
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
.	TokenNameDOT	
normalizedValue	TokenNameIdentifier	 normalized Value
)	TokenNameRPAREN	
||	TokenNameOR_OR	
isSimple	TokenNameIdentifier	 is Simple
&&	TokenNameAND_AND	
!	TokenNameNOT	
bElement	TokenNameIdentifier	 b Element
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
.	TokenNameDOT	
actualValue	TokenNameIdentifier	 actual Value
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
dElement	TokenNameIdentifier	 d Element
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
.	TokenNameDOT	
actualValue	TokenNameIdentifier	 actual Value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"rcase-NameAndTypeOK.4.b"	TokenNameStringLiteral	rcase-NameAndTypeOK.4.b
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
dElement	TokenNameIdentifier	 d Element
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
dElement	TokenNameIdentifier	 d Element
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
.	TokenNameDOT	
stringValue	TokenNameIdentifier	 string Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
bElement	TokenNameIdentifier	 b Element
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
.	TokenNameDOT	
stringValue	TokenNameIdentifier	 string Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// Check identity constraints 	TokenNameCOMMENT_LINE	Check identity constraints 
// 	TokenNameCOMMENT_LINE	 
checkIDConstraintRestriction	TokenNameIdentifier	 check ID Constraint Restriction
(	TokenNameLPAREN	
dElement	TokenNameIdentifier	 d Element
,	TokenNameCOMMA	
bElement	TokenNameIdentifier	 b Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Check for disallowed substitutions 	TokenNameCOMMENT_LINE	Check for disallowed substitutions 
// 	TokenNameCOMMENT_LINE	 
int	TokenNameint	
blockSet1	TokenNameIdentifier	 block Set1
=	TokenNameEQUAL	
dElement	TokenNameIdentifier	 d Element
.	TokenNameDOT	
fBlock	TokenNameIdentifier	 f Block
;	TokenNameSEMICOLON	
int	TokenNameint	
blockSet2	TokenNameIdentifier	 block Set2
=	TokenNameEQUAL	
bElement	TokenNameIdentifier	 b Element
.	TokenNameDOT	
fBlock	TokenNameIdentifier	 f Block
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
blockSet1	TokenNameIdentifier	 block Set1
&	TokenNameAND	
blockSet2	TokenNameIdentifier	 block Set2
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
blockSet2	TokenNameIdentifier	 block Set2
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
blockSet1	TokenNameIdentifier	 block Set1
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_NONE	TokenNameIdentifier	 DERIVATION  NONE
&&	TokenNameAND_AND	
blockSet2	TokenNameIdentifier	 block Set2
!=	TokenNameNOT_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_NONE	TokenNameIdentifier	 DERIVATION  NONE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"rcase-NameAndTypeOK.6"	TokenNameStringLiteral	rcase-NameAndTypeOK.6
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
dElement	TokenNameIdentifier	 d Element
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Check that the derived element's type is derived from the base's. 	TokenNameCOMMENT_LINE	Check that the derived element's type is derived from the base's. 
// 	TokenNameCOMMENT_LINE	 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
checkTypeDerivationOk	TokenNameIdentifier	 check Type Derivation Ok
(	TokenNameLPAREN	
dElement	TokenNameIdentifier	 d Element
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
,	TokenNameCOMMA	
bElement	TokenNameIdentifier	 b Element
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
,	TokenNameCOMMA	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_EXTENSION	TokenNameIdentifier	 DERIVATION  EXTENSION
|	TokenNameOR	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_LIST	TokenNameIdentifier	 DERIVATION  LIST
|	TokenNameOR	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_UNION	TokenNameIdentifier	 DERIVATION  UNION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"rcase-NameAndTypeOK.7"	TokenNameStringLiteral	rcase-NameAndTypeOK.7
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
dElement	TokenNameIdentifier	 d Element
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
dElement	TokenNameIdentifier	 d Element
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
bElement	TokenNameIdentifier	 b Element
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
checkIDConstraintRestriction	TokenNameIdentifier	 check ID Constraint Restriction
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
derivedElemDecl	TokenNameIdentifier	 derived Elem Decl
,	TokenNameCOMMA	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
baseElemDecl	TokenNameIdentifier	 base Elem Decl
)	TokenNameRPAREN	
throws	TokenNamethrows	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
{	TokenNameLBRACE	
// TODO 	TokenNameCOMMENT_LINE	TODO 
}	TokenNameRBRACE	
// checkIDConstraintRestriction 	TokenNameCOMMENT_LINE	checkIDConstraintRestriction 
private	TokenNameprivate	
static	TokenNamestatic	
boolean	TokenNameboolean	
checkOccurrenceRange	TokenNameIdentifier	 check Occurrence Range
(	TokenNameLPAREN	
int	TokenNameint	
min1	TokenNameIdentifier	 min1
,	TokenNameCOMMA	
int	TokenNameint	
max1	TokenNameIdentifier	 max1
,	TokenNameCOMMA	
int	TokenNameint	
min2	TokenNameIdentifier	 min2
,	TokenNameCOMMA	
int	TokenNameint	
max2	TokenNameIdentifier	 max2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
min1	TokenNameIdentifier	 min1
>=	TokenNameGREATER_EQUAL	
min2	TokenNameIdentifier	 min2
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
max2	TokenNameIdentifier	 max2
==	TokenNameEQUAL_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
OCCURRENCE_UNBOUNDED	TokenNameIdentifier	 OCCURRENCE  UNBOUNDED
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
max1	TokenNameIdentifier	 max1
!=	TokenNameNOT_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
OCCURRENCE_UNBOUNDED	TokenNameIdentifier	 OCCURRENCE  UNBOUNDED
&&	TokenNameAND_AND	
max1	TokenNameIdentifier	 max1
<=	TokenNameLESS_EQUAL	
max2	TokenNameIdentifier	 max2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
checkNSCompat	TokenNameIdentifier	 check NS Compat
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
elem	TokenNameIdentifier	 elem
,	TokenNameCOMMA	
int	TokenNameint	
min1	TokenNameIdentifier	 min1
,	TokenNameCOMMA	
int	TokenNameint	
max1	TokenNameIdentifier	 max1
,	TokenNameCOMMA	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
wildcard	TokenNameIdentifier	 wildcard
,	TokenNameCOMMA	
int	TokenNameint	
min2	TokenNameIdentifier	 min2
,	TokenNameCOMMA	
int	TokenNameint	
max2	TokenNameIdentifier	 max2
,	TokenNameCOMMA	
boolean	TokenNameboolean	
checkWCOccurrence	TokenNameIdentifier	 check WC Occurrence
)	TokenNameRPAREN	
throws	TokenNamethrows	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
{	TokenNameLBRACE	
// check Occurrence ranges 	TokenNameCOMMENT_LINE	check Occurrence ranges 
if	TokenNameif	
(	TokenNameLPAREN	
checkWCOccurrence	TokenNameIdentifier	 check WC Occurrence
&&	TokenNameAND_AND	
!	TokenNameNOT	
checkOccurrenceRange	TokenNameIdentifier	 check Occurrence Range
(	TokenNameLPAREN	
min1	TokenNameIdentifier	 min1
,	TokenNameCOMMA	
max1	TokenNameIdentifier	 max1
,	TokenNameCOMMA	
min2	TokenNameIdentifier	 min2
,	TokenNameCOMMA	
max2	TokenNameIdentifier	 max2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"rcase-NSCompat.2"	TokenNameStringLiteral	rcase-NSCompat.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
elem	TokenNameIdentifier	 elem
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
min1	TokenNameIdentifier	 min1
)	TokenNameRPAREN	
,	TokenNameCOMMA	
max1	TokenNameIdentifier	 max1
==	TokenNameEQUAL_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
OCCURRENCE_UNBOUNDED	TokenNameIdentifier	 OCCURRENCE  UNBOUNDED
?	TokenNameQUESTION	
"unbounded"	TokenNameStringLiteral	unbounded
:	TokenNameCOLON	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
max1	TokenNameIdentifier	 max1
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
min2	TokenNameIdentifier	 min2
)	TokenNameRPAREN	
,	TokenNameCOMMA	
max2	TokenNameIdentifier	 max2
==	TokenNameEQUAL_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
OCCURRENCE_UNBOUNDED	TokenNameIdentifier	 OCCURRENCE  UNBOUNDED
?	TokenNameQUESTION	
"unbounded"	TokenNameStringLiteral	unbounded
:	TokenNameCOLON	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
max2	TokenNameIdentifier	 max2
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// check wildcard allows namespace of element 	TokenNameCOMMENT_LINE	check wildcard allows namespace of element 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
wildcard	TokenNameIdentifier	 wildcard
.	TokenNameDOT	
allowNamespace	TokenNameIdentifier	 allow Namespace
(	TokenNameLPAREN	
elem	TokenNameIdentifier	 elem
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"rcase-NSCompat.1"	TokenNameStringLiteral	rcase-NSCompat.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
elem	TokenNameIdentifier	 elem
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
elem	TokenNameIdentifier	 elem
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
checkNSSubset	TokenNameIdentifier	 check NS Subset
(	TokenNameLPAREN	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
dWildcard	TokenNameIdentifier	 d Wildcard
,	TokenNameCOMMA	
int	TokenNameint	
min1	TokenNameIdentifier	 min1
,	TokenNameCOMMA	
int	TokenNameint	
max1	TokenNameIdentifier	 max1
,	TokenNameCOMMA	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
bWildcard	TokenNameIdentifier	 b Wildcard
,	TokenNameCOMMA	
int	TokenNameint	
min2	TokenNameIdentifier	 min2
,	TokenNameCOMMA	
int	TokenNameint	
max2	TokenNameIdentifier	 max2
)	TokenNameRPAREN	
throws	TokenNamethrows	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
{	TokenNameLBRACE	
// check Occurrence ranges 	TokenNameCOMMENT_LINE	check Occurrence ranges 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
checkOccurrenceRange	TokenNameIdentifier	 check Occurrence Range
(	TokenNameLPAREN	
min1	TokenNameIdentifier	 min1
,	TokenNameCOMMA	
max1	TokenNameIdentifier	 max1
,	TokenNameCOMMA	
min2	TokenNameIdentifier	 min2
,	TokenNameCOMMA	
max2	TokenNameIdentifier	 max2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"rcase-NSSubset.2"	TokenNameStringLiteral	rcase-NSSubset.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
min1	TokenNameIdentifier	 min1
)	TokenNameRPAREN	
,	TokenNameCOMMA	
max1	TokenNameIdentifier	 max1
==	TokenNameEQUAL_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
OCCURRENCE_UNBOUNDED	TokenNameIdentifier	 OCCURRENCE  UNBOUNDED
?	TokenNameQUESTION	
"unbounded"	TokenNameStringLiteral	unbounded
:	TokenNameCOLON	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
max1	TokenNameIdentifier	 max1
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
min2	TokenNameIdentifier	 min2
)	TokenNameRPAREN	
,	TokenNameCOMMA	
max2	TokenNameIdentifier	 max2
==	TokenNameEQUAL_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
OCCURRENCE_UNBOUNDED	TokenNameIdentifier	 OCCURRENCE  UNBOUNDED
?	TokenNameQUESTION	
"unbounded"	TokenNameStringLiteral	unbounded
:	TokenNameCOLON	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
max2	TokenNameIdentifier	 max2
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// check wildcard subset 	TokenNameCOMMENT_LINE	check wildcard subset 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
dWildcard	TokenNameIdentifier	 d Wildcard
.	TokenNameDOT	
isSubsetOf	TokenNameIdentifier	 is Subset Of
(	TokenNameLPAREN	
bWildcard	TokenNameIdentifier	 b Wildcard
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"rcase-NSSubset.1"	TokenNameStringLiteral	rcase-NSSubset.1
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
dWildcard	TokenNameIdentifier	 d Wildcard
.	TokenNameDOT	
weakerProcessContents	TokenNameIdentifier	 weaker Process Contents
(	TokenNameLPAREN	
bWildcard	TokenNameIdentifier	 b Wildcard
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"rcase-NSSubset.3"	TokenNameStringLiteral	rcase-NSSubset.3
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
dWildcard	TokenNameIdentifier	 d Wildcard
.	TokenNameDOT	
getProcessContentsAsString	TokenNameIdentifier	 get Process Contents As String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
bWildcard	TokenNameIdentifier	 b Wildcard
.	TokenNameDOT	
getProcessContentsAsString	TokenNameIdentifier	 get Process Contents As String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
checkNSRecurseCheckCardinality	TokenNameIdentifier	 check NS Recurse Check Cardinality
(	TokenNameLPAREN	
Vector	TokenNameIdentifier	 Vector
children	TokenNameIdentifier	 children
,	TokenNameCOMMA	
int	TokenNameint	
min1	TokenNameIdentifier	 min1
,	TokenNameCOMMA	
int	TokenNameint	
max1	TokenNameIdentifier	 max1
,	TokenNameCOMMA	
SubstitutionGroupHandler	TokenNameIdentifier	 Substitution Group Handler
dSGHandler	TokenNameIdentifier	 d SG Handler
,	TokenNameCOMMA	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
wildcard	TokenNameIdentifier	 wildcard
,	TokenNameCOMMA	
int	TokenNameint	
min2	TokenNameIdentifier	 min2
,	TokenNameCOMMA	
int	TokenNameint	
max2	TokenNameIdentifier	 max2
,	TokenNameCOMMA	
boolean	TokenNameboolean	
checkWCOccurrence	TokenNameIdentifier	 check WC Occurrence
)	TokenNameRPAREN	
throws	TokenNamethrows	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
{	TokenNameLBRACE	
// check Occurrence ranges 	TokenNameCOMMENT_LINE	check Occurrence ranges 
if	TokenNameif	
(	TokenNameLPAREN	
checkWCOccurrence	TokenNameIdentifier	 check WC Occurrence
&&	TokenNameAND_AND	
!	TokenNameNOT	
checkOccurrenceRange	TokenNameIdentifier	 check Occurrence Range
(	TokenNameLPAREN	
min1	TokenNameIdentifier	 min1
,	TokenNameCOMMA	
max1	TokenNameIdentifier	 max1
,	TokenNameCOMMA	
min2	TokenNameIdentifier	 min2
,	TokenNameCOMMA	
max2	TokenNameIdentifier	 max2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"rcase-NSRecurseCheckCardinality.2"	TokenNameStringLiteral	rcase-NSRecurseCheckCardinality.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
min1	TokenNameIdentifier	 min1
)	TokenNameRPAREN	
,	TokenNameCOMMA	
max1	TokenNameIdentifier	 max1
==	TokenNameEQUAL_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
OCCURRENCE_UNBOUNDED	TokenNameIdentifier	 OCCURRENCE  UNBOUNDED
?	TokenNameQUESTION	
"unbounded"	TokenNameStringLiteral	unbounded
:	TokenNameCOLON	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
max1	TokenNameIdentifier	 max1
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
min2	TokenNameIdentifier	 min2
)	TokenNameRPAREN	
,	TokenNameCOMMA	
max2	TokenNameIdentifier	 max2
==	TokenNameEQUAL_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
OCCURRENCE_UNBOUNDED	TokenNameIdentifier	 OCCURRENCE  UNBOUNDED
?	TokenNameQUESTION	
"unbounded"	TokenNameStringLiteral	unbounded
:	TokenNameCOLON	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
max2	TokenNameIdentifier	 max2
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Check that each member of the group is a valid restriction of the wildcard 	TokenNameCOMMENT_LINE	Check that each member of the group is a valid restriction of the wildcard 
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
children	TokenNameIdentifier	 children
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
particle1	TokenNameIdentifier	 particle1
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
)	TokenNameRPAREN	
children	TokenNameIdentifier	 children
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
particleValidRestriction	TokenNameIdentifier	 particle Valid Restriction
(	TokenNameLPAREN	
particle1	TokenNameIdentifier	 particle1
,	TokenNameCOMMA	
dSGHandler	TokenNameIdentifier	 d SG Handler
,	TokenNameCOMMA	
wildcard	TokenNameIdentifier	 wildcard
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// REVISIT: should we really just ignore original cause of this error? 	TokenNameCOMMENT_LINE	REVISIT: should we really just ignore original cause of this error? 
// how can we report it? 	TokenNameCOMMENT_LINE	how can we report it? 
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"rcase-NSRecurseCheckCardinality.1"	TokenNameStringLiteral	rcase-NSRecurseCheckCardinality.1
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
checkRecurse	TokenNameIdentifier	 check Recurse
(	TokenNameLPAREN	
Vector	TokenNameIdentifier	 Vector
dChildren	TokenNameIdentifier	 d Children
,	TokenNameCOMMA	
int	TokenNameint	
min1	TokenNameIdentifier	 min1
,	TokenNameCOMMA	
int	TokenNameint	
max1	TokenNameIdentifier	 max1
,	TokenNameCOMMA	
SubstitutionGroupHandler	TokenNameIdentifier	 Substitution Group Handler
dSGHandler	TokenNameIdentifier	 d SG Handler
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
bChildren	TokenNameIdentifier	 b Children
,	TokenNameCOMMA	
int	TokenNameint	
min2	TokenNameIdentifier	 min2
,	TokenNameCOMMA	
int	TokenNameint	
max2	TokenNameIdentifier	 max2
,	TokenNameCOMMA	
SubstitutionGroupHandler	TokenNameIdentifier	 Substitution Group Handler
bSGHandler	TokenNameIdentifier	 b SG Handler
)	TokenNameRPAREN	
throws	TokenNamethrows	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
{	TokenNameLBRACE	
// check Occurrence ranges 	TokenNameCOMMENT_LINE	check Occurrence ranges 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
checkOccurrenceRange	TokenNameIdentifier	 check Occurrence Range
(	TokenNameLPAREN	
min1	TokenNameIdentifier	 min1
,	TokenNameCOMMA	
max1	TokenNameIdentifier	 max1
,	TokenNameCOMMA	
min2	TokenNameIdentifier	 min2
,	TokenNameCOMMA	
max2	TokenNameIdentifier	 max2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"rcase-Recurse.1"	TokenNameStringLiteral	rcase-Recurse.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
min1	TokenNameIdentifier	 min1
)	TokenNameRPAREN	
,	TokenNameCOMMA	
max1	TokenNameIdentifier	 max1
==	TokenNameEQUAL_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
OCCURRENCE_UNBOUNDED	TokenNameIdentifier	 OCCURRENCE  UNBOUNDED
?	TokenNameQUESTION	
"unbounded"	TokenNameStringLiteral	unbounded
:	TokenNameCOLON	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
max1	TokenNameIdentifier	 max1
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
min2	TokenNameIdentifier	 min2
)	TokenNameRPAREN	
,	TokenNameCOMMA	
max2	TokenNameIdentifier	 max2
==	TokenNameEQUAL_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
OCCURRENCE_UNBOUNDED	TokenNameIdentifier	 OCCURRENCE  UNBOUNDED
?	TokenNameQUESTION	
"unbounded"	TokenNameStringLiteral	unbounded
:	TokenNameCOLON	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
max2	TokenNameIdentifier	 max2
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
count1	TokenNameIdentifier	 count1
=	TokenNameEQUAL	
dChildren	TokenNameIdentifier	 d Children
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
count2	TokenNameIdentifier	 count2
=	TokenNameEQUAL	
bChildren	TokenNameIdentifier	 b Children
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
current	TokenNameIdentifier	 current
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
label	TokenNameIdentifier	 label
:	TokenNameCOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
count1	TokenNameIdentifier	 count1
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
particle1	TokenNameIdentifier	 particle1
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
)	TokenNameRPAREN	
dChildren	TokenNameIdentifier	 d Children
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
current	TokenNameIdentifier	 current
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
count2	TokenNameIdentifier	 count2
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
particle2	TokenNameIdentifier	 particle2
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
)	TokenNameRPAREN	
bChildren	TokenNameIdentifier	 b Children
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
current	TokenNameIdentifier	 current
+=	TokenNamePLUS_EQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
particleValidRestriction	TokenNameIdentifier	 particle Valid Restriction
(	TokenNameLPAREN	
particle1	TokenNameIdentifier	 particle1
,	TokenNameCOMMA	
dSGHandler	TokenNameIdentifier	 d SG Handler
,	TokenNameCOMMA	
particle2	TokenNameIdentifier	 particle2
,	TokenNameCOMMA	
bSGHandler	TokenNameIdentifier	 b SG Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
label	TokenNameIdentifier	 label
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
particle2	TokenNameIdentifier	 particle2
.	TokenNameDOT	
emptiable	TokenNameIdentifier	 emptiable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"rcase-Recurse.2"	TokenNameStringLiteral	rcase-Recurse.2
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"rcase-Recurse.2"	TokenNameStringLiteral	rcase-Recurse.2
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Now, see if there are some elements in the base we didn't match up 	TokenNameCOMMENT_LINE	Now, see if there are some elements in the base we didn't match up 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
current	TokenNameIdentifier	 current
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
count2	TokenNameIdentifier	 count2
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
particle2	TokenNameIdentifier	 particle2
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
)	TokenNameRPAREN	
bChildren	TokenNameIdentifier	 b Children
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
particle2	TokenNameIdentifier	 particle2
.	TokenNameDOT	
emptiable	TokenNameIdentifier	 emptiable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"rcase-Recurse.2"	TokenNameStringLiteral	rcase-Recurse.2
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
checkRecurseUnordered	TokenNameIdentifier	 check Recurse Unordered
(	TokenNameLPAREN	
Vector	TokenNameIdentifier	 Vector
dChildren	TokenNameIdentifier	 d Children
,	TokenNameCOMMA	
int	TokenNameint	
min1	TokenNameIdentifier	 min1
,	TokenNameCOMMA	
int	TokenNameint	
max1	TokenNameIdentifier	 max1
,	TokenNameCOMMA	
SubstitutionGroupHandler	TokenNameIdentifier	 Substitution Group Handler
dSGHandler	TokenNameIdentifier	 d SG Handler
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
bChildren	TokenNameIdentifier	 b Children
,	TokenNameCOMMA	
int	TokenNameint	
min2	TokenNameIdentifier	 min2
,	TokenNameCOMMA	
int	TokenNameint	
max2	TokenNameIdentifier	 max2
,	TokenNameCOMMA	
SubstitutionGroupHandler	TokenNameIdentifier	 Substitution Group Handler
bSGHandler	TokenNameIdentifier	 b SG Handler
)	TokenNameRPAREN	
throws	TokenNamethrows	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
{	TokenNameLBRACE	
// check Occurrence ranges 	TokenNameCOMMENT_LINE	check Occurrence ranges 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
checkOccurrenceRange	TokenNameIdentifier	 check Occurrence Range
(	TokenNameLPAREN	
min1	TokenNameIdentifier	 min1
,	TokenNameCOMMA	
max1	TokenNameIdentifier	 max1
,	TokenNameCOMMA	
min2	TokenNameIdentifier	 min2
,	TokenNameCOMMA	
max2	TokenNameIdentifier	 max2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"rcase-RecurseUnordered.1"	TokenNameStringLiteral	rcase-RecurseUnordered.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
min1	TokenNameIdentifier	 min1
)	TokenNameRPAREN	
,	TokenNameCOMMA	
max1	TokenNameIdentifier	 max1
==	TokenNameEQUAL_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
OCCURRENCE_UNBOUNDED	TokenNameIdentifier	 OCCURRENCE  UNBOUNDED
?	TokenNameQUESTION	
"unbounded"	TokenNameStringLiteral	unbounded
:	TokenNameCOLON	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
max1	TokenNameIdentifier	 max1
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
min2	TokenNameIdentifier	 min2
)	TokenNameRPAREN	
,	TokenNameCOMMA	
max2	TokenNameIdentifier	 max2
==	TokenNameEQUAL_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
OCCURRENCE_UNBOUNDED	TokenNameIdentifier	 OCCURRENCE  UNBOUNDED
?	TokenNameQUESTION	
"unbounded"	TokenNameStringLiteral	unbounded
:	TokenNameCOLON	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
max2	TokenNameIdentifier	 max2
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
count1	TokenNameIdentifier	 count1
=	TokenNameEQUAL	
dChildren	TokenNameIdentifier	 d Children
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
count2	TokenNameIdentifier	 count2
=	TokenNameEQUAL	
bChildren	TokenNameIdentifier	 b Children
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
foundIt	TokenNameIdentifier	 found It
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
count2	TokenNameIdentifier	 count2
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
label	TokenNameIdentifier	 label
:	TokenNameCOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
count1	TokenNameIdentifier	 count1
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
particle1	TokenNameIdentifier	 particle1
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
)	TokenNameRPAREN	
dChildren	TokenNameIdentifier	 d Children
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
count2	TokenNameIdentifier	 count2
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
particle2	TokenNameIdentifier	 particle2
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
)	TokenNameRPAREN	
bChildren	TokenNameIdentifier	 b Children
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
particleValidRestriction	TokenNameIdentifier	 particle Valid Restriction
(	TokenNameLPAREN	
particle1	TokenNameIdentifier	 particle1
,	TokenNameCOMMA	
dSGHandler	TokenNameIdentifier	 d SG Handler
,	TokenNameCOMMA	
particle2	TokenNameIdentifier	 particle2
,	TokenNameCOMMA	
bSGHandler	TokenNameIdentifier	 b SG Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
foundIt	TokenNameIdentifier	 found It
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"rcase-RecurseUnordered.2"	TokenNameStringLiteral	rcase-RecurseUnordered.2
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
foundIt	TokenNameIdentifier	 found It
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
label	TokenNameIdentifier	 label
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// didn't find a match. Detect an error 	TokenNameCOMMENT_LINE	didn't find a match. Detect an error 
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"rcase-RecurseUnordered.2"	TokenNameStringLiteral	rcase-RecurseUnordered.2
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Now, see if there are some elements in the base we didn't match up 	TokenNameCOMMENT_LINE	Now, see if there are some elements in the base we didn't match up 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
count2	TokenNameIdentifier	 count2
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
particle2	TokenNameIdentifier	 particle2
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
)	TokenNameRPAREN	
bChildren	TokenNameIdentifier	 b Children
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
foundIt	TokenNameIdentifier	 found It
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
&&	TokenNameAND_AND	
!	TokenNameNOT	
particle2	TokenNameIdentifier	 particle2
.	TokenNameDOT	
emptiable	TokenNameIdentifier	 emptiable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"rcase-RecurseUnordered.2"	TokenNameStringLiteral	rcase-RecurseUnordered.2
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
checkRecurseLax	TokenNameIdentifier	 check Recurse Lax
(	TokenNameLPAREN	
Vector	TokenNameIdentifier	 Vector
dChildren	TokenNameIdentifier	 d Children
,	TokenNameCOMMA	
int	TokenNameint	
min1	TokenNameIdentifier	 min1
,	TokenNameCOMMA	
int	TokenNameint	
max1	TokenNameIdentifier	 max1
,	TokenNameCOMMA	
SubstitutionGroupHandler	TokenNameIdentifier	 Substitution Group Handler
dSGHandler	TokenNameIdentifier	 d SG Handler
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
bChildren	TokenNameIdentifier	 b Children
,	TokenNameCOMMA	
int	TokenNameint	
min2	TokenNameIdentifier	 min2
,	TokenNameCOMMA	
int	TokenNameint	
max2	TokenNameIdentifier	 max2
,	TokenNameCOMMA	
SubstitutionGroupHandler	TokenNameIdentifier	 Substitution Group Handler
bSGHandler	TokenNameIdentifier	 b SG Handler
)	TokenNameRPAREN	
throws	TokenNamethrows	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
{	TokenNameLBRACE	
// check Occurrence ranges 	TokenNameCOMMENT_LINE	check Occurrence ranges 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
checkOccurrenceRange	TokenNameIdentifier	 check Occurrence Range
(	TokenNameLPAREN	
min1	TokenNameIdentifier	 min1
,	TokenNameCOMMA	
max1	TokenNameIdentifier	 max1
,	TokenNameCOMMA	
min2	TokenNameIdentifier	 min2
,	TokenNameCOMMA	
max2	TokenNameIdentifier	 max2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"rcase-RecurseLax.1"	TokenNameStringLiteral	rcase-RecurseLax.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
min1	TokenNameIdentifier	 min1
)	TokenNameRPAREN	
,	TokenNameCOMMA	
max1	TokenNameIdentifier	 max1
==	TokenNameEQUAL_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
OCCURRENCE_UNBOUNDED	TokenNameIdentifier	 OCCURRENCE  UNBOUNDED
?	TokenNameQUESTION	
"unbounded"	TokenNameStringLiteral	unbounded
:	TokenNameCOLON	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
max1	TokenNameIdentifier	 max1
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
min2	TokenNameIdentifier	 min2
)	TokenNameRPAREN	
,	TokenNameCOMMA	
max2	TokenNameIdentifier	 max2
==	TokenNameEQUAL_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
OCCURRENCE_UNBOUNDED	TokenNameIdentifier	 OCCURRENCE  UNBOUNDED
?	TokenNameQUESTION	
"unbounded"	TokenNameStringLiteral	unbounded
:	TokenNameCOLON	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
max2	TokenNameIdentifier	 max2
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
count1	TokenNameIdentifier	 count1
=	TokenNameEQUAL	
dChildren	TokenNameIdentifier	 d Children
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
count2	TokenNameIdentifier	 count2
=	TokenNameEQUAL	
bChildren	TokenNameIdentifier	 b Children
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
current	TokenNameIdentifier	 current
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
label	TokenNameIdentifier	 label
:	TokenNameCOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
count1	TokenNameIdentifier	 count1
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
particle1	TokenNameIdentifier	 particle1
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
)	TokenNameRPAREN	
dChildren	TokenNameIdentifier	 d Children
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
current	TokenNameIdentifier	 current
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
count2	TokenNameIdentifier	 count2
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
particle2	TokenNameIdentifier	 particle2
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
)	TokenNameRPAREN	
bChildren	TokenNameIdentifier	 b Children
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
current	TokenNameIdentifier	 current
+=	TokenNamePLUS_EQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
// IHR: go back one element on b list because the next element may match 	TokenNameCOMMENT_LINE	IHR: go back one element on b list because the next element may match 
// this as well. 	TokenNameCOMMENT_LINE	this as well. 
if	TokenNameif	
(	TokenNameLPAREN	
particleValidRestriction	TokenNameIdentifier	 particle Valid Restriction
(	TokenNameLPAREN	
particle1	TokenNameIdentifier	 particle1
,	TokenNameCOMMA	
dSGHandler	TokenNameIdentifier	 d SG Handler
,	TokenNameCOMMA	
particle2	TokenNameIdentifier	 particle2
,	TokenNameCOMMA	
bSGHandler	TokenNameIdentifier	 b SG Handler
)	TokenNameRPAREN	
)	TokenNameRPAREN	
current	TokenNameIdentifier	 current
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
label	TokenNameIdentifier	 label
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// didn't find a match. Detect an error 	TokenNameCOMMENT_LINE	didn't find a match. Detect an error 
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"rcase-RecurseLax.2"	TokenNameStringLiteral	rcase-RecurseLax.2
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
checkMapAndSum	TokenNameIdentifier	 check Map And Sum
(	TokenNameLPAREN	
Vector	TokenNameIdentifier	 Vector
dChildren	TokenNameIdentifier	 d Children
,	TokenNameCOMMA	
int	TokenNameint	
min1	TokenNameIdentifier	 min1
,	TokenNameCOMMA	
int	TokenNameint	
max1	TokenNameIdentifier	 max1
,	TokenNameCOMMA	
SubstitutionGroupHandler	TokenNameIdentifier	 Substitution Group Handler
dSGHandler	TokenNameIdentifier	 d SG Handler
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
bChildren	TokenNameIdentifier	 b Children
,	TokenNameCOMMA	
int	TokenNameint	
min2	TokenNameIdentifier	 min2
,	TokenNameCOMMA	
int	TokenNameint	
max2	TokenNameIdentifier	 max2
,	TokenNameCOMMA	
SubstitutionGroupHandler	TokenNameIdentifier	 Substitution Group Handler
bSGHandler	TokenNameIdentifier	 b SG Handler
)	TokenNameRPAREN	
throws	TokenNamethrows	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
{	TokenNameLBRACE	
// See if the sequence group is a valid restriction of the choice 	TokenNameCOMMENT_LINE	See if the sequence group is a valid restriction of the choice 
// Here is an example of a valid restriction: 	TokenNameCOMMENT_LINE	Here is an example of a valid restriction: 
// <choice minOccurs="2"> 	TokenNameCOMMENT_LINE	<choice minOccurs="2"> 
// <a/> 	TokenNameCOMMENT_LINE	<a/> 
// <b/> 	TokenNameCOMMENT_LINE	<b/> 
// <c/> 	TokenNameCOMMENT_LINE	<c/> 
// </choice> 	TokenNameCOMMENT_LINE	</choice> 
// 	TokenNameCOMMENT_LINE	 
// <sequence> 	TokenNameCOMMENT_LINE	<sequence> 
// <b/> 	TokenNameCOMMENT_LINE	<b/> 
// <a/> 	TokenNameCOMMENT_LINE	<a/> 
// </sequence> 	TokenNameCOMMENT_LINE	</sequence> 
// check Occurrence ranges 	TokenNameCOMMENT_LINE	check Occurrence ranges 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
checkOccurrenceRange	TokenNameIdentifier	 check Occurrence Range
(	TokenNameLPAREN	
min1	TokenNameIdentifier	 min1
,	TokenNameCOMMA	
max1	TokenNameIdentifier	 max1
,	TokenNameCOMMA	
min2	TokenNameIdentifier	 min2
,	TokenNameCOMMA	
max2	TokenNameIdentifier	 max2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"rcase-MapAndSum.2"	TokenNameStringLiteral	rcase-MapAndSum.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
min1	TokenNameIdentifier	 min1
)	TokenNameRPAREN	
,	TokenNameCOMMA	
max1	TokenNameIdentifier	 max1
==	TokenNameEQUAL_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
OCCURRENCE_UNBOUNDED	TokenNameIdentifier	 OCCURRENCE  UNBOUNDED
?	TokenNameQUESTION	
"unbounded"	TokenNameStringLiteral	unbounded
:	TokenNameCOLON	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
max1	TokenNameIdentifier	 max1
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
min2	TokenNameIdentifier	 min2
)	TokenNameRPAREN	
,	TokenNameCOMMA	
max2	TokenNameIdentifier	 max2
==	TokenNameEQUAL_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
OCCURRENCE_UNBOUNDED	TokenNameIdentifier	 OCCURRENCE  UNBOUNDED
?	TokenNameQUESTION	
"unbounded"	TokenNameStringLiteral	unbounded
:	TokenNameCOLON	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
max2	TokenNameIdentifier	 max2
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
count1	TokenNameIdentifier	 count1
=	TokenNameEQUAL	
dChildren	TokenNameIdentifier	 d Children
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
count2	TokenNameIdentifier	 count2
=	TokenNameEQUAL	
bChildren	TokenNameIdentifier	 b Children
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
label	TokenNameIdentifier	 label
:	TokenNameCOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
count1	TokenNameIdentifier	 count1
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
particle1	TokenNameIdentifier	 particle1
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
)	TokenNameRPAREN	
dChildren	TokenNameIdentifier	 d Children
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
count2	TokenNameIdentifier	 count2
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
particle2	TokenNameIdentifier	 particle2
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
)	TokenNameRPAREN	
bChildren	TokenNameIdentifier	 b Children
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
particleValidRestriction	TokenNameIdentifier	 particle Valid Restriction
(	TokenNameLPAREN	
particle1	TokenNameIdentifier	 particle1
,	TokenNameCOMMA	
dSGHandler	TokenNameIdentifier	 d SG Handler
,	TokenNameCOMMA	
particle2	TokenNameIdentifier	 particle2
,	TokenNameCOMMA	
bSGHandler	TokenNameIdentifier	 b SG Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
label	TokenNameIdentifier	 label
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// didn't find a match. Detect an error 	TokenNameCOMMENT_LINE	didn't find a match. Detect an error 
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"rcase-MapAndSum.1"	TokenNameStringLiteral	rcase-MapAndSum.1
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// to check whether two element overlap, as defined in constraint UPA 	TokenNameCOMMENT_LINE	to check whether two element overlap, as defined in constraint UPA 
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
overlapUPA	TokenNameIdentifier	 overlap UPA
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
element1	TokenNameIdentifier	 element1
,	TokenNameCOMMA	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
element2	TokenNameIdentifier	 element2
,	TokenNameCOMMA	
SubstitutionGroupHandler	TokenNameIdentifier	 Substitution Group Handler
sgHandler	TokenNameIdentifier	 sg Handler
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if the two element have the same name and namespace, 	TokenNameCOMMENT_LINE	if the two element have the same name and namespace, 
if	TokenNameif	
(	TokenNameLPAREN	
element1	TokenNameIdentifier	 element1
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
==	TokenNameEQUAL_EQUAL	
element2	TokenNameIdentifier	 element2
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
&&	TokenNameAND_AND	
element1	TokenNameIdentifier	 element1
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
==	TokenNameEQUAL_EQUAL	
element2	TokenNameIdentifier	 element2
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// or if there is an element decl in element1's substitution group, 	TokenNameCOMMENT_LINE	or if there is an element decl in element1's substitution group, 
// who has the same name/namespace with element2 	TokenNameCOMMENT_LINE	who has the same name/namespace with element2 
XSElementDecl	TokenNameIdentifier	 XS Element Decl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
subGroup	TokenNameIdentifier	 sub Group
=	TokenNameEQUAL	
sgHandler	TokenNameIdentifier	 sg Handler
.	TokenNameDOT	
getSubstitutionGroup	TokenNameIdentifier	 get Substitution Group
(	TokenNameLPAREN	
element1	TokenNameIdentifier	 element1
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
subGroup	TokenNameIdentifier	 sub Group
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
subGroup	TokenNameIdentifier	 sub Group
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
==	TokenNameEQUAL_EQUAL	
element2	TokenNameIdentifier	 element2
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
&&	TokenNameAND_AND	
subGroup	TokenNameIdentifier	 sub Group
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
==	TokenNameEQUAL_EQUAL	
element2	TokenNameIdentifier	 element2
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// or if there is an element decl in element2's substitution group, 	TokenNameCOMMENT_LINE	or if there is an element decl in element2's substitution group, 
// who has the same name/namespace with element1 	TokenNameCOMMENT_LINE	who has the same name/namespace with element1 
subGroup	TokenNameIdentifier	 sub Group
=	TokenNameEQUAL	
sgHandler	TokenNameIdentifier	 sg Handler
.	TokenNameDOT	
getSubstitutionGroup	TokenNameIdentifier	 get Substitution Group
(	TokenNameLPAREN	
element2	TokenNameIdentifier	 element2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
subGroup	TokenNameIdentifier	 sub Group
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
subGroup	TokenNameIdentifier	 sub Group
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
==	TokenNameEQUAL_EQUAL	
element1	TokenNameIdentifier	 element1
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
&&	TokenNameAND_AND	
subGroup	TokenNameIdentifier	 sub Group
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
==	TokenNameEQUAL_EQUAL	
element1	TokenNameIdentifier	 element1
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// to check whether an element overlaps with a wildcard, 	TokenNameCOMMENT_LINE	to check whether an element overlaps with a wildcard, 
// as defined in constraint UPA 	TokenNameCOMMENT_LINE	as defined in constraint UPA 
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
overlapUPA	TokenNameIdentifier	 overlap UPA
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
wildcard	TokenNameIdentifier	 wildcard
,	TokenNameCOMMA	
SubstitutionGroupHandler	TokenNameIdentifier	 Substitution Group Handler
sgHandler	TokenNameIdentifier	 sg Handler
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if the wildcard allows the element 	TokenNameCOMMENT_LINE	if the wildcard allows the element 
if	TokenNameif	
(	TokenNameLPAREN	
wildcard	TokenNameIdentifier	 wildcard
.	TokenNameDOT	
allowNamespace	TokenNameIdentifier	 allow Namespace
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// or if the wildcard allows any element in the substitution group 	TokenNameCOMMENT_LINE	or if the wildcard allows any element in the substitution group 
XSElementDecl	TokenNameIdentifier	 XS Element Decl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
subGroup	TokenNameIdentifier	 sub Group
=	TokenNameEQUAL	
sgHandler	TokenNameIdentifier	 sg Handler
.	TokenNameDOT	
getSubstitutionGroup	TokenNameIdentifier	 get Substitution Group
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
subGroup	TokenNameIdentifier	 sub Group
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
wildcard	TokenNameIdentifier	 wildcard
.	TokenNameDOT	
allowNamespace	TokenNameIdentifier	 allow Namespace
(	TokenNameLPAREN	
subGroup	TokenNameIdentifier	 sub Group
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
overlapUPA	TokenNameIdentifier	 overlap UPA
(	TokenNameLPAREN	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
wildcard1	TokenNameIdentifier	 wildcard1
,	TokenNameCOMMA	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
wildcard2	TokenNameIdentifier	 wildcard2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if the intersection of the two wildcard is not empty list 	TokenNameCOMMENT_LINE	if the intersection of the two wildcard is not empty list 
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
intersect	TokenNameIdentifier	 intersect
=	TokenNameEQUAL	
wildcard1	TokenNameIdentifier	 wildcard1
.	TokenNameDOT	
performIntersectionWith	TokenNameIdentifier	 perform Intersection With
(	TokenNameLPAREN	
wildcard2	TokenNameIdentifier	 wildcard2
,	TokenNameCOMMA	
wildcard1	TokenNameIdentifier	 wildcard1
.	TokenNameDOT	
fProcessContents	TokenNameIdentifier	 f Process Contents
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
intersect	TokenNameIdentifier	 intersect
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
intersect	TokenNameIdentifier	 intersect
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
!=	TokenNameNOT_EQUAL	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
.	TokenNameDOT	
NSCONSTRAINT_LIST	TokenNameIdentifier	 NSCONSTRAINT  LIST
||	TokenNameOR_OR	
intersect	TokenNameIdentifier	 intersect
.	TokenNameDOT	
fNamespaceList	TokenNameIdentifier	 f Namespace List
.	TokenNameDOT	
length	TokenNameIdentifier	 length
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// call one of the above methods according to the type of decls 	TokenNameCOMMENT_LINE	call one of the above methods according to the type of decls 
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
overlapUPA	TokenNameIdentifier	 overlap UPA
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
decl1	TokenNameIdentifier	 decl1
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
decl2	TokenNameIdentifier	 decl2
,	TokenNameCOMMA	
SubstitutionGroupHandler	TokenNameIdentifier	 Substitution Group Handler
sgHandler	TokenNameIdentifier	 sg Handler
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
decl1	TokenNameIdentifier	 decl1
instanceof	TokenNameinstanceof	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
decl2	TokenNameIdentifier	 decl2
instanceof	TokenNameinstanceof	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
overlapUPA	TokenNameIdentifier	 overlap UPA
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
decl1	TokenNameIdentifier	 decl1
,	TokenNameCOMMA	
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
decl2	TokenNameIdentifier	 decl2
,	TokenNameCOMMA	
sgHandler	TokenNameIdentifier	 sg Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
overlapUPA	TokenNameIdentifier	 overlap UPA
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
decl1	TokenNameIdentifier	 decl1
,	TokenNameCOMMA	
(	TokenNameLPAREN	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
)	TokenNameRPAREN	
decl2	TokenNameIdentifier	 decl2
,	TokenNameCOMMA	
sgHandler	TokenNameIdentifier	 sg Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
decl2	TokenNameIdentifier	 decl2
instanceof	TokenNameinstanceof	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
overlapUPA	TokenNameIdentifier	 overlap UPA
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
decl2	TokenNameIdentifier	 decl2
,	TokenNameCOMMA	
(	TokenNameLPAREN	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
)	TokenNameRPAREN	
decl1	TokenNameIdentifier	 decl1
,	TokenNameCOMMA	
sgHandler	TokenNameIdentifier	 sg Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
overlapUPA	TokenNameIdentifier	 overlap UPA
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
)	TokenNameRPAREN	
decl1	TokenNameIdentifier	 decl1
,	TokenNameCOMMA	
(	TokenNameLPAREN	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
)	TokenNameRPAREN	
decl2	TokenNameIdentifier	 decl2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// class XSContraints 	TokenNameCOMMENT_LINE	class XSContraints 
