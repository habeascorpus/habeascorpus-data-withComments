/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
msg	TokenNameIdentifier	 msg
.	TokenNameDOT	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
SymbolTable	TokenNameIdentifier	 Symbol Table
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
XMLChar	TokenNameIdentifier	 XML Char
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
XMLStringBuffer	TokenNameIdentifier	 XML String Buffer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
XMLSymbols	TokenNameIdentifier	 XML Symbols
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
Augmentations	TokenNameIdentifier	 Augmentations
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XMLDTDContentModelHandler	TokenNameIdentifier	 XMLDTD Content Model Handler
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XMLDTDHandler	TokenNameIdentifier	 XMLDTD Handler
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XMLResourceIdentifier	TokenNameIdentifier	 XML Resource Identifier
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XMLString	TokenNameIdentifier	 XML String
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XNIException	TokenNameIdentifier	 XNI Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLComponent	TokenNameIdentifier	 XML Component
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLComponentManager	TokenNameIdentifier	 XML Component Manager
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLDTDScanner	TokenNameIdentifier	 XMLDTD Scanner
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLInputSource	TokenNameIdentifier	 XML Input Source
;	TokenNameSEMICOLON	
/** * This class is responsible for scanning the declarations found * in the internal and external subsets of a DTD in an XML document. * The scanner acts as the sources for the DTD information which is * communicated to the DTD handlers. * <p> * This component requires the following features and properties from the * component manager that uses it: * <ul> * <li>http://xml.org/sax/features/validation</li> * <li>http://apache.org/xml/features/scanner/notify-char-refs</li> * <li>http://apache.org/xml/properties/internal/symbol-table</li> * <li>http://apache.org/xml/properties/internal/error-reporter</li> * <li>http://apache.org/xml/properties/internal/entity-manager</li> * </ul> * * @xerces.internal * * @author Arnaud Le Hors, IBM * @author Andy Clark, IBM * @author Glenn Marcy, IBM * @author Eric Ye, IBM * * @version $Id: XMLDTDScannerImpl.java 965250 2010-07-18 16:04:58Z mrglavas $ */	TokenNameCOMMENT_JAVADOC	 This class is responsible for scanning the declarations found in the internal and external subsets of a DTD in an XML document. The scanner acts as the sources for the DTD information which is communicated to the DTD handlers. <p> This component requires the following features and properties from the component manager that uses it: <ul> <li>http://xml.org/sax/features/validation</li> <li>http://apache.org/xml/features/scanner/notify-char-refs</li> <li>http://apache.org/xml/properties/internal/symbol-table</li> <li>http://apache.org/xml/properties/internal/error-reporter</li> <li>http://apache.org/xml/properties/internal/entity-manager</li> </ul> * @xerces.internal * @author Arnaud Le Hors, IBM @author Andy Clark, IBM @author Glenn Marcy, IBM @author Eric Ye, IBM * @version $Id: XMLDTDScannerImpl.java 965250 2010-07-18 16:04:58Z mrglavas $ 
public	TokenNamepublic	
class	TokenNameclass	
XMLDTDScannerImpl	TokenNameIdentifier	 XMLDTD Scanner Impl
extends	TokenNameextends	
XMLScanner	TokenNameIdentifier	 XML Scanner
implements	TokenNameimplements	
XMLDTDScanner	TokenNameIdentifier	 XMLDTD Scanner
,	TokenNameCOMMA	
XMLComponent	TokenNameIdentifier	 XML Component
,	TokenNameCOMMA	
XMLEntityHandler	TokenNameIdentifier	 XML Entity Handler
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// Constants 	TokenNameCOMMENT_LINE	Constants 
// 	TokenNameCOMMENT_LINE	 
// scanner states 	TokenNameCOMMENT_LINE	scanner states 
/** Scanner state: end of input. */	TokenNameCOMMENT_JAVADOC	 Scanner state: end of input. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
SCANNER_STATE_END_OF_INPUT	TokenNameIdentifier	 SCANNER  STATE  END  OF  INPUT
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** Scanner state: text declaration. */	TokenNameCOMMENT_JAVADOC	 Scanner state: text declaration. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
SCANNER_STATE_TEXT_DECL	TokenNameIdentifier	 SCANNER  STATE  TEXT  DECL
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** Scanner state: markup declaration. */	TokenNameCOMMENT_JAVADOC	 Scanner state: markup declaration. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
SCANNER_STATE_MARKUP_DECL	TokenNameIdentifier	 SCANNER  STATE  MARKUP  DECL
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// recognized features and properties 	TokenNameCOMMENT_LINE	recognized features and properties 
/** Recognized features. */	TokenNameCOMMENT_JAVADOC	 Recognized features. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
RECOGNIZED_FEATURES	TokenNameIdentifier	 RECOGNIZED  FEATURES
=	TokenNameEQUAL	
{	TokenNameLBRACE	
VALIDATION	TokenNameIdentifier	 VALIDATION
,	TokenNameCOMMA	
NOTIFY_CHAR_REFS	TokenNameIdentifier	 NOTIFY  CHAR  REFS
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** Feature defaults. */	TokenNameCOMMENT_JAVADOC	 Feature defaults. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Boolean	TokenNameIdentifier	 Boolean
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
FEATURE_DEFAULTS	TokenNameIdentifier	 FEATURE  DEFAULTS
=	TokenNameEQUAL	
{	TokenNameLBRACE	
null	TokenNamenull	
,	TokenNameCOMMA	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
FALSE	TokenNameIdentifier	 FALSE
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** Recognized properties. */	TokenNameCOMMENT_JAVADOC	 Recognized properties. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
RECOGNIZED_PROPERTIES	TokenNameIdentifier	 RECOGNIZED  PROPERTIES
=	TokenNameEQUAL	
{	TokenNameLBRACE	
SYMBOL_TABLE	TokenNameIdentifier	 SYMBOL  TABLE
,	TokenNameCOMMA	
ERROR_REPORTER	TokenNameIdentifier	 ERROR  REPORTER
,	TokenNameCOMMA	
ENTITY_MANAGER	TokenNameIdentifier	 ENTITY  MANAGER
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** Property defaults. */	TokenNameCOMMENT_JAVADOC	 Property defaults. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
PROPERTY_DEFAULTS	TokenNameIdentifier	 PROPERTY  DEFAULTS
=	TokenNameEQUAL	
{	TokenNameLBRACE	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
// debugging 	TokenNameCOMMENT_LINE	debugging 
/** Debug scanner state. */	TokenNameCOMMENT_JAVADOC	 Debug scanner state. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
DEBUG_SCANNER_STATE	TokenNameIdentifier	 DEBUG  SCANNER  STATE
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Data 	TokenNameCOMMENT_LINE	Data 
// 	TokenNameCOMMENT_LINE	 
// handlers 	TokenNameCOMMENT_LINE	handlers 
/** DTD handler. */	TokenNameCOMMENT_JAVADOC	 DTD handler. 
protected	TokenNameprotected	
XMLDTDHandler	TokenNameIdentifier	 XMLDTD Handler
fDTDHandler	TokenNameIdentifier	 f DTD Handler
;	TokenNameSEMICOLON	
/** DTD content model handler. */	TokenNameCOMMENT_JAVADOC	 DTD content model handler. 
protected	TokenNameprotected	
XMLDTDContentModelHandler	TokenNameIdentifier	 XMLDTD Content Model Handler
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
;	TokenNameSEMICOLON	
// state 	TokenNameCOMMENT_LINE	state 
/** Scanner state. */	TokenNameCOMMENT_JAVADOC	 Scanner state. 
protected	TokenNameprotected	
int	TokenNameint	
fScannerState	TokenNameIdentifier	 f Scanner State
;	TokenNameSEMICOLON	
/** Standalone. */	TokenNameCOMMENT_JAVADOC	 Standalone. 
protected	TokenNameprotected	
boolean	TokenNameboolean	
fStandalone	TokenNameIdentifier	 f Standalone
;	TokenNameSEMICOLON	
/** Seen external DTD. */	TokenNameCOMMENT_JAVADOC	 Seen external DTD. 
protected	TokenNameprotected	
boolean	TokenNameboolean	
fSeenExternalDTD	TokenNameIdentifier	 f Seen External DTD
;	TokenNameSEMICOLON	
/** Seen a parameter entity reference. */	TokenNameCOMMENT_JAVADOC	 Seen a parameter entity reference. 
protected	TokenNameprotected	
boolean	TokenNameboolean	
fSeenPEReferences	TokenNameIdentifier	 f Seen PE References
;	TokenNameSEMICOLON	
// private data 	TokenNameCOMMENT_LINE	private data 
/** Start DTD called. */	TokenNameCOMMENT_JAVADOC	 Start DTD called. 
private	TokenNameprivate	
boolean	TokenNameboolean	
fStartDTDCalled	TokenNameIdentifier	 f Start DTD Called
;	TokenNameSEMICOLON	
/** * Stack of content operators (either '|' or ',') in children * content. */	TokenNameCOMMENT_JAVADOC	 Stack of content operators (either '|' or ',') in children content. 
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fContentStack	TokenNameIdentifier	 f Content Stack
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
5	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/** Size of content stack. */	TokenNameCOMMENT_JAVADOC	 Size of content stack. 
private	TokenNameprivate	
int	TokenNameint	
fContentDepth	TokenNameIdentifier	 f Content Depth
;	TokenNameSEMICOLON	
/** Parameter entity stack to check well-formedness. */	TokenNameCOMMENT_JAVADOC	 Parameter entity stack to check well-formedness. 
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fPEStack	TokenNameIdentifier	 f PE Stack
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
5	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/** Parameter entity stack to report start/end entity calls. */	TokenNameCOMMENT_JAVADOC	 Parameter entity stack to report start/end entity calls. 
private	TokenNameprivate	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fPEReport	TokenNameIdentifier	 f PE Report
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
5	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/** Number of opened parameter entities. */	TokenNameCOMMENT_JAVADOC	 Number of opened parameter entities. 
private	TokenNameprivate	
int	TokenNameint	
fPEDepth	TokenNameIdentifier	 f PE Depth
;	TokenNameSEMICOLON	
/** Markup depth. */	TokenNameCOMMENT_JAVADOC	 Markup depth. 
private	TokenNameprivate	
int	TokenNameint	
fMarkUpDepth	TokenNameIdentifier	 f Mark Up Depth
;	TokenNameSEMICOLON	
/** Number of opened external entities. */	TokenNameCOMMENT_JAVADOC	 Number of opened external entities. 
private	TokenNameprivate	
int	TokenNameint	
fExtEntityDepth	TokenNameIdentifier	 f Ext Entity Depth
;	TokenNameSEMICOLON	
/** Number of opened include sections. */	TokenNameCOMMENT_JAVADOC	 Number of opened include sections. 
private	TokenNameprivate	
int	TokenNameint	
fIncludeSectDepth	TokenNameIdentifier	 f Include Sect Depth
;	TokenNameSEMICOLON	
// temporary variables 	TokenNameCOMMENT_LINE	temporary variables 
/** Array of 3 strings. */	TokenNameCOMMENT_JAVADOC	 Array of 3 strings. 
private	TokenNameprivate	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fStrings	TokenNameIdentifier	 f Strings
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
3	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/** String. */	TokenNameCOMMENT_JAVADOC	 String. 
private	TokenNameprivate	
final	TokenNamefinal	
XMLString	TokenNameIdentifier	 XML String
fString	TokenNameIdentifier	 f String
=	TokenNameEQUAL	
new	TokenNamenew	
XMLString	TokenNameIdentifier	 XML String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** String buffer. */	TokenNameCOMMENT_JAVADOC	 String buffer. 
private	TokenNameprivate	
final	TokenNamefinal	
XMLStringBuffer	TokenNameIdentifier	 XML String Buffer
fStringBuffer	TokenNameIdentifier	 f String Buffer
=	TokenNameEQUAL	
new	TokenNamenew	
XMLStringBuffer	TokenNameIdentifier	 XML String Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** String buffer. */	TokenNameCOMMENT_JAVADOC	 String buffer. 
private	TokenNameprivate	
final	TokenNamefinal	
XMLStringBuffer	TokenNameIdentifier	 XML String Buffer
fStringBuffer2	TokenNameIdentifier	 f String Buffer2
=	TokenNameEQUAL	
new	TokenNamenew	
XMLStringBuffer	TokenNameIdentifier	 XML String Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Literal text. */	TokenNameCOMMENT_JAVADOC	 Literal text. 
private	TokenNameprivate	
final	TokenNamefinal	
XMLString	TokenNameIdentifier	 XML String
fLiteral	TokenNameIdentifier	 f Literal
=	TokenNameEQUAL	
new	TokenNamenew	
XMLString	TokenNameIdentifier	 XML String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Literal text. */	TokenNameCOMMENT_JAVADOC	 Literal text. 
private	TokenNameprivate	
final	TokenNamefinal	
XMLString	TokenNameIdentifier	 XML String
fLiteral2	TokenNameIdentifier	 f Literal2
=	TokenNameEQUAL	
new	TokenNamenew	
XMLString	TokenNameIdentifier	 XML String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Enumeration values. */	TokenNameCOMMENT_JAVADOC	 Enumeration values. 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fEnumeration	TokenNameIdentifier	 f Enumeration
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
5	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/** Enumeration values count. */	TokenNameCOMMENT_JAVADOC	 Enumeration values count. 
private	TokenNameprivate	
int	TokenNameint	
fEnumerationCount	TokenNameIdentifier	 f Enumeration Count
;	TokenNameSEMICOLON	
/** Ignore conditional section buffer. */	TokenNameCOMMENT_JAVADOC	 Ignore conditional section buffer. 
private	TokenNameprivate	
final	TokenNamefinal	
XMLStringBuffer	TokenNameIdentifier	 XML String Buffer
fIgnoreConditionalBuffer	TokenNameIdentifier	 f Ignore Conditional Buffer
=	TokenNameEQUAL	
new	TokenNamenew	
XMLStringBuffer	TokenNameIdentifier	 XML String Buffer
(	TokenNameLPAREN	
128	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Constructors 	TokenNameCOMMENT_LINE	Constructors 
// 	TokenNameCOMMENT_LINE	 
/** Default constructor. */	TokenNameCOMMENT_JAVADOC	 Default constructor. 
public	TokenNamepublic	
XMLDTDScannerImpl	TokenNameIdentifier	 XMLDTD Scanner Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
// <init>() 	TokenNameCOMMENT_LINE	<init>() 
/** Constructor for he use of non-XMLComponentManagers. */	TokenNameCOMMENT_JAVADOC	 Constructor for he use of non-XMLComponentManagers. 
public	TokenNamepublic	
XMLDTDScannerImpl	TokenNameIdentifier	 XMLDTD Scanner Impl
(	TokenNameLPAREN	
SymbolTable	TokenNameIdentifier	 Symbol Table
symbolTable	TokenNameIdentifier	 symbol Table
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
errorReporter	TokenNameIdentifier	 error Reporter
,	TokenNameCOMMA	
XMLEntityManager	TokenNameIdentifier	 XML Entity Manager
entityManager	TokenNameIdentifier	 entity Manager
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
=	TokenNameEQUAL	
symbolTable	TokenNameIdentifier	 symbol Table
;	TokenNameSEMICOLON	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
=	TokenNameEQUAL	
errorReporter	TokenNameIdentifier	 error Reporter
;	TokenNameSEMICOLON	
fEntityManager	TokenNameIdentifier	 f Entity Manager
=	TokenNameEQUAL	
entityManager	TokenNameIdentifier	 entity Manager
;	TokenNameSEMICOLON	
entityManager	TokenNameIdentifier	 entity Manager
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
SYMBOL_TABLE	TokenNameIdentifier	 SYMBOL  TABLE
,	TokenNameCOMMA	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// XMLDTDScanner methods 	TokenNameCOMMENT_LINE	XMLDTDScanner methods 
// 	TokenNameCOMMENT_LINE	 
/** * Sets the input source. * * @param inputSource The input source or null. * * @throws IOException Thrown on i/o error. */	TokenNameCOMMENT_JAVADOC	 Sets the input source. * @param inputSource The input source or null. * @throws IOException Thrown on i/o error. 
public	TokenNamepublic	
void	TokenNamevoid	
setInputSource	TokenNameIdentifier	 set Input Source
(	TokenNameLPAREN	
XMLInputSource	TokenNameIdentifier	 XML Input Source
inputSource	TokenNameIdentifier	 input Source
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
inputSource	TokenNameIdentifier	 input Source
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// no system id was available 	TokenNameCOMMENT_LINE	no system id was available 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
startDTD	TokenNameIdentifier	 start DTD
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
endDTD	TokenNameIdentifier	 end DTD
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fEntityManager	TokenNameIdentifier	 f Entity Manager
.	TokenNameDOT	
setEntityHandler	TokenNameIdentifier	 set Entity Handler
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fEntityManager	TokenNameIdentifier	 f Entity Manager
.	TokenNameDOT	
startDTDEntity	TokenNameIdentifier	 start DTD Entity
(	TokenNameLPAREN	
inputSource	TokenNameIdentifier	 input Source
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// setInputSource(XMLInputSource) 	TokenNameCOMMENT_LINE	setInputSource(XMLInputSource) 
/** * Scans the external subset of the document. * * @param complete True if the scanner should scan the document * completely, pushing all events to the registered * document handler. A value of false indicates that * that the scanner should only scan the next portion * of the document and return. A scanner instance is * permitted to completely scan a document if it does * not support this "pull" scanning model. * * @return True if there is more to scan, false otherwise. */	TokenNameCOMMENT_JAVADOC	 Scans the external subset of the document. * @param complete True if the scanner should scan the document completely, pushing all events to the registered document handler. A value of false indicates that that the scanner should only scan the next portion of the document and return. A scanner instance is permitted to completely scan a document if it does not support this "pull" scanning model. * @return True if there is more to scan, false otherwise. 
public	TokenNamepublic	
boolean	TokenNameboolean	
scanDTDExternalSubset	TokenNameIdentifier	 scan DTD External Subset
(	TokenNameLPAREN	
boolean	TokenNameboolean	
complete	TokenNameIdentifier	 complete
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
fEntityManager	TokenNameIdentifier	 f Entity Manager
.	TokenNameDOT	
setEntityHandler	TokenNameIdentifier	 set Entity Handler
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fScannerState	TokenNameIdentifier	 f Scanner State
==	TokenNameEQUAL_EQUAL	
SCANNER_STATE_TEXT_DECL	TokenNameIdentifier	 SCANNER  STATE  TEXT  DECL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSeenExternalDTD	TokenNameIdentifier	 f Seen External DTD
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
textDecl	TokenNameIdentifier	 text Decl
=	TokenNameEQUAL	
scanTextDecl	TokenNameIdentifier	 scan Text Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fScannerState	TokenNameIdentifier	 f Scanner State
==	TokenNameEQUAL_EQUAL	
SCANNER_STATE_END_OF_INPUT	TokenNameIdentifier	 SCANNER  STATE  END  OF  INPUT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// next state is markup decls regardless of whether there 	TokenNameCOMMENT_LINE	next state is markup decls regardless of whether there 
// is a TextDecl or not 	TokenNameCOMMENT_LINE	is a TextDecl or not 
setScannerState	TokenNameIdentifier	 set Scanner State
(	TokenNameLPAREN	
SCANNER_STATE_MARKUP_DECL	TokenNameIdentifier	 SCANNER  STATE  MARKUP  DECL
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
textDecl	TokenNameIdentifier	 text Decl
&&	TokenNameAND_AND	
!	TokenNameNOT	
complete	TokenNameIdentifier	 complete
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// keep dispatching "events" 	TokenNameCOMMENT_LINE	keep dispatching "events" 
do	TokenNamedo	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
scanDecls	TokenNameIdentifier	 scan Decls
(	TokenNameLPAREN	
complete	TokenNameIdentifier	 complete
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
complete	TokenNameIdentifier	 complete
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// return that there is more to scan 	TokenNameCOMMENT_LINE	return that there is more to scan 
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// scanDTDExternalSubset(boolean):boolean 	TokenNameCOMMENT_LINE	scanDTDExternalSubset(boolean):boolean 
/** * Scans the internal subset of the document. * * @param complete True if the scanner should scan the document * completely, pushing all events to the registered * document handler. A value of false indicates that * that the scanner should only scan the next portion * of the document and return. A scanner instance is * permitted to completely scan a document if it does * not support this "pull" scanning model. * @param standalone True if the document was specified as standalone. * This value is important for verifying certain * well-formedness constraints. * @param hasExternalSubset True if the document has an external DTD. * This allows the scanner to properly notify * the handler of the end of the DTD in the * absence of an external subset. * * @return True if there is more to scan, false otherwise. */	TokenNameCOMMENT_JAVADOC	 Scans the internal subset of the document. * @param complete True if the scanner should scan the document completely, pushing all events to the registered document handler. A value of false indicates that that the scanner should only scan the next portion of the document and return. A scanner instance is permitted to completely scan a document if it does not support this "pull" scanning model. @param standalone True if the document was specified as standalone. This value is important for verifying certain well-formedness constraints. @param hasExternalSubset True if the document has an external DTD. This allows the scanner to properly notify the handler of the end of the DTD in the absence of an external subset. * @return True if there is more to scan, false otherwise. 
public	TokenNamepublic	
boolean	TokenNameboolean	
scanDTDInternalSubset	TokenNameIdentifier	 scan DTD Internal Subset
(	TokenNameLPAREN	
boolean	TokenNameboolean	
complete	TokenNameIdentifier	 complete
,	TokenNameCOMMA	
boolean	TokenNameboolean	
standalone	TokenNameIdentifier	 standalone
,	TokenNameCOMMA	
boolean	TokenNameboolean	
hasExternalSubset	TokenNameIdentifier	 has External Subset
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
// reset entity scanner 	TokenNameCOMMENT_LINE	reset entity scanner 
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
=	TokenNameEQUAL	
fEntityManager	TokenNameIdentifier	 f Entity Manager
.	TokenNameDOT	
getEntityScanner	TokenNameIdentifier	 get Entity Scanner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fEntityManager	TokenNameIdentifier	 f Entity Manager
.	TokenNameDOT	
setEntityHandler	TokenNameIdentifier	 set Entity Handler
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fStandalone	TokenNameIdentifier	 f Standalone
=	TokenNameEQUAL	
standalone	TokenNameIdentifier	 standalone
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fScannerState	TokenNameIdentifier	 f Scanner State
==	TokenNameEQUAL_EQUAL	
SCANNER_STATE_TEXT_DECL	TokenNameIdentifier	 SCANNER  STATE  TEXT  DECL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
startDTD	TokenNameIdentifier	 start DTD
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fStartDTDCalled	TokenNameIdentifier	 f Start DTD Called
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// set starting state for internal subset 	TokenNameCOMMENT_LINE	set starting state for internal subset 
setScannerState	TokenNameIdentifier	 set Scanner State
(	TokenNameLPAREN	
SCANNER_STATE_MARKUP_DECL	TokenNameIdentifier	 SCANNER  STATE  MARKUP  DECL
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// keep dispatching "events" 	TokenNameCOMMENT_LINE	keep dispatching "events" 
do	TokenNamedo	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
scanDecls	TokenNameIdentifier	 scan Decls
(	TokenNameLPAREN	
complete	TokenNameIdentifier	 complete
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
hasExternalSubset	TokenNameIdentifier	 has External Subset
==	TokenNameEQUAL_EQUAL	
false	TokenNamefalse	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
endDTD	TokenNameIdentifier	 end DTD
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// we're done, set starting state for external subset 	TokenNameCOMMENT_LINE	we're done, set starting state for external subset 
setScannerState	TokenNameIdentifier	 set Scanner State
(	TokenNameLPAREN	
SCANNER_STATE_TEXT_DECL	TokenNameIdentifier	 SCANNER  STATE  TEXT  DECL
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
complete	TokenNameIdentifier	 complete
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// return that there is more to scan 	TokenNameCOMMENT_LINE	return that there is more to scan 
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// scanDTDInternalSubset(boolean,boolean,boolean):boolean 	TokenNameCOMMENT_LINE	scanDTDInternalSubset(boolean,boolean,boolean):boolean 
// 	TokenNameCOMMENT_LINE	 
// XMLComponent methods 	TokenNameCOMMENT_LINE	XMLComponent methods 
// 	TokenNameCOMMENT_LINE	 
/** * reset * * @param componentManager */	TokenNameCOMMENT_JAVADOC	 reset * @param componentManager 
public	TokenNamepublic	
void	TokenNamevoid	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
XMLComponentManager	TokenNameIdentifier	 XML Component Manager
componentManager	TokenNameIdentifier	 component Manager
)	TokenNameRPAREN	
throws	TokenNamethrows	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
{	TokenNameLBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
componentManager	TokenNameIdentifier	 component Manager
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
init	TokenNameIdentifier	 init
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// reset(XMLComponentManager) 	TokenNameCOMMENT_LINE	reset(XMLComponentManager) 
// this is made for something like XMLDTDLoader--XMLComponentManager-free operation... 	TokenNameCOMMENT_LINE	this is made for something like XMLDTDLoader--XMLComponentManager-free operation... 
public	TokenNamepublic	
void	TokenNamevoid	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
init	TokenNameIdentifier	 init
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns a list of feature identifiers that are recognized by * this component. This method may return null if no features * are recognized by this component. */	TokenNameCOMMENT_JAVADOC	 Returns a list of feature identifiers that are recognized by this component. This method may return null if no features are recognized by this component. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getRecognizedFeatures	TokenNameIdentifier	 get Recognized Features
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
RECOGNIZED_FEATURES	TokenNameIdentifier	 RECOGNIZED  FEATURES
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getRecognizedFeatures():String[] 	TokenNameCOMMENT_LINE	getRecognizedFeatures():String[] 
/** * Returns a list of property identifiers that are recognized by * this component. This method may return null if no properties * are recognized by this component. */	TokenNameCOMMENT_JAVADOC	 Returns a list of property identifiers that are recognized by this component. This method may return null if no properties are recognized by this component. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getRecognizedProperties	TokenNameIdentifier	 get Recognized Properties
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
RECOGNIZED_PROPERTIES	TokenNameIdentifier	 RECOGNIZED  PROPERTIES
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getRecognizedProperties():String[] 	TokenNameCOMMENT_LINE	getRecognizedProperties():String[] 
/** * Returns the default state for a feature, or null if this * component does not want to report a default value for this * feature. * * @param featureId The feature identifier. * * @since Xerces 2.2.0 */	TokenNameCOMMENT_JAVADOC	 Returns the default state for a feature, or null if this component does not want to report a default value for this feature. * @param featureId The feature identifier. * @since Xerces 2.2.0 
public	TokenNamepublic	
Boolean	TokenNameIdentifier	 Boolean
getFeatureDefault	TokenNameIdentifier	 get Feature Default
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
featureId	TokenNameIdentifier	 feature Id
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
RECOGNIZED_FEATURES	TokenNameIdentifier	 RECOGNIZED  FEATURES
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
RECOGNIZED_FEATURES	TokenNameIdentifier	 RECOGNIZED  FEATURES
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
featureId	TokenNameIdentifier	 feature Id
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
FEATURE_DEFAULTS	TokenNameIdentifier	 FEATURE  DEFAULTS
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getFeatureDefault(String):Boolean 	TokenNameCOMMENT_LINE	getFeatureDefault(String):Boolean 
/** * Returns the default state for a property, or null if this * component does not want to report a default value for this * property. * * @param propertyId The property identifier. * * @since Xerces 2.2.0 */	TokenNameCOMMENT_JAVADOC	 Returns the default state for a property, or null if this component does not want to report a default value for this property. * @param propertyId The property identifier. * @since Xerces 2.2.0 
public	TokenNamepublic	
Object	TokenNameIdentifier	 Object
getPropertyDefault	TokenNameIdentifier	 get Property Default
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
propertyId	TokenNameIdentifier	 property Id
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
RECOGNIZED_PROPERTIES	TokenNameIdentifier	 RECOGNIZED  PROPERTIES
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
RECOGNIZED_PROPERTIES	TokenNameIdentifier	 RECOGNIZED  PROPERTIES
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
propertyId	TokenNameIdentifier	 property Id
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
PROPERTY_DEFAULTS	TokenNameIdentifier	 PROPERTY  DEFAULTS
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getPropertyDefault(String):Object 	TokenNameCOMMENT_LINE	getPropertyDefault(String):Object 
// 	TokenNameCOMMENT_LINE	 
// XMLDTDSource methods 	TokenNameCOMMENT_LINE	XMLDTDSource methods 
// 	TokenNameCOMMENT_LINE	 
/** * setDTDHandler * * @param dtdHandler */	TokenNameCOMMENT_JAVADOC	 setDTDHandler * @param dtdHandler 
public	TokenNamepublic	
void	TokenNamevoid	
setDTDHandler	TokenNameIdentifier	 set DTD Handler
(	TokenNameLPAREN	
XMLDTDHandler	TokenNameIdentifier	 XMLDTD Handler
dtdHandler	TokenNameIdentifier	 dtd Handler
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
=	TokenNameEQUAL	
dtdHandler	TokenNameIdentifier	 dtd Handler
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// setDTDHandler(XMLDTDHandler) 	TokenNameCOMMENT_LINE	setDTDHandler(XMLDTDHandler) 
/** * getDTDHandler * * @return the XMLDTDHandler */	TokenNameCOMMENT_JAVADOC	 getDTDHandler * @return the XMLDTDHandler 
public	TokenNamepublic	
XMLDTDHandler	TokenNameIdentifier	 XMLDTD Handler
getDTDHandler	TokenNameIdentifier	 get DTD Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getDTDHandler(): XMLDTDHandler 	TokenNameCOMMENT_LINE	getDTDHandler(): XMLDTDHandler 
// 	TokenNameCOMMENT_LINE	 
// XMLDTDContentModelSource methods 	TokenNameCOMMENT_LINE	XMLDTDContentModelSource methods 
// 	TokenNameCOMMENT_LINE	 
/** * setDTDContentModelHandler * * @param dtdContentModelHandler */	TokenNameCOMMENT_JAVADOC	 setDTDContentModelHandler * @param dtdContentModelHandler 
public	TokenNamepublic	
void	TokenNamevoid	
setDTDContentModelHandler	TokenNameIdentifier	 set DTD Content Model Handler
(	TokenNameLPAREN	
XMLDTDContentModelHandler	TokenNameIdentifier	 XMLDTD Content Model Handler
dtdContentModelHandler	TokenNameIdentifier	 dtd Content Model Handler
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
=	TokenNameEQUAL	
dtdContentModelHandler	TokenNameIdentifier	 dtd Content Model Handler
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// setDTDContentModelHandler 	TokenNameCOMMENT_LINE	setDTDContentModelHandler 
/** * getDTDContentModelHandler * * @return XMLDTDContentModelHandler */	TokenNameCOMMENT_JAVADOC	 getDTDContentModelHandler * @return XMLDTDContentModelHandler 
public	TokenNamepublic	
XMLDTDContentModelHandler	TokenNameIdentifier	 XMLDTD Content Model Handler
getDTDContentModelHandler	TokenNameIdentifier	 get DTD Content Model Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// setDTDContentModelHandler 	TokenNameCOMMENT_LINE	setDTDContentModelHandler 
// 	TokenNameCOMMENT_LINE	 
// XMLEntityHandler methods 	TokenNameCOMMENT_LINE	XMLEntityHandler methods 
// 	TokenNameCOMMENT_LINE	 
/** * This method notifies of the start of an entity. The DTD has the * pseudo-name of "[dtd]" parameter entity names start with '%'; and * general entities are just specified by their name. * * @param name The name of the entity. * @param identifier The resource identifier. * @param encoding The auto-detected IANA encoding name of the entity * stream. This value will be null in those situations * where the entity encoding is not auto-detected (e.g. * internal entities or a document entity that is * parsed from a java.io.Reader). * @param augs Additional information that may include infoset augmentations * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 This method notifies of the start of an entity. The DTD has the pseudo-name of "[dtd]" parameter entity names start with '%'; and general entities are just specified by their name. * @param name The name of the entity. @param identifier The resource identifier. @param encoding The auto-detected IANA encoding name of the entity stream. This value will be null in those situations where the entity encoding is not auto-detected (e.g. internal entities or a document entity that is parsed from a java.io.Reader). @param augs Additional information that may include infoset augmentations * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
startEntity	TokenNameIdentifier	 start Entity
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
XMLResourceIdentifier	TokenNameIdentifier	 XML Resource Identifier
identifier	TokenNameIdentifier	 identifier
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
startEntity	TokenNameIdentifier	 start Entity
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
identifier	TokenNameIdentifier	 identifier
,	TokenNameCOMMA	
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
dtdEntity	TokenNameIdentifier	 dtd Entity
=	TokenNameEQUAL	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"[dtd]"	TokenNameStringLiteral	[dtd]
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dtdEntity	TokenNameIdentifier	 dtd Entity
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
fStartDTDCalled	TokenNameIdentifier	 f Start DTD Called
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
startDTD	TokenNameIdentifier	 start DTD
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
startExternalSubset	TokenNameIdentifier	 start External Subset
(	TokenNameLPAREN	
identifier	TokenNameIdentifier	 identifier
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fEntityManager	TokenNameIdentifier	 f Entity Manager
.	TokenNameDOT	
startExternalSubset	TokenNameIdentifier	 start External Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fExtEntityDepth	TokenNameIdentifier	 f Ext Entity Depth
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
'%'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pushPEStack	TokenNameIdentifier	 push PE Stack
(	TokenNameLPAREN	
fMarkUpDepth	TokenNameIdentifier	 f Mark Up Depth
,	TokenNameCOMMA	
fReportEntity	TokenNameIdentifier	 f Report Entity
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
isExternal	TokenNameIdentifier	 is External
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fExtEntityDepth	TokenNameIdentifier	 f Ext Entity Depth
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
dtdEntity	TokenNameIdentifier	 dtd Entity
&&	TokenNameAND_AND	
fReportEntity	TokenNameIdentifier	 f Report Entity
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
startParameterEntity	TokenNameIdentifier	 start Parameter Entity
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
identifier	TokenNameIdentifier	 identifier
,	TokenNameCOMMA	
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// startEntity(String,XMLResourceIdentifier,String) 	TokenNameCOMMENT_LINE	startEntity(String,XMLResourceIdentifier,String) 
/** * This method notifies the end of an entity. The DTD has the pseudo-name * of "[dtd]" parameter entity names start with '%'; and general entities * are just specified by their name. * * @param name The name of the entity. * @param augs Additional information that may include infoset augmentations * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 This method notifies the end of an entity. The DTD has the pseudo-name of "[dtd]" parameter entity names start with '%'; and general entities are just specified by their name. * @param name The name of the entity. @param augs Additional information that may include infoset augmentations * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
endEntity	TokenNameIdentifier	 end Entity
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
endEntity	TokenNameIdentifier	 end Entity
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// if there is no data after the doctype 	TokenNameCOMMENT_LINE	if there is no data after the doctype 
// 	TokenNameCOMMENT_LINE	 
if	TokenNameif	
(	TokenNameLPAREN	
fScannerState	TokenNameIdentifier	 f Scanner State
==	TokenNameEQUAL_EQUAL	
SCANNER_STATE_END_OF_INPUT	TokenNameIdentifier	 SCANNER  STATE  END  OF  INPUT
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
// Handle end of PE 	TokenNameCOMMENT_LINE	Handle end of PE 
boolean	TokenNameboolean	
reportEntity	TokenNameIdentifier	 report Entity
=	TokenNameEQUAL	
fReportEntity	TokenNameIdentifier	 f Report Entity
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
"%"	TokenNameStringLiteral	%
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportEntity	TokenNameIdentifier	 report Entity
=	TokenNameEQUAL	
peekReportEntity	TokenNameIdentifier	 peek Report Entity
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// check well-formedness of the enity 	TokenNameCOMMENT_LINE	check well-formedness of the enity 
int	TokenNameint	
startMarkUpDepth	TokenNameIdentifier	 start Mark Up Depth
=	TokenNameEQUAL	
popPEStack	TokenNameIdentifier	 pop PE Stack
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// throw fatalError if this entity was incomplete and 	TokenNameCOMMENT_LINE	throw fatalError if this entity was incomplete and 
// was a freestanding decl 	TokenNameCOMMENT_LINE	was a freestanding decl 
if	TokenNameif	
(	TokenNameLPAREN	
startMarkUpDepth	TokenNameIdentifier	 start Mark Up Depth
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
startMarkUpDepth	TokenNameIdentifier	 start Mark Up Depth
<	TokenNameLESS	
fMarkUpDepth	TokenNameIdentifier	 f Mark Up Depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
"ILL_FORMED_PARAMETER_ENTITY_WHEN_USED_IN_DECL"	TokenNameStringLiteral	ILL_FORMED_PARAMETER_ENTITY_WHEN_USED_IN_DECL
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fEntityManager	TokenNameIdentifier	 f Entity Manager
.	TokenNameDOT	
fCurrentEntity	TokenNameIdentifier	 f Current Entity
.	TokenNameDOT	
name	TokenNameIdentifier	 name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_FATAL_ERROR	TokenNameIdentifier	 SEVERITY  FATAL  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
startMarkUpDepth	TokenNameIdentifier	 start Mark Up Depth
!=	TokenNameNOT_EQUAL	
fMarkUpDepth	TokenNameIdentifier	 f Mark Up Depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportEntity	TokenNameIdentifier	 report Entity
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fValidation	TokenNameIdentifier	 f Validation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Proper nesting of parameter entities is a Validity Constraint 	TokenNameCOMMENT_LINE	Proper nesting of parameter entities is a Validity Constraint 
// and must not be enforced when validation is off 	TokenNameCOMMENT_LINE	and must not be enforced when validation is off 
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
"ImproperDeclarationNesting"	TokenNameStringLiteral	ImproperDeclarationNesting
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
isExternal	TokenNameIdentifier	 is External
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fExtEntityDepth	TokenNameIdentifier	 f Ext Entity Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
reportEntity	TokenNameIdentifier	 report Entity
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
endParameterEntity	TokenNameIdentifier	 end Parameter Entity
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// end DTD 	TokenNameCOMMENT_LINE	end DTD 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"[dtd]"	TokenNameStringLiteral	[dtd]
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fIncludeSectDepth	TokenNameIdentifier	 f Include Sect Depth
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"IncludeSectUnterminated"	TokenNameStringLiteral	IncludeSectUnterminated
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fScannerState	TokenNameIdentifier	 f Scanner State
=	TokenNameEQUAL	
SCANNER_STATE_END_OF_INPUT	TokenNameIdentifier	 SCANNER  STATE  END  OF  INPUT
;	TokenNameSEMICOLON	
// call handler 	TokenNameCOMMENT_LINE	call handler 
fEntityManager	TokenNameIdentifier	 f Entity Manager
.	TokenNameDOT	
endExternalSubset	TokenNameIdentifier	 end External Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
endExternalSubset	TokenNameIdentifier	 end External Subset
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
endDTD	TokenNameIdentifier	 end DTD
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fExtEntityDepth	TokenNameIdentifier	 f Ext Entity Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// endEntity(String) 	TokenNameCOMMENT_LINE	endEntity(String) 
// helper methods 	TokenNameCOMMENT_LINE	helper methods 
/** * Sets the scanner state. * * @param state The new scanner state. */	TokenNameCOMMENT_JAVADOC	 Sets the scanner state. * @param state The new scanner state. 
protected	TokenNameprotected	
final	TokenNamefinal	
void	TokenNamevoid	
setScannerState	TokenNameIdentifier	 set Scanner State
(	TokenNameLPAREN	
int	TokenNameint	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fScannerState	TokenNameIdentifier	 f Scanner State
=	TokenNameEQUAL	
state	TokenNameIdentifier	 state
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG_SCANNER_STATE	TokenNameIdentifier	 DEBUG  SCANNER  STATE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
"### setScannerState: "	TokenNameStringLiteral	### setScannerState: 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
getScannerStateName	TokenNameIdentifier	 get Scanner State Name
(	TokenNameLPAREN	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// setScannerState(int) 	TokenNameCOMMENT_LINE	setScannerState(int) 
// 	TokenNameCOMMENT_LINE	 
// Private methods 	TokenNameCOMMENT_LINE	Private methods 
// 	TokenNameCOMMENT_LINE	 
/** Returns the scanner state name. */	TokenNameCOMMENT_JAVADOC	 Returns the scanner state name. 
private	TokenNameprivate	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
getScannerStateName	TokenNameIdentifier	 get Scanner State Name
(	TokenNameLPAREN	
int	TokenNameint	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG_SCANNER_STATE	TokenNameIdentifier	 DEBUG  SCANNER  STATE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
SCANNER_STATE_END_OF_INPUT	TokenNameIdentifier	 SCANNER  STATE  END  OF  INPUT
:	TokenNameCOLON	
return	TokenNamereturn	
"SCANNER_STATE_END_OF_INPUT"	TokenNameStringLiteral	SCANNER_STATE_END_OF_INPUT
;	TokenNameSEMICOLON	
case	TokenNamecase	
SCANNER_STATE_TEXT_DECL	TokenNameIdentifier	 SCANNER  STATE  TEXT  DECL
:	TokenNameCOLON	
return	TokenNamereturn	
"SCANNER_STATE_TEXT_DECL"	TokenNameStringLiteral	SCANNER_STATE_TEXT_DECL
;	TokenNameSEMICOLON	
case	TokenNamecase	
SCANNER_STATE_MARKUP_DECL	TokenNameIdentifier	 SCANNER  STATE  MARKUP  DECL
:	TokenNameCOLON	
return	TokenNamereturn	
"SCANNER_STATE_MARKUP_DECL"	TokenNameStringLiteral	SCANNER_STATE_MARKUP_DECL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
"??? ("	TokenNameStringLiteral	??? (
+	TokenNamePLUS	
state	TokenNameIdentifier	 state
+	TokenNamePLUS	
')'	TokenNameCharacterLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getScannerStateName(int):String 	TokenNameCOMMENT_LINE	getScannerStateName(int):String 
protected	TokenNameprotected	
final	TokenNamefinal	
boolean	TokenNameboolean	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fExtEntityDepth	TokenNameIdentifier	 f Ext Entity Depth
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * start a parameter entity dealing with the textdecl if there is any * * @param name The name of the parameter entity to start (without the '%') * @param literal Whether this is happening within a literal */	TokenNameCOMMENT_JAVADOC	 start a parameter entity dealing with the textdecl if there is any * @param name The name of the parameter entity to start (without the '%') @param literal Whether this is happening within a literal 
protected	TokenNameprotected	
void	TokenNamevoid	
startPE	TokenNameIdentifier	 start PE
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
boolean	TokenNameboolean	
literal	TokenNameIdentifier	 literal
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
int	TokenNameint	
depth	TokenNameIdentifier	 depth
=	TokenNameEQUAL	
fPEDepth	TokenNameIdentifier	 f PE Depth
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
pName	TokenNameIdentifier	 p Name
=	TokenNameEQUAL	
"%"	TokenNameStringLiteral	%
+	TokenNamePLUS	
name	TokenNameIdentifier	 name
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fSeenPEReferences	TokenNameIdentifier	 f Seen PE References
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSeenPEReferences	TokenNameIdentifier	 f Seen PE References
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
fEntityManager	TokenNameIdentifier	 f Entity Manager
.	TokenNameDOT	
notifyHasPEReferences	TokenNameIdentifier	 notify Has PE References
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fValidation	TokenNameIdentifier	 f Validation
&&	TokenNameAND_AND	
!	TokenNameNOT	
fEntityManager	TokenNameIdentifier	 f Entity Manager
.	TokenNameDOT	
isDeclaredEntity	TokenNameIdentifier	 is Declared Entity
(	TokenNameLPAREN	
pName	TokenNameIdentifier	 p Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
"EntityNotDeclared"	TokenNameStringLiteral	EntityNotDeclared
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fEntityManager	TokenNameIdentifier	 f Entity Manager
.	TokenNameDOT	
startEntity	TokenNameIdentifier	 start Entity
(	TokenNameLPAREN	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
.	TokenNameDOT	
addSymbol	TokenNameIdentifier	 add Symbol
(	TokenNameLPAREN	
pName	TokenNameIdentifier	 p Name
)	TokenNameRPAREN	
,	TokenNameCOMMA	
literal	TokenNameIdentifier	 literal
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// if we actually got a new entity and it's external 	TokenNameCOMMENT_LINE	if we actually got a new entity and it's external 
// parse text decl if there is any 	TokenNameCOMMENT_LINE	parse text decl if there is any 
if	TokenNameif	
(	TokenNameLPAREN	
depth	TokenNameIdentifier	 depth
!=	TokenNameNOT_EQUAL	
fPEDepth	TokenNameIdentifier	 f PE Depth
&&	TokenNameAND_AND	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
isExternal	TokenNameIdentifier	 is External
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
scanTextDecl	TokenNameIdentifier	 scan Text Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Dispatch an XML "event". * * @return true if a TextDecl was scanned. * * @throws IOException Thrown on i/o error. * @throws XNIException Thrown on parse error. * */	TokenNameCOMMENT_JAVADOC	 Dispatch an XML "event". * @return true if a TextDecl was scanned. * @throws IOException Thrown on i/o error. @throws XNIException Thrown on parse error. 
protected	TokenNameprotected	
final	TokenNamefinal	
boolean	TokenNameboolean	
scanTextDecl	TokenNameIdentifier	 scan Text Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
// scan XMLDecl 	TokenNameCOMMENT_LINE	scan XMLDecl 
boolean	TokenNameboolean	
textDecl	TokenNameIdentifier	 text Decl
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipString	TokenNameIdentifier	 skip String
(	TokenNameLPAREN	
"<?xml"	TokenNameStringLiteral	<?xml
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fMarkUpDepth	TokenNameIdentifier	 f Mark Up Depth
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
// NOTE: special case where document starts with a PI 	TokenNameCOMMENT_LINE	NOTE: special case where document starts with a PI 
// whose name starts with "xml" (e.g. "xmlfoo") 	TokenNameCOMMENT_LINE	whose name starts with "xml" (e.g. "xmlfoo") 
if	TokenNameif	
(	TokenNameLPAREN	
isValidNameChar	TokenNameIdentifier	 is Valid Name Char
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
peekChar	TokenNameIdentifier	 peek Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"xml"	TokenNameStringLiteral	xml
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fNamespaces	TokenNameIdentifier	 f Namespaces
)	TokenNameRPAREN	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
isValidNCName	TokenNameIdentifier	 is Valid NC Name
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
peekChar	TokenNameIdentifier	 peek Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanChar	TokenNameIdentifier	 scan Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
isValidNameChar	TokenNameIdentifier	 is Valid Name Char
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
peekChar	TokenNameIdentifier	 peek Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanChar	TokenNameIdentifier	 scan Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
target	TokenNameIdentifier	 target
=	TokenNameEQUAL	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
.	TokenNameDOT	
addSymbol	TokenNameIdentifier	 add Symbol
(	TokenNameLPAREN	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
,	TokenNameCOMMA	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
scanPIData	TokenNameIdentifier	 scan PI Data
(	TokenNameLPAREN	
target	TokenNameIdentifier	 target
,	TokenNameCOMMA	
fString	TokenNameIdentifier	 f String
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// standard Text declaration 	TokenNameCOMMENT_LINE	standard Text declaration 
else	TokenNameelse	
{	TokenNameLBRACE	
// pseudo-attribute values 	TokenNameCOMMENT_LINE	pseudo-attribute values 
String	TokenNameIdentifier	 String
version	TokenNameIdentifier	 version
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
scanXMLDeclOrTextDecl	TokenNameIdentifier	 scan XML Decl Or Text Decl
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
fStrings	TokenNameIdentifier	 f Strings
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
textDecl	TokenNameIdentifier	 text Decl
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
fMarkUpDepth	TokenNameIdentifier	 f Mark Up Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
version	TokenNameIdentifier	 version
=	TokenNameEQUAL	
fStrings	TokenNameIdentifier	 f Strings
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
encoding	TokenNameIdentifier	 encoding
=	TokenNameEQUAL	
fStrings	TokenNameIdentifier	 f Strings
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
setXMLVersion	TokenNameIdentifier	 set XML Version
(	TokenNameLPAREN	
version	TokenNameIdentifier	 version
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
fCurrentEntity	TokenNameIdentifier	 f Current Entity
.	TokenNameDOT	
isEncodingExternallySpecified	TokenNameIdentifier	 is Encoding Externally Specified
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
setEncoding	TokenNameIdentifier	 set Encoding
(	TokenNameLPAREN	
encoding	TokenNameIdentifier	 encoding
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
textDecl	TokenNameIdentifier	 text Decl
(	TokenNameLPAREN	
version	TokenNameIdentifier	 version
,	TokenNameCOMMA	
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
fEntityManager	TokenNameIdentifier	 f Entity Manager
.	TokenNameDOT	
fCurrentEntity	TokenNameIdentifier	 f Current Entity
.	TokenNameDOT	
mayReadChunks	TokenNameIdentifier	 may Read Chunks
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
textDecl	TokenNameIdentifier	 text Decl
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// scanTextDecl(boolean):boolean 	TokenNameCOMMENT_LINE	scanTextDecl(boolean):boolean 
/** * Scans a processing data. This is needed to handle the situation * where a document starts with a processing instruction whose * target name <em>starts with</em> "xml". (e.g. xmlfoo) * * @param target The PI target * @param data The string to fill in with the data */	TokenNameCOMMENT_JAVADOC	 Scans a processing data. This is needed to handle the situation where a document starts with a processing instruction whose target name <em>starts with</em> "xml". (e.g. xmlfoo) * @param target The PI target @param data The string to fill in with the data 
protected	TokenNameprotected	
final	TokenNamefinal	
void	TokenNamevoid	
scanPIData	TokenNameIdentifier	 scan PI Data
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
target	TokenNameIdentifier	 target
,	TokenNameCOMMA	
XMLString	TokenNameIdentifier	 XML String
data	TokenNameIdentifier	 data
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
scanPIData	TokenNameIdentifier	 scan PI Data
(	TokenNameLPAREN	
target	TokenNameIdentifier	 target
,	TokenNameCOMMA	
data	TokenNameIdentifier	 data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fMarkUpDepth	TokenNameIdentifier	 f Mark Up Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
processingInstruction	TokenNameIdentifier	 processing Instruction
(	TokenNameLPAREN	
target	TokenNameIdentifier	 target
,	TokenNameCOMMA	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// scanPIData(String) 	TokenNameCOMMENT_LINE	scanPIData(String) 
/** * Scans a comment. * <p> * <pre> * [15] Comment ::= '&lt!--' ((Char - '-') | ('-' (Char - '-')))* '-->' * </pre> * <p> * <strong>Note:</strong> Called after scanning past '&lt;!--' */	TokenNameCOMMENT_JAVADOC	 Scans a comment. <p> <pre> [15] Comment ::= '&lt!--' ((Char - '-') | ('-' (Char - '-')))* '-->' </pre> <p> <strong>Note:</strong> Called after scanning past '&lt;!--' 
protected	TokenNameprotected	
final	TokenNamefinal	
void	TokenNamevoid	
scanComment	TokenNameIdentifier	 scan Comment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
fReportEntity	TokenNameIdentifier	 f Report Entity
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
scanComment	TokenNameIdentifier	 scan Comment
(	TokenNameLPAREN	
fStringBuffer	TokenNameIdentifier	 f String Buffer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fMarkUpDepth	TokenNameIdentifier	 f Mark Up Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
comment	TokenNameIdentifier	 comment
(	TokenNameLPAREN	
fStringBuffer	TokenNameIdentifier	 f String Buffer
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fReportEntity	TokenNameIdentifier	 f Report Entity
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// scanComment() 	TokenNameCOMMENT_LINE	scanComment() 
/** * Scans an element declaration * <p> * <pre> * [45] elementdecl ::= '&lt;!ELEMENT' S Name S contentspec S? '>' * [46] contentspec ::= 'EMPTY' | 'ANY' | Mixed | children * </pre> * <p> * <strong>Note:</strong> Called after scanning past '&lt;!ELEMENT' */	TokenNameCOMMENT_JAVADOC	 Scans an element declaration <p> <pre> [45] elementdecl ::= '&lt;!ELEMENT' S Name S contentspec S? '>' [46] contentspec ::= 'EMPTY' | 'ANY' | Mixed | children </pre> <p> <strong>Note:</strong> Called after scanning past '&lt;!ELEMENT' 
protected	TokenNameprotected	
final	TokenNamefinal	
void	TokenNamevoid	
scanElementDecl	TokenNameIdentifier	 scan Element Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
// spaces 	TokenNameCOMMENT_LINE	spaces 
fReportEntity	TokenNameIdentifier	 f Report Entity
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_SPACE_REQUIRED_BEFORE_ELEMENT_TYPE_IN_ELEMENTDECL"	TokenNameStringLiteral	MSG_SPACE_REQUIRED_BEFORE_ELEMENT_TYPE_IN_ELEMENTDECL
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// element name 	TokenNameCOMMENT_LINE	element name 
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanName	TokenNameIdentifier	 scan Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_ELEMENT_TYPE_REQUIRED_IN_ELEMENTDECL"	TokenNameStringLiteral	MSG_ELEMENT_TYPE_REQUIRED_IN_ELEMENTDECL
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// spaces 	TokenNameCOMMENT_LINE	spaces 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_SPACE_REQUIRED_BEFORE_CONTENTSPEC_IN_ELEMENTDECL"	TokenNameStringLiteral	MSG_SPACE_REQUIRED_BEFORE_CONTENTSPEC_IN_ELEMENTDECL
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// content model 	TokenNameCOMMENT_LINE	content model 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
.	TokenNameDOT	
startContentModel	TokenNameIdentifier	 start Content Model
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
contentModel	TokenNameIdentifier	 content Model
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fReportEntity	TokenNameIdentifier	 f Report Entity
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipString	TokenNameIdentifier	 skip String
(	TokenNameLPAREN	
"EMPTY"	TokenNameStringLiteral	EMPTY
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
contentModel	TokenNameIdentifier	 content Model
=	TokenNameEQUAL	
"EMPTY"	TokenNameStringLiteral	EMPTY
;	TokenNameSEMICOLON	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
.	TokenNameDOT	
empty	TokenNameIdentifier	 empty
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipString	TokenNameIdentifier	 skip String
(	TokenNameLPAREN	
"ANY"	TokenNameStringLiteral	ANY
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
contentModel	TokenNameIdentifier	 content Model
=	TokenNameEQUAL	
"ANY"	TokenNameStringLiteral	ANY
;	TokenNameSEMICOLON	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
.	TokenNameDOT	
any	TokenNameIdentifier	 any
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'('	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_OPEN_PAREN_OR_ELEMENT_TYPE_REQUIRED_IN_CHILDREN"	TokenNameStringLiteral	MSG_OPEN_PAREN_OR_ELEMENT_TYPE_REQUIRED_IN_CHILDREN
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
.	TokenNameDOT	
startGroup	TokenNameIdentifier	 start Group
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'('	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fMarkUpDepth	TokenNameIdentifier	 f Mark Up Depth
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Mixed content model 	TokenNameCOMMENT_LINE	Mixed content model 
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipString	TokenNameIdentifier	 skip String
(	TokenNameLPAREN	
"#PCDATA"	TokenNameStringLiteral	#PCDATA
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
scanMixed	TokenNameIdentifier	 scan Mixed
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// children content 	TokenNameCOMMENT_LINE	children content 
scanChildren	TokenNameIdentifier	 scan Children
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
contentModel	TokenNameIdentifier	 content Model
=	TokenNameEQUAL	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
.	TokenNameDOT	
endContentModel	TokenNameIdentifier	 end Content Model
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fReportEntity	TokenNameIdentifier	 f Report Entity
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// end 	TokenNameCOMMENT_LINE	end 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'>'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"ElementDeclUnterminated"	TokenNameStringLiteral	ElementDeclUnterminated
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fReportEntity	TokenNameIdentifier	 f Report Entity
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
fMarkUpDepth	TokenNameIdentifier	 f Mark Up Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
elementDecl	TokenNameIdentifier	 element Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
contentModel	TokenNameIdentifier	 content Model
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// scanElementDecl() 	TokenNameCOMMENT_LINE	scanElementDecl() 
/** * scan Mixed content model * This assumes the content model has been parsed up to #PCDATA and * can simply append to fStringBuffer. * <pre> * [51] Mixed ::= '(' S? '#PCDATA' (S? '|' S? Name)* S? ')*' * | '(' S? '#PCDATA' S? ')' * </pre> * * @param elName The element type name this declaration is about. * * <strong>Note:</strong> Called after scanning past '(#PCDATA'. */	TokenNameCOMMENT_JAVADOC	 scan Mixed content model This assumes the content model has been parsed up to #PCDATA and can simply append to fStringBuffer. <pre> [51] Mixed ::= '(' S? '#PCDATA' (S? '|' S? Name)* S? ')*' | '(' S? '#PCDATA' S? ')' </pre> * @param elName The element type name this declaration is about. * <strong>Note:</strong> Called after scanning past '(#PCDATA'. 
private	TokenNameprivate	
final	TokenNamefinal	
void	TokenNamevoid	
scanMixed	TokenNameIdentifier	 scan Mixed
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
elName	TokenNameIdentifier	 el Name
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
childName	TokenNameIdentifier	 child Name
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"#PCDATA"	TokenNameStringLiteral	#PCDATA
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
.	TokenNameDOT	
pcdata	TokenNameIdentifier	 pcdata
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'|'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'|'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
.	TokenNameDOT	
separator	TokenNameIdentifier	 separator
(	TokenNameLPAREN	
XMLDTDContentModelHandler	TokenNameIdentifier	 XMLDTD Content Model Handler
.	TokenNameDOT	
SEPARATOR_CHOICE	TokenNameIdentifier	 SEPARATOR  CHOICE
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
childName	TokenNameIdentifier	 child Name
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanName	TokenNameIdentifier	 scan Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
childName	TokenNameIdentifier	 child Name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_ELEMENT_TYPE_REQUIRED_IN_MIXED_CONTENT"	TokenNameStringLiteral	MSG_ELEMENT_TYPE_REQUIRED_IN_MIXED_CONTENT
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
elName	TokenNameIdentifier	 el Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
childName	TokenNameIdentifier	 child Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
.	TokenNameDOT	
element	TokenNameIdentifier	 element
(	TokenNameLPAREN	
childName	TokenNameIdentifier	 child Name
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// The following check must be done in a single call (as opposed to one 	TokenNameCOMMENT_LINE	The following check must be done in a single call (as opposed to one 
// for ')' and then one for '*') to guarantee that callbacks are 	TokenNameCOMMENT_LINE	for ')' and then one for '*') to guarantee that callbacks are 
// properly nested. We do not want to trigger endEntity too early in 	TokenNameCOMMENT_LINE	properly nested. We do not want to trigger endEntity too early in 
// case we cross the boundary of an entity between the two characters. 	TokenNameCOMMENT_LINE	case we cross the boundary of an entity between the two characters. 
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipString	TokenNameIdentifier	 skip String
(	TokenNameLPAREN	
")*"	TokenNameStringLiteral	)*
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
")*"	TokenNameStringLiteral	)*
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
.	TokenNameDOT	
endGroup	TokenNameIdentifier	 end Group
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
.	TokenNameDOT	
occurrence	TokenNameIdentifier	 occurrence
(	TokenNameLPAREN	
XMLDTDContentModelHandler	TokenNameIdentifier	 XMLDTD Content Model Handler
.	TokenNameDOT	
OCCURS_ZERO_OR_MORE	TokenNameIdentifier	 OCCURS  ZERO  OR  MORE
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
childName	TokenNameIdentifier	 child Name
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MixedContentUnterminated"	TokenNameStringLiteral	MixedContentUnterminated
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
elName	TokenNameIdentifier	 el Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
')'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
')'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
.	TokenNameDOT	
endGroup	TokenNameIdentifier	 end Group
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_CLOSE_PAREN_REQUIRED_IN_CHILDREN"	TokenNameStringLiteral	MSG_CLOSE_PAREN_REQUIRED_IN_CHILDREN
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
elName	TokenNameIdentifier	 el Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fMarkUpDepth	TokenNameIdentifier	 f Mark Up Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
// we are done 	TokenNameCOMMENT_LINE	we are done 
}	TokenNameRBRACE	
/** * scan children content model * This assumes it can simply append to fStringBuffer. * <pre> * [47] children ::= (choice | seq) ('?' | '*' | '+')? * [48] cp ::= (Name | choice | seq) ('?' | '*' | '+')? * [49] choice ::= '(' S? cp ( S? '|' S? cp )+ S? ')' * [50] seq ::= '(' S? cp ( S? ',' S? cp )* S? ')' * </pre> * * @param elName The element type name this declaration is about. * * <strong>Note:</strong> Called after scanning past the first open * paranthesis. */	TokenNameCOMMENT_JAVADOC	 scan children content model This assumes it can simply append to fStringBuffer. <pre> [47] children ::= (choice | seq) ('?' | '*' | '+')? [48] cp ::= (Name | choice | seq) ('?' | '*' | '+')? [49] choice ::= '(' S? cp ( S? '|' S? cp )+ S? ')' [50] seq ::= '(' S? cp ( S? ',' S? cp )* S? ')' </pre> * @param elName The element type name this declaration is about. * <strong>Note:</strong> Called after scanning past the first open paranthesis. 
private	TokenNameprivate	
final	TokenNamefinal	
void	TokenNamevoid	
scanChildren	TokenNameIdentifier	 scan Children
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
elName	TokenNameIdentifier	 el Name
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
fContentDepth	TokenNameIdentifier	 f Content Depth
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
pushContentStack	TokenNameIdentifier	 push Content Stack
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
currentOp	TokenNameIdentifier	 current Op
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
c	TokenNameIdentifier	 c
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'('	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fMarkUpDepth	TokenNameIdentifier	 f Mark Up Depth
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'('	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
.	TokenNameDOT	
startGroup	TokenNameIdentifier	 start Group
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// push current op on stack and reset it 	TokenNameCOMMENT_LINE	push current op on stack and reset it 
pushContentStack	TokenNameIdentifier	 push Content Stack
(	TokenNameLPAREN	
currentOp	TokenNameIdentifier	 current Op
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
currentOp	TokenNameIdentifier	 current Op
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
childName	TokenNameIdentifier	 child Name
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanName	TokenNameIdentifier	 scan Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
childName	TokenNameIdentifier	 child Name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_OPEN_PAREN_OR_ELEMENT_TYPE_REQUIRED_IN_CHILDREN"	TokenNameStringLiteral	MSG_OPEN_PAREN_OR_ELEMENT_TYPE_REQUIRED_IN_CHILDREN
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
elName	TokenNameIdentifier	 el Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
.	TokenNameDOT	
element	TokenNameIdentifier	 element
(	TokenNameLPAREN	
childName	TokenNameIdentifier	 child Name
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
childName	TokenNameIdentifier	 child Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
peekChar	TokenNameIdentifier	 peek Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
'?'	TokenNameCharacterLiteral	
||	TokenNameOR_OR	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
'*'	TokenNameCharacterLiteral	
||	TokenNameOR_OR	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
'+'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
short	TokenNameshort	
oc	TokenNameIdentifier	 oc
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
'?'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
oc	TokenNameIdentifier	 oc
=	TokenNameEQUAL	
XMLDTDContentModelHandler	TokenNameIdentifier	 XMLDTD Content Model Handler
.	TokenNameDOT	
OCCURS_ZERO_OR_ONE	TokenNameIdentifier	 OCCURS  ZERO  OR  ONE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
'*'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
oc	TokenNameIdentifier	 oc
=	TokenNameEQUAL	
XMLDTDContentModelHandler	TokenNameIdentifier	 XMLDTD Content Model Handler
.	TokenNameDOT	
OCCURS_ZERO_OR_MORE	TokenNameIdentifier	 OCCURS  ZERO  OR  MORE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
oc	TokenNameIdentifier	 oc
=	TokenNameEQUAL	
XMLDTDContentModelHandler	TokenNameIdentifier	 XMLDTD Content Model Handler
.	TokenNameDOT	
OCCURS_ONE_OR_MORE	TokenNameIdentifier	 OCCURS  ONE  OR  MORE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
.	TokenNameDOT	
occurrence	TokenNameIdentifier	 occurrence
(	TokenNameLPAREN	
oc	TokenNameIdentifier	 oc
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanChar	TokenNameIdentifier	 scan Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
peekChar	TokenNameIdentifier	 peek Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
','	TokenNameCharacterLiteral	
&&	TokenNameAND_AND	
currentOp	TokenNameIdentifier	 current Op
!=	TokenNameNOT_EQUAL	
'|'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currentOp	TokenNameIdentifier	 current Op
=	TokenNameEQUAL	
c	TokenNameIdentifier	 c
;	TokenNameSEMICOLON	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
.	TokenNameDOT	
separator	TokenNameIdentifier	 separator
(	TokenNameLPAREN	
XMLDTDContentModelHandler	TokenNameIdentifier	 XMLDTD Content Model Handler
.	TokenNameDOT	
SEPARATOR_SEQUENCE	TokenNameIdentifier	 SEPARATOR  SEQUENCE
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanChar	TokenNameIdentifier	 scan Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
','	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
'|'	TokenNameCharacterLiteral	
&&	TokenNameAND_AND	
currentOp	TokenNameIdentifier	 current Op
!=	TokenNameNOT_EQUAL	
','	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currentOp	TokenNameIdentifier	 current Op
=	TokenNameEQUAL	
c	TokenNameIdentifier	 c
;	TokenNameSEMICOLON	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
.	TokenNameDOT	
separator	TokenNameIdentifier	 separator
(	TokenNameLPAREN	
XMLDTDContentModelHandler	TokenNameIdentifier	 XMLDTD Content Model Handler
.	TokenNameDOT	
SEPARATOR_CHOICE	TokenNameIdentifier	 SEPARATOR  CHOICE
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanChar	TokenNameIdentifier	 scan Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'|'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
!=	TokenNameNOT_EQUAL	
')'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_CLOSE_PAREN_REQUIRED_IN_CHILDREN"	TokenNameStringLiteral	MSG_CLOSE_PAREN_REQUIRED_IN_CHILDREN
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
elName	TokenNameIdentifier	 el Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
.	TokenNameDOT	
endGroup	TokenNameIdentifier	 end Group
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// restore previous op 	TokenNameCOMMENT_LINE	restore previous op 
currentOp	TokenNameIdentifier	 current Op
=	TokenNameEQUAL	
popContentStack	TokenNameIdentifier	 pop Content Stack
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
short	TokenNameshort	
oc	TokenNameIdentifier	 oc
;	TokenNameSEMICOLON	
// The following checks must be done in a single call (as 	TokenNameCOMMENT_LINE	The following checks must be done in a single call (as 
// opposed to one for ')' and then one for '?', '*', and '+') 	TokenNameCOMMENT_LINE	opposed to one for ')' and then one for '?', '*', and '+') 
// to guarantee that callbacks are properly nested. We do not 	TokenNameCOMMENT_LINE	to guarantee that callbacks are properly nested. We do not 
// want to trigger endEntity too early in case we cross the 	TokenNameCOMMENT_LINE	want to trigger endEntity too early in case we cross the 
// boundary of an entity between the two characters. 	TokenNameCOMMENT_LINE	boundary of an entity between the two characters. 
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipString	TokenNameIdentifier	 skip String
(	TokenNameLPAREN	
")?"	TokenNameStringLiteral	)?
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
")?"	TokenNameStringLiteral	)?
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
oc	TokenNameIdentifier	 oc
=	TokenNameEQUAL	
XMLDTDContentModelHandler	TokenNameIdentifier	 XMLDTD Content Model Handler
.	TokenNameDOT	
OCCURS_ZERO_OR_ONE	TokenNameIdentifier	 OCCURS  ZERO  OR  ONE
;	TokenNameSEMICOLON	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
.	TokenNameDOT	
occurrence	TokenNameIdentifier	 occurrence
(	TokenNameLPAREN	
oc	TokenNameIdentifier	 oc
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipString	TokenNameIdentifier	 skip String
(	TokenNameLPAREN	
")+"	TokenNameStringLiteral	)+
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
")+"	TokenNameStringLiteral	)+
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
oc	TokenNameIdentifier	 oc
=	TokenNameEQUAL	
XMLDTDContentModelHandler	TokenNameIdentifier	 XMLDTD Content Model Handler
.	TokenNameDOT	
OCCURS_ONE_OR_MORE	TokenNameIdentifier	 OCCURS  ONE  OR  MORE
;	TokenNameSEMICOLON	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
.	TokenNameDOT	
occurrence	TokenNameIdentifier	 occurrence
(	TokenNameLPAREN	
oc	TokenNameIdentifier	 oc
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipString	TokenNameIdentifier	 skip String
(	TokenNameLPAREN	
")*"	TokenNameStringLiteral	)*
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
")*"	TokenNameStringLiteral	)*
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
oc	TokenNameIdentifier	 oc
=	TokenNameEQUAL	
XMLDTDContentModelHandler	TokenNameIdentifier	 XMLDTD Content Model Handler
.	TokenNameDOT	
OCCURS_ZERO_OR_MORE	TokenNameIdentifier	 OCCURS  ZERO  OR  MORE
;	TokenNameSEMICOLON	
fDTDContentModelHandler	TokenNameIdentifier	 f DTD Content Model Handler
.	TokenNameDOT	
occurrence	TokenNameIdentifier	 occurrence
(	TokenNameLPAREN	
oc	TokenNameIdentifier	 oc
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// no occurrence specified 	TokenNameCOMMENT_LINE	no occurrence specified 
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanChar	TokenNameIdentifier	 scan Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
')'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fMarkUpDepth	TokenNameIdentifier	 f Mark Up Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fContentDepth	TokenNameIdentifier	 f Content Depth
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Scans an attlist declaration * <p> * <pre> * [52] AttlistDecl ::= '&lt;!ATTLIST' S Name AttDef* S? '>' * [53] AttDef ::= S Name S AttType S DefaultDecl * </pre> * <p> * <strong>Note:</strong> Called after scanning past '&lt;!ATTLIST' */	TokenNameCOMMENT_JAVADOC	 Scans an attlist declaration <p> <pre> [52] AttlistDecl ::= '&lt;!ATTLIST' S Name AttDef* S? '>' [53] AttDef ::= S Name S AttType S DefaultDecl </pre> <p> <strong>Note:</strong> Called after scanning past '&lt;!ATTLIST' 
protected	TokenNameprotected	
final	TokenNamefinal	
void	TokenNamevoid	
scanAttlistDecl	TokenNameIdentifier	 scan Attlist Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
// spaces 	TokenNameCOMMENT_LINE	spaces 
fReportEntity	TokenNameIdentifier	 f Report Entity
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_SPACE_REQUIRED_BEFORE_ELEMENT_TYPE_IN_ATTLISTDECL"	TokenNameStringLiteral	MSG_SPACE_REQUIRED_BEFORE_ELEMENT_TYPE_IN_ATTLISTDECL
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// element name 	TokenNameCOMMENT_LINE	element name 
String	TokenNameIdentifier	 String
elName	TokenNameIdentifier	 el Name
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanName	TokenNameIdentifier	 scan Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
elName	TokenNameIdentifier	 el Name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_ELEMENT_TYPE_REQUIRED_IN_ATTLISTDECL"	TokenNameStringLiteral	MSG_ELEMENT_TYPE_REQUIRED_IN_ATTLISTDECL
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
startAttlist	TokenNameIdentifier	 start Attlist
(	TokenNameLPAREN	
elName	TokenNameIdentifier	 el Name
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// spaces 	TokenNameCOMMENT_LINE	spaces 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// no space, is it the end yet? 	TokenNameCOMMENT_LINE	no space, is it the end yet? 
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'>'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// yes, stop here 	TokenNameCOMMENT_LINE	yes, stop here 
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
endAttlist	TokenNameIdentifier	 end Attlist
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fMarkUpDepth	TokenNameIdentifier	 f Mark Up Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_SPACE_REQUIRED_BEFORE_ATTRIBUTE_NAME_IN_ATTDEF"	TokenNameStringLiteral	MSG_SPACE_REQUIRED_BEFORE_ATTRIBUTE_NAME_IN_ATTDEF
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
elName	TokenNameIdentifier	 el Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// definitions 	TokenNameCOMMENT_LINE	definitions 
while	TokenNamewhile	
(	TokenNameLPAREN	
!	TokenNameNOT	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'>'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanName	TokenNameIdentifier	 scan Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"AttNameRequiredInAttDef"	TokenNameStringLiteral	AttNameRequiredInAttDef
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
elName	TokenNameIdentifier	 el Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// spaces 	TokenNameCOMMENT_LINE	spaces 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_SPACE_REQUIRED_BEFORE_ATTTYPE_IN_ATTDEF"	TokenNameStringLiteral	MSG_SPACE_REQUIRED_BEFORE_ATTTYPE_IN_ATTDEF
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
elName	TokenNameIdentifier	 el Name
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// type 	TokenNameCOMMENT_LINE	type 
String	TokenNameIdentifier	 String
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
scanAttType	TokenNameIdentifier	 scan Att Type
(	TokenNameLPAREN	
elName	TokenNameIdentifier	 el Name
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// spaces 	TokenNameCOMMENT_LINE	spaces 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_SPACE_REQUIRED_BEFORE_DEFAULTDECL_IN_ATTDEF"	TokenNameStringLiteral	MSG_SPACE_REQUIRED_BEFORE_DEFAULTDECL_IN_ATTDEF
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
elName	TokenNameIdentifier	 el Name
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// default decl 	TokenNameCOMMENT_LINE	default decl 
String	TokenNameIdentifier	 String
defaultType	TokenNameIdentifier	 default Type
=	TokenNameEQUAL	
scanAttDefaultDecl	TokenNameIdentifier	 scan Att Default Decl
(	TokenNameLPAREN	
elName	TokenNameIdentifier	 el Name
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
fLiteral	TokenNameIdentifier	 f Literal
,	TokenNameCOMMA	
fLiteral2	TokenNameIdentifier	 f Literal2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// REVISIT: Should we do anything with the non-normalized 	TokenNameCOMMENT_LINE	REVISIT: Should we do anything with the non-normalized 
// default attribute value? -Ac 	TokenNameCOMMENT_LINE	default attribute value? -Ac 
// yes--according to bug 5073. - neilg 	TokenNameCOMMENT_LINE	yes--according to bug 5073. - neilg 
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
enumeration	TokenNameIdentifier	 enumeration
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fEnumerationCount	TokenNameIdentifier	 f Enumeration Count
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
enumeration	TokenNameIdentifier	 enumeration
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
fEnumerationCount	TokenNameIdentifier	 f Enumeration Count
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fEnumeration	TokenNameIdentifier	 f Enumeration
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
enumeration	TokenNameIdentifier	 enumeration
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fEnumerationCount	TokenNameIdentifier	 f Enumeration Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Determine whether the default value to be passed should be null. 	TokenNameCOMMENT_LINE	Determine whether the default value to be passed should be null. 
// REVISIT: should probably check whether fLiteral.ch is null instead. LM. 	TokenNameCOMMENT_LINE	REVISIT: should probably check whether fLiteral.ch is null instead. LM. 
if	TokenNameif	
(	TokenNameLPAREN	
defaultType	TokenNameIdentifier	 default Type
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
defaultType	TokenNameIdentifier	 default Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"#REQUIRED"	TokenNameStringLiteral	#REQUIRED
)	TokenNameRPAREN	
||	TokenNameOR_OR	
defaultType	TokenNameIdentifier	 default Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"#IMPLIED"	TokenNameStringLiteral	#IMPLIED
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
attributeDecl	TokenNameIdentifier	 attribute Decl
(	TokenNameLPAREN	
elName	TokenNameIdentifier	 el Name
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
enumeration	TokenNameIdentifier	 enumeration
,	TokenNameCOMMA	
defaultType	TokenNameIdentifier	 default Type
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
attributeDecl	TokenNameIdentifier	 attribute Decl
(	TokenNameLPAREN	
elName	TokenNameIdentifier	 el Name
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
enumeration	TokenNameIdentifier	 enumeration
,	TokenNameCOMMA	
defaultType	TokenNameIdentifier	 default Type
,	TokenNameCOMMA	
fLiteral	TokenNameIdentifier	 f Literal
,	TokenNameCOMMA	
fLiteral2	TokenNameIdentifier	 f Literal2
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
endAttlist	TokenNameIdentifier	 end Attlist
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fMarkUpDepth	TokenNameIdentifier	 f Mark Up Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
fReportEntity	TokenNameIdentifier	 f Report Entity
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// scanAttlistDecl() 	TokenNameCOMMENT_LINE	scanAttlistDecl() 
/** * Scans an attribute type definition * <p> * <pre> * [54] AttType ::= StringType | TokenizedType | EnumeratedType * [55] StringType ::= 'CDATA' * [56] TokenizedType ::= 'ID' * | 'IDREF' * | 'IDREFS' * | 'ENTITY' * | 'ENTITIES' * | 'NMTOKEN' * | 'NMTOKENS' * [57] EnumeratedType ::= NotationType | Enumeration * [58] NotationType ::= 'NOTATION' S '(' S? Name (S? '|' S? Name)* S? ')' * [59] Enumeration ::= '(' S? Nmtoken (S? '|' S? Nmtoken)* S? ')' * </pre> * <p> * <strong>Note:</strong> Called after scanning past '&lt;!ATTLIST' * * @param elName The element type name this declaration is about. * @param atName The attribute name this declaration is about. */	TokenNameCOMMENT_JAVADOC	 Scans an attribute type definition <p> <pre> [54] AttType ::= StringType | TokenizedType | EnumeratedType [55] StringType ::= 'CDATA' [56] TokenizedType ::= 'ID' | 'IDREF' | 'IDREFS' | 'ENTITY' | 'ENTITIES' | 'NMTOKEN' | 'NMTOKENS' [57] EnumeratedType ::= NotationType | Enumeration [58] NotationType ::= 'NOTATION' S '(' S? Name (S? '|' S? Name)* S? ')' [59] Enumeration ::= '(' S? Nmtoken (S? '|' S? Nmtoken)* S? ')' </pre> <p> <strong>Note:</strong> Called after scanning past '&lt;!ATTLIST' * @param elName The element type name this declaration is about. @param atName The attribute name this declaration is about. 
private	TokenNameprivate	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
scanAttType	TokenNameIdentifier	 scan Att Type
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
elName	TokenNameIdentifier	 el Name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
atName	TokenNameIdentifier	 at Name
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fEnumerationCount	TokenNameIdentifier	 f Enumeration Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/* * Watchout: the order here is important: when a string happens to * be a substring of another string, the longer one needs to be * looked for first!! */	TokenNameCOMMENT_BLOCK	 Watchout: the order here is important: when a string happens to be a substring of another string, the longer one needs to be looked for first!! 
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipString	TokenNameIdentifier	 skip String
(	TokenNameLPAREN	
"CDATA"	TokenNameStringLiteral	CDATA
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
"CDATA"	TokenNameStringLiteral	CDATA
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipString	TokenNameIdentifier	 skip String
(	TokenNameLPAREN	
"IDREFS"	TokenNameStringLiteral	IDREFS
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
"IDREFS"	TokenNameStringLiteral	IDREFS
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipString	TokenNameIdentifier	 skip String
(	TokenNameLPAREN	
"IDREF"	TokenNameStringLiteral	IDREF
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
"IDREF"	TokenNameStringLiteral	IDREF
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipString	TokenNameIdentifier	 skip String
(	TokenNameLPAREN	
"ID"	TokenNameStringLiteral	ID
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
"ID"	TokenNameStringLiteral	ID
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipString	TokenNameIdentifier	 skip String
(	TokenNameLPAREN	
"ENTITY"	TokenNameStringLiteral	ENTITY
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
"ENTITY"	TokenNameStringLiteral	ENTITY
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipString	TokenNameIdentifier	 skip String
(	TokenNameLPAREN	
"ENTITIES"	TokenNameStringLiteral	ENTITIES
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
"ENTITIES"	TokenNameStringLiteral	ENTITIES
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipString	TokenNameIdentifier	 skip String
(	TokenNameLPAREN	
"NMTOKENS"	TokenNameStringLiteral	NMTOKENS
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
"NMTOKENS"	TokenNameStringLiteral	NMTOKENS
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipString	TokenNameIdentifier	 skip String
(	TokenNameLPAREN	
"NMTOKEN"	TokenNameStringLiteral	NMTOKEN
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
"NMTOKEN"	TokenNameStringLiteral	NMTOKEN
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipString	TokenNameIdentifier	 skip String
(	TokenNameLPAREN	
"NOTATION"	TokenNameStringLiteral	NOTATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
"NOTATION"	TokenNameStringLiteral	NOTATION
;	TokenNameSEMICOLON	
// spaces 	TokenNameCOMMENT_LINE	spaces 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_SPACE_REQUIRED_AFTER_NOTATION_IN_NOTATIONTYPE"	TokenNameStringLiteral	MSG_SPACE_REQUIRED_AFTER_NOTATION_IN_NOTATIONTYPE
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
elName	TokenNameIdentifier	 el Name
,	TokenNameCOMMA	
atName	TokenNameIdentifier	 at Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// open paren 	TokenNameCOMMENT_LINE	open paren 
int	TokenNameint	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanChar	TokenNameIdentifier	 scan Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
!=	TokenNameNOT_EQUAL	
'('	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_OPEN_PAREN_REQUIRED_IN_NOTATIONTYPE"	TokenNameStringLiteral	MSG_OPEN_PAREN_REQUIRED_IN_NOTATIONTYPE
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
elName	TokenNameIdentifier	 el Name
,	TokenNameCOMMA	
atName	TokenNameIdentifier	 at Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fMarkUpDepth	TokenNameIdentifier	 f Mark Up Depth
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
aName	TokenNameIdentifier	 a Name
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanName	TokenNameIdentifier	 scan Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
aName	TokenNameIdentifier	 a Name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_NAME_REQUIRED_IN_NOTATIONTYPE"	TokenNameStringLiteral	MSG_NAME_REQUIRED_IN_NOTATIONTYPE
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
elName	TokenNameIdentifier	 el Name
,	TokenNameCOMMA	
atName	TokenNameIdentifier	 at Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
skipInvalidEnumerationValue	TokenNameIdentifier	 skip Invalid Enumeration Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
'|'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ensureEnumerationSize	TokenNameIdentifier	 ensure Enumeration Size
(	TokenNameLPAREN	
fEnumerationCount	TokenNameIdentifier	 f Enumeration Count
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fEnumeration	TokenNameIdentifier	 f Enumeration
[	TokenNameLBRACKET	
fEnumerationCount	TokenNameIdentifier	 f Enumeration Count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
aName	TokenNameIdentifier	 a Name
;	TokenNameSEMICOLON	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanChar	TokenNameIdentifier	 scan Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
'|'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
!=	TokenNameNOT_EQUAL	
')'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"NotationTypeUnterminated"	TokenNameStringLiteral	NotationTypeUnterminated
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
elName	TokenNameIdentifier	 el Name
,	TokenNameCOMMA	
atName	TokenNameIdentifier	 at Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fMarkUpDepth	TokenNameIdentifier	 f Mark Up Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Enumeration 	TokenNameCOMMENT_LINE	Enumeration 
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
"ENUMERATION"	TokenNameStringLiteral	ENUMERATION
;	TokenNameSEMICOLON	
// open paren 	TokenNameCOMMENT_LINE	open paren 
int	TokenNameint	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanChar	TokenNameIdentifier	 scan Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
!=	TokenNameNOT_EQUAL	
'('	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// "OPEN_PAREN_REQUIRED_BEFORE_ENUMERATION_IN_ATTRDECL", 	TokenNameCOMMENT_LINE	"OPEN_PAREN_REQUIRED_BEFORE_ENUMERATION_IN_ATTRDECL", 
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"AttTypeRequiredInAttDef"	TokenNameStringLiteral	AttTypeRequiredInAttDef
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
elName	TokenNameIdentifier	 el Name
,	TokenNameCOMMA	
atName	TokenNameIdentifier	 at Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fMarkUpDepth	TokenNameIdentifier	 f Mark Up Depth
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanNmtoken	TokenNameIdentifier	 scan Nmtoken
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_NMTOKEN_REQUIRED_IN_ENUMERATION"	TokenNameStringLiteral	MSG_NMTOKEN_REQUIRED_IN_ENUMERATION
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
elName	TokenNameIdentifier	 el Name
,	TokenNameCOMMA	
atName	TokenNameIdentifier	 at Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
skipInvalidEnumerationValue	TokenNameIdentifier	 skip Invalid Enumeration Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
'|'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ensureEnumerationSize	TokenNameIdentifier	 ensure Enumeration Size
(	TokenNameLPAREN	
fEnumerationCount	TokenNameIdentifier	 f Enumeration Count
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fEnumeration	TokenNameIdentifier	 f Enumeration
[	TokenNameLBRACKET	
fEnumerationCount	TokenNameIdentifier	 f Enumeration Count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanChar	TokenNameIdentifier	 scan Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
'|'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
!=	TokenNameNOT_EQUAL	
')'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"EnumerationUnterminated"	TokenNameStringLiteral	EnumerationUnterminated
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
elName	TokenNameIdentifier	 el Name
,	TokenNameCOMMA	
atName	TokenNameIdentifier	 at Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fMarkUpDepth	TokenNameIdentifier	 f Mark Up Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// scanAttType():String 	TokenNameCOMMENT_LINE	scanAttType():String 
/** * Scans an attribute default declaration * <p> * <pre> * [60] DefaultDecl ::= '#REQUIRED' | '#IMPLIED' | (('#FIXED' S)? AttValue) * </pre> * * @param elName * @param atName The name of the attribute being scanned. * @param type * @param defaultVal The string to fill in with the default value. * @param nonNormalizedDefaultVal */	TokenNameCOMMENT_JAVADOC	 Scans an attribute default declaration <p> <pre> [60] DefaultDecl ::= '#REQUIRED' | '#IMPLIED' | (('#FIXED' S)? AttValue) </pre> * @param elName @param atName The name of the attribute being scanned. @param type @param defaultVal The string to fill in with the default value. @param nonNormalizedDefaultVal 
protected	TokenNameprotected	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
scanAttDefaultDecl	TokenNameIdentifier	 scan Att Default Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
elName	TokenNameIdentifier	 el Name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
atName	TokenNameIdentifier	 at Name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
XMLString	TokenNameIdentifier	 XML String
defaultVal	TokenNameIdentifier	 default Val
,	TokenNameCOMMA	
XMLString	TokenNameIdentifier	 XML String
nonNormalizedDefaultVal	TokenNameIdentifier	 non Normalized Default Val
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
defaultType	TokenNameIdentifier	 default Type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fString	TokenNameIdentifier	 f String
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
defaultVal	TokenNameIdentifier	 default Val
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipString	TokenNameIdentifier	 skip String
(	TokenNameLPAREN	
"#REQUIRED"	TokenNameStringLiteral	#REQUIRED
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
defaultType	TokenNameIdentifier	 default Type
=	TokenNameEQUAL	
"#REQUIRED"	TokenNameStringLiteral	#REQUIRED
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipString	TokenNameIdentifier	 skip String
(	TokenNameLPAREN	
"#IMPLIED"	TokenNameStringLiteral	#IMPLIED
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
defaultType	TokenNameIdentifier	 default Type
=	TokenNameEQUAL	
"#IMPLIED"	TokenNameStringLiteral	#IMPLIED
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipString	TokenNameIdentifier	 skip String
(	TokenNameLPAREN	
"#FIXED"	TokenNameStringLiteral	#FIXED
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
defaultType	TokenNameIdentifier	 default Type
=	TokenNameEQUAL	
"#FIXED"	TokenNameStringLiteral	#FIXED
;	TokenNameSEMICOLON	
// spaces 	TokenNameCOMMENT_LINE	spaces 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_SPACE_REQUIRED_AFTER_FIXED_IN_DEFAULTDECL"	TokenNameStringLiteral	MSG_SPACE_REQUIRED_AFTER_FIXED_IN_DEFAULTDECL
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
elName	TokenNameIdentifier	 el Name
,	TokenNameCOMMA	
atName	TokenNameIdentifier	 at Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// AttValue 	TokenNameCOMMENT_LINE	AttValue 
boolean	TokenNameboolean	
isVC	TokenNameIdentifier	 is VC
=	TokenNameEQUAL	
!	TokenNameNOT	
fStandalone	TokenNameIdentifier	 f Standalone
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
fSeenExternalDTD	TokenNameIdentifier	 f Seen External DTD
||	TokenNameOR_OR	
fSeenPEReferences	TokenNameIdentifier	 f Seen PE References
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
scanAttributeValue	TokenNameIdentifier	 scan Attribute Value
(	TokenNameLPAREN	
defaultVal	TokenNameIdentifier	 default Val
,	TokenNameCOMMA	
nonNormalizedDefaultVal	TokenNameIdentifier	 non Normalized Default Val
,	TokenNameCOMMA	
atName	TokenNameIdentifier	 at Name
,	TokenNameCOMMA	
isVC	TokenNameIdentifier	 is VC
,	TokenNameCOMMA	
elName	TokenNameIdentifier	 el Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
defaultType	TokenNameIdentifier	 default Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// ScanAttDefaultDecl 	TokenNameCOMMENT_LINE	ScanAttDefaultDecl 
/** * Scans an entity declaration * <p> * <pre> * [70] EntityDecl ::= GEDecl | PEDecl * [71] GEDecl ::= '&lt;!ENTITY' S Name S EntityDef S? '>' * [72] PEDecl ::= '&lt;!ENTITY' S '%' S Name S PEDef S? '>' * [73] EntityDef ::= EntityValue | (ExternalID NDataDecl?) * [74] PEDef ::= EntityValue | ExternalID * [75] ExternalID ::= 'SYSTEM' S SystemLiteral * | 'PUBLIC' S PubidLiteral S SystemLiteral * [76] NDataDecl ::= S 'NDATA' S Name * </pre> * <p> * <strong>Note:</strong> Called after scanning past '&lt;!ENTITY' */	TokenNameCOMMENT_JAVADOC	 Scans an entity declaration <p> <pre> [70] EntityDecl ::= GEDecl | PEDecl [71] GEDecl ::= '&lt;!ENTITY' S Name S EntityDef S? '>' [72] PEDecl ::= '&lt;!ENTITY' S '%' S Name S PEDef S? '>' [73] EntityDef ::= EntityValue | (ExternalID NDataDecl?) [74] PEDef ::= EntityValue | ExternalID [75] ExternalID ::= 'SYSTEM' S SystemLiteral | 'PUBLIC' S PubidLiteral S SystemLiteral [76] NDataDecl ::= S 'NDATA' S Name </pre> <p> <strong>Note:</strong> Called after scanning past '&lt;!ENTITY' 
private	TokenNameprivate	
final	TokenNamefinal	
void	TokenNamevoid	
scanEntityDecl	TokenNameIdentifier	 scan Entity Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
boolean	TokenNameboolean	
isPEDecl	TokenNameIdentifier	 is PE Decl
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
sawPERef	TokenNameIdentifier	 saw PE Ref
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fReportEntity	TokenNameIdentifier	 f Report Entity
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipSpaces	TokenNameIdentifier	 skip Spaces
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'%'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
isPEDecl	TokenNameIdentifier	 is PE Decl
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// <!ENTITY x "x"> 	TokenNameCOMMENT_LINE	<!ENTITY x "x"> 
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// <!ENTITY % x "x"> 	TokenNameCOMMENT_LINE	<!ENTITY % x "x"> 
isPEDecl	TokenNameIdentifier	 is PE Decl
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_SPACE_REQUIRED_BEFORE_ENTITY_NAME_IN_PEDECL"	TokenNameStringLiteral	MSG_SPACE_REQUIRED_BEFORE_ENTITY_NAME_IN_PEDECL
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
isPEDecl	TokenNameIdentifier	 is PE Decl
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
peekChar	TokenNameIdentifier	 peek Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
'%'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// <!ENTITY %%x; "x"> is legal 	TokenNameCOMMENT_LINE	<!ENTITY %%x; "x"> is legal 
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
isPEDecl	TokenNameIdentifier	 is PE Decl
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
sawPERef	TokenNameIdentifier	 saw PE Ref
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'%'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// <!ENTITY[^ ]...> or <!ENTITY[^ %]...> 	TokenNameCOMMENT_LINE	<!ENTITY[^ ]...> or <!ENTITY[^ %]...> 
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_SPACE_REQUIRED_BEFORE_ENTITY_NAME_IN_ENTITYDECL"	TokenNameStringLiteral	MSG_SPACE_REQUIRED_BEFORE_ENTITY_NAME_IN_ENTITYDECL
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
isPEDecl	TokenNameIdentifier	 is PE Decl
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipSpaces	TokenNameIdentifier	 skip Spaces
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// <!ENTITY% ...> 	TokenNameCOMMENT_LINE	<!ENTITY% ...> 
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_SPACE_REQUIRED_BEFORE_PERCENT_IN_PEDECL"	TokenNameStringLiteral	MSG_SPACE_REQUIRED_BEFORE_PERCENT_IN_PEDECL
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
isPEDecl	TokenNameIdentifier	 is PE Decl
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
sawPERef	TokenNameIdentifier	 saw PE Ref
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
sawPERef	TokenNameIdentifier	 saw PE Ref
)	TokenNameRPAREN	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
peName	TokenNameIdentifier	 pe Name
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanName	TokenNameIdentifier	 scan Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
peName	TokenNameIdentifier	 pe Name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"NameRequiredInPEReference"	TokenNameStringLiteral	NameRequiredInPEReference
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
';'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"SemicolonRequiredInPEReference"	TokenNameStringLiteral	SemicolonRequiredInPEReference
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
peName	TokenNameIdentifier	 pe Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
startPE	TokenNameIdentifier	 start PE
(	TokenNameLPAREN	
peName	TokenNameIdentifier	 pe Name
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipSpaces	TokenNameIdentifier	 skip Spaces
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'%'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isPEDecl	TokenNameIdentifier	 is PE Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
isPEDecl	TokenNameIdentifier	 is PE Decl
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
isPEDecl	TokenNameIdentifier	 is PE Decl
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'%'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// name 	TokenNameCOMMENT_LINE	name 
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fNamespaces	TokenNameIdentifier	 f Namespaces
)	TokenNameRPAREN	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanNCName	TokenNameIdentifier	 scan NC Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanName	TokenNameIdentifier	 scan Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_ENTITY_NAME_REQUIRED_IN_ENTITYDECL"	TokenNameStringLiteral	MSG_ENTITY_NAME_REQUIRED_IN_ENTITYDECL
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// spaces 	TokenNameCOMMENT_LINE	spaces 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fNamespaces	TokenNameIdentifier	 f Namespaces
&&	TokenNameAND_AND	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
peekChar	TokenNameIdentifier	 peek Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
':'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanChar	TokenNameIdentifier	 scan Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XMLStringBuffer	TokenNameIdentifier	 XML String Buffer
colonName	TokenNameIdentifier	 colon Name
=	TokenNameEQUAL	
new	TokenNamenew	
XMLStringBuffer	TokenNameIdentifier	 XML String Buffer
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
colonName	TokenNameIdentifier	 colon Name
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
':'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
str	TokenNameIdentifier	 str
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanName	TokenNameIdentifier	 scan Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
str	TokenNameIdentifier	 str
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
colonName	TokenNameIdentifier	 colon Name
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
str	TokenNameIdentifier	 str
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"ColonNotLegalWithNS"	TokenNameStringLiteral	ColonNotLegalWithNS
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
colonName	TokenNameIdentifier	 colon Name
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_SPACE_REQUIRED_AFTER_ENTITY_NAME_IN_ENTITYDECL"	TokenNameStringLiteral	MSG_SPACE_REQUIRED_AFTER_ENTITY_NAME_IN_ENTITYDECL
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_SPACE_REQUIRED_AFTER_ENTITY_NAME_IN_ENTITYDECL"	TokenNameStringLiteral	MSG_SPACE_REQUIRED_AFTER_ENTITY_NAME_IN_ENTITYDECL
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// external id 	TokenNameCOMMENT_LINE	external id 
scanExternalID	TokenNameIdentifier	 scan External ID
(	TokenNameLPAREN	
fStrings	TokenNameIdentifier	 f Strings
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
systemId	TokenNameIdentifier	 system Id
=	TokenNameEQUAL	
fStrings	TokenNameIdentifier	 f Strings
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
publicId	TokenNameIdentifier	 public Id
=	TokenNameEQUAL	
fStrings	TokenNameIdentifier	 f Strings
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
notation	TokenNameIdentifier	 notation
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// NDATA 	TokenNameCOMMENT_LINE	NDATA 
boolean	TokenNameboolean	
sawSpace	TokenNameIdentifier	 saw Space
=	TokenNameEQUAL	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isPEDecl	TokenNameIdentifier	 is PE Decl
&&	TokenNameAND_AND	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipString	TokenNameIdentifier	 skip String
(	TokenNameLPAREN	
"NDATA"	TokenNameStringLiteral	NDATA
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// check whether there was space before NDATA 	TokenNameCOMMENT_LINE	check whether there was space before NDATA 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
sawSpace	TokenNameIdentifier	 saw Space
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_SPACE_REQUIRED_BEFORE_NDATA_IN_UNPARSED_ENTITYDECL"	TokenNameStringLiteral	MSG_SPACE_REQUIRED_BEFORE_NDATA_IN_UNPARSED_ENTITYDECL
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// spaces 	TokenNameCOMMENT_LINE	spaces 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_SPACE_REQUIRED_BEFORE_NOTATION_NAME_IN_UNPARSED_ENTITYDECL"	TokenNameStringLiteral	MSG_SPACE_REQUIRED_BEFORE_NOTATION_NAME_IN_UNPARSED_ENTITYDECL
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
notation	TokenNameIdentifier	 notation
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanName	TokenNameIdentifier	 scan Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
notation	TokenNameIdentifier	 notation
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_NOTATION_NAME_REQUIRED_FOR_UNPARSED_ENTITYDECL"	TokenNameStringLiteral	MSG_NOTATION_NAME_REQUIRED_FOR_UNPARSED_ENTITYDECL
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// internal entity 	TokenNameCOMMENT_LINE	internal entity 
if	TokenNameif	
(	TokenNameLPAREN	
systemId	TokenNameIdentifier	 system Id
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
scanEntityValue	TokenNameIdentifier	 scan Entity Value
(	TokenNameLPAREN	
fLiteral	TokenNameIdentifier	 f Literal
,	TokenNameCOMMA	
fLiteral2	TokenNameIdentifier	 f Literal2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// since we need it's value anyway, let's snag it so it doesn't get corrupted 	TokenNameCOMMENT_LINE	since we need it's value anyway, let's snag it so it doesn't get corrupted 
// if a new load takes place before we store the entity values 	TokenNameCOMMENT_LINE	if a new load takes place before we store the entity values 
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fStringBuffer2	TokenNameIdentifier	 f String Buffer2
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
fLiteral	TokenNameIdentifier	 f Literal
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
,	TokenNameCOMMA	
fLiteral	TokenNameIdentifier	 f Literal
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
fLiteral	TokenNameIdentifier	 f Literal
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fStringBuffer2	TokenNameIdentifier	 f String Buffer2
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
fLiteral2	TokenNameIdentifier	 f Literal2
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
,	TokenNameCOMMA	
fLiteral2	TokenNameIdentifier	 f Literal2
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
fLiteral2	TokenNameIdentifier	 f Literal2
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// skip possible trailing space 	TokenNameCOMMENT_LINE	skip possible trailing space 
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// end 	TokenNameCOMMENT_LINE	end 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'>'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"EntityDeclUnterminated"	TokenNameStringLiteral	EntityDeclUnterminated
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fMarkUpDepth	TokenNameIdentifier	 f Mark Up Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
// register entity and make callback 	TokenNameCOMMENT_LINE	register entity and make callback 
if	TokenNameif	
(	TokenNameLPAREN	
isPEDecl	TokenNameIdentifier	 is PE Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
"%"	TokenNameStringLiteral	%
+	TokenNamePLUS	
name	TokenNameIdentifier	 name
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
systemId	TokenNameIdentifier	 system Id
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
baseSystemId	TokenNameIdentifier	 base System Id
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
getBaseSystemId	TokenNameIdentifier	 get Base System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
notation	TokenNameIdentifier	 notation
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fEntityManager	TokenNameIdentifier	 f Entity Manager
.	TokenNameDOT	
addUnparsedEntity	TokenNameIdentifier	 add Unparsed Entity
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
publicId	TokenNameIdentifier	 public Id
,	TokenNameCOMMA	
systemId	TokenNameIdentifier	 system Id
,	TokenNameCOMMA	
baseSystemId	TokenNameIdentifier	 base System Id
,	TokenNameCOMMA	
notation	TokenNameIdentifier	 notation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fEntityManager	TokenNameIdentifier	 f Entity Manager
.	TokenNameDOT	
addExternalEntity	TokenNameIdentifier	 add External Entity
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
publicId	TokenNameIdentifier	 public Id
,	TokenNameCOMMA	
systemId	TokenNameIdentifier	 system Id
,	TokenNameCOMMA	
baseSystemId	TokenNameIdentifier	 base System Id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fResourceIdentifier	TokenNameIdentifier	 f Resource Identifier
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
publicId	TokenNameIdentifier	 public Id
,	TokenNameCOMMA	
systemId	TokenNameIdentifier	 system Id
,	TokenNameCOMMA	
baseSystemId	TokenNameIdentifier	 base System Id
,	TokenNameCOMMA	
XMLEntityManager	TokenNameIdentifier	 XML Entity Manager
.	TokenNameDOT	
expandSystemId	TokenNameIdentifier	 expand System Id
(	TokenNameLPAREN	
systemId	TokenNameIdentifier	 system Id
,	TokenNameCOMMA	
baseSystemId	TokenNameIdentifier	 base System Id
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
notation	TokenNameIdentifier	 notation
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
unparsedEntityDecl	TokenNameIdentifier	 unparsed Entity Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
fResourceIdentifier	TokenNameIdentifier	 f Resource Identifier
,	TokenNameCOMMA	
notation	TokenNameIdentifier	 notation
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
externalEntityDecl	TokenNameIdentifier	 external Entity Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
fResourceIdentifier	TokenNameIdentifier	 f Resource Identifier
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fEntityManager	TokenNameIdentifier	 f Entity Manager
.	TokenNameDOT	
addInternalEntity	TokenNameIdentifier	 add Internal Entity
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
internalEntityDecl	TokenNameIdentifier	 internal Entity Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
fStringBuffer	TokenNameIdentifier	 f String Buffer
,	TokenNameCOMMA	
fStringBuffer2	TokenNameIdentifier	 f String Buffer2
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
fReportEntity	TokenNameIdentifier	 f Report Entity
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// scanEntityDecl() 	TokenNameCOMMENT_LINE	scanEntityDecl() 
/** * Scans an entity value. * * @param value The string to fill in with the value. * @param nonNormalizedValue The string to fill in with the * non-normalized value. * * <strong>Note:</strong> This method uses fString, fStringBuffer (through * the use of scanCharReferenceValue), and fStringBuffer2, anything in them * at the time of calling is lost. */	TokenNameCOMMENT_JAVADOC	 Scans an entity value. * @param value The string to fill in with the value. @param nonNormalizedValue The string to fill in with the non-normalized value. * <strong>Note:</strong> This method uses fString, fStringBuffer (through the use of scanCharReferenceValue), and fStringBuffer2, anything in them at the time of calling is lost. 
protected	TokenNameprotected	
final	TokenNamefinal	
void	TokenNamevoid	
scanEntityValue	TokenNameIdentifier	 scan Entity Value
(	TokenNameLPAREN	
XMLString	TokenNameIdentifier	 XML String
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
XMLString	TokenNameIdentifier	 XML String
nonNormalizedValue	TokenNameIdentifier	 non Normalized Value
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
int	TokenNameint	
quote	TokenNameIdentifier	 quote
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanChar	TokenNameIdentifier	 scan Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
quote	TokenNameIdentifier	 quote
!=	TokenNameNOT_EQUAL	
'\''	TokenNameCharacterLiteral	
&&	TokenNameAND_AND	
quote	TokenNameIdentifier	 quote
!=	TokenNameNOT_EQUAL	
'"'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"OpenQuoteMissingInDecl"	TokenNameStringLiteral	OpenQuoteMissingInDecl
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// store at which depth of entities we start 	TokenNameCOMMENT_LINE	store at which depth of entities we start 
int	TokenNameint	
entityDepth	TokenNameIdentifier	 entity Depth
=	TokenNameEQUAL	
fEntityDepth	TokenNameIdentifier	 f Entity Depth
;	TokenNameSEMICOLON	
XMLString	TokenNameIdentifier	 XML String
literal	TokenNameIdentifier	 literal
=	TokenNameEQUAL	
fString	TokenNameIdentifier	 f String
;	TokenNameSEMICOLON	
XMLString	TokenNameIdentifier	 XML String
literal2	TokenNameIdentifier	 literal2
=	TokenNameEQUAL	
fString	TokenNameIdentifier	 f String
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanLiteral	TokenNameIdentifier	 scan Literal
(	TokenNameLPAREN	
quote	TokenNameIdentifier	 quote
,	TokenNameCOMMA	
fString	TokenNameIdentifier	 f String
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
quote	TokenNameIdentifier	 quote
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fStringBuffer2	TokenNameIdentifier	 f String Buffer2
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
fString	TokenNameIdentifier	 f String
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fStringBuffer2	TokenNameIdentifier	 f String Buffer2
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
fString	TokenNameIdentifier	 f String
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'&'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'#'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fStringBuffer2	TokenNameIdentifier	 f String Buffer2
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"&#"	TokenNameStringLiteral	&#
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
scanCharReferenceValue	TokenNameIdentifier	 scan Char Reference Value
(	TokenNameLPAREN	
fStringBuffer	TokenNameIdentifier	 f String Buffer
,	TokenNameCOMMA	
fStringBuffer2	TokenNameIdentifier	 f String Buffer2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'&'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fStringBuffer2	TokenNameIdentifier	 f String Buffer2
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'&'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
eName	TokenNameIdentifier	 e Name
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanName	TokenNameIdentifier	 scan Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
eName	TokenNameIdentifier	 e Name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"NameRequiredInReference"	TokenNameStringLiteral	NameRequiredInReference
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
eName	TokenNameIdentifier	 e Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fStringBuffer2	TokenNameIdentifier	 f String Buffer2
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
eName	TokenNameIdentifier	 e Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
';'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"SemicolonRequiredInReference"	TokenNameStringLiteral	SemicolonRequiredInReference
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
eName	TokenNameIdentifier	 e Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
';'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fStringBuffer2	TokenNameIdentifier	 f String Buffer2
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
';'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'%'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fStringBuffer2	TokenNameIdentifier	 f String Buffer2
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'%'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
peName	TokenNameIdentifier	 pe Name
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanName	TokenNameIdentifier	 scan Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
peName	TokenNameIdentifier	 pe Name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"NameRequiredInPEReference"	TokenNameStringLiteral	NameRequiredInPEReference
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
';'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"SemicolonRequiredInPEReference"	TokenNameStringLiteral	SemicolonRequiredInPEReference
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
peName	TokenNameIdentifier	 pe Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"PEReferenceWithinMarkup"	TokenNameStringLiteral	PEReferenceWithinMarkup
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
peName	TokenNameIdentifier	 pe Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fStringBuffer2	TokenNameIdentifier	 f String Buffer2
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
peName	TokenNameIdentifier	 pe Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fStringBuffer2	TokenNameIdentifier	 f String Buffer2
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
';'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
startPE	TokenNameIdentifier	 start PE
(	TokenNameLPAREN	
peName	TokenNameIdentifier	 pe Name
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// REVISIT: [Q] Why do we skip spaces here? -Ac 	TokenNameCOMMENT_LINE	REVISIT: [Q] Why do we skip spaces here? -Ac 
// REVISIT: This will make returning the non- 	TokenNameCOMMENT_LINE	REVISIT: This will make returning the non- 
// normalized value harder. -Ac 	TokenNameCOMMENT_LINE	normalized value harder. -Ac 
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipSpaces	TokenNameIdentifier	 skip Spaces
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'%'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
peekChar	TokenNameIdentifier	 peek Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
XMLChar	TokenNameIdentifier	 XML Char
.	TokenNameDOT	
isHighSurrogate	TokenNameIdentifier	 is High Surrogate
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
scanSurrogates	TokenNameIdentifier	 scan Surrogates
(	TokenNameLPAREN	
fStringBuffer2	TokenNameIdentifier	 f String Buffer2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
isInvalidLiteral	TokenNameIdentifier	 is Invalid Literal
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"InvalidCharInLiteral"	TokenNameStringLiteral	InvalidCharInLiteral
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toHexString	TokenNameIdentifier	 to Hex String
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanChar	TokenNameIdentifier	 scan Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if it's not the delimiting quote or if it is but from a 	TokenNameCOMMENT_LINE	if it's not the delimiting quote or if it is but from a 
// different entity than the one this literal started from, 	TokenNameCOMMENT_LINE	different entity than the one this literal started from, 
// simply append the character to our buffer 	TokenNameCOMMENT_LINE	simply append the character to our buffer 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
!=	TokenNameNOT_EQUAL	
quote	TokenNameIdentifier	 quote
||	TokenNameOR_OR	
entityDepth	TokenNameIdentifier	 entity Depth
!=	TokenNameNOT_EQUAL	
fEntityDepth	TokenNameIdentifier	 f Entity Depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fStringBuffer2	TokenNameIdentifier	 f String Buffer2
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanChar	TokenNameIdentifier	 scan Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanLiteral	TokenNameIdentifier	 scan Literal
(	TokenNameLPAREN	
quote	TokenNameIdentifier	 quote
,	TokenNameCOMMA	
fString	TokenNameIdentifier	 f String
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
quote	TokenNameIdentifier	 quote
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fStringBuffer	TokenNameIdentifier	 f String Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
fString	TokenNameIdentifier	 f String
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fStringBuffer2	TokenNameIdentifier	 f String Buffer2
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
fString	TokenNameIdentifier	 f String
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
literal	TokenNameIdentifier	 literal
=	TokenNameEQUAL	
fStringBuffer	TokenNameIdentifier	 f String Buffer
;	TokenNameSEMICOLON	
literal2	TokenNameIdentifier	 literal2
=	TokenNameEQUAL	
fStringBuffer2	TokenNameIdentifier	 f String Buffer2
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
literal	TokenNameIdentifier	 literal
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
nonNormalizedValue	TokenNameIdentifier	 non Normalized Value
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
literal2	TokenNameIdentifier	 literal2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
quote	TokenNameIdentifier	 quote
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"CloseQuoteMissingInDecl"	TokenNameStringLiteral	CloseQuoteMissingInDecl
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// scanEntityValue(XMLString,XMLString):void 	TokenNameCOMMENT_LINE	scanEntityValue(XMLString,XMLString):void 
/** * Scans a notation declaration * <p> * <pre> * [82] NotationDecl ::= '&lt;!NOTATION' S Name S (ExternalID|PublicID) S? '>' * [83] PublicID ::= 'PUBLIC' S PubidLiteral * </pre> * <p> * <strong>Note:</strong> Called after scanning past '&lt;!NOTATION' */	TokenNameCOMMENT_JAVADOC	 Scans a notation declaration <p> <pre> [82] NotationDecl ::= '&lt;!NOTATION' S Name S (ExternalID|PublicID) S? '>' [83] PublicID ::= 'PUBLIC' S PubidLiteral </pre> <p> <strong>Note:</strong> Called after scanning past '&lt;!NOTATION' 
private	TokenNameprivate	
final	TokenNamefinal	
void	TokenNamevoid	
scanNotationDecl	TokenNameIdentifier	 scan Notation Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
// spaces 	TokenNameCOMMENT_LINE	spaces 
fReportEntity	TokenNameIdentifier	 f Report Entity
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_SPACE_REQUIRED_BEFORE_NOTATION_NAME_IN_NOTATIONDECL"	TokenNameStringLiteral	MSG_SPACE_REQUIRED_BEFORE_NOTATION_NAME_IN_NOTATIONDECL
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// notation name 	TokenNameCOMMENT_LINE	notation name 
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fNamespaces	TokenNameIdentifier	 f Namespaces
)	TokenNameRPAREN	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanNCName	TokenNameIdentifier	 scan NC Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanName	TokenNameIdentifier	 scan Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_NOTATION_NAME_REQUIRED_IN_NOTATIONDECL"	TokenNameStringLiteral	MSG_NOTATION_NAME_REQUIRED_IN_NOTATIONDECL
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// spaces 	TokenNameCOMMENT_LINE	spaces 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// check for invalid ":" 	TokenNameCOMMENT_LINE	check for invalid ":" 
if	TokenNameif	
(	TokenNameLPAREN	
fNamespaces	TokenNameIdentifier	 f Namespaces
&&	TokenNameAND_AND	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
peekChar	TokenNameIdentifier	 peek Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
':'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanChar	TokenNameIdentifier	 scan Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XMLStringBuffer	TokenNameIdentifier	 XML String Buffer
colonName	TokenNameIdentifier	 colon Name
=	TokenNameEQUAL	
new	TokenNamenew	
XMLStringBuffer	TokenNameIdentifier	 XML String Buffer
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
colonName	TokenNameIdentifier	 colon Name
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
':'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
colonName	TokenNameIdentifier	 colon Name
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanName	TokenNameIdentifier	 scan Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"ColonNotLegalWithNS"	TokenNameStringLiteral	ColonNotLegalWithNS
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
colonName	TokenNameIdentifier	 colon Name
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_SPACE_REQUIRED_AFTER_NOTATION_NAME_IN_NOTATIONDECL"	TokenNameStringLiteral	MSG_SPACE_REQUIRED_AFTER_NOTATION_NAME_IN_NOTATIONDECL
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// external id 	TokenNameCOMMENT_LINE	external id 
scanExternalID	TokenNameIdentifier	 scan External ID
(	TokenNameLPAREN	
fStrings	TokenNameIdentifier	 f Strings
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
systemId	TokenNameIdentifier	 system Id
=	TokenNameEQUAL	
fStrings	TokenNameIdentifier	 f Strings
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
publicId	TokenNameIdentifier	 public Id
=	TokenNameEQUAL	
fStrings	TokenNameIdentifier	 f Strings
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
baseSystemId	TokenNameIdentifier	 base System Id
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
getBaseSystemId	TokenNameIdentifier	 get Base System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
systemId	TokenNameIdentifier	 system Id
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
publicId	TokenNameIdentifier	 public Id
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"ExternalIDorPublicIDRequired"	TokenNameStringLiteral	ExternalIDorPublicIDRequired
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// skip possible trailing space 	TokenNameCOMMENT_LINE	skip possible trailing space 
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// end 	TokenNameCOMMENT_LINE	end 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'>'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"NotationDeclUnterminated"	TokenNameStringLiteral	NotationDeclUnterminated
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fMarkUpDepth	TokenNameIdentifier	 f Mark Up Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fResourceIdentifier	TokenNameIdentifier	 f Resource Identifier
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
publicId	TokenNameIdentifier	 public Id
,	TokenNameCOMMA	
systemId	TokenNameIdentifier	 system Id
,	TokenNameCOMMA	
baseSystemId	TokenNameIdentifier	 base System Id
,	TokenNameCOMMA	
XMLEntityManager	TokenNameIdentifier	 XML Entity Manager
.	TokenNameDOT	
expandSystemId	TokenNameIdentifier	 expand System Id
(	TokenNameLPAREN	
systemId	TokenNameIdentifier	 system Id
,	TokenNameCOMMA	
baseSystemId	TokenNameIdentifier	 base System Id
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
notationDecl	TokenNameIdentifier	 notation Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
fResourceIdentifier	TokenNameIdentifier	 f Resource Identifier
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fReportEntity	TokenNameIdentifier	 f Report Entity
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// scanNotationDecl() 	TokenNameCOMMENT_LINE	scanNotationDecl() 
/** * Scans a conditional section. If it's a section to ignore the whole * section gets scanned through and this method only returns after the * closing bracket has been found. When it's an include section though, it * returns to let the main loop take care of scanning it. In that case the * end of the section if handled by the main loop (scanDecls). * <p> * <pre> * [61] conditionalSect ::= includeSect | ignoreSect * [62] includeSect ::= '&lt;![' S? 'INCLUDE' S? '[' extSubsetDecl ']]>' * [63] ignoreSect ::= '&lt;![' S? 'IGNORE' S? '[' ignoreSectContents* ']]>' * [64] ignoreSectContents ::= Ignore ('&lt;![' ignoreSectContents ']]>' Ignore)* * [65] Ignore ::= Char* - (Char* ('&lt;![' | ']]>') Char*) * </pre> * <p> * <strong>Note:</strong> Called after scanning past '&lt;![' */	TokenNameCOMMENT_JAVADOC	 Scans a conditional section. If it's a section to ignore the whole section gets scanned through and this method only returns after the closing bracket has been found. When it's an include section though, it returns to let the main loop take care of scanning it. In that case the end of the section if handled by the main loop (scanDecls). <p> <pre> [61] conditionalSect ::= includeSect | ignoreSect [62] includeSect ::= '&lt;![' S? 'INCLUDE' S? '[' extSubsetDecl ']]>' [63] ignoreSect ::= '&lt;![' S? 'IGNORE' S? '[' ignoreSectContents* ']]>' [64] ignoreSectContents ::= Ignore ('&lt;![' ignoreSectContents ']]>' Ignore)* [65] Ignore ::= Char* - (Char* ('&lt;![' | ']]>') Char*) </pre> <p> <strong>Note:</strong> Called after scanning past '&lt;![' 
private	TokenNameprivate	
final	TokenNamefinal	
void	TokenNamevoid	
scanConditionalSect	TokenNameIdentifier	 scan Conditional Sect
(	TokenNameLPAREN	
int	TokenNameint	
currPEDepth	TokenNameIdentifier	 curr PE Depth
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
fReportEntity	TokenNameIdentifier	 f Report Entity
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipString	TokenNameIdentifier	 skip String
(	TokenNameLPAREN	
"INCLUDE"	TokenNameStringLiteral	INCLUDE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
currPEDepth	TokenNameIdentifier	 curr PE Depth
!=	TokenNameNOT_EQUAL	
fPEDepth	TokenNameIdentifier	 f PE Depth
&&	TokenNameAND_AND	
fValidation	TokenNameIdentifier	 f Validation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
"INVALID_PE_IN_CONDITIONAL"	TokenNameStringLiteral	INVALID_PE_IN_CONDITIONAL
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fEntityManager	TokenNameIdentifier	 f Entity Manager
.	TokenNameDOT	
fCurrentEntity	TokenNameIdentifier	 f Current Entity
.	TokenNameDOT	
name	TokenNameIdentifier	 name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'['	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_MARKUP_NOT_RECOGNIZED_IN_DTD"	TokenNameStringLiteral	MSG_MARKUP_NOT_RECOGNIZED_IN_DTD
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
startConditional	TokenNameIdentifier	 start Conditional
(	TokenNameLPAREN	
XMLDTDHandler	TokenNameIdentifier	 XMLDTD Handler
.	TokenNameDOT	
CONDITIONAL_INCLUDE	TokenNameIdentifier	 CONDITIONAL  INCLUDE
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fIncludeSectDepth	TokenNameIdentifier	 f Include Sect Depth
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
// just stop there and go back to the main loop 	TokenNameCOMMENT_LINE	just stop there and go back to the main loop 
fReportEntity	TokenNameIdentifier	 f Report Entity
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipString	TokenNameIdentifier	 skip String
(	TokenNameLPAREN	
"IGNORE"	TokenNameStringLiteral	IGNORE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
currPEDepth	TokenNameIdentifier	 curr PE Depth
!=	TokenNameNOT_EQUAL	
fPEDepth	TokenNameIdentifier	 f PE Depth
&&	TokenNameAND_AND	
fValidation	TokenNameIdentifier	 f Validation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
"INVALID_PE_IN_CONDITIONAL"	TokenNameStringLiteral	INVALID_PE_IN_CONDITIONAL
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fEntityManager	TokenNameIdentifier	 f Entity Manager
.	TokenNameDOT	
fCurrentEntity	TokenNameIdentifier	 f Current Entity
.	TokenNameDOT	
name	TokenNameIdentifier	 name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
startConditional	TokenNameIdentifier	 start Conditional
(	TokenNameLPAREN	
XMLDTDHandler	TokenNameIdentifier	 XMLDTD Handler
.	TokenNameDOT	
CONDITIONAL_IGNORE	TokenNameIdentifier	 CONDITIONAL  IGNORE
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'['	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_MARKUP_NOT_RECOGNIZED_IN_DTD"	TokenNameStringLiteral	MSG_MARKUP_NOT_RECOGNIZED_IN_DTD
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fReportEntity	TokenNameIdentifier	 f Report Entity
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
int	TokenNameint	
initialDepth	TokenNameIdentifier	 initial Depth
=	TokenNameEQUAL	
++	TokenNamePLUS_PLUS	
fIncludeSectDepth	TokenNameIdentifier	 f Include Sect Depth
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fIgnoreConditionalBuffer	TokenNameIdentifier	 f Ignore Conditional Buffer
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'<'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fIgnoreConditionalBuffer	TokenNameIdentifier	 f Ignore Conditional Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'<'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// These tests are split so that we handle cases like 	TokenNameCOMMENT_LINE	These tests are split so that we handle cases like 
// '<<![' and '<!<![' which we might otherwise miss. 	TokenNameCOMMENT_LINE	'<<![' and '<!<![' which we might otherwise miss. 
// 	TokenNameCOMMENT_LINE	 
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'!'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'['	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fIgnoreConditionalBuffer	TokenNameIdentifier	 f Ignore Conditional Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"!["	TokenNameStringLiteral	![
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fIncludeSectDepth	TokenNameIdentifier	 f Include Sect Depth
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fIgnoreConditionalBuffer	TokenNameIdentifier	 f Ignore Conditional Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"!"	TokenNameStringLiteral	!
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
']'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fIgnoreConditionalBuffer	TokenNameIdentifier	 f Ignore Conditional Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
']'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// The same thing goes for ']<![' and '<]]>', etc. 	TokenNameCOMMENT_LINE	The same thing goes for ']<![' and '<]]>', etc. 
// 	TokenNameCOMMENT_LINE	 
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
']'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fIgnoreConditionalBuffer	TokenNameIdentifier	 f Ignore Conditional Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
']'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
']'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
/* empty loop body */	TokenNameCOMMENT_BLOCK	 empty loop body 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fIgnoreConditionalBuffer	TokenNameIdentifier	 f Ignore Conditional Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
']'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'>'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fIncludeSectDepth	TokenNameIdentifier	 f Include Sect Depth
--	TokenNameMINUS_MINUS	
==	TokenNameEQUAL_EQUAL	
initialDepth	TokenNameIdentifier	 initial Depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fMarkUpDepth	TokenNameIdentifier	 f Mark Up Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fLiteral	TokenNameIdentifier	 f Literal
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
fIgnoreConditionalBuffer	TokenNameIdentifier	 f Ignore Conditional Buffer
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fIgnoreConditionalBuffer	TokenNameIdentifier	 f Ignore Conditional Buffer
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
ignoredCharacters	TokenNameIdentifier	 ignored Characters
(	TokenNameLPAREN	
fLiteral	TokenNameIdentifier	 f Literal
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
endConditional	TokenNameIdentifier	 end Conditional
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fIgnoreConditionalBuffer	TokenNameIdentifier	 f Ignore Conditional Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'>'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanChar	TokenNameIdentifier	 scan Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fScannerState	TokenNameIdentifier	 f Scanner State
==	TokenNameEQUAL_EQUAL	
SCANNER_STATE_END_OF_INPUT	TokenNameIdentifier	 SCANNER  STATE  END  OF  INPUT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"IgnoreSectUnterminated"	TokenNameStringLiteral	IgnoreSectUnterminated
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fIgnoreConditionalBuffer	TokenNameIdentifier	 f Ignore Conditional Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_MARKUP_NOT_RECOGNIZED_IN_DTD"	TokenNameStringLiteral	MSG_MARKUP_NOT_RECOGNIZED_IN_DTD
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// scanConditionalSect() 	TokenNameCOMMENT_LINE	scanConditionalSect() 
/** * Dispatch an XML "event". * * @param complete True if this method is intended to scan * and dispatch as much as possible. * * @return True if there is more to scan. * * @throws IOException Thrown on i/o error. * @throws XNIException Thrown on parse error. * */	TokenNameCOMMENT_JAVADOC	 Dispatch an XML "event". * @param complete True if this method is intended to scan and dispatch as much as possible. * @return True if there is more to scan. * @throws IOException Thrown on i/o error. @throws XNIException Thrown on parse error. 
protected	TokenNameprotected	
final	TokenNamefinal	
boolean	TokenNameboolean	
scanDecls	TokenNameIdentifier	 scan Decls
(	TokenNameLPAREN	
boolean	TokenNameboolean	
complete	TokenNameIdentifier	 complete
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
again	TokenNameIdentifier	 again
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
again	TokenNameIdentifier	 again
&&	TokenNameAND_AND	
fScannerState	TokenNameIdentifier	 f Scanner State
==	TokenNameEQUAL_EQUAL	
SCANNER_STATE_MARKUP_DECL	TokenNameIdentifier	 SCANNER  STATE  MARKUP  DECL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
again	TokenNameIdentifier	 again
=	TokenNameEQUAL	
complete	TokenNameIdentifier	 complete
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'<'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fMarkUpDepth	TokenNameIdentifier	 f Mark Up Depth
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'?'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
scanPI	TokenNameIdentifier	 scan PI
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'!'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'-'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'-'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_MARKUP_NOT_RECOGNIZED_IN_DTD"	TokenNameStringLiteral	MSG_MARKUP_NOT_RECOGNIZED_IN_DTD
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
scanComment	TokenNameIdentifier	 scan Comment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipString	TokenNameIdentifier	 skip String
(	TokenNameLPAREN	
"ELEMENT"	TokenNameStringLiteral	ELEMENT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
scanElementDecl	TokenNameIdentifier	 scan Element Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipString	TokenNameIdentifier	 skip String
(	TokenNameLPAREN	
"ATTLIST"	TokenNameStringLiteral	ATTLIST
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
scanAttlistDecl	TokenNameIdentifier	 scan Attlist Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipString	TokenNameIdentifier	 skip String
(	TokenNameLPAREN	
"ENTITY"	TokenNameStringLiteral	ENTITY
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
scanEntityDecl	TokenNameIdentifier	 scan Entity Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipString	TokenNameIdentifier	 skip String
(	TokenNameLPAREN	
"NOTATION"	TokenNameStringLiteral	NOTATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
scanNotationDecl	TokenNameIdentifier	 scan Notation Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'['	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
scanConditionalSect	TokenNameIdentifier	 scan Conditional Sect
(	TokenNameLPAREN	
fPEDepth	TokenNameIdentifier	 f PE Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fMarkUpDepth	TokenNameIdentifier	 f Mark Up Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_MARKUP_NOT_RECOGNIZED_IN_DTD"	TokenNameStringLiteral	MSG_MARKUP_NOT_RECOGNIZED_IN_DTD
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fMarkUpDepth	TokenNameIdentifier	 f Mark Up Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_MARKUP_NOT_RECOGNIZED_IN_DTD"	TokenNameStringLiteral	MSG_MARKUP_NOT_RECOGNIZED_IN_DTD
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fIncludeSectDepth	TokenNameIdentifier	 f Include Sect Depth
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
']'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// end of conditional section? 	TokenNameCOMMENT_LINE	end of conditional section? 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
']'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'>'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"IncludeSectUnterminated"	TokenNameStringLiteral	IncludeSectUnterminated
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// call handler 	TokenNameCOMMENT_LINE	call handler 
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
endConditional	TokenNameIdentifier	 end Conditional
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// decreaseMarkupDepth(); 	TokenNameCOMMENT_LINE	decreaseMarkupDepth(); 
fIncludeSectDepth	TokenNameIdentifier	 f Include Sect Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
fMarkUpDepth	TokenNameIdentifier	 f Mark Up Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
scanningInternalSubset	TokenNameIdentifier	 scanning Internal Subset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
peekChar	TokenNameIdentifier	 peek Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
']'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// this is the end of the internal subset, let's stop here 	TokenNameCOMMENT_LINE	this is the end of the internal subset, let's stop here 
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipSpaces	TokenNameIdentifier	 skip Spaces
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// simply skip 	TokenNameCOMMENT_LINE	simply skip 
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MSG_MARKUP_NOT_RECOGNIZED_IN_DTD"	TokenNameStringLiteral	MSG_MARKUP_NOT_RECOGNIZED_IN_DTD
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Skip the part in error 	TokenNameCOMMENT_LINE	Skip the part in error 
int	TokenNameint	
ch	TokenNameIdentifier	 ch
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
// Ignore the current character 	TokenNameCOMMENT_LINE	Ignore the current character 
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanChar	TokenNameIdentifier	 scan Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Skip any separators 	TokenNameCOMMENT_LINE	Skip any separators 
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Keeping getting the next character, 	TokenNameCOMMENT_LINE	Keeping getting the next character, 
// until it's one of the expected ones 	TokenNameCOMMENT_LINE	until it's one of the expected ones 
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
peekChar	TokenNameIdentifier	 peek Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
!=	TokenNameNOT_EQUAL	
'<'	TokenNameCharacterLiteral	
&&	TokenNameAND_AND	
ch	TokenNameIdentifier	 ch
!=	TokenNameNOT_EQUAL	
']'	TokenNameCharacterLiteral	
&&	TokenNameAND_AND	
!	TokenNameNOT	
XMLChar	TokenNameIdentifier	 XML Char
.	TokenNameDOT	
isSpace	TokenNameIdentifier	 is Space
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
fScannerState	TokenNameIdentifier	 f Scanner State
!=	TokenNameNOT_EQUAL	
SCANNER_STATE_END_OF_INPUT	TokenNameIdentifier	 SCANNER  STATE  END  OF  INPUT
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Skip separator. This is typically just whitespace but it can also be one * or more parameter entity references. * <p> * If there are some it "expands them" by calling the corresponding entity * from the entity manager. * <p> * This is recursive and will process has many refs as possible. * * @param spaceRequired Specify whether some leading whitespace should be * found * @param lookForPERefs Specify whether parameter entity references should * be looked for * @return True if any leading whitespace was found or the end of a * parameter entity was crossed. */	TokenNameCOMMENT_JAVADOC	 Skip separator. This is typically just whitespace but it can also be one or more parameter entity references. <p> If there are some it "expands them" by calling the corresponding entity from the entity manager. <p> This is recursive and will process has many refs as possible. * @param spaceRequired Specify whether some leading whitespace should be found @param lookForPERefs Specify whether parameter entity references should be looked for @return True if any leading whitespace was found or the end of a parameter entity was crossed. 
private	TokenNameprivate	
boolean	TokenNameboolean	
skipSeparator	TokenNameIdentifier	 skip Separator
(	TokenNameLPAREN	
boolean	TokenNameboolean	
spaceRequired	TokenNameIdentifier	 space Required
,	TokenNameCOMMA	
boolean	TokenNameboolean	
lookForPERefs	TokenNameIdentifier	 look For PE Refs
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
int	TokenNameint	
depth	TokenNameIdentifier	 depth
=	TokenNameEQUAL	
fPEDepth	TokenNameIdentifier	 f PE Depth
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
sawSpace	TokenNameIdentifier	 saw Space
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipSpaces	TokenNameIdentifier	 skip Spaces
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
lookForPERefs	TokenNameIdentifier	 look For PE Refs
||	TokenNameOR_OR	
!	TokenNameNOT	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'%'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
!	TokenNameNOT	
spaceRequired	TokenNameIdentifier	 space Required
||	TokenNameOR_OR	
sawSpace	TokenNameIdentifier	 saw Space
||	TokenNameOR_OR	
(	TokenNameLPAREN	
depth	TokenNameIdentifier	 depth
!=	TokenNameNOT_EQUAL	
fPEDepth	TokenNameIdentifier	 f PE Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanName	TokenNameIdentifier	 scan Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"NameRequiredInPEReference"	TokenNameStringLiteral	NameRequiredInPEReference
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
';'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"SemicolonRequiredInPEReference"	TokenNameStringLiteral	SemicolonRequiredInPEReference
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
startPE	TokenNameIdentifier	 start PE
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipSpaces	TokenNameIdentifier	 skip Spaces
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
skipChar	TokenNameIdentifier	 skip Char
(	TokenNameLPAREN	
'%'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* * Element Children Content Stack */	TokenNameCOMMENT_BLOCK	 Element Children Content Stack 
private	TokenNameprivate	
final	TokenNamefinal	
void	TokenNamevoid	
pushContentStack	TokenNameIdentifier	 push Content Stack
(	TokenNameLPAREN	
int	TokenNameint	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fContentStack	TokenNameIdentifier	 f Content Stack
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
fContentDepth	TokenNameIdentifier	 f Content Depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newStack	TokenNameIdentifier	 new Stack
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
fContentDepth	TokenNameIdentifier	 f Content Depth
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fContentStack	TokenNameIdentifier	 f Content Stack
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newStack	TokenNameIdentifier	 new Stack
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fContentDepth	TokenNameIdentifier	 f Content Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fContentStack	TokenNameIdentifier	 f Content Stack
=	TokenNameEQUAL	
newStack	TokenNameIdentifier	 new Stack
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fContentStack	TokenNameIdentifier	 f Content Stack
[	TokenNameLBRACKET	
fContentDepth	TokenNameIdentifier	 f Content Depth
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
c	TokenNameIdentifier	 c
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
popContentStack	TokenNameIdentifier	 pop Content Stack
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fContentStack	TokenNameIdentifier	 f Content Stack
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
fContentDepth	TokenNameIdentifier	 f Content Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* * Parameter Entity Stack */	TokenNameCOMMENT_BLOCK	 Parameter Entity Stack 
private	TokenNameprivate	
final	TokenNamefinal	
void	TokenNamevoid	
pushPEStack	TokenNameIdentifier	 push PE Stack
(	TokenNameLPAREN	
int	TokenNameint	
depth	TokenNameIdentifier	 depth
,	TokenNameCOMMA	
boolean	TokenNameboolean	
report	TokenNameIdentifier	 report
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fPEStack	TokenNameIdentifier	 f PE Stack
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
fPEDepth	TokenNameIdentifier	 f PE Depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newIntStack	TokenNameIdentifier	 new Int Stack
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
fPEDepth	TokenNameIdentifier	 f PE Depth
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fPEStack	TokenNameIdentifier	 f PE Stack
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newIntStack	TokenNameIdentifier	 new Int Stack
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fPEDepth	TokenNameIdentifier	 f PE Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fPEStack	TokenNameIdentifier	 f PE Stack
=	TokenNameEQUAL	
newIntStack	TokenNameIdentifier	 new Int Stack
;	TokenNameSEMICOLON	
// report end/start calls 	TokenNameCOMMENT_LINE	report end/start calls 
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newBooleanStack	TokenNameIdentifier	 new Boolean Stack
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
fPEDepth	TokenNameIdentifier	 f PE Depth
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fPEReport	TokenNameIdentifier	 f PE Report
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newBooleanStack	TokenNameIdentifier	 new Boolean Stack
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fPEDepth	TokenNameIdentifier	 f PE Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fPEReport	TokenNameIdentifier	 f PE Report
=	TokenNameEQUAL	
newBooleanStack	TokenNameIdentifier	 new Boolean Stack
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fPEReport	TokenNameIdentifier	 f PE Report
[	TokenNameLBRACKET	
fPEDepth	TokenNameIdentifier	 f PE Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
report	TokenNameIdentifier	 report
;	TokenNameSEMICOLON	
fPEStack	TokenNameIdentifier	 f PE Stack
[	TokenNameLBRACKET	
fPEDepth	TokenNameIdentifier	 f PE Depth
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
depth	TokenNameIdentifier	 depth
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** pop the stack */	TokenNameCOMMENT_JAVADOC	 pop the stack 
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
popPEStack	TokenNameIdentifier	 pop PE Stack
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fPEStack	TokenNameIdentifier	 f PE Stack
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
fPEDepth	TokenNameIdentifier	 f PE Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** look at the top of the stack */	TokenNameCOMMENT_JAVADOC	 look at the top of the stack 
private	TokenNameprivate	
final	TokenNamefinal	
boolean	TokenNameboolean	
peekReportEntity	TokenNameIdentifier	 peek Report Entity
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fPEReport	TokenNameIdentifier	 f PE Report
[	TokenNameLBRACKET	
fPEDepth	TokenNameIdentifier	 f PE Depth
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* * Utility method */	TokenNameCOMMENT_BLOCK	 Utility method 
private	TokenNameprivate	
final	TokenNamefinal	
void	TokenNamevoid	
ensureEnumerationSize	TokenNameIdentifier	 ensure Enumeration Size
(	TokenNameLPAREN	
int	TokenNameint	
size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fEnumeration	TokenNameIdentifier	 f Enumeration
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newEnum	TokenNameIdentifier	 new Enum
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
size	TokenNameIdentifier	 size
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fEnumeration	TokenNameIdentifier	 f Enumeration
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newEnum	TokenNameIdentifier	 new Enum
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fEnumeration	TokenNameIdentifier	 f Enumeration
=	TokenNameEQUAL	
newEnum	TokenNameIdentifier	 new Enum
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// private methods 	TokenNameCOMMENT_LINE	private methods 
private	TokenNameprivate	
void	TokenNamevoid	
init	TokenNameIdentifier	 init
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// reset state related data 	TokenNameCOMMENT_LINE	reset state related data 
fStartDTDCalled	TokenNameIdentifier	 f Start DTD Called
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fExtEntityDepth	TokenNameIdentifier	 f Ext Entity Depth
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fIncludeSectDepth	TokenNameIdentifier	 f Include Sect Depth
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fMarkUpDepth	TokenNameIdentifier	 f Mark Up Depth
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fPEDepth	TokenNameIdentifier	 f PE Depth
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fStandalone	TokenNameIdentifier	 f Standalone
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fSeenExternalDTD	TokenNameIdentifier	 f Seen External DTD
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fSeenPEReferences	TokenNameIdentifier	 f Seen PE References
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// set starting state 	TokenNameCOMMENT_LINE	set starting state 
setScannerState	TokenNameIdentifier	 set Scanner State
(	TokenNameLPAREN	
SCANNER_STATE_TEXT_DECL	TokenNameIdentifier	 SCANNER  STATE  TEXT  DECL
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
skipInvalidEnumerationValue	TokenNameIdentifier	 skip Invalid Enumeration Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
int	TokenNameint	
c	TokenNameIdentifier	 c
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
fEntityScanner	TokenNameIdentifier	 f Entity Scanner
.	TokenNameDOT	
scanChar	TokenNameIdentifier	 scan Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
!=	TokenNameNOT_EQUAL	
'|'	TokenNameCharacterLiteral	
&&	TokenNameAND_AND	
c	TokenNameIdentifier	 c
!=	TokenNameNOT_EQUAL	
')'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ensureEnumerationSize	TokenNameIdentifier	 ensure Enumeration Size
(	TokenNameLPAREN	
fEnumerationCount	TokenNameIdentifier	 f Enumeration Count
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fEnumeration	TokenNameIdentifier	 f Enumeration
[	TokenNameLBRACKET	
fEnumerationCount	TokenNameIdentifier	 f Enumeration Count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
EMPTY_STRING	TokenNameIdentifier	 EMPTY  STRING
;	TokenNameSEMICOLON	
return	TokenNamereturn	
c	TokenNameIdentifier	 c
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// class XMLDTDScannerImpl 	TokenNameCOMMENT_LINE	class XMLDTDScannerImpl 
