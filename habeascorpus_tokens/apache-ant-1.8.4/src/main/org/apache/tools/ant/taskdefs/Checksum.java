/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
taskdefs	TokenNameIdentifier	 taskdefs
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
security	TokenNameIdentifier	 security
.	TokenNameDOT	
DigestInputStream	TokenNameIdentifier	 Digest Input Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
security	TokenNameIdentifier	 security
.	TokenNameDOT	
MessageDigest	TokenNameIdentifier	 Message Digest
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
security	TokenNameIdentifier	 security
.	TokenNameDOT	
NoSuchAlgorithmException	TokenNameIdentifier	 No Such Algorithm Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
security	TokenNameIdentifier	 security
.	TokenNameDOT	
NoSuchProviderException	TokenNameIdentifier	 No Such Provider Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
File	TokenNameIdentifier	 File
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
FileOutputStream	TokenNameIdentifier	 File Output Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
FileInputStream	TokenNameIdentifier	 File Input Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
FileReader	TokenNameIdentifier	 File Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
BufferedReader	TokenNameIdentifier	 Buffered Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Comparator	TokenNameIdentifier	 Comparator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
HashMap	TokenNameIdentifier	 Hash Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Map	TokenNameIdentifier	 Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Iterator	TokenNameIdentifier	 Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Hashtable	TokenNameIdentifier	 Hashtable
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Enumeration	TokenNameIdentifier	 Enumeration
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Set	TokenNameIdentifier	 Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Arrays	TokenNameIdentifier	 Arrays
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
MessageFormat	TokenNameIdentifier	 Message Format
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
ParseException	TokenNameIdentifier	 Parse Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
BuildException	TokenNameIdentifier	 Build Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
Project	TokenNameIdentifier	 Project
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
taskdefs	TokenNameIdentifier	 taskdefs
.	TokenNameDOT	
condition	TokenNameIdentifier	 condition
.	TokenNameDOT	
Condition	TokenNameIdentifier	 Condition
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
EnumeratedAttribute	TokenNameIdentifier	 Enumerated Attribute
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
FileSet	TokenNameIdentifier	 File Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
Resource	TokenNameIdentifier	 Resource
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
ResourceCollection	TokenNameIdentifier	 Resource Collection
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
FileProvider	TokenNameIdentifier	 File Provider
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
Union	TokenNameIdentifier	 Union
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
Restrict	TokenNameIdentifier	 Restrict
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
selectors	TokenNameIdentifier	 selectors
.	TokenNameDOT	
Type	TokenNameIdentifier	 Type
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
FileUtils	TokenNameIdentifier	 File Utils
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
StringUtils	TokenNameIdentifier	 String Utils
;	TokenNameSEMICOLON	
/** * Used to create or verify file checksums. * * @since Ant 1.5 * * @ant.task category="control" */	TokenNameCOMMENT_JAVADOC	 Used to create or verify file checksums. * @since Ant 1.5 * @ant.task category="control" 
public	TokenNamepublic	
class	TokenNameclass	
Checksum	TokenNameIdentifier	 Checksum
extends	TokenNameextends	
MatchingTask	TokenNameIdentifier	 Matching Task
implements	TokenNameimplements	
Condition	TokenNameIdentifier	 Condition
{	TokenNameLBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
FileUtils	TokenNameIdentifier	 File Utils
FILE_UTILS	TokenNameIdentifier	 FILE  UTILS
=	TokenNameEQUAL	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
getFileUtils	TokenNameIdentifier	 get File Utils
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
NIBBLE	TokenNameIdentifier	 NIBBLE
=	TokenNameEQUAL	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
WORD	TokenNameIdentifier	 WORD
=	TokenNameEQUAL	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
BUFFER_SIZE	TokenNameIdentifier	 BUFFER  SIZE
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
1024	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
BYTE_MASK	TokenNameIdentifier	 BYTE  MASK
=	TokenNameEQUAL	
0xFF	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
FileUnion	TokenNameIdentifier	 File Union
extends	TokenNameextends	
Restrict	TokenNameIdentifier	 Restrict
{	TokenNameLBRACE	
private	TokenNameprivate	
Union	TokenNameIdentifier	 Union
u	TokenNameIdentifier	 u
;	TokenNameSEMICOLON	
FileUnion	TokenNameIdentifier	 File Union
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
u	TokenNameIdentifier	 u
=	TokenNameEQUAL	
new	TokenNamenew	
Union	TokenNameIdentifier	 Union
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
super	TokenNamesuper	
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
u	TokenNameIdentifier	 u
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
super	TokenNamesuper	
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
FILE	TokenNameIdentifier	 FILE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
ResourceCollection	TokenNameIdentifier	 Resource Collection
rc	TokenNameIdentifier	 rc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
u	TokenNameIdentifier	 u
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
rc	TokenNameIdentifier	 rc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * File for which checksum is to be calculated. */	TokenNameCOMMENT_JAVADOC	 File for which checksum is to be calculated. 
private	TokenNameprivate	
File	TokenNameIdentifier	 File
file	TokenNameIdentifier	 file
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** * Root directory in which the checksum files will be written. * If not specified, the checksum files will be written * in the same directory as each file. */	TokenNameCOMMENT_JAVADOC	 Root directory in which the checksum files will be written. If not specified, the checksum files will be written in the same directory as each file. 
private	TokenNameprivate	
File	TokenNameIdentifier	 File
todir	TokenNameIdentifier	 todir
;	TokenNameSEMICOLON	
/** * MessageDigest algorithm to be used. */	TokenNameCOMMENT_JAVADOC	 MessageDigest algorithm to be used. 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
algorithm	TokenNameIdentifier	 algorithm
=	TokenNameEQUAL	
"MD5"	TokenNameStringLiteral	MD5
;	TokenNameSEMICOLON	
/** * MessageDigest Algorithm provider */	TokenNameCOMMENT_JAVADOC	 MessageDigest Algorithm provider 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
provider	TokenNameIdentifier	 provider
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** * File Extension that is be to used to create or identify * destination file */	TokenNameCOMMENT_JAVADOC	 File Extension that is be to used to create or identify destination file 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
fileext	TokenNameIdentifier	 fileext
;	TokenNameSEMICOLON	
/** * Holds generated checksum and gets set as a Project Property. */	TokenNameCOMMENT_JAVADOC	 Holds generated checksum and gets set as a Project Property. 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
property	TokenNameIdentifier	 property
;	TokenNameSEMICOLON	
/** * Holds checksums for all files (both calculated and cached on disk). * Key: java.util.File (source file) * Value: java.lang.String (digest) */	TokenNameCOMMENT_JAVADOC	 Holds checksums for all files (both calculated and cached on disk). Key: java.util.File (source file) Value: java.lang.String (digest) 
private	TokenNameprivate	
Map	TokenNameIdentifier	 Map
allDigests	TokenNameIdentifier	 all Digests
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Holds relative file names for all files (always with a forward slash). * This is used to calculate the total hash. * Key: java.util.File (source file) * Value: java.lang.String (relative file name) */	TokenNameCOMMENT_JAVADOC	 Holds relative file names for all files (always with a forward slash). This is used to calculate the total hash. Key: java.util.File (source file) Value: java.lang.String (relative file name) 
private	TokenNameprivate	
Map	TokenNameIdentifier	 Map
relativeFilePaths	TokenNameIdentifier	 relative File Paths
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Property where totalChecksum gets set. */	TokenNameCOMMENT_JAVADOC	 Property where totalChecksum gets set. 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
totalproperty	TokenNameIdentifier	 totalproperty
;	TokenNameSEMICOLON	
/** * Whether or not to create a new file. * Defaults to <code>false</code>. */	TokenNameCOMMENT_JAVADOC	 Whether or not to create a new file. Defaults to <code>false</code>. 
private	TokenNameprivate	
boolean	TokenNameboolean	
forceOverwrite	TokenNameIdentifier	 force Overwrite
;	TokenNameSEMICOLON	
/** * Contains the result of a checksum verification. ("true" or "false") */	TokenNameCOMMENT_JAVADOC	 Contains the result of a checksum verification. ("true" or "false") 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
verifyProperty	TokenNameIdentifier	 verify Property
;	TokenNameSEMICOLON	
/** * Resource Collection. */	TokenNameCOMMENT_JAVADOC	 Resource Collection. 
private	TokenNameprivate	
FileUnion	TokenNameIdentifier	 File Union
resources	TokenNameIdentifier	 resources
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** * Stores SourceFile, DestFile pairs and SourceFile, Property String pairs. */	TokenNameCOMMENT_JAVADOC	 Stores SourceFile, DestFile pairs and SourceFile, Property String pairs. 
private	TokenNameprivate	
Hashtable	TokenNameIdentifier	 Hashtable
includeFileMap	TokenNameIdentifier	 include File Map
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Message Digest instance */	TokenNameCOMMENT_JAVADOC	 Message Digest instance 
private	TokenNameprivate	
MessageDigest	TokenNameIdentifier	 Message Digest
messageDigest	TokenNameIdentifier	 message Digest
;	TokenNameSEMICOLON	
/** * is this task being used as a nested condition element? */	TokenNameCOMMENT_JAVADOC	 is this task being used as a nested condition element? 
private	TokenNameprivate	
boolean	TokenNameboolean	
isCondition	TokenNameIdentifier	 is Condition
;	TokenNameSEMICOLON	
/** * Size of the read buffer to use. */	TokenNameCOMMENT_JAVADOC	 Size of the read buffer to use. 
private	TokenNameprivate	
int	TokenNameint	
readBufferSize	TokenNameIdentifier	 read Buffer Size
=	TokenNameEQUAL	
BUFFER_SIZE	TokenNameIdentifier	 BUFFER  SIZE
;	TokenNameSEMICOLON	
/** * Formater for the checksum file. */	TokenNameCOMMENT_JAVADOC	 Formater for the checksum file. 
private	TokenNameprivate	
MessageFormat	TokenNameIdentifier	 Message Format
format	TokenNameIdentifier	 format
=	TokenNameEQUAL	
FormatElement	TokenNameIdentifier	 Format Element
.	TokenNameDOT	
getDefault	TokenNameIdentifier	 get Default
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getFormat	TokenNameIdentifier	 get Format
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Sets the file for which the checksum is to be calculated. * @param file a <code>File</code> value */	TokenNameCOMMENT_JAVADOC	 Sets the file for which the checksum is to be calculated. @param file a <code>File</code> value 
public	TokenNamepublic	
void	TokenNamevoid	
setFile	TokenNameIdentifier	 set File
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
file	TokenNameIdentifier	 file
=	TokenNameEQUAL	
file	TokenNameIdentifier	 file
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets the root directory where checksum files will be * written/read * @param todir the directory to write to * @since Ant 1.6 */	TokenNameCOMMENT_JAVADOC	 Sets the root directory where checksum files will be written/read @param todir the directory to write to @since Ant 1.6 
public	TokenNamepublic	
void	TokenNamevoid	
setTodir	TokenNameIdentifier	 set Todir
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
todir	TokenNameIdentifier	 todir
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
todir	TokenNameIdentifier	 todir
=	TokenNameEQUAL	
todir	TokenNameIdentifier	 todir
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Specifies the algorithm to be used to compute the checksum. * Defaults to "MD5". Other popular algorithms like "SHA" may be used as well. * @param algorithm a <code>String</code> value */	TokenNameCOMMENT_JAVADOC	 Specifies the algorithm to be used to compute the checksum. Defaults to "MD5". Other popular algorithms like "SHA" may be used as well. @param algorithm a <code>String</code> value 
public	TokenNamepublic	
void	TokenNamevoid	
setAlgorithm	TokenNameIdentifier	 set Algorithm
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
algorithm	TokenNameIdentifier	 algorithm
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
algorithm	TokenNameIdentifier	 algorithm
=	TokenNameEQUAL	
algorithm	TokenNameIdentifier	 algorithm
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets the MessageDigest algorithm provider to be used * to calculate the checksum. * @param provider a <code>String</code> value */	TokenNameCOMMENT_JAVADOC	 Sets the MessageDigest algorithm provider to be used to calculate the checksum. @param provider a <code>String</code> value 
public	TokenNamepublic	
void	TokenNamevoid	
setProvider	TokenNameIdentifier	 set Provider
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
provider	TokenNameIdentifier	 provider
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
provider	TokenNameIdentifier	 provider
=	TokenNameEQUAL	
provider	TokenNameIdentifier	 provider
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets the file extension that is be to used to * create or identify destination file. * @param fileext a <code>String</code> value */	TokenNameCOMMENT_JAVADOC	 Sets the file extension that is be to used to create or identify destination file. @param fileext a <code>String</code> value 
public	TokenNamepublic	
void	TokenNamevoid	
setFileext	TokenNameIdentifier	 set Fileext
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
fileext	TokenNameIdentifier	 fileext
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fileext	TokenNameIdentifier	 fileext
=	TokenNameEQUAL	
fileext	TokenNameIdentifier	 fileext
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets the property to hold the generated checksum. * @param property a <code>String</code> value */	TokenNameCOMMENT_JAVADOC	 Sets the property to hold the generated checksum. @param property a <code>String</code> value 
public	TokenNamepublic	
void	TokenNamevoid	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
property	TokenNameIdentifier	 property
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
property	TokenNameIdentifier	 property
=	TokenNameEQUAL	
property	TokenNameIdentifier	 property
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets the property to hold the generated total checksum * for all files. * @param totalproperty a <code>String</code> value * * @since Ant 1.6 */	TokenNameCOMMENT_JAVADOC	 Sets the property to hold the generated total checksum for all files. @param totalproperty a <code>String</code> value * @since Ant 1.6 
public	TokenNamepublic	
void	TokenNamevoid	
setTotalproperty	TokenNameIdentifier	 set Totalproperty
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
totalproperty	TokenNameIdentifier	 totalproperty
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
totalproperty	TokenNameIdentifier	 totalproperty
=	TokenNameEQUAL	
totalproperty	TokenNameIdentifier	 totalproperty
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets the verify property. This project property holds * the result of a checksum verification - "true" or "false" * @param verifyProperty a <code>String</code> value */	TokenNameCOMMENT_JAVADOC	 Sets the verify property. This project property holds the result of a checksum verification - "true" or "false" @param verifyProperty a <code>String</code> value 
public	TokenNamepublic	
void	TokenNamevoid	
setVerifyproperty	TokenNameIdentifier	 set Verifyproperty
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
verifyProperty	TokenNameIdentifier	 verify Property
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
verifyProperty	TokenNameIdentifier	 verify Property
=	TokenNameEQUAL	
verifyProperty	TokenNameIdentifier	 verify Property
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Whether or not to overwrite existing file irrespective of * whether it is newer than * the source file. Defaults to false. * @param forceOverwrite a <code>boolean</code> value */	TokenNameCOMMENT_JAVADOC	 Whether or not to overwrite existing file irrespective of whether it is newer than the source file. Defaults to false. @param forceOverwrite a <code>boolean</code> value 
public	TokenNamepublic	
void	TokenNamevoid	
setForceOverwrite	TokenNameIdentifier	 set Force Overwrite
(	TokenNameLPAREN	
boolean	TokenNameboolean	
forceOverwrite	TokenNameIdentifier	 force Overwrite
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
forceOverwrite	TokenNameIdentifier	 force Overwrite
=	TokenNameEQUAL	
forceOverwrite	TokenNameIdentifier	 force Overwrite
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The size of the read buffer to use. * @param size an <code>int</code> value */	TokenNameCOMMENT_JAVADOC	 The size of the read buffer to use. @param size an <code>int</code> value 
public	TokenNamepublic	
void	TokenNamevoid	
setReadBufferSize	TokenNameIdentifier	 set Read Buffer Size
(	TokenNameLPAREN	
int	TokenNameint	
size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
readBufferSize	TokenNameIdentifier	 read Buffer Size
=	TokenNameEQUAL	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Select the in/output pattern via a well know format name. * @param e an <code>enumerated</code> value * * @since 1.7.0 */	TokenNameCOMMENT_JAVADOC	 Select the in/output pattern via a well know format name. @param e an <code>enumerated</code> value * @since 1.7.0 
public	TokenNamepublic	
void	TokenNamevoid	
setFormat	TokenNameIdentifier	 set Format
(	TokenNameLPAREN	
FormatElement	TokenNameIdentifier	 Format Element
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
format	TokenNameIdentifier	 format
=	TokenNameEQUAL	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getFormat	TokenNameIdentifier	 get Format
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Specify the pattern to use as a MessageFormat pattern. * * <p>{0} gets replaced by the checksum, {1} by the filename.</p> * @param p a <code>String</code> value * * @since 1.7.0 */	TokenNameCOMMENT_JAVADOC	 Specify the pattern to use as a MessageFormat pattern. * <p>{0} gets replaced by the checksum, {1} by the filename.</p> @param p a <code>String</code> value * @since 1.7.0 
public	TokenNamepublic	
void	TokenNamevoid	
setPattern	TokenNameIdentifier	 set Pattern
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
p	TokenNameIdentifier	 p
)	TokenNameRPAREN	
{	TokenNameLBRACE	
format	TokenNameIdentifier	 format
=	TokenNameEQUAL	
new	TokenNamenew	
MessageFormat	TokenNameIdentifier	 Message Format
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Files to generate checksums for. * @param set a fileset of files to generate checksums for. */	TokenNameCOMMENT_JAVADOC	 Files to generate checksums for. @param set a fileset of files to generate checksums for. 
public	TokenNamepublic	
void	TokenNamevoid	
addFileset	TokenNameIdentifier	 add Fileset
(	TokenNameLPAREN	
FileSet	TokenNameIdentifier	 File Set
set	TokenNameIdentifier	 set
)	TokenNameRPAREN	
{	TokenNameLBRACE	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
set	TokenNameIdentifier	 set
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Add a resource collection. * @param rc the ResourceCollection to add. */	TokenNameCOMMENT_JAVADOC	 Add a resource collection. @param rc the ResourceCollection to add. 
public	TokenNamepublic	
void	TokenNamevoid	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
ResourceCollection	TokenNameIdentifier	 Resource Collection
rc	TokenNameIdentifier	 rc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
rc	TokenNameIdentifier	 rc
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
resources	TokenNameIdentifier	 resources
=	TokenNameEQUAL	
(	TokenNameLPAREN	
resources	TokenNameIdentifier	 resources
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
new	TokenNamenew	
FileUnion	TokenNameIdentifier	 File Union
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
resources	TokenNameIdentifier	 resources
;	TokenNameSEMICOLON	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
rc	TokenNameIdentifier	 rc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Calculate the checksum(s). * @throws BuildException on error */	TokenNameCOMMENT_JAVADOC	 Calculate the checksum(s). @throws BuildException on error 
public	TokenNamepublic	
void	TokenNamevoid	
execute	TokenNameIdentifier	 execute
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
BuildException	TokenNameIdentifier	 Build Exception
{	TokenNameLBRACE	
isCondition	TokenNameIdentifier	 is Condition
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
validateAndExecute	TokenNameIdentifier	 validate And Execute
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
verifyProperty	TokenNameIdentifier	 verify Property
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
setNewProperty	TokenNameIdentifier	 set New Property
(	TokenNameLPAREN	
verifyProperty	TokenNameIdentifier	 verify Property
,	TokenNameCOMMA	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
?	TokenNameQUESTION	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
TRUE	TokenNameIdentifier	 TRUE
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
FALSE	TokenNameIdentifier	 FALSE
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Calculate the checksum(s) * * @return Returns true if the checksum verification test passed, * false otherwise. * @throws BuildException on error */	TokenNameCOMMENT_JAVADOC	 Calculate the checksum(s) * @return Returns true if the checksum verification test passed, false otherwise. @throws BuildException on error 
public	TokenNamepublic	
boolean	TokenNameboolean	
eval	TokenNameIdentifier	 eval
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
BuildException	TokenNameIdentifier	 Build Exception
{	TokenNameLBRACE	
isCondition	TokenNameIdentifier	 is Condition
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
validateAndExecute	TokenNameIdentifier	 validate And Execute
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Validate attributes and get down to business. */	TokenNameCOMMENT_JAVADOC	 Validate attributes and get down to business. 
private	TokenNameprivate	
boolean	TokenNameboolean	
validateAndExecute	TokenNameIdentifier	 validate And Execute
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
BuildException	TokenNameIdentifier	 Build Exception
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
savedFileExt	TokenNameIdentifier	 saved File Ext
=	TokenNameEQUAL	
fileext	TokenNameIdentifier	 fileext
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
resources	TokenNameIdentifier	 resources
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Specify at least one source - a file or a resource collection."	TokenNameStringLiteral	Specify at least one source - a file or a resource collection.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
resources	TokenNameIdentifier	 resources
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
isFilesystemOnly	TokenNameIdentifier	 is Filesystem Only
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Can only calculate checksums for file-based resources."	TokenNameStringLiteral	Can only calculate checksums for file-based resources.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
isDirectory	TokenNameIdentifier	 is Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Checksum cannot be generated for directories"	TokenNameStringLiteral	Checksum cannot be generated for directories
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
totalproperty	TokenNameIdentifier	 totalproperty
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"File and Totalproperty cannot co-exist."	TokenNameStringLiteral	File and Totalproperty cannot co-exist.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
property	TokenNameIdentifier	 property
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
fileext	TokenNameIdentifier	 fileext
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Property and FileExt cannot co-exist."	TokenNameStringLiteral	Property and FileExt cannot co-exist.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
property	TokenNameIdentifier	 property
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
forceOverwrite	TokenNameIdentifier	 force Overwrite
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"ForceOverwrite cannot be used when Property is specified"	TokenNameStringLiteral	ForceOverwrite cannot be used when Property is specified
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
ct	TokenNameIdentifier	 ct
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
resources	TokenNameIdentifier	 resources
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ct	TokenNameIdentifier	 ct
+=	TokenNamePLUS_EQUAL	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ct	TokenNameIdentifier	 ct
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ct	TokenNameIdentifier	 ct
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Multiple files cannot be used when Property is specified"	TokenNameStringLiteral	Multiple files cannot be used when Property is specified
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
verifyProperty	TokenNameIdentifier	 verify Property
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
isCondition	TokenNameIdentifier	 is Condition
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
verifyProperty	TokenNameIdentifier	 verify Property
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
forceOverwrite	TokenNameIdentifier	 force Overwrite
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"VerifyProperty and ForceOverwrite cannot co-exist."	TokenNameStringLiteral	VerifyProperty and ForceOverwrite cannot co-exist.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isCondition	TokenNameIdentifier	 is Condition
&&	TokenNameAND_AND	
forceOverwrite	TokenNameIdentifier	 force Overwrite
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"ForceOverwrite cannot be used when conditions are being used."	TokenNameStringLiteral	ForceOverwrite cannot be used when conditions are being used.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
messageDigest	TokenNameIdentifier	 message Digest
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
provider	TokenNameIdentifier	 provider
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
messageDigest	TokenNameIdentifier	 message Digest
=	TokenNameEQUAL	
MessageDigest	TokenNameIdentifier	 Message Digest
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
algorithm	TokenNameIdentifier	 algorithm
,	TokenNameCOMMA	
provider	TokenNameIdentifier	 provider
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
NoSuchAlgorithmException	TokenNameIdentifier	 No Such Algorithm Exception
noalgo	TokenNameIdentifier	 noalgo
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
noalgo	TokenNameIdentifier	 noalgo
,	TokenNameCOMMA	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
NoSuchProviderException	TokenNameIdentifier	 No Such Provider Exception
noprovider	TokenNameIdentifier	 noprovider
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
noprovider	TokenNameIdentifier	 noprovider
,	TokenNameCOMMA	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
messageDigest	TokenNameIdentifier	 message Digest
=	TokenNameEQUAL	
MessageDigest	TokenNameIdentifier	 Message Digest
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
algorithm	TokenNameIdentifier	 algorithm
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
NoSuchAlgorithmException	TokenNameIdentifier	 No Such Algorithm Exception
noalgo	TokenNameIdentifier	 noalgo
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
noalgo	TokenNameIdentifier	 noalgo
,	TokenNameCOMMA	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
messageDigest	TokenNameIdentifier	 message Digest
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Unable to create Message Digest"	TokenNameStringLiteral	Unable to create Message Digest
,	TokenNameCOMMA	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fileext	TokenNameIdentifier	 fileext
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fileext	TokenNameIdentifier	 fileext
=	TokenNameEQUAL	
"."	TokenNameStringLiteral	.
+	TokenNamePLUS	
algorithm	TokenNameIdentifier	 algorithm
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fileext	TokenNameIdentifier	 fileext
.	TokenNameDOT	
trim	TokenNameIdentifier	 trim
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"File extension when specified must not be an empty string"	TokenNameStringLiteral	File extension when specified must not be an empty string
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
resources	TokenNameIdentifier	 resources
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Iterator	TokenNameIdentifier	 Iterator
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Resource	TokenNameIdentifier	 Resource
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Resource	TokenNameIdentifier	 Resource
)	TokenNameRPAREN	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
src	TokenNameIdentifier	 src
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
FileProvider	TokenNameIdentifier	 File Provider
)	TokenNameRPAREN	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
as	TokenNameIdentifier	 as
(	TokenNameLPAREN	
FileProvider	TokenNameIdentifier	 File Provider
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getFile	TokenNameIdentifier	 get File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
totalproperty	TokenNameIdentifier	 totalproperty
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
todir	TokenNameIdentifier	 todir
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Use '/' to calculate digest based on file name. 	TokenNameCOMMENT_LINE	Use '/' to calculate digest based on file name. 
// This is required in order to get the same result 	TokenNameCOMMENT_LINE	This is required in order to get the same result 
// on different platforms. 	TokenNameCOMMENT_LINE	on different platforms. 
relativeFilePaths	TokenNameIdentifier	 relative File Paths
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separatorChar	TokenNameIdentifier	 separator Char
,	TokenNameCOMMA	
'/'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
addToIncludeFileMap	TokenNameIdentifier	 add To Include File Map
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
totalproperty	TokenNameIdentifier	 totalproperty
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
todir	TokenNameIdentifier	 todir
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
relativeFilePaths	TokenNameIdentifier	 relative File Paths
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separatorChar	TokenNameIdentifier	 separator Char
,	TokenNameCOMMA	
'/'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
addToIncludeFileMap	TokenNameIdentifier	 add To Include File Map
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
generateChecksums	TokenNameIdentifier	 generate Checksums
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
fileext	TokenNameIdentifier	 fileext
=	TokenNameEQUAL	
savedFileExt	TokenNameIdentifier	 saved File Ext
;	TokenNameSEMICOLON	
includeFileMap	TokenNameIdentifier	 include File Map
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Add key-value pair to the hashtable upon which * to later operate upon. */	TokenNameCOMMENT_JAVADOC	 Add key-value pair to the hashtable upon which to later operate upon. 
private	TokenNameprivate	
void	TokenNamevoid	
addToIncludeFileMap	TokenNameIdentifier	 add To Include File Map
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
throws	TokenNamethrows	
BuildException	TokenNameIdentifier	 Build Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
property	TokenNameIdentifier	 property
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
checksumFile	TokenNameIdentifier	 checksum File
=	TokenNameEQUAL	
getChecksumFile	TokenNameIdentifier	 get Checksum File
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
forceOverwrite	TokenNameIdentifier	 force Overwrite
||	TokenNameOR_OR	
isCondition	TokenNameIdentifier	 is Condition
||	TokenNameOR_OR	
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
lastModified	TokenNameIdentifier	 last Modified
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
checksumFile	TokenNameIdentifier	 checksum File
.	TokenNameDOT	
lastModified	TokenNameIdentifier	 last Modified
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
includeFileMap	TokenNameIdentifier	 include File Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
checksumFile	TokenNameIdentifier	 checksum File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
+	TokenNamePLUS	
" omitted as "	TokenNameStringLiteral	 omitted as 
+	TokenNamePLUS	
checksumFile	TokenNameIdentifier	 checksum File
+	TokenNamePLUS	
" is up to date."	TokenNameStringLiteral	 is up to date.
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_VERBOSE	TokenNameIdentifier	 MSG  VERBOSE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
totalproperty	TokenNameIdentifier	 totalproperty
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Read the checksum from disk. 	TokenNameCOMMENT_LINE	Read the checksum from disk. 
String	TokenNameIdentifier	 String
checksum	TokenNameIdentifier	 checksum
=	TokenNameEQUAL	
readChecksum	TokenNameIdentifier	 read Checksum
(	TokenNameLPAREN	
checksumFile	TokenNameIdentifier	 checksum File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
digest	TokenNameIdentifier	 digest
=	TokenNameEQUAL	
decodeHex	TokenNameIdentifier	 decode Hex
(	TokenNameLPAREN	
checksum	TokenNameIdentifier	 checksum
.	TokenNameDOT	
toCharArray	TokenNameIdentifier	 to Char Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
allDigests	TokenNameIdentifier	 all Digests
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
digest	TokenNameIdentifier	 digest
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
includeFileMap	TokenNameIdentifier	 include File Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
property	TokenNameIdentifier	 property
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
message	TokenNameIdentifier	 message
=	TokenNameEQUAL	
"Could not find file "	TokenNameStringLiteral	Could not find file 
+	TokenNamePLUS	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" to generate checksum for."	TokenNameStringLiteral	 to generate checksum for.
;	TokenNameSEMICOLON	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
message	TokenNameIdentifier	 message
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
message	TokenNameIdentifier	 message
,	TokenNameCOMMA	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
File	TokenNameIdentifier	 File
getChecksumFile	TokenNameIdentifier	 get Checksum File
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
directory	TokenNameIdentifier	 directory
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
todir	TokenNameIdentifier	 todir
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// A separate directory was explicitly declared 	TokenNameCOMMENT_LINE	A separate directory was explicitly declared 
String	TokenNameIdentifier	 String
path	TokenNameIdentifier	 path
=	TokenNameEQUAL	
getRelativeFilePath	TokenNameIdentifier	 get Relative File Path
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
directory	TokenNameIdentifier	 directory
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
todir	TokenNameIdentifier	 todir
,	TokenNameCOMMA	
path	TokenNameIdentifier	 path
)	TokenNameRPAREN	
.	TokenNameDOT	
getParentFile	TokenNameIdentifier	 get Parent File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Create the directory, as it might not exist. 	TokenNameCOMMENT_LINE	Create the directory, as it might not exist. 
directory	TokenNameIdentifier	 directory
.	TokenNameDOT	
mkdirs	TokenNameIdentifier	 mkdirs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Just use the same directory as the file itself. 	TokenNameCOMMENT_LINE	Just use the same directory as the file itself. 
// This directory will exist 	TokenNameCOMMENT_LINE	This directory will exist 
directory	TokenNameIdentifier	 directory
=	TokenNameEQUAL	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
getParentFile	TokenNameIdentifier	 get Parent File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
File	TokenNameIdentifier	 File
checksumFile	TokenNameIdentifier	 checksum File
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
directory	TokenNameIdentifier	 directory
,	TokenNameCOMMA	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
fileext	TokenNameIdentifier	 fileext
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
checksumFile	TokenNameIdentifier	 checksum File
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Generate checksum(s) using the message digest created earlier. */	TokenNameCOMMENT_JAVADOC	 Generate checksum(s) using the message digest created earlier. 
private	TokenNameprivate	
boolean	TokenNameboolean	
generateChecksums	TokenNameIdentifier	 generate Checksums
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
BuildException	TokenNameIdentifier	 Build Exception
{	TokenNameLBRACE	
boolean	TokenNameboolean	
checksumMatches	TokenNameIdentifier	 checksum Matches
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
FileInputStream	TokenNameIdentifier	 File Input Stream
fis	TokenNameIdentifier	 fis
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
FileOutputStream	TokenNameIdentifier	 File Output Stream
fos	TokenNameIdentifier	 fos
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
buf	TokenNameIdentifier	 buf
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
readBufferSize	TokenNameIdentifier	 read Buffer Size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Enumeration	TokenNameIdentifier	 Enumeration
e	TokenNameIdentifier	 e
=	TokenNameEQUAL	
includeFileMap	TokenNameIdentifier	 include File Map
.	TokenNameDOT	
keys	TokenNameIdentifier	 keys
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
hasMoreElements	TokenNameIdentifier	 has More Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
messageDigest	TokenNameIdentifier	 message Digest
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
src	TokenNameIdentifier	 src
=	TokenNameEQUAL	
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
)	TokenNameRPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
nextElement	TokenNameIdentifier	 next Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isCondition	TokenNameIdentifier	 is Condition
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Calculating "	TokenNameStringLiteral	Calculating 
+	TokenNamePLUS	
algorithm	TokenNameIdentifier	 algorithm
+	TokenNamePLUS	
" checksum for "	TokenNameStringLiteral	 checksum for 
+	TokenNamePLUS	
src	TokenNameIdentifier	 src
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_VERBOSE	TokenNameIdentifier	 MSG  VERBOSE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fis	TokenNameIdentifier	 fis
=	TokenNameEQUAL	
new	TokenNamenew	
FileInputStream	TokenNameIdentifier	 File Input Stream
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DigestInputStream	TokenNameIdentifier	 Digest Input Stream
dis	TokenNameIdentifier	 dis
=	TokenNameEQUAL	
new	TokenNamenew	
DigestInputStream	TokenNameIdentifier	 Digest Input Stream
(	TokenNameLPAREN	
fis	TokenNameIdentifier	 fis
,	TokenNameCOMMA	
messageDigest	TokenNameIdentifier	 message Digest
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
dis	TokenNameIdentifier	 dis
.	TokenNameDOT	
read	TokenNameIdentifier	 read
(	TokenNameLPAREN	
buf	TokenNameIdentifier	 buf
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
readBufferSize	TokenNameIdentifier	 read Buffer Size
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Empty statement 	TokenNameCOMMENT_LINE	Empty statement 
}	TokenNameRBRACE	
dis	TokenNameIdentifier	 dis
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fis	TokenNameIdentifier	 fis
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fis	TokenNameIdentifier	 fis
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fileDigest	TokenNameIdentifier	 file Digest
=	TokenNameEQUAL	
messageDigest	TokenNameIdentifier	 message Digest
.	TokenNameDOT	
digest	TokenNameIdentifier	 digest
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
totalproperty	TokenNameIdentifier	 totalproperty
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
allDigests	TokenNameIdentifier	 all Digests
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
,	TokenNameCOMMA	
fileDigest	TokenNameIdentifier	 file Digest
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
checksum	TokenNameIdentifier	 checksum
=	TokenNameEQUAL	
createDigestString	TokenNameIdentifier	 create Digest String
(	TokenNameLPAREN	
fileDigest	TokenNameIdentifier	 file Digest
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//can either be a property name string or a file 	TokenNameCOMMENT_LINE	can either be a property name string or a file 
Object	TokenNameIdentifier	 Object
destination	TokenNameIdentifier	 destination
=	TokenNameEQUAL	
includeFileMap	TokenNameIdentifier	 include File Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
destination	TokenNameIdentifier	 destination
instanceof	TokenNameinstanceof	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
prop	TokenNameIdentifier	 prop
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
destination	TokenNameIdentifier	 destination
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isCondition	TokenNameIdentifier	 is Condition
)	TokenNameRPAREN	
{	TokenNameLBRACE	
checksumMatches	TokenNameIdentifier	 checksum Matches
=	TokenNameEQUAL	
checksumMatches	TokenNameIdentifier	 checksum Matches
&&	TokenNameAND_AND	
checksum	TokenNameIdentifier	 checksum
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
property	TokenNameIdentifier	 property
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
setNewProperty	TokenNameIdentifier	 set New Property
(	TokenNameLPAREN	
prop	TokenNameIdentifier	 prop
,	TokenNameCOMMA	
checksum	TokenNameIdentifier	 checksum
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
destination	TokenNameIdentifier	 destination
instanceof	TokenNameinstanceof	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
File	TokenNameIdentifier	 File
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isCondition	TokenNameIdentifier	 is Condition
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
existingFile	TokenNameIdentifier	 existing File
=	TokenNameEQUAL	
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
)	TokenNameRPAREN	
destination	TokenNameIdentifier	 destination
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
existingFile	TokenNameIdentifier	 existing File
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
suppliedChecksum	TokenNameIdentifier	 supplied Checksum
=	TokenNameEQUAL	
readChecksum	TokenNameIdentifier	 read Checksum
(	TokenNameLPAREN	
existingFile	TokenNameIdentifier	 existing File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
checksumMatches	TokenNameIdentifier	 checksum Matches
=	TokenNameEQUAL	
checksumMatches	TokenNameIdentifier	 checksum Matches
&&	TokenNameAND_AND	
checksum	TokenNameIdentifier	 checksum
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
suppliedChecksum	TokenNameIdentifier	 supplied Checksum
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
BuildException	TokenNameIdentifier	 Build Exception
be	TokenNameIdentifier	 be
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// file is on wrong format, swallow 	TokenNameCOMMENT_LINE	file is on wrong format, swallow 
checksumMatches	TokenNameIdentifier	 checksum Matches
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
checksumMatches	TokenNameIdentifier	 checksum Matches
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
dest	TokenNameIdentifier	 dest
=	TokenNameEQUAL	
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
)	TokenNameRPAREN	
destination	TokenNameIdentifier	 destination
;	TokenNameSEMICOLON	
fos	TokenNameIdentifier	 fos
=	TokenNameEQUAL	
new	TokenNamenew	
FileOutputStream	TokenNameIdentifier	 File Output Stream
(	TokenNameLPAREN	
dest	TokenNameIdentifier	 dest
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fos	TokenNameIdentifier	 fos
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
format	TokenNameIdentifier	 format
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
checksum	TokenNameIdentifier	 checksum
,	TokenNameCOMMA	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
getRelativePath	TokenNameIdentifier	 get Relative Path
(	TokenNameLPAREN	
dest	TokenNameIdentifier	 dest
.	TokenNameDOT	
getParentFile	TokenNameIdentifier	 get Parent File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
src	TokenNameIdentifier	 src
)	TokenNameRPAREN	
,	TokenNameCOMMA	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
getRelativePath	TokenNameIdentifier	 get Relative Path
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getBaseDir	TokenNameIdentifier	 get Base Dir
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
src	TokenNameIdentifier	 src
)	TokenNameRPAREN	
,	TokenNameCOMMA	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
.	TokenNameDOT	
getBytes	TokenNameIdentifier	 get Bytes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fos	TokenNameIdentifier	 fos
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
StringUtils	TokenNameIdentifier	 String Utils
.	TokenNameDOT	
LINE_SEP	TokenNameIdentifier	 LINE  SEP
.	TokenNameDOT	
getBytes	TokenNameIdentifier	 get Bytes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fos	TokenNameIdentifier	 fos
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fos	TokenNameIdentifier	 fos
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
totalproperty	TokenNameIdentifier	 totalproperty
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Calculate the total checksum 	TokenNameCOMMENT_LINE	Calculate the total checksum 
// Convert the keys (source files) into a sorted array. 	TokenNameCOMMENT_LINE	Convert the keys (source files) into a sorted array. 
Set	TokenNameIdentifier	 Set
keys	TokenNameIdentifier	 keys
=	TokenNameEQUAL	
allDigests	TokenNameIdentifier	 all Digests
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
keyArray	TokenNameIdentifier	 key Array
=	TokenNameEQUAL	
keys	TokenNameIdentifier	 keys
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// File is Comparable, but sort-order is platform 	TokenNameCOMMENT_LINE	File is Comparable, but sort-order is platform 
// dependent (case-insensitive on Windows) 	TokenNameCOMMENT_LINE	dependent (case-insensitive on Windows) 
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
keyArray	TokenNameIdentifier	 key Array
,	TokenNameCOMMA	
new	TokenNamenew	
Comparator	TokenNameIdentifier	 Comparator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
int	TokenNameint	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
o1	TokenNameIdentifier	 o1
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
o2	TokenNameIdentifier	 o2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
f1	TokenNameIdentifier	 f1
=	TokenNameEQUAL	
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
)	TokenNameRPAREN	
o1	TokenNameIdentifier	 o1
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
f2	TokenNameIdentifier	 f2
=	TokenNameEQUAL	
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
)	TokenNameRPAREN	
o2	TokenNameIdentifier	 o2
;	TokenNameSEMICOLON	
return	TokenNamereturn	
f1	TokenNameIdentifier	 f1
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
(	TokenNameLPAREN	
f2	TokenNameIdentifier	 f2
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
:	TokenNameCOLON	
(	TokenNameLPAREN	
f2	TokenNameIdentifier	 f2
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
getRelativeFilePath	TokenNameIdentifier	 get Relative File Path
(	TokenNameLPAREN	
f1	TokenNameIdentifier	 f1
)	TokenNameRPAREN	
.	TokenNameDOT	
compareTo	TokenNameIdentifier	 compare To
(	TokenNameLPAREN	
getRelativeFilePath	TokenNameIdentifier	 get Relative File Path
(	TokenNameLPAREN	
f2	TokenNameIdentifier	 f2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Loop over the checksums and generate a total hash. 	TokenNameCOMMENT_LINE	Loop over the checksums and generate a total hash. 
messageDigest	TokenNameIdentifier	 message Digest
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
keyArray	TokenNameIdentifier	 key Array
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
src	TokenNameIdentifier	 src
=	TokenNameEQUAL	
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
)	TokenNameRPAREN	
keyArray	TokenNameIdentifier	 key Array
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// Add the digest for the file content 	TokenNameCOMMENT_LINE	Add the digest for the file content 
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
digest	TokenNameIdentifier	 digest
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
allDigests	TokenNameIdentifier	 all Digests
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
messageDigest	TokenNameIdentifier	 message Digest
.	TokenNameDOT	
update	TokenNameIdentifier	 update
(	TokenNameLPAREN	
digest	TokenNameIdentifier	 digest
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Add the file path 	TokenNameCOMMENT_LINE	Add the file path 
String	TokenNameIdentifier	 String
fileName	TokenNameIdentifier	 file Name
=	TokenNameEQUAL	
getRelativeFilePath	TokenNameIdentifier	 get Relative File Path
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
messageDigest	TokenNameIdentifier	 message Digest
.	TokenNameDOT	
update	TokenNameIdentifier	 update
(	TokenNameLPAREN	
fileName	TokenNameIdentifier	 file Name
.	TokenNameDOT	
getBytes	TokenNameIdentifier	 get Bytes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
totalChecksum	TokenNameIdentifier	 total Checksum
=	TokenNameEQUAL	
createDigestString	TokenNameIdentifier	 create Digest String
(	TokenNameLPAREN	
messageDigest	TokenNameIdentifier	 message Digest
.	TokenNameDOT	
digest	TokenNameIdentifier	 digest
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
setNewProperty	TokenNameIdentifier	 set New Property
(	TokenNameLPAREN	
totalproperty	TokenNameIdentifier	 totalproperty
,	TokenNameCOMMA	
totalChecksum	TokenNameIdentifier	 total Checksum
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
,	TokenNameCOMMA	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
fis	TokenNameIdentifier	 fis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
fos	TokenNameIdentifier	 fos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
checksumMatches	TokenNameIdentifier	 checksum Matches
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
createDigestString	TokenNameIdentifier	 create Digest String
(	TokenNameLPAREN	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fileDigest	TokenNameIdentifier	 file Digest
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StringBuffer	TokenNameIdentifier	 String Buffer
checksumSb	TokenNameIdentifier	 checksum Sb
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fileDigest	TokenNameIdentifier	 file Digest
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
hexStr	TokenNameIdentifier	 hex Str
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toHexString	TokenNameIdentifier	 to Hex String
(	TokenNameLPAREN	
BYTE_MASK	TokenNameIdentifier	 BYTE  MASK
&	TokenNameAND	
fileDigest	TokenNameIdentifier	 file Digest
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
hexStr	TokenNameIdentifier	 hex Str
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<	TokenNameLESS	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
checksumSb	TokenNameIdentifier	 checksum Sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"0"	TokenNameStringLiteral	0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
checksumSb	TokenNameIdentifier	 checksum Sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
hexStr	TokenNameIdentifier	 hex Str
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
checksumSb	TokenNameIdentifier	 checksum Sb
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Converts an array of characters representing hexadecimal values into an * array of bytes of those same values. The returned array will be half the * length of the passed array, as it takes two characters to represent any * given byte. An exception is thrown if the passed char array has an odd * number of elements. * * NOTE: This code is copied from jakarta-commons codec. * @param data an array of characters representing hexadecimal values * @return the converted array of bytes * @throws BuildException on error */	TokenNameCOMMENT_JAVADOC	 Converts an array of characters representing hexadecimal values into an array of bytes of those same values. The returned array will be half the length of the passed array, as it takes two characters to represent any given byte. An exception is thrown if the passed char array has an odd number of elements. * NOTE: This code is copied from jakarta-commons codec. @param data an array of characters representing hexadecimal values @return the converted array of bytes @throws BuildException on error 
public	TokenNamepublic	
static	TokenNamestatic	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
decodeHex	TokenNameIdentifier	 decode Hex
(	TokenNameLPAREN	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
data	TokenNameIdentifier	 data
)	TokenNameRPAREN	
throws	TokenNamethrows	
BuildException	TokenNameIdentifier	 Build Exception
{	TokenNameLBRACE	
int	TokenNameint	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
l	TokenNameIdentifier	 l
&	TokenNameAND	
0x01	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"odd number of characters."	TokenNameStringLiteral	odd number of characters.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
out	TokenNameIdentifier	 out
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
l	TokenNameIdentifier	 l
>>	TokenNameRIGHT_SHIFT	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// two characters form the hex value. 	TokenNameCOMMENT_LINE	two characters form the hex value. 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
l	TokenNameIdentifier	 l
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
digit	TokenNameIdentifier	 digit
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
WORD	TokenNameIdentifier	 WORD
)	TokenNameRPAREN	
<<	TokenNameLEFT_SHIFT	
NIBBLE	TokenNameIdentifier	 NIBBLE
;	TokenNameSEMICOLON	
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
f	TokenNameIdentifier	 f
|	TokenNameOR	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
digit	TokenNameIdentifier	 digit
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
WORD	TokenNameIdentifier	 WORD
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
out	TokenNameIdentifier	 out
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
f	TokenNameIdentifier	 f
&	TokenNameAND	
BYTE_MASK	TokenNameIdentifier	 BYTE  MASK
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
out	TokenNameIdentifier	 out
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * reads the checksum from a file using the specified format. * * @since 1.7 */	TokenNameCOMMENT_JAVADOC	 reads the checksum from a file using the specified format. * @since 1.7 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
readChecksum	TokenNameIdentifier	 read Checksum
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
f	TokenNameIdentifier	 f
)	TokenNameRPAREN	
{	TokenNameLBRACE	
BufferedReader	TokenNameIdentifier	 Buffered Reader
diskChecksumReader	TokenNameIdentifier	 disk Checksum Reader
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
diskChecksumReader	TokenNameIdentifier	 disk Checksum Reader
=	TokenNameEQUAL	
new	TokenNamenew	
BufferedReader	TokenNameIdentifier	 Buffered Reader
(	TokenNameLPAREN	
new	TokenNamenew	
FileReader	TokenNameIdentifier	 File Reader
(	TokenNameLPAREN	
f	TokenNameIdentifier	 f
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
format	TokenNameIdentifier	 format
.	TokenNameDOT	
parse	TokenNameIdentifier	 parse
(	TokenNameLPAREN	
diskChecksumReader	TokenNameIdentifier	 disk Checksum Reader
.	TokenNameDOT	
readLine	TokenNameIdentifier	 read Line
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
result	TokenNameIdentifier	 result
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"failed to find a checksum"	TokenNameStringLiteral	failed to find a checksum
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
result	TokenNameIdentifier	 result
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Couldn't read checksum file "	TokenNameStringLiteral	Couldn't read checksum file 
+	TokenNamePLUS	
f	TokenNameIdentifier	 f
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ParseException	TokenNameIdentifier	 Parse Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Couldn't read checksum file "	TokenNameStringLiteral	Couldn't read checksum file 
+	TokenNamePLUS	
f	TokenNameIdentifier	 f
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
diskChecksumReader	TokenNameIdentifier	 disk Checksum Reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * @since Ant 1.8.2 */	TokenNameCOMMENT_JAVADOC	 @since Ant 1.8.2 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
getRelativeFilePath	TokenNameIdentifier	 get Relative File Path
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
f	TokenNameIdentifier	 f
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
path	TokenNameIdentifier	 path
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
relativeFilePaths	TokenNameIdentifier	 relative File Paths
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
f	TokenNameIdentifier	 f
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//bug 37386. this should not occur, but it has, once. 	TokenNameCOMMENT_LINE	bug 37386. this should not occur, but it has, once. 
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Internal error: "	TokenNameStringLiteral	Internal error: 
+	TokenNamePLUS	
"relativeFilePaths could not match file "	TokenNameStringLiteral	relativeFilePaths could not match file 
+	TokenNamePLUS	
f	TokenNameIdentifier	 f
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
"please file a bug report on this"	TokenNameStringLiteral	please file a bug report on this
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
path	TokenNameIdentifier	 path
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Helper class for the format attribute. * * @since 1.7 */	TokenNameCOMMENT_JAVADOC	 Helper class for the format attribute. * @since 1.7 
public	TokenNamepublic	
static	TokenNamestatic	
class	TokenNameclass	
FormatElement	TokenNameIdentifier	 Format Element
extends	TokenNameextends	
EnumeratedAttribute	TokenNameIdentifier	 Enumerated Attribute
{	TokenNameLBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
HashMap	TokenNameIdentifier	 Hash Map
formatMap	TokenNameIdentifier	 format Map
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
CHECKSUM	TokenNameIdentifier	 CHECKSUM
=	TokenNameEQUAL	
"CHECKSUM"	TokenNameStringLiteral	CHECKSUM
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
MD5SUM	TokenNameIdentifier	 M D5 SUM
=	TokenNameEQUAL	
"MD5SUM"	TokenNameStringLiteral	MD5SUM
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
SVF	TokenNameIdentifier	 SVF
=	TokenNameEQUAL	
"SVF"	TokenNameStringLiteral	SVF
;	TokenNameSEMICOLON	
static	TokenNamestatic	
{	TokenNameLBRACE	
formatMap	TokenNameIdentifier	 format Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
CHECKSUM	TokenNameIdentifier	 CHECKSUM
,	TokenNameCOMMA	
new	TokenNamenew	
MessageFormat	TokenNameIdentifier	 Message Format
(	TokenNameLPAREN	
"{0}"	TokenNameStringLiteral	{0}
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
formatMap	TokenNameIdentifier	 format Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
MD5SUM	TokenNameIdentifier	 M D5 SUM
,	TokenNameCOMMA	
new	TokenNamenew	
MessageFormat	TokenNameIdentifier	 Message Format
(	TokenNameLPAREN	
"{0} *{1}"	TokenNameStringLiteral	{0} *{1}
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
formatMap	TokenNameIdentifier	 format Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
SVF	TokenNameIdentifier	 SVF
,	TokenNameCOMMA	
new	TokenNamenew	
MessageFormat	TokenNameIdentifier	 Message Format
(	TokenNameLPAREN	
"MD5 ({1}) = {0}"	TokenNameStringLiteral	MD5 ({1}) = {0}
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Constructor for FormatElement */	TokenNameCOMMENT_JAVADOC	 Constructor for FormatElement 
public	TokenNamepublic	
FormatElement	TokenNameIdentifier	 Format Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the default value - CHECKSUM. * @return the defaul value. */	TokenNameCOMMENT_JAVADOC	 Get the default value - CHECKSUM. @return the defaul value. 
public	TokenNamepublic	
static	TokenNamestatic	
FormatElement	TokenNameIdentifier	 Format Element
getDefault	TokenNameIdentifier	 get Default
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
FormatElement	TokenNameIdentifier	 Format Element
e	TokenNameIdentifier	 e
=	TokenNameEQUAL	
new	TokenNamenew	
FormatElement	TokenNameIdentifier	 Format Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
setValue	TokenNameIdentifier	 set Value
(	TokenNameLPAREN	
CHECKSUM	TokenNameIdentifier	 CHECKSUM
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Convert this enumerated type to a <code>MessageFormat</code>. * @return a <code>MessageFormat</code> object. */	TokenNameCOMMENT_JAVADOC	 Convert this enumerated type to a <code>MessageFormat</code>. @return a <code>MessageFormat</code> object. 
public	TokenNamepublic	
MessageFormat	TokenNameIdentifier	 Message Format
getFormat	TokenNameIdentifier	 get Format
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
MessageFormat	TokenNameIdentifier	 Message Format
)	TokenNameRPAREN	
formatMap	TokenNameIdentifier	 format Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the valid values. * @return an array of values. */	TokenNameCOMMENT_JAVADOC	 Get the valid values. @return an array of values. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getValues	TokenNameIdentifier	 get Values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
CHECKSUM	TokenNameIdentifier	 CHECKSUM
,	TokenNameCOMMA	
MD5SUM	TokenNameIdentifier	 M D5 SUM
,	TokenNameCOMMA	
SVF	TokenNameIdentifier	 SVF
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
