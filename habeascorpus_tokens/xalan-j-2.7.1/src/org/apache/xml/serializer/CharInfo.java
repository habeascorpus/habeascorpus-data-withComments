/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
/* * $Id: CharInfo.java 468654 2006-10-28 07:09:23Z minchau $ */	TokenNameCOMMENT_BLOCK	 $Id: CharInfo.java 468654 2006-10-28 07:09:23Z minchau $ 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
serializer	TokenNameIdentifier	 serializer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
BufferedReader	TokenNameIdentifier	 Buffered Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
InputStream	TokenNameIdentifier	 Input Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
InputStreamReader	TokenNameIdentifier	 Input Stream Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
UnsupportedEncodingException	TokenNameIdentifier	 Unsupported Encoding Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
net	TokenNameIdentifier	 net
.	TokenNameDOT	
URL	TokenNameIdentifier	 URL
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Enumeration	TokenNameIdentifier	 Enumeration
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
HashMap	TokenNameIdentifier	 Hash Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Hashtable	TokenNameIdentifier	 Hashtable
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
PropertyResourceBundle	TokenNameIdentifier	 Property Resource Bundle
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ResourceBundle	TokenNameIdentifier	 Resource Bundle
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
security	TokenNameIdentifier	 security
.	TokenNameDOT	
AccessController	TokenNameIdentifier	 Access Controller
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
security	TokenNameIdentifier	 security
.	TokenNameDOT	
PrivilegedAction	TokenNameIdentifier	 Privileged Action
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
TransformerException	TokenNameIdentifier	 Transformer Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
serializer	TokenNameIdentifier	 serializer
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
MsgKey	TokenNameIdentifier	 Msg Key
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
serializer	TokenNameIdentifier	 serializer
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
SystemIDResolver	TokenNameIdentifier	 System ID Resolver
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
serializer	TokenNameIdentifier	 serializer
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
Utils	TokenNameIdentifier	 Utils
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
serializer	TokenNameIdentifier	 serializer
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
WrappedRuntimeException	TokenNameIdentifier	 Wrapped Runtime Exception
;	TokenNameSEMICOLON	
/** * This class provides services that tell if a character should have * special treatement, such as entity reference substitution or normalization * of a newline character. It also provides character to entity reference * lookup. * * DEVELOPERS: See Known Issue in the constructor. * * @xsl.usage internal */	TokenNameCOMMENT_JAVADOC	 This class provides services that tell if a character should have special treatement, such as entity reference substitution or normalization of a newline character. It also provides character to entity reference lookup. * DEVELOPERS: See Known Issue in the constructor. * @xsl.usage internal 
final	TokenNamefinal	
class	TokenNameclass	
CharInfo	TokenNameIdentifier	 Char Info
{	TokenNameLBRACE	
/** Given a character, lookup a String to output (e.g. a decorated entity reference). */	TokenNameCOMMENT_JAVADOC	 Given a character, lookup a String to output (e.g. a decorated entity reference). 
private	TokenNameprivate	
HashMap	TokenNameIdentifier	 Hash Map
m_charToString	TokenNameIdentifier	 m char To String
;	TokenNameSEMICOLON	
/** * The name of the HTML entities file. * If specified, the file will be resource loaded with the default class loader. */	TokenNameCOMMENT_JAVADOC	 The name of the HTML entities file. If specified, the file will be resource loaded with the default class loader. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
HTML_ENTITIES_RESOURCE	TokenNameIdentifier	 HTML  ENTITIES  RESOURCE
=	TokenNameEQUAL	
SerializerBase	TokenNameIdentifier	 Serializer Base
.	TokenNameDOT	
PKG_NAME	TokenNameIdentifier	 PKG  NAME
+	TokenNamePLUS	
".HTMLEntities"	TokenNameStringLiteral	.HTMLEntities
;	TokenNameSEMICOLON	
/** * The name of the XML entities file. * If specified, the file will be resource loaded with the default class loader. */	TokenNameCOMMENT_JAVADOC	 The name of the XML entities file. If specified, the file will be resource loaded with the default class loader. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
XML_ENTITIES_RESOURCE	TokenNameIdentifier	 XML  ENTITIES  RESOURCE
=	TokenNameEQUAL	
SerializerBase	TokenNameIdentifier	 Serializer Base
.	TokenNameDOT	
PKG_NAME	TokenNameIdentifier	 PKG  NAME
+	TokenNamePLUS	
".XMLEntities"	TokenNameStringLiteral	.XMLEntities
;	TokenNameSEMICOLON	
/** The horizontal tab character, which the parser should always normalize. */	TokenNameCOMMENT_JAVADOC	 The horizontal tab character, which the parser should always normalize. 
static	TokenNamestatic	
final	TokenNamefinal	
char	TokenNamechar	
S_HORIZONAL_TAB	TokenNameIdentifier	 S  HORIZONAL  TAB
=	TokenNameEQUAL	
0x09	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** The linefeed character, which the parser should always normalize. */	TokenNameCOMMENT_JAVADOC	 The linefeed character, which the parser should always normalize. 
static	TokenNamestatic	
final	TokenNamefinal	
char	TokenNamechar	
S_LINEFEED	TokenNameIdentifier	 S  LINEFEED
=	TokenNameEQUAL	
0x0A	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** The carriage return character, which the parser should always normalize. */	TokenNameCOMMENT_JAVADOC	 The carriage return character, which the parser should always normalize. 
static	TokenNamestatic	
final	TokenNamefinal	
char	TokenNamechar	
S_CARRIAGERETURN	TokenNameIdentifier	 S  CARRIAGERETURN
=	TokenNameEQUAL	
0x0D	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
char	TokenNamechar	
S_SPACE	TokenNameIdentifier	 S  SPACE
=	TokenNameEQUAL	
0x20	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
char	TokenNamechar	
S_QUOTE	TokenNameIdentifier	 S  QUOTE
=	TokenNameEQUAL	
0x22	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
char	TokenNamechar	
S_LT	TokenNameIdentifier	 S  LT
=	TokenNameEQUAL	
0x3C	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
char	TokenNamechar	
S_GT	TokenNameIdentifier	 S  GT
=	TokenNameEQUAL	
0x3E	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
char	TokenNamechar	
S_NEL	TokenNameIdentifier	 S  NEL
=	TokenNameEQUAL	
0x85	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
char	TokenNamechar	
S_LINE_SEPARATOR	TokenNameIdentifier	 S  LINE  SEPARATOR
=	TokenNameEQUAL	
0x2028	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** This flag is an optimization for HTML entities. It false if entities * other than quot (34), amp (38), lt (60) and gt (62) are defined * in the range 0 to 127. * @xsl.usage internal */	TokenNameCOMMENT_JAVADOC	 This flag is an optimization for HTML entities. It false if entities other than quot (34), amp (38), lt (60) and gt (62) are defined in the range 0 to 127. @xsl.usage internal 
boolean	TokenNameboolean	
onlyQuotAmpLtGt	TokenNameIdentifier	 only Quot Amp Lt Gt
;	TokenNameSEMICOLON	
/** Copy the first 0,1 ... ASCII_MAX values into an array */	TokenNameCOMMENT_JAVADOC	 Copy the first 0,1 ... ASCII_MAX values into an array 
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
ASCII_MAX	TokenNameIdentifier	 ASCII  MAX
=	TokenNameEQUAL	
128	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** Array of values is faster access than a set of bits * to quickly check ASCII characters in attribute values, * the value is true if the character in an attribute value * should be mapped to a String. */	TokenNameCOMMENT_JAVADOC	 Array of values is faster access than a set of bits to quickly check ASCII characters in attribute values, the value is true if the character in an attribute value should be mapped to a String. 
private	TokenNameprivate	
final	TokenNamefinal	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
shouldMapAttrChar_ASCII	TokenNameIdentifier	 should Map Attr Char  ASCII
;	TokenNameSEMICOLON	
/** Array of values is faster access than a set of bits * to quickly check ASCII characters in text nodes, * the value is true if the character in a text node * should be mapped to a String. */	TokenNameCOMMENT_JAVADOC	 Array of values is faster access than a set of bits to quickly check ASCII characters in text nodes, the value is true if the character in a text node should be mapped to a String. 
private	TokenNameprivate	
final	TokenNamefinal	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
shouldMapTextChar_ASCII	TokenNameIdentifier	 should Map Text Char  ASCII
;	TokenNameSEMICOLON	
/** An array of bits to record if the character is in the set. * Although information in this array is complete, the * isSpecialAttrASCII array is used first because access to its values * is common and faster. */	TokenNameCOMMENT_JAVADOC	 An array of bits to record if the character is in the set. Although information in this array is complete, the isSpecialAttrASCII array is used first because access to its values is common and faster. 
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
array_of_bits	TokenNameIdentifier	 array of bits
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// 5 for 32 bit words, 6 for 64 bit words ... 	TokenNameCOMMENT_LINE	5 for 32 bit words, 6 for 64 bit words ... 
/* * This constant is used to shift an integer to quickly * calculate which element its bit is stored in. * 5 for 32 bit words (int) , 6 for 64 bit words (long) */	TokenNameCOMMENT_BLOCK	 This constant is used to shift an integer to quickly calculate which element its bit is stored in. 5 for 32 bit words (int) , 6 for 64 bit words (long) 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
SHIFT_PER_WORD	TokenNameIdentifier	 SHIFT  PER  WORD
=	TokenNameEQUAL	
5	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/* * A mask to get the low order bits which are used to * calculate the value of the bit within a given word, * that will represent the presence of the integer in the * set. * * 0x1F for 32 bit words (int), * or 0x3F for 64 bit words (long) */	TokenNameCOMMENT_BLOCK	 A mask to get the low order bits which are used to calculate the value of the bit within a given word, that will represent the presence of the integer in the set. * 0x1F for 32 bit words (int), or 0x3F for 64 bit words (long) 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
LOW_ORDER_BITMASK	TokenNameIdentifier	 LOW  ORDER  BITMASK
=	TokenNameEQUAL	
0x1f	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/* * This is used for optimizing the lookup of bits representing * the integers in the set. It is the index of the first element * in the array array_of_bits[] that is not used. */	TokenNameCOMMENT_BLOCK	 This is used for optimizing the lookup of bits representing the integers in the set. It is the index of the first element in the array array_of_bits[] that is not used. 
private	TokenNameprivate	
int	TokenNameint	
firstWordNotUsed	TokenNameIdentifier	 first Word Not Used
;	TokenNameSEMICOLON	
/** * A base constructor just to explicitly create the fields, * with the exception of m_charToString which is handled * by the constructor that delegates base construction to this one. * <p> * m_charToString is not created here only for performance reasons, * to avoid creating a Hashtable that will be replaced when * making a mutable copy, {@link #mutableCopyOf(CharInfo)}. * */	TokenNameCOMMENT_JAVADOC	 A base constructor just to explicitly create the fields, with the exception of m_charToString which is handled by the constructor that delegates base construction to this one. <p> m_charToString is not created here only for performance reasons, to avoid creating a Hashtable that will be replaced when making a mutable copy, {@link #mutableCopyOf(CharInfo)}. 
private	TokenNameprivate	
CharInfo	TokenNameIdentifier	 Char Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
array_of_bits	TokenNameIdentifier	 array of bits
=	TokenNameEQUAL	
createEmptySetOfIntegers	TokenNameIdentifier	 create Empty Set Of Integers
(	TokenNameLPAREN	
65535	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
firstWordNotUsed	TokenNameIdentifier	 first Word Not Used
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
shouldMapAttrChar_ASCII	TokenNameIdentifier	 should Map Attr Char  ASCII
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
ASCII_MAX	TokenNameIdentifier	 ASCII  MAX
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
shouldMapTextChar_ASCII	TokenNameIdentifier	 should Map Text Char  ASCII
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
ASCII_MAX	TokenNameIdentifier	 ASCII  MAX
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
m_charKey	TokenNameIdentifier	 m char Key
=	TokenNameEQUAL	
new	TokenNamenew	
CharKey	TokenNameIdentifier	 Char Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Not set here, but in a constructor that uses this one 	TokenNameCOMMENT_LINE	Not set here, but in a constructor that uses this one 
// this.m_charToString = new Hashtable(); 	TokenNameCOMMENT_LINE	this.m_charToString = new Hashtable(); 
this	TokenNamethis	
.	TokenNameDOT	
onlyQuotAmpLtGt	TokenNameIdentifier	 only Quot Amp Lt Gt
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
CharInfo	TokenNameIdentifier	 Char Info
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
entitiesResource	TokenNameIdentifier	 entities Resource
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
method	TokenNameIdentifier	 method
,	TokenNameCOMMA	
boolean	TokenNameboolean	
internal	TokenNameIdentifier	 internal
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// call the default constructor to create the fields 	TokenNameCOMMENT_LINE	call the default constructor to create the fields 
this	TokenNamethis	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
m_charToString	TokenNameIdentifier	 m char To String
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ResourceBundle	TokenNameIdentifier	 Resource Bundle
entities	TokenNameIdentifier	 entities
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
noExtraEntities	TokenNameIdentifier	 no Extra Entities
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// Make various attempts to interpret the parameter as a properties 	TokenNameCOMMENT_LINE	Make various attempts to interpret the parameter as a properties 
// file or resource file, as follows: 	TokenNameCOMMENT_LINE	file or resource file, as follows: 
// 	TokenNameCOMMENT_LINE	 
// 1) attempt to load .properties file using ResourceBundle 	TokenNameCOMMENT_LINE	1) attempt to load .properties file using ResourceBundle 
// 2) try using the class loader to find the specified file a resource 	TokenNameCOMMENT_LINE	2) try using the class loader to find the specified file a resource 
// file 	TokenNameCOMMENT_LINE	file 
// 3) try treating the resource a URI 	TokenNameCOMMENT_LINE	3) try treating the resource a URI 
if	TokenNameif	
(	TokenNameLPAREN	
internal	TokenNameIdentifier	 internal
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
// Load entity property files by using PropertyResourceBundle, 	TokenNameCOMMENT_LINE	Load entity property files by using PropertyResourceBundle, 
// cause of security issure for applets 	TokenNameCOMMENT_LINE	cause of security issure for applets 
entities	TokenNameIdentifier	 entities
=	TokenNameEQUAL	
PropertyResourceBundle	TokenNameIdentifier	 Property Resource Bundle
.	TokenNameDOT	
getBundle	TokenNameIdentifier	 get Bundle
(	TokenNameLPAREN	
entitiesResource	TokenNameIdentifier	 entities Resource
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
entities	TokenNameIdentifier	 entities
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Enumeration	TokenNameIdentifier	 Enumeration
keys	TokenNameIdentifier	 keys
=	TokenNameEQUAL	
entities	TokenNameIdentifier	 entities
.	TokenNameDOT	
getKeys	TokenNameIdentifier	 get Keys
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
keys	TokenNameIdentifier	 keys
.	TokenNameDOT	
hasMoreElements	TokenNameIdentifier	 has More Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
keys	TokenNameIdentifier	 keys
.	TokenNameDOT	
nextElement	TokenNameIdentifier	 next Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
entities	TokenNameIdentifier	 entities
.	TokenNameDOT	
getString	TokenNameIdentifier	 get String
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
code	TokenNameIdentifier	 code
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
parseInt	TokenNameIdentifier	 parse Int
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
extra	TokenNameIdentifier	 extra
=	TokenNameEQUAL	
defineEntity	TokenNameIdentifier	 define Entity
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
code	TokenNameIdentifier	 code
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
extra	TokenNameIdentifier	 extra
)	TokenNameRPAREN	
noExtraEntities	TokenNameIdentifier	 no Extra Entities
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
InputStream	TokenNameIdentifier	 Input Stream
is	TokenNameIdentifier	 is
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// Load user specified resource file by using URL loading, it 	TokenNameCOMMENT_LINE	Load user specified resource file by using URL loading, it 
// requires a valid URI as parameter 	TokenNameCOMMENT_LINE	requires a valid URI as parameter 
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
internal	TokenNameIdentifier	 internal
)	TokenNameRPAREN	
{	TokenNameLBRACE	
is	TokenNameIdentifier	 is
=	TokenNameEQUAL	
CharInfo	TokenNameIdentifier	 Char Info
.	TokenNameDOT	
class	TokenNameclass	
.	TokenNameDOT	
getResourceAsStream	TokenNameIdentifier	 get Resource As Stream
(	TokenNameLPAREN	
entitiesResource	TokenNameIdentifier	 entities Resource
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
ClassLoader	TokenNameIdentifier	 Class Loader
cl	TokenNameIdentifier	 cl
=	TokenNameEQUAL	
ObjectFactory	TokenNameIdentifier	 Object Factory
.	TokenNameDOT	
findClassLoader	TokenNameIdentifier	 find Class Loader
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cl	TokenNameIdentifier	 cl
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
is	TokenNameIdentifier	 is
=	TokenNameEQUAL	
ClassLoader	TokenNameIdentifier	 Class Loader
.	TokenNameDOT	
getSystemResourceAsStream	TokenNameIdentifier	 get System Resource As Stream
(	TokenNameLPAREN	
entitiesResource	TokenNameIdentifier	 entities Resource
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
is	TokenNameIdentifier	 is
=	TokenNameEQUAL	
cl	TokenNameIdentifier	 cl
.	TokenNameDOT	
getResourceAsStream	TokenNameIdentifier	 get Resource As Stream
(	TokenNameLPAREN	
entitiesResource	TokenNameIdentifier	 entities Resource
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
URL	TokenNameIdentifier	 URL
url	TokenNameIdentifier	 url
=	TokenNameEQUAL	
new	TokenNamenew	
URL	TokenNameIdentifier	 URL
(	TokenNameLPAREN	
entitiesResource	TokenNameIdentifier	 entities Resource
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
is	TokenNameIdentifier	 is
=	TokenNameEQUAL	
url	TokenNameIdentifier	 url
.	TokenNameDOT	
openStream	TokenNameIdentifier	 open Stream
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
Utils	TokenNameIdentifier	 Utils
.	TokenNameDOT	
messages	TokenNameIdentifier	 messages
.	TokenNameDOT	
createMessage	TokenNameIdentifier	 create Message
(	TokenNameLPAREN	
MsgKey	TokenNameIdentifier	 Msg Key
.	TokenNameDOT	
ER_RESOURCE_COULD_NOT_FIND	TokenNameIdentifier	 ER  RESOURCE  COULD  NOT  FIND
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
entitiesResource	TokenNameIdentifier	 entities Resource
,	TokenNameCOMMA	
entitiesResource	TokenNameIdentifier	 entities Resource
}	TokenNameRBRACE	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Fix Bugzilla#4000: force reading in UTF-8 	TokenNameCOMMENT_LINE	Fix Bugzilla#4000: force reading in UTF-8 
// This creates the de facto standard that Xalan's resource 	TokenNameCOMMENT_LINE	This creates the de facto standard that Xalan's resource 
// files must be encoded in UTF-8. This should work in all 	TokenNameCOMMENT_LINE	files must be encoded in UTF-8. This should work in all 
// JVMs. 	TokenNameCOMMENT_LINE	JVMs. 
// 	TokenNameCOMMENT_LINE	 
// %REVIEW% KNOWN ISSUE: IT FAILS IN MICROSOFT VJ++, which 	TokenNameCOMMENT_LINE	%REVIEW% KNOWN ISSUE: IT FAILS IN MICROSOFT VJ++, which 
// didn't implement the UTF-8 encoding. Theoretically, we should 	TokenNameCOMMENT_LINE	didn't implement the UTF-8 encoding. Theoretically, we should 
// simply let it fail in that case, since the JVM is obviously 	TokenNameCOMMENT_LINE	simply let it fail in that case, since the JVM is obviously 
// broken if it doesn't support such a basic standard. But 	TokenNameCOMMENT_LINE	broken if it doesn't support such a basic standard. But 
// since there are still some users attempting to use VJ++ for 	TokenNameCOMMENT_LINE	since there are still some users attempting to use VJ++ for 
// development, we have dropped in a fallback which makes a 	TokenNameCOMMENT_LINE	development, we have dropped in a fallback which makes a 
// second attempt using the platform's default encoding. In VJ++ 	TokenNameCOMMENT_LINE	second attempt using the platform's default encoding. In VJ++ 
// this is apparently ASCII, which is subset of UTF-8... and 	TokenNameCOMMENT_LINE	this is apparently ASCII, which is subset of UTF-8... and 
// since the strings we'll be reading here are also primarily 	TokenNameCOMMENT_LINE	since the strings we'll be reading here are also primarily 
// limited to the 7-bit ASCII range (at least, in English 	TokenNameCOMMENT_LINE	limited to the 7-bit ASCII range (at least, in English 
// versions of Xalan), this should work well enough to keep us 	TokenNameCOMMENT_LINE	versions of Xalan), this should work well enough to keep us 
// on the air until we're ready to officially decommit from 	TokenNameCOMMENT_LINE	on the air until we're ready to officially decommit from 
// VJ++. 	TokenNameCOMMENT_LINE	VJ++. 
BufferedReader	TokenNameIdentifier	 Buffered Reader
reader	TokenNameIdentifier	 reader
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
reader	TokenNameIdentifier	 reader
=	TokenNameEQUAL	
new	TokenNamenew	
BufferedReader	TokenNameIdentifier	 Buffered Reader
(	TokenNameLPAREN	
new	TokenNamenew	
InputStreamReader	TokenNameIdentifier	 Input Stream Reader
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
,	TokenNameCOMMA	
"UTF-8"	TokenNameStringLiteral	UTF-8
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
UnsupportedEncodingException	TokenNameIdentifier	 Unsupported Encoding Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reader	TokenNameIdentifier	 reader
=	TokenNameEQUAL	
new	TokenNamenew	
BufferedReader	TokenNameIdentifier	 Buffered Reader
(	TokenNameLPAREN	
new	TokenNamenew	
InputStreamReader	TokenNameIdentifier	 Input Stream Reader
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
line	TokenNameIdentifier	 line
=	TokenNameEQUAL	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
readLine	TokenNameIdentifier	 read Line
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
line	TokenNameIdentifier	 line
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
line	TokenNameIdentifier	 line
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
line	TokenNameIdentifier	 line
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
'#'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
line	TokenNameIdentifier	 line
=	TokenNameEQUAL	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
readLine	TokenNameIdentifier	 read Line
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
line	TokenNameIdentifier	 line
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
' '	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
line	TokenNameIdentifier	 line
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
index	TokenNameIdentifier	 index
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
<	TokenNameLESS	
line	TokenNameIdentifier	 line
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
line	TokenNameIdentifier	 line
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
' '	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
code	TokenNameIdentifier	 code
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
parseInt	TokenNameIdentifier	 parse Int
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
extra	TokenNameIdentifier	 extra
=	TokenNameEQUAL	
defineEntity	TokenNameIdentifier	 define Entity
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
code	TokenNameIdentifier	 code
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
extra	TokenNameIdentifier	 extra
)	TokenNameRPAREN	
noExtraEntities	TokenNameIdentifier	 no Extra Entities
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
line	TokenNameIdentifier	 line
=	TokenNameEQUAL	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
readLine	TokenNameIdentifier	 read Line
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
is	TokenNameIdentifier	 is
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
Utils	TokenNameIdentifier	 Utils
.	TokenNameDOT	
messages	TokenNameIdentifier	 messages
.	TokenNameDOT	
createMessage	TokenNameIdentifier	 create Message
(	TokenNameLPAREN	
MsgKey	TokenNameIdentifier	 Msg Key
.	TokenNameDOT	
ER_RESOURCE_COULD_NOT_LOAD	TokenNameIdentifier	 ER  RESOURCE  COULD  NOT  LOAD
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
entitiesResource	TokenNameIdentifier	 entities Resource
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
entitiesResource	TokenNameIdentifier	 entities Resource
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
is	TokenNameIdentifier	 is
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
except	TokenNameIdentifier	 except
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
onlyQuotAmpLtGt	TokenNameIdentifier	 only Quot Amp Lt Gt
=	TokenNameEQUAL	
noExtraEntities	TokenNameIdentifier	 no Extra Entities
;	TokenNameSEMICOLON	
/* Now that we've used get(ch) just above to initialize the * two arrays we will change by adding a tab to the set of * special chars for XML (but not HTML!). * We do this because a tab is always a * special character in an XML attribute, * but only a special character in XML text * if it has an entity defined for it. * This is the reason for this delay. */	TokenNameCOMMENT_BLOCK	 Now that we've used get(ch) just above to initialize the two arrays we will change by adding a tab to the set of special chars for XML (but not HTML!). We do this because a tab is always a special character in an XML attribute, but only a special character in XML text if it has an entity defined for it. This is the reason for this delay. 
if	TokenNameif	
(	TokenNameLPAREN	
Method	TokenNameIdentifier	 Method
.	TokenNameDOT	
XML	TokenNameIdentifier	 XML
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
method	TokenNameIdentifier	 method
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// We choose not to escape the quotation mark as &quot; in text nodes 	TokenNameCOMMENT_LINE	We choose not to escape the quotation mark as &quot; in text nodes 
shouldMapTextChar_ASCII	TokenNameIdentifier	 should Map Text Char  ASCII
[	TokenNameLBRACKET	
S_QUOTE	TokenNameIdentifier	 S  QUOTE
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
Method	TokenNameIdentifier	 Method
.	TokenNameDOT	
HTML	TokenNameIdentifier	 HTML
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
method	TokenNameIdentifier	 method
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// The XSLT 1.0 recommendation says 	TokenNameCOMMENT_LINE	The XSLT 1.0 recommendation says 
// "The html output method should not escape < characters occurring in attribute values." 	TokenNameCOMMENT_LINE	"The html output method should not escape < characters occurring in attribute values." 
// So we don't escape '<' in an attribute for HTML 	TokenNameCOMMENT_LINE	So we don't escape '<' in an attribute for HTML 
shouldMapAttrChar_ASCII	TokenNameIdentifier	 should Map Attr Char  ASCII
[	TokenNameLBRACKET	
'<'	TokenNameCharacterLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// We choose not to escape the quotation mark as &quot; in text nodes. 	TokenNameCOMMENT_LINE	We choose not to escape the quotation mark as &quot; in text nodes. 
shouldMapTextChar_ASCII	TokenNameIdentifier	 should Map Text Char  ASCII
[	TokenNameLBRACKET	
S_QUOTE	TokenNameIdentifier	 S  QUOTE
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Defines a new character reference. The reference's name and value are * supplied. Nothing happens if the character reference is already defined. * <p>Unlike internal entities, character references are a string to single * character mapping. They are used to map non-ASCII characters both on * parsing and printing, primarily for HTML documents. '&amp;lt;' is an * example of a character reference.</p> * * @param name The entity's name * @param value The entity's value * @return true if the mapping is not one of: * <ul> * <li> '<' to "&lt;" * <li> '>' to "&gt;" * <li> '&' to "&amp;" * <li> '"' to "&quot;" * </ul> */	TokenNameCOMMENT_JAVADOC	 Defines a new character reference. The reference's name and value are supplied. Nothing happens if the character reference is already defined. <p>Unlike internal entities, character references are a string to single character mapping. They are used to map non-ASCII characters both on parsing and printing, primarily for HTML documents. '&amp;lt;' is an example of a character reference.</p> * @param name The entity's name @param value The entity's value @return true if the mapping is not one of: <ul> <li> '<' to "&lt;" <li> '>' to "&gt;" <li> '&' to "&amp;" <li> '"' to "&quot;" </ul> 
private	TokenNameprivate	
boolean	TokenNameboolean	
defineEntity	TokenNameIdentifier	 define Entity
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
char	TokenNamechar	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StringBuffer	TokenNameIdentifier	 String Buffer
sb	TokenNameIdentifier	 sb
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
"&"	TokenNameStringLiteral	&
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
';'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
entityString	TokenNameIdentifier	 entity String
=	TokenNameEQUAL	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
extra	TokenNameIdentifier	 extra
=	TokenNameEQUAL	
defineChar2StringMapping	TokenNameIdentifier	 define Char2 String Mapping
(	TokenNameLPAREN	
entityString	TokenNameIdentifier	 entity String
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
extra	TokenNameIdentifier	 extra
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * A utility object, just used to map characters to output Strings, * needed because a HashMap needs to map an object as a key, not a * Java primitive type, like a char, so this object gets around that * and it is reusable. */	TokenNameCOMMENT_JAVADOC	 A utility object, just used to map characters to output Strings, needed because a HashMap needs to map an object as a key, not a Java primitive type, like a char, so this object gets around that and it is reusable. 
private	TokenNameprivate	
final	TokenNamefinal	
CharKey	TokenNameIdentifier	 Char Key
m_charKey	TokenNameIdentifier	 m char Key
;	TokenNameSEMICOLON	
/** * Map a character to a String. For example given * the character '>' this method would return the fully decorated * entity name "&lt;". * Strings for entity references are loaded from a properties file, * but additional mappings defined through calls to defineChar2String() * are possible. Such entity reference mappings could be over-ridden. * * This is reusing a stored key object, in an effort to avoid * heap activity. Unfortunately, that introduces a threading risk. * Simplest fix for now is to make it a synchronized method, or to give * up the reuse; I see very little performance difference between them. * Long-term solution would be to replace the hashtable with a sparse array * keyed directly from the character's integer value; see DTM's * string pool for a related solution. * * @param value The character that should be resolved to * a String, e.g. resolve '>' to "&lt;". * * @return The String that the character is mapped to, or null if not found. * @xsl.usage internal */	TokenNameCOMMENT_JAVADOC	 Map a character to a String. For example given the character '>' this method would return the fully decorated entity name "&lt;". Strings for entity references are loaded from a properties file, but additional mappings defined through calls to defineChar2String() are possible. Such entity reference mappings could be over-ridden. * This is reusing a stored key object, in an effort to avoid heap activity. Unfortunately, that introduces a threading risk. Simplest fix for now is to make it a synchronized method, or to give up the reuse; I see very little performance difference between them. Long-term solution would be to replace the hashtable with a sparse array keyed directly from the character's integer value; see DTM's string pool for a related solution. * @param value The character that should be resolved to a String, e.g. resolve '>' to "&lt;". * @return The String that the character is mapped to, or null if not found. @xsl.usage internal 
String	TokenNameIdentifier	 String
getOutputStringForChar	TokenNameIdentifier	 get Output String For Char
(	TokenNameLPAREN	
char	TokenNamechar	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// CharKey m_charKey = new CharKey(); //Alternative to synchronized 	TokenNameCOMMENT_LINE	CharKey m_charKey = new CharKey(); //Alternative to synchronized 
m_charKey	TokenNameIdentifier	 m char Key
.	TokenNameDOT	
setChar	TokenNameIdentifier	 set Char
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
m_charToString	TokenNameIdentifier	 m char To String
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
m_charKey	TokenNameIdentifier	 m char Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Tell if the character argument that is from * an attribute value has a mapping to a String. * * @param value the value of a character that is in an attribute value * @return true if the character should have any special treatment, * such as when writing out entity references. * @xsl.usage internal */	TokenNameCOMMENT_JAVADOC	 Tell if the character argument that is from an attribute value has a mapping to a String. * @param value the value of a character that is in an attribute value @return true if the character should have any special treatment, such as when writing out entity references. @xsl.usage internal 
final	TokenNamefinal	
boolean	TokenNameboolean	
shouldMapAttrChar	TokenNameIdentifier	 should Map Attr Char
(	TokenNameLPAREN	
int	TokenNameint	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// for performance try the values in the boolean array first, 	TokenNameCOMMENT_LINE	for performance try the values in the boolean array first, 
// this is faster access than the BitSet for common ASCII values 	TokenNameCOMMENT_LINE	this is faster access than the BitSet for common ASCII values 
if	TokenNameif	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
<	TokenNameLESS	
ASCII_MAX	TokenNameIdentifier	 ASCII  MAX
)	TokenNameRPAREN	
return	TokenNamereturn	
shouldMapAttrChar_ASCII	TokenNameIdentifier	 should Map Attr Char  ASCII
[	TokenNameLBRACKET	
value	TokenNameIdentifier	 value
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// rather than java.util.BitSet, our private 	TokenNameCOMMENT_LINE	rather than java.util.BitSet, our private 
// implementation is faster (and less general). 	TokenNameCOMMENT_LINE	implementation is faster (and less general). 
return	TokenNamereturn	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Tell if the character argument that is from a * text node has a mapping to a String, for example * to map '<' to "&lt;". * * @param value the value of a character that is in a text node * @return true if the character has a mapping to a String, * such as when writing out entity references. * @xsl.usage internal */	TokenNameCOMMENT_JAVADOC	 Tell if the character argument that is from a text node has a mapping to a String, for example to map '<' to "&lt;". * @param value the value of a character that is in a text node @return true if the character has a mapping to a String, such as when writing out entity references. @xsl.usage internal 
final	TokenNamefinal	
boolean	TokenNameboolean	
shouldMapTextChar	TokenNameIdentifier	 should Map Text Char
(	TokenNameLPAREN	
int	TokenNameint	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// for performance try the values in the boolean array first, 	TokenNameCOMMENT_LINE	for performance try the values in the boolean array first, 
// this is faster access than the BitSet for common ASCII values 	TokenNameCOMMENT_LINE	this is faster access than the BitSet for common ASCII values 
if	TokenNameif	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
<	TokenNameLESS	
ASCII_MAX	TokenNameIdentifier	 ASCII  MAX
)	TokenNameRPAREN	
return	TokenNamereturn	
shouldMapTextChar_ASCII	TokenNameIdentifier	 should Map Text Char  ASCII
[	TokenNameLBRACKET	
value	TokenNameIdentifier	 value
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// rather than java.util.BitSet, our private 	TokenNameCOMMENT_LINE	rather than java.util.BitSet, our private 
// implementation is faster (and less general). 	TokenNameCOMMENT_LINE	implementation is faster (and less general). 
return	TokenNamereturn	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
CharInfo	TokenNameIdentifier	 Char Info
getCharInfoBasedOnPrivilege	TokenNameIdentifier	 get Char Info Based On Privilege
(	TokenNameLPAREN	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
entitiesFileName	TokenNameIdentifier	 entities File Name
,	TokenNameCOMMA	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
method	TokenNameIdentifier	 method
,	TokenNameCOMMA	
final	TokenNamefinal	
boolean	TokenNameboolean	
internal	TokenNameIdentifier	 internal
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
CharInfo	TokenNameIdentifier	 Char Info
)	TokenNameRPAREN	
AccessController	TokenNameIdentifier	 Access Controller
.	TokenNameDOT	
doPrivileged	TokenNameIdentifier	 do Privileged
(	TokenNameLPAREN	
new	TokenNamenew	
PrivilegedAction	TokenNameIdentifier	 Privileged Action
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
Object	TokenNameIdentifier	 Object
run	TokenNameIdentifier	 run
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
CharInfo	TokenNameIdentifier	 Char Info
(	TokenNameLPAREN	
entitiesFileName	TokenNameIdentifier	 entities File Name
,	TokenNameCOMMA	
method	TokenNameIdentifier	 method
,	TokenNameCOMMA	
internal	TokenNameIdentifier	 internal
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Factory that reads in a resource file that describes the mapping of * characters to entity references. * * Resource files must be encoded in UTF-8 and have a format like: * <pre> * # First char # is a comment * Entity numericValue * quot 34 * amp 38 * </pre> * (Note: Why don't we just switch to .properties files? Oct-01 -sc) * * @param entitiesResource Name of entities resource file that should * be loaded, which describes that mapping of characters to entity references. * @param method the output method type, which should be one of "xml", "html", "text"... * * @xsl.usage internal */	TokenNameCOMMENT_JAVADOC	 Factory that reads in a resource file that describes the mapping of characters to entity references. * Resource files must be encoded in UTF-8 and have a format like: <pre> # First char # is a comment Entity numericValue quot 34 amp 38 </pre> (Note: Why don't we just switch to .properties files? Oct-01 -sc) * @param entitiesResource Name of entities resource file that should be loaded, which describes that mapping of characters to entity references. @param method the output method type, which should be one of "xml", "html", "text"... * @xsl.usage internal 
static	TokenNamestatic	
CharInfo	TokenNameIdentifier	 Char Info
getCharInfo	TokenNameIdentifier	 get Char Info
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
entitiesFileName	TokenNameIdentifier	 entities File Name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
method	TokenNameIdentifier	 method
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CharInfo	TokenNameIdentifier	 Char Info
charInfo	TokenNameIdentifier	 char Info
=	TokenNameEQUAL	
(	TokenNameLPAREN	
CharInfo	TokenNameIdentifier	 Char Info
)	TokenNameRPAREN	
m_getCharInfoCache	TokenNameIdentifier	 m get Char Info Cache
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
entitiesFileName	TokenNameIdentifier	 entities File Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
charInfo	TokenNameIdentifier	 char Info
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
mutableCopyOf	TokenNameIdentifier	 mutable Copy Of
(	TokenNameLPAREN	
charInfo	TokenNameIdentifier	 char Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// try to load it internally - cache 	TokenNameCOMMENT_LINE	try to load it internally - cache 
try	TokenNametry	
{	TokenNameLBRACE	
charInfo	TokenNameIdentifier	 char Info
=	TokenNameEQUAL	
getCharInfoBasedOnPrivilege	TokenNameIdentifier	 get Char Info Based On Privilege
(	TokenNameLPAREN	
entitiesFileName	TokenNameIdentifier	 entities File Name
,	TokenNameCOMMA	
method	TokenNameIdentifier	 method
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Put the common copy of charInfo in the cache, but return 	TokenNameCOMMENT_LINE	Put the common copy of charInfo in the cache, but return 
// a copy of it. 	TokenNameCOMMENT_LINE	a copy of it. 
m_getCharInfoCache	TokenNameIdentifier	 m get Char Info Cache
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
entitiesFileName	TokenNameIdentifier	 entities File Name
,	TokenNameCOMMA	
charInfo	TokenNameIdentifier	 char Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
mutableCopyOf	TokenNameIdentifier	 mutable Copy Of
(	TokenNameLPAREN	
charInfo	TokenNameIdentifier	 char Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
// try to load it externally - do not cache 	TokenNameCOMMENT_LINE	try to load it externally - do not cache 
try	TokenNametry	
{	TokenNameLBRACE	
return	TokenNamereturn	
getCharInfoBasedOnPrivilege	TokenNameIdentifier	 get Char Info Based On Privilege
(	TokenNameLPAREN	
entitiesFileName	TokenNameIdentifier	 entities File Name
,	TokenNameCOMMA	
method	TokenNameIdentifier	 method
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
absoluteEntitiesFileName	TokenNameIdentifier	 absolute Entities File Name
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
entitiesFileName	TokenNameIdentifier	 entities File Name
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
':'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
absoluteEntitiesFileName	TokenNameIdentifier	 absolute Entities File Name
=	TokenNameEQUAL	
SystemIDResolver	TokenNameIdentifier	 System ID Resolver
.	TokenNameDOT	
getAbsoluteURIFromRelative	TokenNameIdentifier	 get Absolute URI From Relative
(	TokenNameLPAREN	
entitiesFileName	TokenNameIdentifier	 entities File Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
absoluteEntitiesFileName	TokenNameIdentifier	 absolute Entities File Name
=	TokenNameEQUAL	
SystemIDResolver	TokenNameIdentifier	 System ID Resolver
.	TokenNameDOT	
getAbsoluteURI	TokenNameIdentifier	 get Absolute URI
(	TokenNameLPAREN	
entitiesFileName	TokenNameIdentifier	 entities File Name
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
TransformerException	TokenNameIdentifier	 Transformer Exception
te	TokenNameIdentifier	 te
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
WrappedRuntimeException	TokenNameIdentifier	 Wrapped Runtime Exception
(	TokenNameLPAREN	
te	TokenNameIdentifier	 te
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
getCharInfoBasedOnPrivilege	TokenNameIdentifier	 get Char Info Based On Privilege
(	TokenNameLPAREN	
entitiesFileName	TokenNameIdentifier	 entities File Name
,	TokenNameCOMMA	
method	TokenNameIdentifier	 method
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Create a mutable copy of the cached one. * @param charInfo The cached one. * @return */	TokenNameCOMMENT_JAVADOC	 Create a mutable copy of the cached one. @param charInfo The cached one. @return 
private	TokenNameprivate	
static	TokenNamestatic	
CharInfo	TokenNameIdentifier	 Char Info
mutableCopyOf	TokenNameIdentifier	 mutable Copy Of
(	TokenNameLPAREN	
CharInfo	TokenNameIdentifier	 Char Info
charInfo	TokenNameIdentifier	 char Info
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CharInfo	TokenNameIdentifier	 Char Info
copy	TokenNameIdentifier	 copy
=	TokenNameEQUAL	
new	TokenNamenew	
CharInfo	TokenNameIdentifier	 Char Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
max	TokenNameIdentifier	 max
=	TokenNameEQUAL	
charInfo	TokenNameIdentifier	 char Info
.	TokenNameDOT	
array_of_bits	TokenNameIdentifier	 array of bits
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
charInfo	TokenNameIdentifier	 char Info
.	TokenNameDOT	
array_of_bits	TokenNameIdentifier	 array of bits
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
copy	TokenNameIdentifier	 copy
.	TokenNameDOT	
array_of_bits	TokenNameIdentifier	 array of bits
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
max	TokenNameIdentifier	 max
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
copy	TokenNameIdentifier	 copy
.	TokenNameDOT	
firstWordNotUsed	TokenNameIdentifier	 first Word Not Used
=	TokenNameEQUAL	
charInfo	TokenNameIdentifier	 char Info
.	TokenNameDOT	
firstWordNotUsed	TokenNameIdentifier	 first Word Not Used
;	TokenNameSEMICOLON	
max	TokenNameIdentifier	 max
=	TokenNameEQUAL	
charInfo	TokenNameIdentifier	 char Info
.	TokenNameDOT	
shouldMapAttrChar_ASCII	TokenNameIdentifier	 should Map Attr Char  ASCII
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
charInfo	TokenNameIdentifier	 char Info
.	TokenNameDOT	
shouldMapAttrChar_ASCII	TokenNameIdentifier	 should Map Attr Char  ASCII
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
copy	TokenNameIdentifier	 copy
.	TokenNameDOT	
shouldMapAttrChar_ASCII	TokenNameIdentifier	 should Map Attr Char  ASCII
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
max	TokenNameIdentifier	 max
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
max	TokenNameIdentifier	 max
=	TokenNameEQUAL	
charInfo	TokenNameIdentifier	 char Info
.	TokenNameDOT	
shouldMapTextChar_ASCII	TokenNameIdentifier	 should Map Text Char  ASCII
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
charInfo	TokenNameIdentifier	 char Info
.	TokenNameDOT	
shouldMapTextChar_ASCII	TokenNameIdentifier	 should Map Text Char  ASCII
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
copy	TokenNameIdentifier	 copy
.	TokenNameDOT	
shouldMapTextChar_ASCII	TokenNameIdentifier	 should Map Text Char  ASCII
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
max	TokenNameIdentifier	 max
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// utility field copy.m_charKey is already created in the default constructor 	TokenNameCOMMENT_LINE	utility field copy.m_charKey is already created in the default constructor 
copy	TokenNameIdentifier	 copy
.	TokenNameDOT	
m_charToString	TokenNameIdentifier	 m char To String
=	TokenNameEQUAL	
(	TokenNameLPAREN	
HashMap	TokenNameIdentifier	 Hash Map
)	TokenNameRPAREN	
charInfo	TokenNameIdentifier	 char Info
.	TokenNameDOT	
m_charToString	TokenNameIdentifier	 m char To String
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
copy	TokenNameIdentifier	 copy
.	TokenNameDOT	
onlyQuotAmpLtGt	TokenNameIdentifier	 only Quot Amp Lt Gt
=	TokenNameEQUAL	
charInfo	TokenNameIdentifier	 char Info
.	TokenNameDOT	
onlyQuotAmpLtGt	TokenNameIdentifier	 only Quot Amp Lt Gt
;	TokenNameSEMICOLON	
return	TokenNamereturn	
copy	TokenNameIdentifier	 copy
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Table of user-specified char infos. * The table maps entify file names (the name of the * property file without the .properties extension) * to CharInfo objects populated with entities defined in * corresponding property file. */	TokenNameCOMMENT_JAVADOC	 Table of user-specified char infos. The table maps entify file names (the name of the property file without the .properties extension) to CharInfo objects populated with entities defined in corresponding property file. 
private	TokenNameprivate	
static	TokenNamestatic	
Hashtable	TokenNameIdentifier	 Hashtable
m_getCharInfoCache	TokenNameIdentifier	 m get Char Info Cache
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Returns the array element holding the bit value for the * given integer * @param i the integer that might be in the set of integers * */	TokenNameCOMMENT_JAVADOC	 Returns the array element holding the bit value for the given integer @param i the integer that might be in the set of integers 
private	TokenNameprivate	
static	TokenNamestatic	
int	TokenNameint	
arrayIndex	TokenNameIdentifier	 array Index
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
>>	TokenNameRIGHT_SHIFT	
SHIFT_PER_WORD	TokenNameIdentifier	 SHIFT  PER  WORD
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * For a given integer in the set it returns the single bit * value used within a given word that represents whether * the integer is in the set or not. */	TokenNameCOMMENT_JAVADOC	 For a given integer in the set it returns the single bit value used within a given word that represents whether the integer is in the set or not. 
private	TokenNameprivate	
static	TokenNamestatic	
int	TokenNameint	
bit	TokenNameIdentifier	 bit
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
ret	TokenNameIdentifier	 ret
=	TokenNameEQUAL	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
&	TokenNameAND	
LOW_ORDER_BITMASK	TokenNameIdentifier	 LOW  ORDER  BITMASK
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
ret	TokenNameIdentifier	 ret
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Creates a new empty set of integers (characters) * @param max the maximum integer to be in the set. */	TokenNameCOMMENT_JAVADOC	 Creates a new empty set of integers (characters) @param max the maximum integer to be in the set. 
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
createEmptySetOfIntegers	TokenNameIdentifier	 create Empty Set Of Integers
(	TokenNameLPAREN	
int	TokenNameint	
max	TokenNameIdentifier	 max
)	TokenNameRPAREN	
{	TokenNameLBRACE	
firstWordNotUsed	TokenNameIdentifier	 first Word Not Used
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// an optimization 	TokenNameCOMMENT_LINE	an optimization 
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
arr	TokenNameIdentifier	 arr
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
arrayIndex	TokenNameIdentifier	 array Index
(	TokenNameLPAREN	
max	TokenNameIdentifier	 max
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
arr	TokenNameIdentifier	 arr
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Adds the integer (character) to the set of integers. * @param i the integer to add to the set, valid values are * 0, 1, 2 ... up to the maximum that was specified at * the creation of the set. */	TokenNameCOMMENT_JAVADOC	 Adds the integer (character) to the set of integers. @param i the integer to add to the set, valid values are 0, 1, 2 ... up to the maximum that was specified at the creation of the set. 
private	TokenNameprivate	
final	TokenNamefinal	
void	TokenNamevoid	
set	TokenNameIdentifier	 set
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
setASCIItextDirty	TokenNameIdentifier	 set ASCI Itext Dirty
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setASCIIattrDirty	TokenNameIdentifier	 set ASCI Iattr Dirty
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
>>	TokenNameRIGHT_SHIFT	
SHIFT_PER_WORD	TokenNameIdentifier	 SHIFT  PER  WORD
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// this word is used 	TokenNameCOMMENT_LINE	this word is used 
int	TokenNameint	
k	TokenNameIdentifier	 k
=	TokenNameEQUAL	
j	TokenNameIdentifier	 j
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
firstWordNotUsed	TokenNameIdentifier	 first Word Not Used
<	TokenNameLESS	
k	TokenNameIdentifier	 k
)	TokenNameRPAREN	
// for optimization purposes. 	TokenNameCOMMENT_LINE	for optimization purposes. 
firstWordNotUsed	TokenNameIdentifier	 first Word Not Used
=	TokenNameEQUAL	
k	TokenNameIdentifier	 k
;	TokenNameSEMICOLON	
array_of_bits	TokenNameIdentifier	 array of bits
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
|=	TokenNameOR_EQUAL	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
&	TokenNameAND	
LOW_ORDER_BITMASK	TokenNameIdentifier	 LOW  ORDER  BITMASK
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return true if the integer (character)is in the set of integers. * * This implementation uses an array of integers with 32 bits per * integer. If a bit is set to 1 the corresponding integer is * in the set of integers. * * @param i an integer that is tested to see if it is the * set of integers, or not. */	TokenNameCOMMENT_JAVADOC	 Return true if the integer (character)is in the set of integers. * This implementation uses an array of integers with 32 bits per integer. If a bit is set to 1 the corresponding integer is in the set of integers. * @param i an integer that is tested to see if it is the set of integers, or not. 
private	TokenNameprivate	
final	TokenNamefinal	
boolean	TokenNameboolean	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
in_the_set	TokenNameIdentifier	 in the set
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
>>	TokenNameRIGHT_SHIFT	
SHIFT_PER_WORD	TokenNameIdentifier	 SHIFT  PER  WORD
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// wordIndex(i) 	TokenNameCOMMENT_LINE	wordIndex(i) 
// an optimization here, ... a quick test to see 	TokenNameCOMMENT_LINE	an optimization here, ... a quick test to see 
// if this integer is beyond any of the words in use 	TokenNameCOMMENT_LINE	if this integer is beyond any of the words in use 
if	TokenNameif	
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
firstWordNotUsed	TokenNameIdentifier	 first Word Not Used
)	TokenNameRPAREN	
in_the_set	TokenNameIdentifier	 in the set
=	TokenNameEQUAL	
(	TokenNameLPAREN	
array_of_bits	TokenNameIdentifier	 array of bits
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
&	TokenNameAND	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
&	TokenNameAND	
LOW_ORDER_BITMASK	TokenNameIdentifier	 LOW  ORDER  BITMASK
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// 0L for 64 bit words 	TokenNameCOMMENT_LINE	0L for 64 bit words 
return	TokenNamereturn	
in_the_set	TokenNameIdentifier	 in the set
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * This method returns true if there are some non-standard mappings to * entities other than quot, amp, lt, gt, and its only purpose is for * performance. * @param charToMap The value of the character that is mapped to a String * @param outputString The String to which the character is mapped, usually * an entity reference such as "&lt;". * @return true if the mapping is not one of: * <ul> * <li> '<' to "&lt;" * <li> '>' to "&gt;" * <li> '&' to "&amp;" * <li> '"' to "&quot;" * </ul> */	TokenNameCOMMENT_JAVADOC	 This method returns true if there are some non-standard mappings to entities other than quot, amp, lt, gt, and its only purpose is for performance. @param charToMap The value of the character that is mapped to a String @param outputString The String to which the character is mapped, usually an entity reference such as "&lt;". @return true if the mapping is not one of: <ul> <li> '<' to "&lt;" <li> '>' to "&gt;" <li> '&' to "&amp;" <li> '"' to "&quot;" </ul> 
private	TokenNameprivate	
boolean	TokenNameboolean	
extraEntity	TokenNameIdentifier	 extra Entity
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
outputString	TokenNameIdentifier	 output String
,	TokenNameCOMMA	
int	TokenNameint	
charToMap	TokenNameIdentifier	 char To Map
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
extra	TokenNameIdentifier	 extra
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
charToMap	TokenNameIdentifier	 char To Map
<	TokenNameLESS	
ASCII_MAX	TokenNameIdentifier	 ASCII  MAX
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
charToMap	TokenNameIdentifier	 char To Map
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
'"'	TokenNameCharacterLiteral	
:	TokenNameCOLON	
// quot 	TokenNameCOMMENT_LINE	quot 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
outputString	TokenNameIdentifier	 output String
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"&quot;"	TokenNameStringLiteral	&quot;
)	TokenNameRPAREN	
)	TokenNameRPAREN	
extra	TokenNameIdentifier	 extra
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
'&'	TokenNameCharacterLiteral	
:	TokenNameCOLON	
// amp 	TokenNameCOMMENT_LINE	amp 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
outputString	TokenNameIdentifier	 output String
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"&amp;"	TokenNameStringLiteral	&amp;
)	TokenNameRPAREN	
)	TokenNameRPAREN	
extra	TokenNameIdentifier	 extra
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
'<'	TokenNameCharacterLiteral	
:	TokenNameCOLON	
// lt 	TokenNameCOMMENT_LINE	lt 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
outputString	TokenNameIdentifier	 output String
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"&lt;"	TokenNameStringLiteral	&lt;
)	TokenNameRPAREN	
)	TokenNameRPAREN	
extra	TokenNameIdentifier	 extra
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
'>'	TokenNameCharacterLiteral	
:	TokenNameCOLON	
// gt 	TokenNameCOMMENT_LINE	gt 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
outputString	TokenNameIdentifier	 output String
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"&gt;"	TokenNameStringLiteral	&gt;
)	TokenNameRPAREN	
)	TokenNameRPAREN	
extra	TokenNameIdentifier	 extra
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
// other entity in range 0 to 127 	TokenNameCOMMENT_LINE	other entity in range 0 to 127 
extra	TokenNameIdentifier	 extra
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
extra	TokenNameIdentifier	 extra
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * If the character is in the ASCII range then * mark it as needing replacement with * a String on output if it occurs in a text node. * @param ch */	TokenNameCOMMENT_JAVADOC	 If the character is in the ASCII range then mark it as needing replacement with a String on output if it occurs in a text node. @param ch 
private	TokenNameprivate	
void	TokenNamevoid	
setASCIItextDirty	TokenNameIdentifier	 set ASCI Itext Dirty
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
<=	TokenNameLESS_EQUAL	
j	TokenNameIdentifier	 j
&&	TokenNameAND_AND	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
ASCII_MAX	TokenNameIdentifier	 ASCII  MAX
)	TokenNameRPAREN	
{	TokenNameLBRACE	
shouldMapTextChar_ASCII	TokenNameIdentifier	 should Map Text Char  ASCII
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * If the character is in the ASCII range then * mark it as needing replacement with * a String on output if it occurs in a attribute value. * @param ch */	TokenNameCOMMENT_JAVADOC	 If the character is in the ASCII range then mark it as needing replacement with a String on output if it occurs in a attribute value. @param ch 
private	TokenNameprivate	
void	TokenNamevoid	
setASCIIattrDirty	TokenNameIdentifier	 set ASCI Iattr Dirty
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
<=	TokenNameLESS_EQUAL	
j	TokenNameIdentifier	 j
&&	TokenNameAND_AND	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
ASCII_MAX	TokenNameIdentifier	 ASCII  MAX
)	TokenNameRPAREN	
{	TokenNameLBRACE	
shouldMapAttrChar_ASCII	TokenNameIdentifier	 should Map Attr Char  ASCII
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Call this method to register a char to String mapping, for example * to map '<' to "&lt;". * @param outputString The String to map to. * @param inputChar The char to map from. * @return true if the mapping is not one of: * <ul> * <li> '<' to "&lt;" * <li> '>' to "&gt;" * <li> '&' to "&amp;" * <li> '"' to "&quot;" * </ul> */	TokenNameCOMMENT_JAVADOC	 Call this method to register a char to String mapping, for example to map '<' to "&lt;". @param outputString The String to map to. @param inputChar The char to map from. @return true if the mapping is not one of: <ul> <li> '<' to "&lt;" <li> '>' to "&gt;" <li> '&' to "&amp;" <li> '"' to "&quot;" </ul> 
boolean	TokenNameboolean	
defineChar2StringMapping	TokenNameIdentifier	 define Char2 String Mapping
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
outputString	TokenNameIdentifier	 output String
,	TokenNameCOMMA	
char	TokenNamechar	
inputChar	TokenNameIdentifier	 input Char
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CharKey	TokenNameIdentifier	 Char Key
character	TokenNameIdentifier	 character
=	TokenNameEQUAL	
new	TokenNamenew	
CharKey	TokenNameIdentifier	 Char Key
(	TokenNameLPAREN	
inputChar	TokenNameIdentifier	 input Char
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
m_charToString	TokenNameIdentifier	 m char To String
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
character	TokenNameIdentifier	 character
,	TokenNameCOMMA	
outputString	TokenNameIdentifier	 output String
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
set	TokenNameIdentifier	 set
(	TokenNameLPAREN	
inputChar	TokenNameIdentifier	 input Char
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// mark the character has having a mapping to a String 	TokenNameCOMMENT_LINE	mark the character has having a mapping to a String 
boolean	TokenNameboolean	
extraMapping	TokenNameIdentifier	 extra Mapping
=	TokenNameEQUAL	
extraEntity	TokenNameIdentifier	 extra Entity
(	TokenNameLPAREN	
outputString	TokenNameIdentifier	 output String
,	TokenNameCOMMA	
inputChar	TokenNameIdentifier	 input Char
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
extraMapping	TokenNameIdentifier	 extra Mapping
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Simple class for fast lookup of char values, when used with * hashtables. You can set the char, then use it as a key. * * @xsl.usage internal */	TokenNameCOMMENT_JAVADOC	 Simple class for fast lookup of char values, when used with hashtables. You can set the char, then use it as a key. * @xsl.usage internal 
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
CharKey	TokenNameIdentifier	 Char Key
extends	TokenNameextends	
Object	TokenNameIdentifier	 Object
{	TokenNameLBRACE	
/** String value */	TokenNameCOMMENT_JAVADOC	 String value 
private	TokenNameprivate	
char	TokenNamechar	
m_char	TokenNameIdentifier	 m char
;	TokenNameSEMICOLON	
/** * Constructor CharKey * * @param key char value of this object. */	TokenNameCOMMENT_JAVADOC	 Constructor CharKey * @param key char value of this object. 
public	TokenNamepublic	
CharKey	TokenNameIdentifier	 Char Key
(	TokenNameLPAREN	
char	TokenNamechar	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
m_char	TokenNameIdentifier	 m char
=	TokenNameEQUAL	
key	TokenNameIdentifier	 key
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Default constructor for a CharKey. * * @param key char value of this object. */	TokenNameCOMMENT_JAVADOC	 Default constructor for a CharKey. * @param key char value of this object. 
public	TokenNamepublic	
CharKey	TokenNameIdentifier	 Char Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
/** * Get the hash value of the character. * * @return hash value of the character. */	TokenNameCOMMENT_JAVADOC	 Get the hash value of the character. * @return hash value of the character. 
public	TokenNamepublic	
final	TokenNamefinal	
void	TokenNamevoid	
setChar	TokenNameIdentifier	 set Char
(	TokenNameLPAREN	
char	TokenNamechar	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
{	TokenNameLBRACE	
m_char	TokenNameIdentifier	 m char
=	TokenNameEQUAL	
c	TokenNameIdentifier	 c
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the hash value of the character. * * @return hash value of the character. */	TokenNameCOMMENT_JAVADOC	 Get the hash value of the character. * @return hash value of the character. 
public	TokenNamepublic	
final	TokenNamefinal	
int	TokenNameint	
hashCode	TokenNameIdentifier	 hash Code
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
m_char	TokenNameIdentifier	 m char
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Override of equals() for this object * * @param obj to compare to * * @return True if this object equals this string value */	TokenNameCOMMENT_JAVADOC	 Override of equals() for this object * @param obj to compare to * @return True if this object equals this string value 
public	TokenNamepublic	
final	TokenNamefinal	
boolean	TokenNameboolean	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
obj	TokenNameIdentifier	 obj
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
CharKey	TokenNameIdentifier	 Char Key
)	TokenNameRPAREN	
obj	TokenNameIdentifier	 obj
)	TokenNameRPAREN	
.	TokenNameDOT	
m_char	TokenNameIdentifier	 m char
==	TokenNameEQUAL_EQUAL	
m_char	TokenNameIdentifier	 m char
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
