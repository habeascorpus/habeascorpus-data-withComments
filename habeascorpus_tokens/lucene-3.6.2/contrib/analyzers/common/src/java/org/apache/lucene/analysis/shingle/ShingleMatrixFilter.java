package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
shingle	TokenNameIdentifier	 shingle
;	TokenNameSEMICOLON	
/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_JAVADOC	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
HashSet	TokenNameIdentifier	 Hash Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Iterator	TokenNameIdentifier	 Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
LinkedList	TokenNameIdentifier	 Linked List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
List	TokenNameIdentifier	 List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
NoSuchElementException	TokenNameIdentifier	 No Such Element Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Set	TokenNameIdentifier	 Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
Token	TokenNameIdentifier	 Token
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
TokenStream	TokenNameIdentifier	 Token Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
miscellaneous	TokenNameIdentifier	 miscellaneous
.	TokenNameDOT	
EmptyTokenStream	TokenNameIdentifier	 Empty Token Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
payloads	TokenNameIdentifier	 payloads
.	TokenNameDOT	
PayloadHelper	TokenNameIdentifier	 Payload Helper
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
shingle	TokenNameIdentifier	 shingle
.	TokenNameDOT	
ShingleMatrixFilter	TokenNameIdentifier	 Shingle Matrix Filter
.	TokenNameDOT	
Matrix	TokenNameIdentifier	 Matrix
.	TokenNameDOT	
Column	TokenNameIdentifier	 Column
.	TokenNameDOT	
Row	TokenNameIdentifier	 Row
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
tokenattributes	TokenNameIdentifier	 tokenattributes
.	TokenNameDOT	
CharTermAttribute	TokenNameIdentifier	 Char Term Attribute
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
tokenattributes	TokenNameIdentifier	 tokenattributes
.	TokenNameDOT	
FlagsAttribute	TokenNameIdentifier	 Flags Attribute
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
tokenattributes	TokenNameIdentifier	 tokenattributes
.	TokenNameDOT	
OffsetAttribute	TokenNameIdentifier	 Offset Attribute
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
tokenattributes	TokenNameIdentifier	 tokenattributes
.	TokenNameDOT	
PayloadAttribute	TokenNameIdentifier	 Payload Attribute
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
tokenattributes	TokenNameIdentifier	 tokenattributes
.	TokenNameDOT	
PositionIncrementAttribute	TokenNameIdentifier	 Position Increment Attribute
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
tokenattributes	TokenNameIdentifier	 tokenattributes
.	TokenNameDOT	
TypeAttribute	TokenNameIdentifier	 Type Attribute
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
Payload	TokenNameIdentifier	 Payload
;	TokenNameSEMICOLON	
/** * <p>A ShingleMatrixFilter constructs shingles (token n-grams) from a token stream. * In other words, it creates combinations of tokens as a single token. * * <p>For example, the sentence "please divide this sentence into shingles" * might be tokenized into shingles "please divide", "divide this", * "this sentence", "sentence into", and "into shingles". * * <p>Using a shingle filter at index and query time can in some instances * be used to replace phrase queries, especially them with 0 slop. * * <p>Without a spacer character * it can be used to handle composition and decomposition of words * such as searching for "multi dimensional" instead of "multidimensional". * It is a rather common human problem at query time * in several languages, notably the northern Germanic branch. * * <p>Shingles are amongst many things also known to solve problems * in spell checking, language detection and document clustering. * * <p>This filter is backed by a three dimensional column oriented matrix * used to create permutations of the second dimension, the rows, * and leaves the third, the z-axis, for for multi token synonyms. * * <p>In order to use this filter you need to define a way of positioning * the input stream tokens in the matrix. This is done using a * {@link org.apache.lucene.analysis.shingle.ShingleMatrixFilter.TokenSettingsCodec}. * There are three simple implementations for demonstrational purposes, * see {@link org.apache.lucene.analysis.shingle.ShingleMatrixFilter.OneDimensionalNonWeightedTokenSettingsCodec}, * {@link org.apache.lucene.analysis.shingle.ShingleMatrixFilter.TwoDimensionalNonWeightedSynonymTokenSettingsCodec} * and {@link org.apache.lucene.analysis.shingle.ShingleMatrixFilter.SimpleThreeDimensionalTokenSettingsCodec}. * * <p>Consider this token matrix: * <pre> * Token[column][row][z-axis]{ * {{hello}, {greetings, and, salutations}}, * {{world}, {earth}, {tellus}} * }; * </pre> * * It would produce the following 2-3 gram sized shingles: * * <pre> * "hello_world" * "greetings_and" * "greetings_and_salutations" * "and_salutations" * "and_salutations_world" * "salutations_world" * "hello_earth" * "and_salutations_earth" * "salutations_earth" * "hello_tellus" * "and_salutations_tellus" * "salutations_tellus" * </pre> * * <p>This implementation can be rather heap demanding * if (maximum shingle size - minimum shingle size) is a great number and the stream contains many columns, * or if each column contains a great number of rows. * * <p>The problem is that in order avoid producing duplicates * the filter needs to keep track of any shingle already produced and returned to the consumer. * * There is a bit of resource management to handle this * but it would of course be much better if the filter was written * so it never created the same shingle more than once in the first place. * * <p>The filter also has basic support for calculating weights for the shingles * based on the weights of the tokens from the input stream, output shingle size, etc. * See {@link #calculateShingleWeight(org.apache.lucene.analysis.Token, java.util.List, int, java.util.List, java.util.List)}. * <p/> * @deprecated Will be removed in Lucene 4.0. This filter is unmaintained and might not behave * correctly if used with custom Attributes, i.e. Attributes other than * the ones located in <code>org.apache.lucene.analysis.tokenattributes</code>. It also uses * hardcoded payload encoders which makes it not easily adaptable to other use-cases. */	TokenNameCOMMENT_JAVADOC	 <p>A ShingleMatrixFilter constructs shingles (token n-grams) from a token stream. In other words, it creates combinations of tokens as a single token. * <p>For example, the sentence "please divide this sentence into shingles" might be tokenized into shingles "please divide", "divide this", "this sentence", "sentence into", and "into shingles". * <p>Using a shingle filter at index and query time can in some instances be used to replace phrase queries, especially them with 0 slop. * <p>Without a spacer character it can be used to handle composition and decomposition of words such as searching for "multi dimensional" instead of "multidimensional". It is a rather common human problem at query time in several languages, notably the northern Germanic branch. * <p>Shingles are amongst many things also known to solve problems in spell checking, language detection and document clustering. * <p>This filter is backed by a three dimensional column oriented matrix used to create permutations of the second dimension, the rows, and leaves the third, the z-axis, for for multi token synonyms. * <p>In order to use this filter you need to define a way of positioning the input stream tokens in the matrix. This is done using a {@link org.apache.lucene.analysis.shingle.ShingleMatrixFilter.TokenSettingsCodec}. There are three simple implementations for demonstrational purposes, see {@link org.apache.lucene.analysis.shingle.ShingleMatrixFilter.OneDimensionalNonWeightedTokenSettingsCodec}, {@link org.apache.lucene.analysis.shingle.ShingleMatrixFilter.TwoDimensionalNonWeightedSynonymTokenSettingsCodec} and {@link org.apache.lucene.analysis.shingle.ShingleMatrixFilter.SimpleThreeDimensionalTokenSettingsCodec}. * <p>Consider this token matrix: <pre> Token[column][row][z-axis]{ {{hello}, {greetings, and, salutations}}, {{world}, {earth}, {tellus}} }; </pre> * It would produce the following 2-3 gram sized shingles: * <pre> "hello_world" "greetings_and" "greetings_and_salutations" "and_salutations" "and_salutations_world" "salutations_world" "hello_earth" "and_salutations_earth" "salutations_earth" "hello_tellus" "and_salutations_tellus" "salutations_tellus" </pre> * <p>This implementation can be rather heap demanding if (maximum shingle size - minimum shingle size) is a great number and the stream contains many columns, or if each column contains a great number of rows. * <p>The problem is that in order avoid producing duplicates the filter needs to keep track of any shingle already produced and returned to the consumer. * There is a bit of resource management to handle this but it would of course be much better if the filter was written so it never created the same shingle more than once in the first place. * <p>The filter also has basic support for calculating weights for the shingles based on the weights of the tokens from the input stream, output shingle size, etc. See {@link #calculateShingleWeight(org.apache.lucene.analysis.Token, java.util.List, int, java.util.List, java.util.List)}. <p/> @deprecated Will be removed in Lucene 4.0. This filter is unmaintained and might not behave correctly if used with custom Attributes, i.e. Attributes other than the ones located in <code>org.apache.lucene.analysis.tokenattributes</code>. It also uses hardcoded payload encoders which makes it not easily adaptable to other use-cases. 
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
public	TokenNamepublic	
final	TokenNamefinal	
class	TokenNameclass	
ShingleMatrixFilter	TokenNameIdentifier	 Shingle Matrix Filter
extends	TokenNameextends	
TokenStream	TokenNameIdentifier	 Token Stream
{	TokenNameLBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
Character	TokenNameIdentifier	 Character
defaultSpacerCharacter	TokenNameIdentifier	 default Spacer Character
=	TokenNameEQUAL	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
'_'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
TokenSettingsCodec	TokenNameIdentifier	 Token Settings Codec
defaultSettingsCodec	TokenNameIdentifier	 default Settings Codec
=	TokenNameEQUAL	
new	TokenNamenew	
OneDimensionalNonWeightedTokenSettingsCodec	TokenNameIdentifier	 One Dimensional Non Weighted Token Settings Codec
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
ignoringSinglePrefixOrSuffixShingleByDefault	TokenNameIdentifier	 ignoring Single Prefix Or Suffix Shingle By Default
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** * Strategy used to code and decode meta data of the tokens from the input stream * regarding how to position the tokens in the matrix, set and retreive weight, et c. */	TokenNameCOMMENT_JAVADOC	 Strategy used to code and decode meta data of the tokens from the input stream regarding how to position the tokens in the matrix, set and retreive weight, et c. 
public	TokenNamepublic	
static	TokenNamestatic	
abstract	TokenNameabstract	
class	TokenNameclass	
TokenSettingsCodec	TokenNameIdentifier	 Token Settings Codec
{	TokenNameLBRACE	
/** * Retrieves information on how a {@link org.apache.lucene.analysis.Token} is to be inserted to a {@link org.apache.lucene.analysis.shingle.ShingleMatrixFilter.Matrix}. * @param token * @return {@link ShingleMatrixFilter.TokenPositioner} * @throws IOException */	TokenNameCOMMENT_JAVADOC	 Retrieves information on how a {@link org.apache.lucene.analysis.Token} is to be inserted to a {@link org.apache.lucene.analysis.shingle.ShingleMatrixFilter.Matrix}. @param token @return {@link ShingleMatrixFilter.TokenPositioner} @throws IOException 
public	TokenNamepublic	
abstract	TokenNameabstract	
TokenPositioner	TokenNameIdentifier	 Token Positioner
getTokenPositioner	TokenNameIdentifier	 get Token Positioner
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
/** * Sets information on how a {@link org.apache.lucene.analysis.Token} is to be inserted to a {@link org.apache.lucene.analysis.shingle.ShingleMatrixFilter.Matrix}. * * @param token * @param tokenPositioner */	TokenNameCOMMENT_JAVADOC	 Sets information on how a {@link org.apache.lucene.analysis.Token} is to be inserted to a {@link org.apache.lucene.analysis.shingle.ShingleMatrixFilter.Matrix}. * @param token @param tokenPositioner 
public	TokenNamepublic	
abstract	TokenNameabstract	
void	TokenNamevoid	
setTokenPositioner	TokenNameIdentifier	 set Token Positioner
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
ShingleMatrixFilter	TokenNameIdentifier	 Shingle Matrix Filter
.	TokenNameDOT	
TokenPositioner	TokenNameIdentifier	 Token Positioner
tokenPositioner	TokenNameIdentifier	 token Positioner
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Have this method return 1f in order to 'disable' weights. * @param token * @return the weight of parameter token */	TokenNameCOMMENT_JAVADOC	 Have this method return 1f in order to 'disable' weights. @param token @return the weight of parameter token 
public	TokenNamepublic	
abstract	TokenNameabstract	
float	TokenNamefloat	
getWeight	TokenNameIdentifier	 get Weight
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Have this method do nothing in order to 'disable' weights. * @param token * @param weight */	TokenNameCOMMENT_JAVADOC	 Have this method do nothing in order to 'disable' weights. @param token @param weight 
public	TokenNamepublic	
abstract	TokenNameabstract	
void	TokenNamevoid	
setWeight	TokenNameIdentifier	 set Weight
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
float	TokenNamefloat	
weight	TokenNameIdentifier	 weight
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Used to describe how a {@link org.apache.lucene.analysis.Token} is to be inserted to a {@link org.apache.lucene.analysis.shingle.ShingleMatrixFilter.Matrix}. * @see org.apache.lucene.analysis.shingle.ShingleMatrixFilter.TokenSettingsCodec#getTokenPositioner(org.apache.lucene.analysis.Token) * @see org.apache.lucene.analysis.shingle.ShingleMatrixFilter.TokenSettingsCodec#setTokenPositioner(org.apache.lucene.analysis.Token,org.apache.lucene.analysis.shingle.ShingleMatrixFilter.TokenPositioner) */	TokenNameCOMMENT_JAVADOC	 Used to describe how a {@link org.apache.lucene.analysis.Token} is to be inserted to a {@link org.apache.lucene.analysis.shingle.ShingleMatrixFilter.Matrix}. @see org.apache.lucene.analysis.shingle.ShingleMatrixFilter.TokenSettingsCodec#getTokenPositioner(org.apache.lucene.analysis.Token) @see org.apache.lucene.analysis.shingle.ShingleMatrixFilter.TokenSettingsCodec#setTokenPositioner(org.apache.lucene.analysis.Token,org.apache.lucene.analysis.shingle.ShingleMatrixFilter.TokenPositioner) 
public	TokenNamepublic	
static	TokenNamestatic	
class	TokenNameclass	
TokenPositioner	TokenNameIdentifier	 Token Positioner
{	TokenNameLBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
TokenPositioner	TokenNameIdentifier	 Token Positioner
newColumn	TokenNameIdentifier	 new Column
=	TokenNameEQUAL	
new	TokenNamenew	
TokenPositioner	TokenNameIdentifier	 Token Positioner
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
TokenPositioner	TokenNameIdentifier	 Token Positioner
newRow	TokenNameIdentifier	 new Row
=	TokenNameEQUAL	
new	TokenNamenew	
TokenPositioner	TokenNameIdentifier	 Token Positioner
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
TokenPositioner	TokenNameIdentifier	 Token Positioner
sameRow	TokenNameIdentifier	 same Row
=	TokenNameEQUAL	
new	TokenNamenew	
TokenPositioner	TokenNameIdentifier	 Token Positioner
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
index	TokenNameIdentifier	 index
;	TokenNameSEMICOLON	
private	TokenNameprivate	
TokenPositioner	TokenNameIdentifier	 Token Positioner
(	TokenNameLPAREN	
int	TokenNameint	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
index	TokenNameIdentifier	 index
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getIndex	TokenNameIdentifier	 get Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
index	TokenNameIdentifier	 index
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// filter instance settings variables 	TokenNameCOMMENT_LINE	filter instance settings variables 
private	TokenNameprivate	
TokenSettingsCodec	TokenNameIdentifier	 Token Settings Codec
settingsCodec	TokenNameIdentifier	 settings Codec
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
minimumShingleSize	TokenNameIdentifier	 minimum Shingle Size
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
maximumShingleSize	TokenNameIdentifier	 maximum Shingle Size
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
ignoringSinglePrefixOrSuffixShingle	TokenNameIdentifier	 ignoring Single Prefix Or Suffix Shingle
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Character	TokenNameIdentifier	 Character
spacerCharacter	TokenNameIdentifier	 spacer Character
=	TokenNameEQUAL	
defaultSpacerCharacter	TokenNameIdentifier	 default Spacer Character
;	TokenNameSEMICOLON	
private	TokenNameprivate	
TokenStream	TokenNameIdentifier	 Token Stream
input	TokenNameIdentifier	 input
;	TokenNameSEMICOLON	
private	TokenNameprivate	
CharTermAttribute	TokenNameIdentifier	 Char Term Attribute
termAtt	TokenNameIdentifier	 term Att
;	TokenNameSEMICOLON	
private	TokenNameprivate	
PositionIncrementAttribute	TokenNameIdentifier	 Position Increment Attribute
posIncrAtt	TokenNameIdentifier	 pos Incr Att
;	TokenNameSEMICOLON	
private	TokenNameprivate	
PayloadAttribute	TokenNameIdentifier	 Payload Attribute
payloadAtt	TokenNameIdentifier	 payload Att
;	TokenNameSEMICOLON	
private	TokenNameprivate	
OffsetAttribute	TokenNameIdentifier	 Offset Attribute
offsetAtt	TokenNameIdentifier	 offset Att
;	TokenNameSEMICOLON	
private	TokenNameprivate	
TypeAttribute	TokenNameIdentifier	 Type Attribute
typeAtt	TokenNameIdentifier	 type Att
;	TokenNameSEMICOLON	
private	TokenNameprivate	
FlagsAttribute	TokenNameIdentifier	 Flags Attribute
flagsAtt	TokenNameIdentifier	 flags Att
;	TokenNameSEMICOLON	
private	TokenNameprivate	
CharTermAttribute	TokenNameIdentifier	 Char Term Attribute
in_termAtt	TokenNameIdentifier	 in term Att
;	TokenNameSEMICOLON	
private	TokenNameprivate	
PositionIncrementAttribute	TokenNameIdentifier	 Position Increment Attribute
in_posIncrAtt	TokenNameIdentifier	 in pos Incr Att
;	TokenNameSEMICOLON	
private	TokenNameprivate	
PayloadAttribute	TokenNameIdentifier	 Payload Attribute
in_payloadAtt	TokenNameIdentifier	 in payload Att
;	TokenNameSEMICOLON	
private	TokenNameprivate	
OffsetAttribute	TokenNameIdentifier	 Offset Attribute
in_offsetAtt	TokenNameIdentifier	 in offset Att
;	TokenNameSEMICOLON	
private	TokenNameprivate	
TypeAttribute	TokenNameIdentifier	 Type Attribute
in_typeAtt	TokenNameIdentifier	 in type Att
;	TokenNameSEMICOLON	
private	TokenNameprivate	
FlagsAttribute	TokenNameIdentifier	 Flags Attribute
in_flagsAtt	TokenNameIdentifier	 in flags Att
;	TokenNameSEMICOLON	
/** * Creates a shingle filter based on a user defined matrix. * * The filter /will/ delete columns from the input matrix! You will not be able to reset the filter if you used this constructor. * todo: don't touch the matrix! use a boolean, set the input stream to null or something, and keep track of where in the matrix we are at. * * @param matrix the input based for creating shingles. Does not need to contain any information until {@link #incrementToken()} is called the first time. * @param minimumShingleSize minimum number of tokens in any shingle. * @param maximumShingleSize maximum number of tokens in any shingle. * @param spacerCharacter character to use between texts of the token parts in a shingle. null for none. * @param ignoringSinglePrefixOrSuffixShingle if true, shingles that only contains permutation of the first of the last column will not be produced as shingles. Useful when adding boundary marker tokens such as '^' and '$'. * @param settingsCodec codec used to read input token weight and matrix positioning. */	TokenNameCOMMENT_JAVADOC	 Creates a shingle filter based on a user defined matrix. * The filter /will/ delete columns from the input matrix! You will not be able to reset the filter if you used this constructor. todo: don't touch the matrix! use a boolean, set the input stream to null or something, and keep track of where in the matrix we are at. * @param matrix the input based for creating shingles. Does not need to contain any information until {@link #incrementToken()} is called the first time. @param minimumShingleSize minimum number of tokens in any shingle. @param maximumShingleSize maximum number of tokens in any shingle. @param spacerCharacter character to use between texts of the token parts in a shingle. null for none. @param ignoringSinglePrefixOrSuffixShingle if true, shingles that only contains permutation of the first of the last column will not be produced as shingles. Useful when adding boundary marker tokens such as '^' and '$'. @param settingsCodec codec used to read input token weight and matrix positioning. 
public	TokenNamepublic	
ShingleMatrixFilter	TokenNameIdentifier	 Shingle Matrix Filter
(	TokenNameLPAREN	
Matrix	TokenNameIdentifier	 Matrix
matrix	TokenNameIdentifier	 matrix
,	TokenNameCOMMA	
int	TokenNameint	
minimumShingleSize	TokenNameIdentifier	 minimum Shingle Size
,	TokenNameCOMMA	
int	TokenNameint	
maximumShingleSize	TokenNameIdentifier	 maximum Shingle Size
,	TokenNameCOMMA	
Character	TokenNameIdentifier	 Character
spacerCharacter	TokenNameIdentifier	 spacer Character
,	TokenNameCOMMA	
boolean	TokenNameboolean	
ignoringSinglePrefixOrSuffixShingle	TokenNameIdentifier	 ignoring Single Prefix Or Suffix Shingle
,	TokenNameCOMMA	
TokenSettingsCodec	TokenNameIdentifier	 Token Settings Codec
settingsCodec	TokenNameIdentifier	 settings Codec
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
matrix	TokenNameIdentifier	 matrix
=	TokenNameEQUAL	
matrix	TokenNameIdentifier	 matrix
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
minimumShingleSize	TokenNameIdentifier	 minimum Shingle Size
=	TokenNameEQUAL	
minimumShingleSize	TokenNameIdentifier	 minimum Shingle Size
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
maximumShingleSize	TokenNameIdentifier	 maximum Shingle Size
=	TokenNameEQUAL	
maximumShingleSize	TokenNameIdentifier	 maximum Shingle Size
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
spacerCharacter	TokenNameIdentifier	 spacer Character
=	TokenNameEQUAL	
spacerCharacter	TokenNameIdentifier	 spacer Character
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
ignoringSinglePrefixOrSuffixShingle	TokenNameIdentifier	 ignoring Single Prefix Or Suffix Shingle
=	TokenNameEQUAL	
ignoringSinglePrefixOrSuffixShingle	TokenNameIdentifier	 ignoring Single Prefix Or Suffix Shingle
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
settingsCodec	TokenNameIdentifier	 settings Codec
=	TokenNameEQUAL	
settingsCodec	TokenNameIdentifier	 settings Codec
;	TokenNameSEMICOLON	
termAtt	TokenNameIdentifier	 term Att
=	TokenNameEQUAL	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
CharTermAttribute	TokenNameIdentifier	 Char Term Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
posIncrAtt	TokenNameIdentifier	 pos Incr Att
=	TokenNameEQUAL	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
PositionIncrementAttribute	TokenNameIdentifier	 Position Increment Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
payloadAtt	TokenNameIdentifier	 payload Att
=	TokenNameEQUAL	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
PayloadAttribute	TokenNameIdentifier	 Payload Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
offsetAtt	TokenNameIdentifier	 offset Att
=	TokenNameEQUAL	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
OffsetAttribute	TokenNameIdentifier	 Offset Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
typeAtt	TokenNameIdentifier	 type Att
=	TokenNameEQUAL	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
TypeAttribute	TokenNameIdentifier	 Type Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
flagsAtt	TokenNameIdentifier	 flags Att
=	TokenNameEQUAL	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
FlagsAttribute	TokenNameIdentifier	 Flags Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// set the input to be an empty token stream, we already have the data. 	TokenNameCOMMENT_LINE	set the input to be an empty token stream, we already have the data. 
this	TokenNamethis	
.	TokenNameDOT	
input	TokenNameIdentifier	 input
=	TokenNameEQUAL	
new	TokenNamenew	
EmptyTokenStream	TokenNameIdentifier	 Empty Token Stream
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
in_termAtt	TokenNameIdentifier	 in term Att
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
CharTermAttribute	TokenNameIdentifier	 Char Term Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
in_posIncrAtt	TokenNameIdentifier	 in pos Incr Att
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
PositionIncrementAttribute	TokenNameIdentifier	 Position Increment Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
in_payloadAtt	TokenNameIdentifier	 in payload Att
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
PayloadAttribute	TokenNameIdentifier	 Payload Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
in_offsetAtt	TokenNameIdentifier	 in offset Att
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
OffsetAttribute	TokenNameIdentifier	 Offset Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
in_typeAtt	TokenNameIdentifier	 in type Att
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
TypeAttribute	TokenNameIdentifier	 Type Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
in_flagsAtt	TokenNameIdentifier	 in flags Att
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
FlagsAttribute	TokenNameIdentifier	 Flags Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Creates a shingle filter using default settings. * * @see #defaultSpacerCharacter * @see #ignoringSinglePrefixOrSuffixShingleByDefault * @see #defaultSettingsCodec * * @param input stream from which to construct the matrix * @param minimumShingleSize minimum number of tokens in any shingle. * @param maximumShingleSize maximum number of tokens in any shingle. */	TokenNameCOMMENT_JAVADOC	 Creates a shingle filter using default settings. * @see #defaultSpacerCharacter @see #ignoringSinglePrefixOrSuffixShingleByDefault @see #defaultSettingsCodec * @param input stream from which to construct the matrix @param minimumShingleSize minimum number of tokens in any shingle. @param maximumShingleSize maximum number of tokens in any shingle. 
public	TokenNamepublic	
ShingleMatrixFilter	TokenNameIdentifier	 Shingle Matrix Filter
(	TokenNameLPAREN	
TokenStream	TokenNameIdentifier	 Token Stream
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
int	TokenNameint	
minimumShingleSize	TokenNameIdentifier	 minimum Shingle Size
,	TokenNameCOMMA	
int	TokenNameint	
maximumShingleSize	TokenNameIdentifier	 maximum Shingle Size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
minimumShingleSize	TokenNameIdentifier	 minimum Shingle Size
,	TokenNameCOMMA	
maximumShingleSize	TokenNameIdentifier	 maximum Shingle Size
,	TokenNameCOMMA	
defaultSpacerCharacter	TokenNameIdentifier	 default Spacer Character
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Creates a shingle filter using default settings. * * @see #ignoringSinglePrefixOrSuffixShingleByDefault * @see #defaultSettingsCodec * * @param input stream from which to construct the matrix * @param minimumShingleSize minimum number of tokens in any shingle. * @param maximumShingleSize maximum number of tokens in any shingle. * @param spacerCharacter character to use between texts of the token parts in a shingle. null for none. */	TokenNameCOMMENT_JAVADOC	 Creates a shingle filter using default settings. * @see #ignoringSinglePrefixOrSuffixShingleByDefault @see #defaultSettingsCodec * @param input stream from which to construct the matrix @param minimumShingleSize minimum number of tokens in any shingle. @param maximumShingleSize maximum number of tokens in any shingle. @param spacerCharacter character to use between texts of the token parts in a shingle. null for none. 
public	TokenNamepublic	
ShingleMatrixFilter	TokenNameIdentifier	 Shingle Matrix Filter
(	TokenNameLPAREN	
TokenStream	TokenNameIdentifier	 Token Stream
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
int	TokenNameint	
minimumShingleSize	TokenNameIdentifier	 minimum Shingle Size
,	TokenNameCOMMA	
int	TokenNameint	
maximumShingleSize	TokenNameIdentifier	 maximum Shingle Size
,	TokenNameCOMMA	
Character	TokenNameIdentifier	 Character
spacerCharacter	TokenNameIdentifier	 spacer Character
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
minimumShingleSize	TokenNameIdentifier	 minimum Shingle Size
,	TokenNameCOMMA	
maximumShingleSize	TokenNameIdentifier	 maximum Shingle Size
,	TokenNameCOMMA	
spacerCharacter	TokenNameIdentifier	 spacer Character
,	TokenNameCOMMA	
ignoringSinglePrefixOrSuffixShingleByDefault	TokenNameIdentifier	 ignoring Single Prefix Or Suffix Shingle By Default
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Creates a shingle filter using the default {@link TokenSettingsCodec}. * * @see #defaultSettingsCodec * * @param input stream from which to construct the matrix * @param minimumShingleSize minimum number of tokens in any shingle. * @param maximumShingleSize maximum number of tokens in any shingle. * @param spacerCharacter character to use between texts of the token parts in a shingle. null for none. * @param ignoringSinglePrefixOrSuffixShingle if true, shingles that only contains permutation of the first of the last column will not be produced as shingles. Useful when adding boundary marker tokens such as '^' and '$'. */	TokenNameCOMMENT_JAVADOC	 Creates a shingle filter using the default {@link TokenSettingsCodec}. * @see #defaultSettingsCodec * @param input stream from which to construct the matrix @param minimumShingleSize minimum number of tokens in any shingle. @param maximumShingleSize maximum number of tokens in any shingle. @param spacerCharacter character to use between texts of the token parts in a shingle. null for none. @param ignoringSinglePrefixOrSuffixShingle if true, shingles that only contains permutation of the first of the last column will not be produced as shingles. Useful when adding boundary marker tokens such as '^' and '$'. 
public	TokenNamepublic	
ShingleMatrixFilter	TokenNameIdentifier	 Shingle Matrix Filter
(	TokenNameLPAREN	
TokenStream	TokenNameIdentifier	 Token Stream
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
int	TokenNameint	
minimumShingleSize	TokenNameIdentifier	 minimum Shingle Size
,	TokenNameCOMMA	
int	TokenNameint	
maximumShingleSize	TokenNameIdentifier	 maximum Shingle Size
,	TokenNameCOMMA	
Character	TokenNameIdentifier	 Character
spacerCharacter	TokenNameIdentifier	 spacer Character
,	TokenNameCOMMA	
boolean	TokenNameboolean	
ignoringSinglePrefixOrSuffixShingle	TokenNameIdentifier	 ignoring Single Prefix Or Suffix Shingle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
minimumShingleSize	TokenNameIdentifier	 minimum Shingle Size
,	TokenNameCOMMA	
maximumShingleSize	TokenNameIdentifier	 maximum Shingle Size
,	TokenNameCOMMA	
spacerCharacter	TokenNameIdentifier	 spacer Character
,	TokenNameCOMMA	
ignoringSinglePrefixOrSuffixShingle	TokenNameIdentifier	 ignoring Single Prefix Or Suffix Shingle
,	TokenNameCOMMA	
defaultSettingsCodec	TokenNameIdentifier	 default Settings Codec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Creates a shingle filter with ad hoc parameter settings. * * @param input stream from which to construct the matrix * @param minimumShingleSize minimum number of tokens in any shingle. * @param maximumShingleSize maximum number of tokens in any shingle. * @param spacerCharacter character to use between texts of the token parts in a shingle. null for none. * @param ignoringSinglePrefixOrSuffixShingle if true, shingles that only contains permutation of the first of the last column will not be produced as shingles. Useful when adding boundary marker tokens such as '^' and '$'. * @param settingsCodec codec used to read input token weight and matrix positioning. */	TokenNameCOMMENT_JAVADOC	 Creates a shingle filter with ad hoc parameter settings. * @param input stream from which to construct the matrix @param minimumShingleSize minimum number of tokens in any shingle. @param maximumShingleSize maximum number of tokens in any shingle. @param spacerCharacter character to use between texts of the token parts in a shingle. null for none. @param ignoringSinglePrefixOrSuffixShingle if true, shingles that only contains permutation of the first of the last column will not be produced as shingles. Useful when adding boundary marker tokens such as '^' and '$'. @param settingsCodec codec used to read input token weight and matrix positioning. 
public	TokenNamepublic	
ShingleMatrixFilter	TokenNameIdentifier	 Shingle Matrix Filter
(	TokenNameLPAREN	
TokenStream	TokenNameIdentifier	 Token Stream
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
int	TokenNameint	
minimumShingleSize	TokenNameIdentifier	 minimum Shingle Size
,	TokenNameCOMMA	
int	TokenNameint	
maximumShingleSize	TokenNameIdentifier	 maximum Shingle Size
,	TokenNameCOMMA	
Character	TokenNameIdentifier	 Character
spacerCharacter	TokenNameIdentifier	 spacer Character
,	TokenNameCOMMA	
boolean	TokenNameboolean	
ignoringSinglePrefixOrSuffixShingle	TokenNameIdentifier	 ignoring Single Prefix Or Suffix Shingle
,	TokenNameCOMMA	
TokenSettingsCodec	TokenNameIdentifier	 Token Settings Codec
settingsCodec	TokenNameIdentifier	 settings Codec
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
input	TokenNameIdentifier	 input
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
minimumShingleSize	TokenNameIdentifier	 minimum Shingle Size
=	TokenNameEQUAL	
minimumShingleSize	TokenNameIdentifier	 minimum Shingle Size
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
maximumShingleSize	TokenNameIdentifier	 maximum Shingle Size
=	TokenNameEQUAL	
maximumShingleSize	TokenNameIdentifier	 maximum Shingle Size
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
spacerCharacter	TokenNameIdentifier	 spacer Character
=	TokenNameEQUAL	
spacerCharacter	TokenNameIdentifier	 spacer Character
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
ignoringSinglePrefixOrSuffixShingle	TokenNameIdentifier	 ignoring Single Prefix Or Suffix Shingle
=	TokenNameEQUAL	
ignoringSinglePrefixOrSuffixShingle	TokenNameIdentifier	 ignoring Single Prefix Or Suffix Shingle
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
settingsCodec	TokenNameIdentifier	 settings Codec
=	TokenNameEQUAL	
settingsCodec	TokenNameIdentifier	 settings Codec
;	TokenNameSEMICOLON	
termAtt	TokenNameIdentifier	 term Att
=	TokenNameEQUAL	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
CharTermAttribute	TokenNameIdentifier	 Char Term Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
posIncrAtt	TokenNameIdentifier	 pos Incr Att
=	TokenNameEQUAL	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
PositionIncrementAttribute	TokenNameIdentifier	 Position Increment Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
payloadAtt	TokenNameIdentifier	 payload Att
=	TokenNameEQUAL	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
PayloadAttribute	TokenNameIdentifier	 Payload Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
offsetAtt	TokenNameIdentifier	 offset Att
=	TokenNameEQUAL	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
OffsetAttribute	TokenNameIdentifier	 Offset Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
typeAtt	TokenNameIdentifier	 type Att
=	TokenNameEQUAL	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
TypeAttribute	TokenNameIdentifier	 Type Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
flagsAtt	TokenNameIdentifier	 flags Att
=	TokenNameEQUAL	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
FlagsAttribute	TokenNameIdentifier	 Flags Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
in_termAtt	TokenNameIdentifier	 in term Att
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
CharTermAttribute	TokenNameIdentifier	 Char Term Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
in_posIncrAtt	TokenNameIdentifier	 in pos Incr Att
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
PositionIncrementAttribute	TokenNameIdentifier	 Position Increment Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
in_payloadAtt	TokenNameIdentifier	 in payload Att
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
PayloadAttribute	TokenNameIdentifier	 Payload Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
in_offsetAtt	TokenNameIdentifier	 in offset Att
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
OffsetAttribute	TokenNameIdentifier	 Offset Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
in_typeAtt	TokenNameIdentifier	 in type Att
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
TypeAttribute	TokenNameIdentifier	 Type Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
in_flagsAtt	TokenNameIdentifier	 in flags Att
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
FlagsAttribute	TokenNameIdentifier	 Flags Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// internal filter instance variables 	TokenNameCOMMENT_LINE	internal filter instance variables 
/** iterator over the current matrix row permutations */	TokenNameCOMMENT_JAVADOC	 iterator over the current matrix row permutations 
private	TokenNameprivate	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
Matrix	TokenNameIdentifier	 Matrix
.	TokenNameDOT	
Column	TokenNameIdentifier	 Column
.	TokenNameDOT	
Row	TokenNameIdentifier	 Row
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
>	TokenNameGREATER	
permutations	TokenNameIdentifier	 permutations
;	TokenNameSEMICOLON	
/** the current permutation of tokens used to produce shingles */	TokenNameCOMMENT_JAVADOC	 the current permutation of tokens used to produce shingles 
private	TokenNameprivate	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
currentPermuationTokens	TokenNameIdentifier	 current Permuation Tokens
;	TokenNameSEMICOLON	
/** index to what row a token in currentShingleTokens represents*/	TokenNameCOMMENT_JAVADOC	 index to what row a token in currentShingleTokens represents
private	TokenNameprivate	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Matrix	TokenNameIdentifier	 Matrix
.	TokenNameDOT	
Column	TokenNameIdentifier	 Column
.	TokenNameDOT	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
currentPermutationRows	TokenNameIdentifier	 current Permutation Rows
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
currentPermutationTokensStartOffset	TokenNameIdentifier	 current Permutation Tokens Start Offset
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
currentShingleLength	TokenNameIdentifier	 current Shingle Length
;	TokenNameSEMICOLON	
/** * a set containing shingles that has been the result of a call to {@link #incrementToken()}, * used to avoid producing the same shingle more than once. */	TokenNameCOMMENT_JAVADOC	 a set containing shingles that has been the result of a call to {@link #incrementToken()}, used to avoid producing the same shingle more than once. 
private	TokenNameprivate	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
shinglesSeen	TokenNameIdentifier	 shingles Seen
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
permutations	TokenNameIdentifier	 permutations
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
shinglesSeen	TokenNameIdentifier	 shingles Seen
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
Matrix	TokenNameIdentifier	 Matrix
matrix	TokenNameIdentifier	 matrix
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Token	TokenNameIdentifier	 Token
reusableToken	TokenNameIdentifier	 reusable Token
=	TokenNameEQUAL	
new	TokenNamenew	
Token	TokenNameIdentifier	 Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
final	TokenNamefinal	
boolean	TokenNameboolean	
incrementToken	TokenNameIdentifier	 increment Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
matrix	TokenNameIdentifier	 matrix
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
matrix	TokenNameIdentifier	 matrix
=	TokenNameEQUAL	
new	TokenNamenew	
Matrix	TokenNameIdentifier	 Matrix
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// fill matrix with maximumShingleSize columns 	TokenNameCOMMENT_LINE	fill matrix with maximumShingleSize columns 
while	TokenNamewhile	
(	TokenNameLPAREN	
matrix	TokenNameIdentifier	 matrix
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<	TokenNameLESS	
maximumShingleSize	TokenNameIdentifier	 maximum Shingle Size
&&	TokenNameAND_AND	
readColumn	TokenNameIdentifier	 read Column
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// this loop looks ugly 	TokenNameCOMMENT_LINE	this loop looks ugly 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// this loop exists in order to avoid recursive calls to the next method 	TokenNameCOMMENT_LINE	this loop exists in order to avoid recursive calls to the next method 
// as the complexity of a large matrix 	TokenNameCOMMENT_LINE	as the complexity of a large matrix 
// then would require a multi gigabyte sized stack. 	TokenNameCOMMENT_LINE	then would require a multi gigabyte sized stack. 
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
produceNextToken	TokenNameIdentifier	 produce Next Token
(	TokenNameLPAREN	
reusableToken	TokenNameIdentifier	 reusable Token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
==	TokenNameEQUAL_EQUAL	
request_next_token	TokenNameIdentifier	 request next token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
clearAttributes	TokenNameIdentifier	 clear Attributes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
termAtt	TokenNameIdentifier	 term Att
.	TokenNameDOT	
copyBuffer	TokenNameIdentifier	 copy Buffer
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
buffer	TokenNameIdentifier	 buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
posIncrAtt	TokenNameIdentifier	 pos Incr Att
.	TokenNameDOT	
setPositionIncrement	TokenNameIdentifier	 set Position Increment
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
getPositionIncrement	TokenNameIdentifier	 get Position Increment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
flagsAtt	TokenNameIdentifier	 flags Att
.	TokenNameDOT	
setFlags	TokenNameIdentifier	 set Flags
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
getFlags	TokenNameIdentifier	 get Flags
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
offsetAtt	TokenNameIdentifier	 offset Att
.	TokenNameDOT	
setOffset	TokenNameIdentifier	 set Offset
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
startOffset	TokenNameIdentifier	 start Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
endOffset	TokenNameIdentifier	 end Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
typeAtt	TokenNameIdentifier	 type Att
.	TokenNameDOT	
setType	TokenNameIdentifier	 set Type
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
type	TokenNameIdentifier	 type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
payloadAtt	TokenNameIdentifier	 payload Att
.	TokenNameDOT	
setPayload	TokenNameIdentifier	 set Payload
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
getPayload	TokenNameIdentifier	 get Payload
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
Token	TokenNameIdentifier	 Token
getNextInputToken	TokenNameIdentifier	 get Next Input Token
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
incrementToken	TokenNameIdentifier	 increment Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
copyBuffer	TokenNameIdentifier	 copy Buffer
(	TokenNameLPAREN	
in_termAtt	TokenNameIdentifier	 in term Att
.	TokenNameDOT	
buffer	TokenNameIdentifier	 buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
in_termAtt	TokenNameIdentifier	 in term Att
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
setPositionIncrement	TokenNameIdentifier	 set Position Increment
(	TokenNameLPAREN	
in_posIncrAtt	TokenNameIdentifier	 in pos Incr Att
.	TokenNameDOT	
getPositionIncrement	TokenNameIdentifier	 get Position Increment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
setFlags	TokenNameIdentifier	 set Flags
(	TokenNameLPAREN	
in_flagsAtt	TokenNameIdentifier	 in flags Att
.	TokenNameDOT	
getFlags	TokenNameIdentifier	 get Flags
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
setOffset	TokenNameIdentifier	 set Offset
(	TokenNameLPAREN	
in_offsetAtt	TokenNameIdentifier	 in offset Att
.	TokenNameDOT	
startOffset	TokenNameIdentifier	 start Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
in_offsetAtt	TokenNameIdentifier	 in offset Att
.	TokenNameDOT	
endOffset	TokenNameIdentifier	 end Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
setType	TokenNameIdentifier	 set Type
(	TokenNameLPAREN	
in_typeAtt	TokenNameIdentifier	 in type Att
.	TokenNameDOT	
type	TokenNameIdentifier	 type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
setPayload	TokenNameIdentifier	 set Payload
(	TokenNameLPAREN	
in_payloadAtt	TokenNameIdentifier	 in payload Att
.	TokenNameDOT	
getPayload	TokenNameIdentifier	 get Payload
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
Token	TokenNameIdentifier	 Token
getNextToken	TokenNameIdentifier	 get Next Token
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
this	TokenNamethis	
.	TokenNameDOT	
incrementToken	TokenNameIdentifier	 increment Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
copyBuffer	TokenNameIdentifier	 copy Buffer
(	TokenNameLPAREN	
termAtt	TokenNameIdentifier	 term Att
.	TokenNameDOT	
buffer	TokenNameIdentifier	 buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
termAtt	TokenNameIdentifier	 term Att
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
setPositionIncrement	TokenNameIdentifier	 set Position Increment
(	TokenNameLPAREN	
posIncrAtt	TokenNameIdentifier	 pos Incr Att
.	TokenNameDOT	
getPositionIncrement	TokenNameIdentifier	 get Position Increment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
setFlags	TokenNameIdentifier	 set Flags
(	TokenNameLPAREN	
flagsAtt	TokenNameIdentifier	 flags Att
.	TokenNameDOT	
getFlags	TokenNameIdentifier	 get Flags
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
setOffset	TokenNameIdentifier	 set Offset
(	TokenNameLPAREN	
offsetAtt	TokenNameIdentifier	 offset Att
.	TokenNameDOT	
startOffset	TokenNameIdentifier	 start Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
offsetAtt	TokenNameIdentifier	 offset Att
.	TokenNameDOT	
endOffset	TokenNameIdentifier	 end Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
setType	TokenNameIdentifier	 set Type
(	TokenNameLPAREN	
typeAtt	TokenNameIdentifier	 type Att
.	TokenNameDOT	
type	TokenNameIdentifier	 type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
setPayload	TokenNameIdentifier	 set Payload
(	TokenNameLPAREN	
payloadAtt	TokenNameIdentifier	 payload Att
.	TokenNameDOT	
getPayload	TokenNameIdentifier	 get Payload
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Token	TokenNameIdentifier	 Token
request_next_token	TokenNameIdentifier	 request next token
=	TokenNameEQUAL	
new	TokenNamenew	
Token	TokenNameIdentifier	 Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * This method exists in order to avoid recursive calls to the method * as the complexity of a fairly small matrix then easily would require * a gigabyte sized stack per thread. * * @param reusableToken * @return null if exhausted, instance request_next_token if one more call is required for an answer, or instance parameter resuableToken. * @throws IOException */	TokenNameCOMMENT_JAVADOC	 This method exists in order to avoid recursive calls to the method as the complexity of a fairly small matrix then easily would require a gigabyte sized stack per thread. * @param reusableToken @return null if exhausted, instance request_next_token if one more call is required for an answer, or instance parameter resuableToken. @throws IOException 
private	TokenNameprivate	
Token	TokenNameIdentifier	 Token
produceNextToken	TokenNameIdentifier	 produce Next Token
(	TokenNameLPAREN	
final	TokenNamefinal	
Token	TokenNameIdentifier	 Token
reusableToken	TokenNameIdentifier	 reusable Token
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
currentPermuationTokens	TokenNameIdentifier	 current Permuation Tokens
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currentShingleLength	TokenNameIdentifier	 current Shingle Length
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
currentShingleLength	TokenNameIdentifier	 current Shingle Length
+	TokenNamePLUS	
currentPermutationTokensStartOffset	TokenNameIdentifier	 current Permutation Tokens Start Offset
<=	TokenNameLESS_EQUAL	
currentPermuationTokens	TokenNameIdentifier	 current Permuation Tokens
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
currentShingleLength	TokenNameIdentifier	 current Shingle Length
<=	TokenNameLESS_EQUAL	
maximumShingleSize	TokenNameIdentifier	 maximum Shingle Size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// it is possible to create at least one more shingle of the current matrix permutation 	TokenNameCOMMENT_LINE	it is possible to create at least one more shingle of the current matrix permutation 
if	TokenNameif	
(	TokenNameLPAREN	
ignoringSinglePrefixOrSuffixShingle	TokenNameIdentifier	 ignoring Single Prefix Or Suffix Shingle
&&	TokenNameAND_AND	
currentShingleLength	TokenNameIdentifier	 current Shingle Length
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
currentPermutationRows	TokenNameIdentifier	 current Permutation Rows
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
currentPermutationTokensStartOffset	TokenNameIdentifier	 current Permutation Tokens Start Offset
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getColumn	TokenNameIdentifier	 get Column
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
isFirst	TokenNameIdentifier	 is First
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
currentPermutationRows	TokenNameIdentifier	 current Permutation Rows
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
currentPermutationTokensStartOffset	TokenNameIdentifier	 current Permutation Tokens Start Offset
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getColumn	TokenNameIdentifier	 get Column
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
isLast	TokenNameIdentifier	 is Last
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getNextToken	TokenNameIdentifier	 get Next Token
(	TokenNameLPAREN	
reusableToken	TokenNameIdentifier	 reusable Token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
termLength	TokenNameIdentifier	 term Length
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
shingle	TokenNameIdentifier	 shingle
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
(	TokenNameLPAREN	
currentShingleLength	TokenNameIdentifier	 current Shingle Length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
currentShingleLength	TokenNameIdentifier	 current Shingle Length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Token	TokenNameIdentifier	 Token
shingleToken	TokenNameIdentifier	 shingle Token
=	TokenNameEQUAL	
currentPermuationTokens	TokenNameIdentifier	 current Permuation Tokens
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
currentPermutationTokensStartOffset	TokenNameIdentifier	 current Permutation Tokens Start Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
termLength	TokenNameIdentifier	 term Length
+=	TokenNamePLUS_EQUAL	
shingleToken	TokenNameIdentifier	 shingle Token
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
shingle	TokenNameIdentifier	 shingle
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
shingleToken	TokenNameIdentifier	 shingle Token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
spacerCharacter	TokenNameIdentifier	 spacer Character
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
termLength	TokenNameIdentifier	 term Length
+=	TokenNamePLUS_EQUAL	
currentShingleLength	TokenNameIdentifier	 current Shingle Length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// only produce shingles that not already has been created 	TokenNameCOMMENT_LINE	only produce shingles that not already has been created 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
shinglesSeen	TokenNameIdentifier	 shingles Seen
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
shingle	TokenNameIdentifier	 shingle
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
request_next_token	TokenNameIdentifier	 request next token
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// shingle token factory 	TokenNameCOMMENT_LINE	shingle token factory 
StringBuilder	TokenNameIdentifier	 String Builder
sb	TokenNameIdentifier	 sb
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuilder	TokenNameIdentifier	 String Builder
(	TokenNameLPAREN	
termLength	TokenNameIdentifier	 term Length
+	TokenNamePLUS	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// paranormal ability to foresee the future. 	TokenNameCOMMENT_LINE	paranormal ability to foresee the future. 
for	TokenNamefor	
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
shingleToken	TokenNameIdentifier	 shingle Token
:	TokenNameCOLON	
shingle	TokenNameIdentifier	 shingle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
spacerCharacter	TokenNameIdentifier	 spacer Character
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
spacerCharacter	TokenNameIdentifier	 spacer Character
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
shingleToken	TokenNameIdentifier	 shingle Token
.	TokenNameDOT	
buffer	TokenNameIdentifier	 buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
shingleToken	TokenNameIdentifier	 shingle Token
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
reusableToken	TokenNameIdentifier	 reusable Token
.	TokenNameDOT	
setEmpty	TokenNameIdentifier	 set Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
sb	TokenNameIdentifier	 sb
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
updateToken	TokenNameIdentifier	 update Token
(	TokenNameLPAREN	
reusableToken	TokenNameIdentifier	 reusable Token
,	TokenNameCOMMA	
shingle	TokenNameIdentifier	 shingle
,	TokenNameCOMMA	
currentPermutationTokensStartOffset	TokenNameIdentifier	 current Permutation Tokens Start Offset
,	TokenNameCOMMA	
currentPermutationRows	TokenNameIdentifier	 current Permutation Rows
,	TokenNameCOMMA	
currentPermuationTokens	TokenNameIdentifier	 current Permuation Tokens
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
reusableToken	TokenNameIdentifier	 reusable Token
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// it is NOT possible to create one more shingles of the current matrix permutation 	TokenNameCOMMENT_LINE	it is NOT possible to create one more shingles of the current matrix permutation 
if	TokenNameif	
(	TokenNameLPAREN	
currentPermutationTokensStartOffset	TokenNameIdentifier	 current Permutation Tokens Start Offset
<	TokenNameLESS	
currentPermuationTokens	TokenNameIdentifier	 current Permuation Tokens
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// reset shingle size and move one step to the right in the current tokens permutation 	TokenNameCOMMENT_LINE	reset shingle size and move one step to the right in the current tokens permutation 
currentPermutationTokensStartOffset	TokenNameIdentifier	 current Permutation Tokens Start Offset
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
currentShingleLength	TokenNameIdentifier	 current Shingle Length
=	TokenNameEQUAL	
minimumShingleSize	TokenNameIdentifier	 minimum Shingle Size
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
request_next_token	TokenNameIdentifier	 request next token
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
permutations	TokenNameIdentifier	 permutations
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// todo does this ever occur? 	TokenNameCOMMENT_LINE	todo does this ever occur? 
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
permutations	TokenNameIdentifier	 permutations
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// load more data (if available) to the matrix 	TokenNameCOMMENT_LINE	load more data (if available) to the matrix 
if	TokenNameif	
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
readColumn	TokenNameIdentifier	 read Column
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// don't really care, we just read it. 	TokenNameCOMMENT_LINE	don't really care, we just read it. 
}	TokenNameRBRACE	
// get rid of resources 	TokenNameCOMMENT_LINE	get rid of resources 
// delete the first column in the matrix 	TokenNameCOMMENT_LINE	delete the first column in the matrix 
Matrix	TokenNameIdentifier	 Matrix
.	TokenNameDOT	
Column	TokenNameIdentifier	 Column
deletedColumn	TokenNameIdentifier	 deleted Column
=	TokenNameEQUAL	
matrix	TokenNameIdentifier	 matrix
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// remove all shingles seen that include any of the tokens from the deleted column. 	TokenNameCOMMENT_LINE	remove all shingles seen that include any of the tokens from the deleted column. 
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
deletedColumnTokens	TokenNameIdentifier	 deleted Column Tokens
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Matrix	TokenNameIdentifier	 Matrix
.	TokenNameDOT	
Column	TokenNameIdentifier	 Column
.	TokenNameDOT	
Row	TokenNameIdentifier	 Row
row	TokenNameIdentifier	 row
:	TokenNameCOLON	
deletedColumn	TokenNameIdentifier	 deleted Column
.	TokenNameDOT	
getRows	TokenNameIdentifier	 get Rows
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
:	TokenNameCOLON	
row	TokenNameIdentifier	 row
.	TokenNameDOT	
getTokens	TokenNameIdentifier	 get Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
deletedColumnTokens	TokenNameIdentifier	 deleted Column Tokens
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
shinglesSeenIterator	TokenNameIdentifier	 shingles Seen Iterator
=	TokenNameEQUAL	
shinglesSeen	TokenNameIdentifier	 shingles Seen
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
shinglesSeenIterator	TokenNameIdentifier	 shingles Seen Iterator
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
shingle	TokenNameIdentifier	 shingle
=	TokenNameEQUAL	
shinglesSeenIterator	TokenNameIdentifier	 shingles Seen Iterator
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
deletedColumnToken	TokenNameIdentifier	 deleted Column Token
:	TokenNameCOLON	
deletedColumnTokens	TokenNameIdentifier	 deleted Column Tokens
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
shingle	TokenNameIdentifier	 shingle
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
deletedColumnToken	TokenNameIdentifier	 deleted Column Token
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
shinglesSeenIterator	TokenNameIdentifier	 shingles Seen Iterator
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
matrix	TokenNameIdentifier	 matrix
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<	TokenNameLESS	
minimumShingleSize	TokenNameIdentifier	 minimum Shingle Size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// exhausted 	TokenNameCOMMENT_LINE	exhausted 
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// create permutations of the matrix it now looks 	TokenNameCOMMENT_LINE	create permutations of the matrix it now looks 
permutations	TokenNameIdentifier	 permutations
=	TokenNameEQUAL	
matrix	TokenNameIdentifier	 matrix
.	TokenNameDOT	
permutationIterator	TokenNameIdentifier	 permutation Iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
nextTokensPermutation	TokenNameIdentifier	 next Tokens Permutation
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
request_next_token	TokenNameIdentifier	 request next token
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
permutations	TokenNameIdentifier	 permutations
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
permutations	TokenNameIdentifier	 permutations
=	TokenNameEQUAL	
matrix	TokenNameIdentifier	 matrix
.	TokenNameDOT	
permutationIterator	TokenNameIdentifier	 permutation Iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
permutations	TokenNameIdentifier	 permutations
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
nextTokensPermutation	TokenNameIdentifier	 next Tokens Permutation
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
request_next_token	TokenNameIdentifier	 request next token
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * get next permutation of row combinations, * creates list of all tokens in the row and * an index from each such token to what row they exist in. * finally resets the current (next) shingle size and offset. */	TokenNameCOMMENT_JAVADOC	 get next permutation of row combinations, creates list of all tokens in the row and an index from each such token to what row they exist in. finally resets the current (next) shingle size and offset. 
private	TokenNameprivate	
void	TokenNamevoid	
nextTokensPermutation	TokenNameIdentifier	 next Tokens Permutation
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Matrix	TokenNameIdentifier	 Matrix
.	TokenNameDOT	
Column	TokenNameIdentifier	 Column
.	TokenNameDOT	
Row	TokenNameIdentifier	 Row
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
rowsPermutation	TokenNameIdentifier	 rows Permutation
=	TokenNameEQUAL	
permutations	TokenNameIdentifier	 permutations
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Matrix	TokenNameIdentifier	 Matrix
.	TokenNameDOT	
Column	TokenNameIdentifier	 Column
.	TokenNameDOT	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
currentPermutationRows	TokenNameIdentifier	 current Permutation Rows
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Matrix	TokenNameIdentifier	 Matrix
.	TokenNameDOT	
Column	TokenNameIdentifier	 Column
.	TokenNameDOT	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
currentPermuationTokens	TokenNameIdentifier	 current Permuation Tokens
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Matrix	TokenNameIdentifier	 Matrix
.	TokenNameDOT	
Column	TokenNameIdentifier	 Column
.	TokenNameDOT	
Row	TokenNameIdentifier	 Row
row	TokenNameIdentifier	 row
:	TokenNameCOLON	
rowsPermutation	TokenNameIdentifier	 rows Permutation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
:	TokenNameCOLON	
row	TokenNameIdentifier	 row
.	TokenNameDOT	
getTokens	TokenNameIdentifier	 get Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currentPermuationTokens	TokenNameIdentifier	 current Permuation Tokens
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
currentPermutationRows	TokenNameIdentifier	 current Permutation Rows
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
row	TokenNameIdentifier	 row
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
this	TokenNamethis	
.	TokenNameDOT	
currentPermuationTokens	TokenNameIdentifier	 current Permuation Tokens
=	TokenNameEQUAL	
currentPermuationTokens	TokenNameIdentifier	 current Permuation Tokens
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
currentPermutationRows	TokenNameIdentifier	 current Permutation Rows
=	TokenNameEQUAL	
currentPermutationRows	TokenNameIdentifier	 current Permutation Rows
;	TokenNameSEMICOLON	
currentPermutationTokensStartOffset	TokenNameIdentifier	 current Permutation Tokens Start Offset
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
currentShingleLength	TokenNameIdentifier	 current Shingle Length
=	TokenNameEQUAL	
minimumShingleSize	TokenNameIdentifier	 minimum Shingle Size
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Final touch of a shingle token before it is passed on to the consumer from method {@link #incrementToken()}. * * Calculates and sets type, flags, position increment, start/end offsets and weight. * * @param token Shingle token * @param shingle Tokens used to produce the shingle token. * @param currentPermutationStartOffset Start offset in parameter currentPermutationTokens * @param currentPermutationRows index to Matrix.Column.Row from the position of tokens in parameter currentPermutationTokens * @param currentPermuationTokens tokens of the current permutation of rows in the matrix. */	TokenNameCOMMENT_JAVADOC	 Final touch of a shingle token before it is passed on to the consumer from method {@link #incrementToken()}. * Calculates and sets type, flags, position increment, start/end offsets and weight. * @param token Shingle token @param shingle Tokens used to produce the shingle token. @param currentPermutationStartOffset Start offset in parameter currentPermutationTokens @param currentPermutationRows index to Matrix.Column.Row from the position of tokens in parameter currentPermutationTokens @param currentPermuationTokens tokens of the current permutation of rows in the matrix. 
public	TokenNamepublic	
void	TokenNamevoid	
updateToken	TokenNameIdentifier	 update Token
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
shingle	TokenNameIdentifier	 shingle
,	TokenNameCOMMA	
int	TokenNameint	
currentPermutationStartOffset	TokenNameIdentifier	 current Permutation Start Offset
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
currentPermutationRows	TokenNameIdentifier	 current Permutation Rows
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
currentPermuationTokens	TokenNameIdentifier	 current Permuation Tokens
)	TokenNameRPAREN	
{	TokenNameLBRACE	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
setType	TokenNameIdentifier	 set Type
(	TokenNameLPAREN	
ShingleMatrixFilter	TokenNameIdentifier	 Shingle Matrix Filter
.	TokenNameDOT	
class	TokenNameclass	
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
setFlags	TokenNameIdentifier	 set Flags
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
setPositionIncrement	TokenNameIdentifier	 set Position Increment
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
setStartOffset	TokenNameIdentifier	 set Start Offset
(	TokenNameLPAREN	
shingle	TokenNameIdentifier	 shingle
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
startOffset	TokenNameIdentifier	 start Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
setEndOffset	TokenNameIdentifier	 set End Offset
(	TokenNameLPAREN	
shingle	TokenNameIdentifier	 shingle
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
shingle	TokenNameIdentifier	 shingle
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
endOffset	TokenNameIdentifier	 end Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
settingsCodec	TokenNameIdentifier	 settings Codec
.	TokenNameDOT	
setWeight	TokenNameIdentifier	 set Weight
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
calculateShingleWeight	TokenNameIdentifier	 calculate Shingle Weight
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
shingle	TokenNameIdentifier	 shingle
,	TokenNameCOMMA	
currentPermutationStartOffset	TokenNameIdentifier	 current Permutation Start Offset
,	TokenNameCOMMA	
currentPermutationRows	TokenNameIdentifier	 current Permutation Rows
,	TokenNameCOMMA	
currentPermuationTokens	TokenNameIdentifier	 current Permuation Tokens
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Evaluates the new shingle token weight. * * for (shingle part token in shingle) * weight += shingle part token weight * (1 / sqrt(all shingle part token weights summed)) * * This algorithm gives a slightly greater score for longer shingles * and is rather penalising to great shingle token part weights. * * @param shingleToken token returned to consumer * @param shingle tokens the tokens used to produce the shingle token. * @param currentPermutationStartOffset start offset in parameter currentPermutationRows and currentPermutationTokens. * @param currentPermutationRows an index to what matrix row a token in parameter currentPermutationTokens exist. * @param currentPermuationTokens all tokens in the current row permutation of the matrix. A sub list (parameter offset, parameter shingle.size) equals parameter shingle. * @return weight to be set for parameter shingleToken */	TokenNameCOMMENT_JAVADOC	 Evaluates the new shingle token weight. * for (shingle part token in shingle) weight += shingle part token weight (1 / sqrt(all shingle part token weights summed)) * This algorithm gives a slightly greater score for longer shingles and is rather penalising to great shingle token part weights. * @param shingleToken token returned to consumer @param shingle tokens the tokens used to produce the shingle token. @param currentPermutationStartOffset start offset in parameter currentPermutationRows and currentPermutationTokens. @param currentPermutationRows an index to what matrix row a token in parameter currentPermutationTokens exist. @param currentPermuationTokens all tokens in the current row permutation of the matrix. A sub list (parameter offset, parameter shingle.size) equals parameter shingle. @return weight to be set for parameter shingleToken 
public	TokenNamepublic	
float	TokenNamefloat	
calculateShingleWeight	TokenNameIdentifier	 calculate Shingle Weight
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
shingleToken	TokenNameIdentifier	 shingle Token
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
shingle	TokenNameIdentifier	 shingle
,	TokenNameCOMMA	
int	TokenNameint	
currentPermutationStartOffset	TokenNameIdentifier	 current Permutation Start Offset
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
currentPermutationRows	TokenNameIdentifier	 current Permutation Rows
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
currentPermuationTokens	TokenNameIdentifier	 current Permuation Tokens
)	TokenNameRPAREN	
{	TokenNameLBRACE	
double	TokenNamedouble	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
weights	TokenNameIdentifier	 weights
=	TokenNameEQUAL	
new	TokenNamenew	
double	TokenNamedouble	
[	TokenNameLBRACKET	
shingle	TokenNameIdentifier	 shingle
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
total	TokenNameIdentifier	 total
=	TokenNameEQUAL	
0f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
top	TokenNameIdentifier	 top
=	TokenNameEQUAL	
0d	TokenNameDoubleLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
weights	TokenNameIdentifier	 weights
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
weights	TokenNameIdentifier	 weights
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
settingsCodec	TokenNameIdentifier	 settings Codec
.	TokenNameDOT	
getWeight	TokenNameIdentifier	 get Weight
(	TokenNameLPAREN	
shingle	TokenNameIdentifier	 shingle
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
tmp	TokenNameIdentifier	 tmp
=	TokenNameEQUAL	
weights	TokenNameIdentifier	 weights
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
tmp	TokenNameIdentifier	 tmp
>	TokenNameGREATER	
top	TokenNameIdentifier	 top
)	TokenNameRPAREN	
{	TokenNameLBRACE	
top	TokenNameIdentifier	 top
=	TokenNameEQUAL	
tmp	TokenNameIdentifier	 tmp
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
total	TokenNameIdentifier	 total
+=	TokenNamePLUS_EQUAL	
tmp	TokenNameIdentifier	 tmp
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
double	TokenNamedouble	
factor	TokenNameIdentifier	 factor
=	TokenNameEQUAL	
1d	TokenNameDoubleLiteral	
/	TokenNameDIVIDE	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
sqrt	TokenNameIdentifier	 sqrt
(	TokenNameLPAREN	
total	TokenNameIdentifier	 total
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
weight	TokenNameIdentifier	 weight
=	TokenNameEQUAL	
0d	TokenNameDoubleLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
double	TokenNamedouble	
partWeight	TokenNameIdentifier	 part Weight
:	TokenNameCOLON	
weights	TokenNameIdentifier	 weights
)	TokenNameRPAREN	
{	TokenNameLBRACE	
weight	TokenNameIdentifier	 weight
+=	TokenNamePLUS_EQUAL	
partWeight	TokenNameIdentifier	 part Weight
*	TokenNameMULTIPLY	
factor	TokenNameIdentifier	 factor
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
weight	TokenNameIdentifier	 weight
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
Token	TokenNameIdentifier	 Token
readColumnBuf	TokenNameIdentifier	 read Column Buf
;	TokenNameSEMICOLON	
/** * Loads one column from the token stream. * * When the last token is read from the token stream it will column.setLast(true); * * @return true if it manage to read one more column from the input token stream * @throws IOException if the matrix source input stream throws an exception */	TokenNameCOMMENT_JAVADOC	 Loads one column from the token stream. * When the last token is read from the token stream it will column.setLast(true); * @return true if it manage to read one more column from the input token stream @throws IOException if the matrix source input stream throws an exception 
private	TokenNameprivate	
boolean	TokenNameboolean	
readColumn	TokenNameIdentifier	 read Column
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
readColumnBuf	TokenNameIdentifier	 read Column Buf
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
readColumnBuf	TokenNameIdentifier	 read Column Buf
;	TokenNameSEMICOLON	
readColumnBuf	TokenNameIdentifier	 read Column Buf
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
getNextInputToken	TokenNameIdentifier	 get Next Input Token
(	TokenNameLPAREN	
new	TokenNamenew	
Token	TokenNameIdentifier	 Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Matrix	TokenNameIdentifier	 Matrix
.	TokenNameDOT	
Column	TokenNameIdentifier	 Column
currentReaderColumn	TokenNameIdentifier	 current Reader Column
=	TokenNameEQUAL	
matrix	TokenNameIdentifier	 matrix
.	TokenNameDOT	
new	TokenNamenew	
Column	TokenNameIdentifier	 Column
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Matrix	TokenNameIdentifier	 Matrix
.	TokenNameDOT	
Column	TokenNameIdentifier	 Column
.	TokenNameDOT	
Row	TokenNameIdentifier	 Row
currentReaderRow	TokenNameIdentifier	 current Reader Row
=	TokenNameEQUAL	
currentReaderColumn	TokenNameIdentifier	 current Reader Column
.	TokenNameDOT	
new	TokenNamenew	
Row	TokenNameIdentifier	 Row
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
currentReaderRow	TokenNameIdentifier	 current Reader Row
.	TokenNameDOT	
getTokens	TokenNameIdentifier	 get Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TokenPositioner	TokenNameIdentifier	 Token Positioner
tokenPositioner	TokenNameIdentifier	 token Positioner
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
readColumnBuf	TokenNameIdentifier	 read Column Buf
=	TokenNameEQUAL	
getNextInputToken	TokenNameIdentifier	 get Next Input Token
(	TokenNameLPAREN	
new	TokenNamenew	
Token	TokenNameIdentifier	 Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
tokenPositioner	TokenNameIdentifier	 token Positioner
=	TokenNameEQUAL	
settingsCodec	TokenNameIdentifier	 settings Codec
.	TokenNameDOT	
getTokenPositioner	TokenNameIdentifier	 get Token Positioner
(	TokenNameLPAREN	
readColumnBuf	TokenNameIdentifier	 read Column Buf
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
TokenPositioner	TokenNameIdentifier	 Token Positioner
.	TokenNameDOT	
newColumn	TokenNameIdentifier	 new Column
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
tokenPositioner	TokenNameIdentifier	 token Positioner
==	TokenNameEQUAL_EQUAL	
TokenPositioner	TokenNameIdentifier	 Token Positioner
.	TokenNameDOT	
sameRow	TokenNameIdentifier	 same Row
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currentReaderRow	TokenNameIdentifier	 current Reader Row
.	TokenNameDOT	
getTokens	TokenNameIdentifier	 get Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
readColumnBuf	TokenNameIdentifier	 read Column Buf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
/*if (tokenPositioner == TokenPositioner.newRow)*/	TokenNameCOMMENT_BLOCK	if (tokenPositioner == TokenPositioner.newRow)
{	TokenNameLBRACE	
currentReaderRow	TokenNameIdentifier	 current Reader Row
=	TokenNameEQUAL	
currentReaderColumn	TokenNameIdentifier	 current Reader Column
.	TokenNameDOT	
new	TokenNamenew	
Row	TokenNameIdentifier	 Row
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
currentReaderRow	TokenNameIdentifier	 current Reader Row
.	TokenNameDOT	
getTokens	TokenNameIdentifier	 get Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
readColumnBuf	TokenNameIdentifier	 read Column Buf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
readColumnBuf	TokenNameIdentifier	 read Column Buf
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
readColumnBuf	TokenNameIdentifier	 read Column Buf
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
readColumnBuf	TokenNameIdentifier	 read Column Buf
=	TokenNameEQUAL	
getNextInputToken	TokenNameIdentifier	 get Next Input Token
(	TokenNameLPAREN	
new	TokenNamenew	
Token	TokenNameIdentifier	 Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
readColumnBuf	TokenNameIdentifier	 read Column Buf
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currentReaderColumn	TokenNameIdentifier	 current Reader Column
.	TokenNameDOT	
setLast	TokenNameIdentifier	 set Last
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * A column focused matrix in three dimensions: * * <pre> * Token[column][row][z-axis] { * {{hello}, {greetings, and, salutations}}, * {{world}, {earth}, {tellus}} * }; * </pre> * * todo consider row groups * to indicate that shingles is only to contain permutations with texts in that same row group. * */	TokenNameCOMMENT_JAVADOC	 A column focused matrix in three dimensions: * <pre> Token[column][row][z-axis] { {{hello}, {greetings, and, salutations}}, {{world}, {earth}, {tellus}} }; </pre> * todo consider row groups to indicate that shingles is only to contain permutations with texts in that same row group. 
public	TokenNamepublic	
static	TokenNamestatic	
class	TokenNameclass	
Matrix	TokenNameIdentifier	 Matrix
{	TokenNameLBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
columnsHasBeenCreated	TokenNameIdentifier	 columns Has Been Created
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Column	TokenNameIdentifier	 Column
>	TokenNameGREATER	
columns	TokenNameIdentifier	 columns
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Column	TokenNameIdentifier	 Column
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Column	TokenNameIdentifier	 Column
>	TokenNameGREATER	
getColumns	TokenNameIdentifier	 get Columns
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
columns	TokenNameIdentifier	 columns
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
class	TokenNameclass	
Column	TokenNameIdentifier	 Column
{	TokenNameLBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
last	TokenNameIdentifier	 last
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
first	TokenNameIdentifier	 first
;	TokenNameSEMICOLON	
public	TokenNamepublic	
Matrix	TokenNameIdentifier	 Matrix
getMatrix	TokenNameIdentifier	 get Matrix
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
Matrix	TokenNameIdentifier	 Matrix
.	TokenNameDOT	
this	TokenNamethis	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Column	TokenNameIdentifier	 Column
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Row	TokenNameIdentifier	 Row
row	TokenNameIdentifier	 row
=	TokenNameEQUAL	
new	TokenNamenew	
Row	TokenNameIdentifier	 Row
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
row	TokenNameIdentifier	 row
.	TokenNameDOT	
getTokens	TokenNameIdentifier	 get Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Column	TokenNameIdentifier	 Column
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
Matrix	TokenNameIdentifier	 Matrix
.	TokenNameDOT	
this	TokenNamethis	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
columnsHasBeenCreated	TokenNameIdentifier	 columns Has Been Created
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
setFirst	TokenNameIdentifier	 set First
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
columnsHasBeenCreated	TokenNameIdentifier	 columns Has Been Created
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
Matrix	TokenNameIdentifier	 Matrix
.	TokenNameDOT	
this	TokenNamethis	
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
rows	TokenNameIdentifier	 rows
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
getRows	TokenNameIdentifier	 get Rows
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
rows	TokenNameIdentifier	 rows
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getIndex	TokenNameIdentifier	 get Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
Matrix	TokenNameIdentifier	 Matrix
.	TokenNameDOT	
this	TokenNamethis	
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
String	TokenNameIdentifier	 String
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
"Column{"	TokenNameStringLiteral	Column{
+	TokenNamePLUS	
"first="	TokenNameStringLiteral	first=
+	TokenNamePLUS	
first	TokenNameIdentifier	 first
+	TokenNamePLUS	
", last="	TokenNameStringLiteral	, last=
+	TokenNamePLUS	
last	TokenNameIdentifier	 last
+	TokenNamePLUS	
", rows="	TokenNameStringLiteral	, rows=
+	TokenNamePLUS	
rows	TokenNameIdentifier	 rows
+	TokenNamePLUS	
'}'	TokenNameCharacterLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isFirst	TokenNameIdentifier	 is First
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
first	TokenNameIdentifier	 first
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setFirst	TokenNameIdentifier	 set First
(	TokenNameLPAREN	
boolean	TokenNameboolean	
first	TokenNameIdentifier	 first
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
first	TokenNameIdentifier	 first
=	TokenNameEQUAL	
first	TokenNameIdentifier	 first
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setLast	TokenNameIdentifier	 set Last
(	TokenNameLPAREN	
boolean	TokenNameboolean	
last	TokenNameIdentifier	 last
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
last	TokenNameIdentifier	 last
=	TokenNameEQUAL	
last	TokenNameIdentifier	 last
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isLast	TokenNameIdentifier	 is Last
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
last	TokenNameIdentifier	 last
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
class	TokenNameclass	
Row	TokenNameIdentifier	 Row
{	TokenNameLBRACE	
public	TokenNamepublic	
Column	TokenNameIdentifier	 Column
getColumn	TokenNameIdentifier	 get Column
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
Column	TokenNameIdentifier	 Column
.	TokenNameDOT	
this	TokenNamethis	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
tokens	TokenNameIdentifier	 tokens
=	TokenNameEQUAL	
new	TokenNamenew	
LinkedList	TokenNameIdentifier	 Linked List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
Row	TokenNameIdentifier	 Row
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Column	TokenNameIdentifier	 Column
.	TokenNameDOT	
this	TokenNamethis	
.	TokenNameDOT	
rows	TokenNameIdentifier	 rows
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getIndex	TokenNameIdentifier	 get Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
Column	TokenNameIdentifier	 Column
.	TokenNameDOT	
this	TokenNamethis	
.	TokenNameDOT	
rows	TokenNameIdentifier	 rows
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
getTokens	TokenNameIdentifier	 get Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
tokens	TokenNameIdentifier	 tokens
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setTokens	TokenNameIdentifier	 set Tokens
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
tokens	TokenNameIdentifier	 tokens
=	TokenNameEQUAL	
tokens	TokenNameIdentifier	 tokens
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// public int getStartOffset() { 	TokenNameCOMMENT_LINE	public int getStartOffset() { 
// int ret = tokens[0].startOffset(); 	TokenNameCOMMENT_LINE	int ret = tokens[0].startOffset(); 
// if (getIndex() > 0 && ret == 0) { 	TokenNameCOMMENT_LINE	if (getIndex() > 0 && ret == 0) { 
// ret = Column.this.rows.get(0).getStartOffset(); 	TokenNameCOMMENT_LINE	ret = Column.this.rows.get(0).getStartOffset(); 
// } 	TokenNameCOMMENT_LINE	} 
// return ret; 	TokenNameCOMMENT_LINE	return ret; 
// } 	TokenNameCOMMENT_LINE	} 
// 	TokenNameCOMMENT_LINE	 
// public int getEndOffset() { 	TokenNameCOMMENT_LINE	public int getEndOffset() { 
// int ret = tokens[tokens.length - 1].endOffset(); 	TokenNameCOMMENT_LINE	int ret = tokens[tokens.length - 1].endOffset(); 
// if (getIndex() > 0 && ret == 0) { 	TokenNameCOMMENT_LINE	if (getIndex() > 0 && ret == 0) { 
// ret = Column.this.rows.get(0).getEndOffset(); 	TokenNameCOMMENT_LINE	ret = Column.this.rows.get(0).getEndOffset(); 
// } 	TokenNameCOMMENT_LINE	} 
// return ret; 	TokenNameCOMMENT_LINE	return ret; 
// } 	TokenNameCOMMENT_LINE	} 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
String	TokenNameIdentifier	 String
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
"Row{"	TokenNameStringLiteral	Row{
+	TokenNamePLUS	
"index="	TokenNameStringLiteral	index=
+	TokenNamePLUS	
getIndex	TokenNameIdentifier	 get Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
", tokens="	TokenNameStringLiteral	, tokens=
+	TokenNamePLUS	
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
+	TokenNamePLUS	
'}'	TokenNameCharacterLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
Column	TokenNameIdentifier	 Column
.	TokenNameDOT	
Row	TokenNameIdentifier	 Row
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
>	TokenNameGREATER	
permutationIterator	TokenNameIdentifier	 permutation Iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
Column	TokenNameIdentifier	 Column
.	TokenNameDOT	
Row	TokenNameIdentifier	 Row
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
columnRowCounters	TokenNameIdentifier	 column Row Counters
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
void	TokenNamevoid	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
"not implemented"	TokenNameStringLiteral	not implemented
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
columnRowCounters	TokenNameIdentifier	 column Row Counters
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
int	TokenNameint	
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
s	TokenNameIdentifier	 s
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
n	TokenNameIdentifier	 n
>=	TokenNameGREATER_EQUAL	
s	TokenNameIdentifier	 s
&&	TokenNameAND_AND	
columnRowCounters	TokenNameIdentifier	 column Row Counters
[	TokenNameLBRACKET	
s	TokenNameIdentifier	 s
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
<	TokenNameLESS	
(	TokenNameLPAREN	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getRows	TokenNameIdentifier	 get Rows
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Column	TokenNameIdentifier	 Column
.	TokenNameDOT	
Row	TokenNameIdentifier	 Row
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
NoSuchElementException	TokenNameIdentifier	 No Such Element Exception
(	TokenNameLPAREN	
"no more elements"	TokenNameStringLiteral	no more elements
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Column	TokenNameIdentifier	 Column
.	TokenNameDOT	
Row	TokenNameIdentifier	 Row
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
rows	TokenNameIdentifier	 rows
=	TokenNameEQUAL	
new	TokenNamenew	
Column	TokenNameIdentifier	 Column
.	TokenNameDOT	
Row	TokenNameIdentifier	 Row
[	TokenNameLBRACKET	
columnRowCounters	TokenNameIdentifier	 column Row Counters
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
columnRowCounters	TokenNameIdentifier	 column Row Counters
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
rows	TokenNameIdentifier	 rows
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
.	TokenNameDOT	
rows	TokenNameIdentifier	 rows
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
columnRowCounters	TokenNameIdentifier	 column Row Counters
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
incrementColumnRowCounters	TokenNameIdentifier	 increment Column Row Counters
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
rows	TokenNameIdentifier	 rows
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
incrementColumnRowCounters	TokenNameIdentifier	 increment Column Row Counters
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
columnRowCounters	TokenNameIdentifier	 column Row Counters
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
columnRowCounters	TokenNameIdentifier	 column Row Counters
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
columnRowCounters	TokenNameIdentifier	 column Row Counters
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
.	TokenNameDOT	
rows	TokenNameIdentifier	 rows
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
columnRowCounters	TokenNameIdentifier	 column Row Counters
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
columnRowCounters	TokenNameIdentifier	 column Row Counters
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
String	TokenNameIdentifier	 String
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
"Matrix{"	TokenNameStringLiteral	Matrix{
+	TokenNamePLUS	
"columns="	TokenNameStringLiteral	columns=
+	TokenNamePLUS	
columns	TokenNameIdentifier	 columns
+	TokenNamePLUS	
'}'	TokenNameCharacterLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getMinimumShingleSize	TokenNameIdentifier	 get Minimum Shingle Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
minimumShingleSize	TokenNameIdentifier	 minimum Shingle Size
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setMinimumShingleSize	TokenNameIdentifier	 set Minimum Shingle Size
(	TokenNameLPAREN	
int	TokenNameint	
minimumShingleSize	TokenNameIdentifier	 minimum Shingle Size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
minimumShingleSize	TokenNameIdentifier	 minimum Shingle Size
=	TokenNameEQUAL	
minimumShingleSize	TokenNameIdentifier	 minimum Shingle Size
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getMaximumShingleSize	TokenNameIdentifier	 get Maximum Shingle Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
maximumShingleSize	TokenNameIdentifier	 maximum Shingle Size
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setMaximumShingleSize	TokenNameIdentifier	 set Maximum Shingle Size
(	TokenNameLPAREN	
int	TokenNameint	
maximumShingleSize	TokenNameIdentifier	 maximum Shingle Size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
maximumShingleSize	TokenNameIdentifier	 maximum Shingle Size
=	TokenNameEQUAL	
maximumShingleSize	TokenNameIdentifier	 maximum Shingle Size
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Matrix	TokenNameIdentifier	 Matrix
getMatrix	TokenNameIdentifier	 get Matrix
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
matrix	TokenNameIdentifier	 matrix
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setMatrix	TokenNameIdentifier	 set Matrix
(	TokenNameLPAREN	
Matrix	TokenNameIdentifier	 Matrix
matrix	TokenNameIdentifier	 matrix
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
matrix	TokenNameIdentifier	 matrix
=	TokenNameEQUAL	
matrix	TokenNameIdentifier	 matrix
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Character	TokenNameIdentifier	 Character
getSpacerCharacter	TokenNameIdentifier	 get Spacer Character
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
spacerCharacter	TokenNameIdentifier	 spacer Character
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setSpacerCharacter	TokenNameIdentifier	 set Spacer Character
(	TokenNameLPAREN	
Character	TokenNameIdentifier	 Character
spacerCharacter	TokenNameIdentifier	 spacer Character
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
spacerCharacter	TokenNameIdentifier	 spacer Character
=	TokenNameEQUAL	
spacerCharacter	TokenNameIdentifier	 spacer Character
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isIgnoringSinglePrefixOrSuffixShingle	TokenNameIdentifier	 is Ignoring Single Prefix Or Suffix Shingle
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
ignoringSinglePrefixOrSuffixShingle	TokenNameIdentifier	 ignoring Single Prefix Or Suffix Shingle
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setIgnoringSinglePrefixOrSuffixShingle	TokenNameIdentifier	 set Ignoring Single Prefix Or Suffix Shingle
(	TokenNameLPAREN	
boolean	TokenNameboolean	
ignoringSinglePrefixOrSuffixShingle	TokenNameIdentifier	 ignoring Single Prefix Or Suffix Shingle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
ignoringSinglePrefixOrSuffixShingle	TokenNameIdentifier	 ignoring Single Prefix Or Suffix Shingle
=	TokenNameEQUAL	
ignoringSinglePrefixOrSuffixShingle	TokenNameIdentifier	 ignoring Single Prefix Or Suffix Shingle
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Using this codec makes a {@link ShingleMatrixFilter} act like {@link org.apache.lucene.analysis.shingle.ShingleFilter}. * It produces the most simple sort of shingles, ignoring token position increments, et c. * * It adds each token as a new column. */	TokenNameCOMMENT_JAVADOC	 Using this codec makes a {@link ShingleMatrixFilter} act like {@link org.apache.lucene.analysis.shingle.ShingleFilter}. It produces the most simple sort of shingles, ignoring token position increments, et c. * It adds each token as a new column. 
public	TokenNamepublic	
static	TokenNamestatic	
class	TokenNameclass	
OneDimensionalNonWeightedTokenSettingsCodec	TokenNameIdentifier	 One Dimensional Non Weighted Token Settings Codec
extends	TokenNameextends	
TokenSettingsCodec	TokenNameIdentifier	 Token Settings Codec
{	TokenNameLBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
TokenPositioner	TokenNameIdentifier	 Token Positioner
getTokenPositioner	TokenNameIdentifier	 get Token Positioner
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
TokenPositioner	TokenNameIdentifier	 Token Positioner
.	TokenNameDOT	
newColumn	TokenNameIdentifier	 new Column
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
setTokenPositioner	TokenNameIdentifier	 set Token Positioner
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
TokenPositioner	TokenNameIdentifier	 Token Positioner
tokenPositioner	TokenNameIdentifier	 token Positioner
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
float	TokenNamefloat	
getWeight	TokenNameIdentifier	 get Weight
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
1f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
setWeight	TokenNameIdentifier	 set Weight
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
float	TokenNamefloat	
weight	TokenNameIdentifier	 weight
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * A codec that creates a two dimensional matrix * by treating tokens from the input stream with 0 position increment * as new rows to the current column. */	TokenNameCOMMENT_JAVADOC	 A codec that creates a two dimensional matrix by treating tokens from the input stream with 0 position increment as new rows to the current column. 
public	TokenNamepublic	
static	TokenNamestatic	
class	TokenNameclass	
TwoDimensionalNonWeightedSynonymTokenSettingsCodec	TokenNameIdentifier	 Two Dimensional Non Weighted Synonym Token Settings Codec
extends	TokenNameextends	
TokenSettingsCodec	TokenNameIdentifier	 Token Settings Codec
{	TokenNameLBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
TokenPositioner	TokenNameIdentifier	 Token Positioner
getTokenPositioner	TokenNameIdentifier	 get Token Positioner
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
getPositionIncrement	TokenNameIdentifier	 get Position Increment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
TokenPositioner	TokenNameIdentifier	 Token Positioner
.	TokenNameDOT	
newRow	TokenNameIdentifier	 new Row
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
TokenPositioner	TokenNameIdentifier	 Token Positioner
.	TokenNameDOT	
newColumn	TokenNameIdentifier	 new Column
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
setTokenPositioner	TokenNameIdentifier	 set Token Positioner
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
TokenPositioner	TokenNameIdentifier	 Token Positioner
tokenPositioner	TokenNameIdentifier	 token Positioner
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
UnsupportedOperationException	TokenNameIdentifier	 Unsupported Operation Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
float	TokenNamefloat	
getWeight	TokenNameIdentifier	 get Weight
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
1f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
setWeight	TokenNameIdentifier	 set Weight
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
float	TokenNamefloat	
weight	TokenNameIdentifier	 weight
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * A full featured codec not to be used for something serious. * * It takes complete control of * payload for weight * and the bit flags for positioning in the matrix. * * Mainly exist for demonstrational purposes. */	TokenNameCOMMENT_JAVADOC	 A full featured codec not to be used for something serious. * It takes complete control of payload for weight and the bit flags for positioning in the matrix. * Mainly exist for demonstrational purposes. 
public	TokenNamepublic	
static	TokenNamestatic	
class	TokenNameclass	
SimpleThreeDimensionalTokenSettingsCodec	TokenNameIdentifier	 Simple Three Dimensional Token Settings Codec
extends	TokenNameextends	
TokenSettingsCodec	TokenNameIdentifier	 Token Settings Codec
{	TokenNameLBRACE	
/** * @param token * @return the token flags int value as TokenPosition * @throws IOException */	TokenNameCOMMENT_JAVADOC	 @param token @return the token flags int value as TokenPosition @throws IOException 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
TokenPositioner	TokenNameIdentifier	 Token Positioner
getTokenPositioner	TokenNameIdentifier	 get Token Positioner
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
getFlags	TokenNameIdentifier	 get Flags
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
TokenPositioner	TokenNameIdentifier	 Token Positioner
.	TokenNameDOT	
newColumn	TokenNameIdentifier	 new Column
;	TokenNameSEMICOLON	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
TokenPositioner	TokenNameIdentifier	 Token Positioner
.	TokenNameDOT	
newRow	TokenNameIdentifier	 new Row
;	TokenNameSEMICOLON	
case	TokenNamecase	
2	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
TokenPositioner	TokenNameIdentifier	 Token Positioner
.	TokenNameDOT	
sameRow	TokenNameIdentifier	 same Row
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IOException	TokenNameIdentifier	 IO Exception
(	TokenNameLPAREN	
"Unknown matrix positioning of token "	TokenNameStringLiteral	Unknown matrix positioning of token 
+	TokenNamePLUS	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets the TokenPositioner as token flags int value. * * @param token * @param tokenPositioner */	TokenNameCOMMENT_JAVADOC	 Sets the TokenPositioner as token flags int value. * @param token @param tokenPositioner 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
setTokenPositioner	TokenNameIdentifier	 set Token Positioner
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
TokenPositioner	TokenNameIdentifier	 Token Positioner
tokenPositioner	TokenNameIdentifier	 token Positioner
)	TokenNameRPAREN	
{	TokenNameLBRACE	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
setFlags	TokenNameIdentifier	 set Flags
(	TokenNameLPAREN	
tokenPositioner	TokenNameIdentifier	 token Positioner
.	TokenNameDOT	
getIndex	TokenNameIdentifier	 get Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns a 32 bit float from the payload, or 1f it null. * * @param token * @return 32 bit float */	TokenNameCOMMENT_JAVADOC	 Returns a 32 bit float from the payload, or 1f it null. * @param token @return 32 bit float 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
float	TokenNamefloat	
getWeight	TokenNameIdentifier	 get Weight
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
getPayload	TokenNameIdentifier	 get Payload
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
getPayload	TokenNameIdentifier	 get Payload
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getData	TokenNameIdentifier	 get Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
1f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
PayloadHelper	TokenNameIdentifier	 Payload Helper
.	TokenNameDOT	
decodeFloat	TokenNameIdentifier	 decode Float
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
getPayload	TokenNameIdentifier	 get Payload
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getData	TokenNameIdentifier	 get Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Stores a 32 bit float in the payload, or set it to null if 1f; * @param token * @param weight */	TokenNameCOMMENT_JAVADOC	 Stores a 32 bit float in the payload, or set it to null if 1f; @param token @param weight 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
setWeight	TokenNameIdentifier	 set Weight
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
float	TokenNamefloat	
weight	TokenNameIdentifier	 weight
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
weight	TokenNameIdentifier	 weight
==	TokenNameEQUAL_EQUAL	
1f	TokenNameFloatingPointLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
setPayload	TokenNameIdentifier	 set Payload
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
setPayload	TokenNameIdentifier	 set Payload
(	TokenNameLPAREN	
new	TokenNamenew	
Payload	TokenNameIdentifier	 Payload
(	TokenNameLPAREN	
PayloadHelper	TokenNameIdentifier	 Payload Helper
.	TokenNameDOT	
encodeFloat	TokenNameIdentifier	 encode Float
(	TokenNameLPAREN	
weight	TokenNameIdentifier	 weight
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
