package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
fst	TokenNameIdentifier	 fst
;	TokenNameSEMICOLON	
/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_JAVADOC	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
BufferedInputStream	TokenNameIdentifier	 Buffered Input Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
BufferedOutputStream	TokenNameIdentifier	 Buffered Output Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
File	TokenNameIdentifier	 File
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
FileInputStream	TokenNameIdentifier	 File Input Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
FileOutputStream	TokenNameIdentifier	 File Output Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
InputStream	TokenNameIdentifier	 Input Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
OutputStream	TokenNameIdentifier	 Output Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
HashMap	TokenNameIdentifier	 Hash Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Map	TokenNameIdentifier	 Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
DataInput	TokenNameIdentifier	 Data Input
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
DataOutput	TokenNameIdentifier	 Data Output
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
InputStreamDataInput	TokenNameIdentifier	 Input Stream Data Input
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
OutputStreamDataOutput	TokenNameIdentifier	 Output Stream Data Output
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayUtil	TokenNameIdentifier	 Array Util
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
CodecUtil	TokenNameIdentifier	 Codec Util
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
IOUtils	TokenNameIdentifier	 IO Utils
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
IntsRef	TokenNameIdentifier	 Ints Ref
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
PriorityQueue	TokenNameIdentifier	 Priority Queue
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
RamUsageEstimator	TokenNameIdentifier	 Ram Usage Estimator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
Builder	TokenNameIdentifier	 Builder
.	TokenNameDOT	
UnCompiledNode	TokenNameIdentifier	 Un Compiled Node
;	TokenNameSEMICOLON	
// TODO: break this into WritableFST and ReadOnlyFST.. then 	TokenNameCOMMENT_LINE	TODO: break this into WritableFST and ReadOnlyFST.. then 
// we can have subclasses of ReadOnlyFST to handle the 	TokenNameCOMMENT_LINE	we can have subclasses of ReadOnlyFST to handle the 
// different byte[] level encodings (packed or 	TokenNameCOMMENT_LINE	different byte[] level encodings (packed or 
// not)... and things like nodeCount, arcCount are read only 	TokenNameCOMMENT_LINE	not)... and things like nodeCount, arcCount are read only 
// TODO: if FST is pure prefix trie we can do a more compact 	TokenNameCOMMENT_LINE	TODO: if FST is pure prefix trie we can do a more compact 
// job, ie, once we are at a 'suffix only', just store the 	TokenNameCOMMENT_LINE	job, ie, once we are at a 'suffix only', just store the 
// completion labels as a string not as a series of arcs. 	TokenNameCOMMENT_LINE	completion labels as a string not as a series of arcs. 
// TODO: maybe make an explicit thread state that holds 	TokenNameCOMMENT_LINE	TODO: maybe make an explicit thread state that holds 
// reusable stuff eg BytesReader, a scratch arc 	TokenNameCOMMENT_LINE	reusable stuff eg BytesReader, a scratch arc 
// NOTE: while the FST is able to represent a non-final 	TokenNameCOMMENT_LINE	NOTE: while the FST is able to represent a non-final 
// dead-end state (NON_FINAL_END_NODE=0), the layers above 	TokenNameCOMMENT_LINE	dead-end state (NON_FINAL_END_NODE=0), the layers above 
// (FSTEnum, Util) have problems with this!! 	TokenNameCOMMENT_LINE	(FSTEnum, Util) have problems with this!! 
/** Represents an finite state machine (FST), using a * compact byte[] format. * <p> The format is similar to what's used by Morfologik * (http://sourceforge.net/projects/morfologik). * * <p><b>NOTE</b>: the FST cannot be larger than ~2.1 GB * because it uses int to address the byte[]. * * @lucene.experimental */	TokenNameCOMMENT_JAVADOC	 Represents an finite state machine (FST), using a compact byte[] format. <p> The format is similar to what's used by Morfologik (http://sourceforge.net/projects/morfologik). * <p><b>NOTE</b>: the FST cannot be larger than ~2.1 GB because it uses int to address the byte[]. * @lucene.experimental 
public	TokenNamepublic	
final	TokenNamefinal	
class	TokenNameclass	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
{	TokenNameLBRACE	
/** Specifies allowed range of each int input label for * this FST. */	TokenNameCOMMENT_JAVADOC	 Specifies allowed range of each int input label for this FST. 
public	TokenNamepublic	
static	TokenNamestatic	
enum	TokenNameenum	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
{	TokenNameLBRACE	
BYTE1	TokenNameIdentifier	 BYT E1
,	TokenNameCOMMA	
BYTE2	TokenNameIdentifier	 BYT E2
,	TokenNameCOMMA	
BYTE4	TokenNameIdentifier	 BYT E4
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
inputType	TokenNameIdentifier	 input Type
;	TokenNameSEMICOLON	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
BIT_FINAL_ARC	TokenNameIdentifier	 BIT  FINAL  ARC
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
BIT_LAST_ARC	TokenNameIdentifier	 BIT  LAST  ARC
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
BIT_TARGET_NEXT	TokenNameIdentifier	 BIT  TARGET  NEXT
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// TODO: we can free up a bit if we can nuke this: 	TokenNameCOMMENT_LINE	TODO: we can free up a bit if we can nuke this: 
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
BIT_STOP_NODE	TokenNameIdentifier	 BIT  STOP  NODE
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
BIT_ARC_HAS_OUTPUT	TokenNameIdentifier	 BIT  ARC  HAS  OUTPUT
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
BIT_ARC_HAS_FINAL_OUTPUT	TokenNameIdentifier	 BIT  ARC  HAS  FINAL  OUTPUT
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
5	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Arcs are stored as fixed-size (per entry) array, so 	TokenNameCOMMENT_LINE	Arcs are stored as fixed-size (per entry) array, so 
// that we can find an arc using binary search. We do 	TokenNameCOMMENT_LINE	that we can find an arc using binary search. We do 
// this when number of arcs is > NUM_ARCS_ARRAY: 	TokenNameCOMMENT_LINE	this when number of arcs is > NUM_ARCS_ARRAY: 
// If set, the target node is delta coded vs current 	TokenNameCOMMENT_LINE	If set, the target node is delta coded vs current 
// position: 	TokenNameCOMMENT_LINE	position: 
private	TokenNameprivate	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
BIT_TARGET_DELTA	TokenNameIdentifier	 BIT  TARGET  DELTA
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
static	TokenNamestatic	
byte	TokenNamebyte	
ARCS_AS_FIXED_ARRAY	TokenNameIdentifier	 ARCS  AS  FIXED  ARRAY
=	TokenNameEQUAL	
BIT_ARC_HAS_FINAL_OUTPUT	TokenNameIdentifier	 BIT  ARC  HAS  FINAL  OUTPUT
;	TokenNameSEMICOLON	
/** * @see #shouldExpand(UnCompiledNode) */	TokenNameCOMMENT_JAVADOC	 @see #shouldExpand(UnCompiledNode) 
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
FIXED_ARRAY_SHALLOW_DISTANCE	TokenNameIdentifier	 FIXED  ARRAY  SHALLOW  DISTANCE
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// 0 => only root node. 	TokenNameCOMMENT_LINE	0 => only root node. 
/** * @see #shouldExpand(UnCompiledNode) */	TokenNameCOMMENT_JAVADOC	 @see #shouldExpand(UnCompiledNode) 
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
FIXED_ARRAY_NUM_ARCS_SHALLOW	TokenNameIdentifier	 FIXED  ARRAY  NUM  ARCS  SHALLOW
=	TokenNameEQUAL	
5	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** * @see #shouldExpand(UnCompiledNode) */	TokenNameCOMMENT_JAVADOC	 @see #shouldExpand(UnCompiledNode) 
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
FIXED_ARRAY_NUM_ARCS_DEEP	TokenNameIdentifier	 FIXED  ARRAY  NUM  ARCS  DEEP
=	TokenNameEQUAL	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// Increment version to change it 	TokenNameCOMMENT_LINE	Increment version to change it 
private	TokenNameprivate	
final	TokenNamefinal	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
FILE_FORMAT_NAME	TokenNameIdentifier	 FILE  FORMAT  NAME
=	TokenNameEQUAL	
"FST"	TokenNameStringLiteral	FST
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
VERSION_START	TokenNameIdentifier	 VERSION  START
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** Changed numBytesPerArc for array'd case from byte to int. */	TokenNameCOMMENT_JAVADOC	 Changed numBytesPerArc for array'd case from byte to int. 
private	TokenNameprivate	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
VERSION_INT_NUM_BYTES_PER_ARC	TokenNameIdentifier	 VERSION  INT  NUM  BYTES  PER  ARC
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** Write BYTE2 labels as 2-byte short, not vInt. */	TokenNameCOMMENT_JAVADOC	 Write BYTE2 labels as 2-byte short, not vInt. 
private	TokenNameprivate	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
VERSION_SHORT_BYTE2_LABELS	TokenNameIdentifier	 VERSION  SHORT  BYT E2  LABELS
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** Added optional packed format. */	TokenNameCOMMENT_JAVADOC	 Added optional packed format. 
private	TokenNameprivate	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
VERSION_PACKED	TokenNameIdentifier	 VERSION  PACKED
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
VERSION_CURRENT	TokenNameIdentifier	 VERSION  CURRENT
=	TokenNameEQUAL	
VERSION_PACKED	TokenNameIdentifier	 VERSION  PACKED
;	TokenNameSEMICOLON	
// Never serialized; just used to represent the virtual 	TokenNameCOMMENT_LINE	Never serialized; just used to represent the virtual 
// final node w/ no arcs: 	TokenNameCOMMENT_LINE	final node w/ no arcs: 
private	TokenNameprivate	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
FINAL_END_NODE	TokenNameIdentifier	 FINAL  END  NODE
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Never serialized; just used to represent the virtual 	TokenNameCOMMENT_LINE	Never serialized; just used to represent the virtual 
// non-final node w/ no arcs: 	TokenNameCOMMENT_LINE	non-final node w/ no arcs: 
private	TokenNameprivate	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
NON_FINAL_END_NODE	TokenNameIdentifier	 NON  FINAL  END  NODE
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// if non-null, this FST accepts the empty string and 	TokenNameCOMMENT_LINE	if non-null, this FST accepts the empty string and 
// produces this output 	TokenNameCOMMENT_LINE	produces this output 
T	TokenNameIdentifier	 T
emptyOutput	TokenNameIdentifier	 empty Output
;	TokenNameSEMICOLON	
private	TokenNameprivate	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
emptyOutputBytes	TokenNameIdentifier	 empty Output Bytes
;	TokenNameSEMICOLON	
// Not private to avoid synthetic access$NNN methods: 	TokenNameCOMMENT_LINE	Not private to avoid synthetic access$NNN methods: 
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bytes	TokenNameIdentifier	 bytes
;	TokenNameSEMICOLON	
int	TokenNameint	
byteUpto	TokenNameIdentifier	 byte Upto
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
startNode	TokenNameIdentifier	 start Node
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
Outputs	TokenNameIdentifier	 Outputs
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
outputs	TokenNameIdentifier	 outputs
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
lastFrozenNode	TokenNameIdentifier	 last Frozen Node
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
T	TokenNameIdentifier	 T
NO_OUTPUT	TokenNameIdentifier	 NO  OUTPUT
;	TokenNameSEMICOLON	
public	TokenNamepublic	
int	TokenNameint	
nodeCount	TokenNameIdentifier	 node Count
;	TokenNameSEMICOLON	
public	TokenNamepublic	
int	TokenNameint	
arcCount	TokenNameIdentifier	 arc Count
;	TokenNameSEMICOLON	
public	TokenNamepublic	
int	TokenNameint	
arcWithOutputCount	TokenNameIdentifier	 arc With Output Count
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
boolean	TokenNameboolean	
packed	TokenNameIdentifier	 packed
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
nodeRefToAddress	TokenNameIdentifier	 node Ref To Address
;	TokenNameSEMICOLON	
// If arc has this label then that arc is final/accepted 	TokenNameCOMMENT_LINE	If arc has this label then that arc is final/accepted 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
END_LABEL	TokenNameIdentifier	 END  LABEL
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
allowArrayArcs	TokenNameIdentifier	 allow Array Arcs
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
cachedRootArcs	TokenNameIdentifier	 cached Root Arcs
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/** Represents a single arc. */	TokenNameCOMMENT_JAVADOC	 Represents a single arc. 
public	TokenNamepublic	
final	TokenNamefinal	
static	TokenNamestatic	
class	TokenNameclass	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
{	TokenNameLBRACE	
public	TokenNamepublic	
int	TokenNameint	
label	TokenNameIdentifier	 label
;	TokenNameSEMICOLON	
public	TokenNamepublic	
T	TokenNameIdentifier	 T
output	TokenNameIdentifier	 output
;	TokenNameSEMICOLON	
// From node (ord or address); currently only used when 	TokenNameCOMMENT_LINE	From node (ord or address); currently only used when 
// building an FST w/ willPackFST=true: 	TokenNameCOMMENT_LINE	building an FST w/ willPackFST=true: 
int	TokenNameint	
node	TokenNameIdentifier	 node
;	TokenNameSEMICOLON	
// To node (ord or address): 	TokenNameCOMMENT_LINE	To node (ord or address): 
public	TokenNamepublic	
int	TokenNameint	
target	TokenNameIdentifier	 target
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
flags	TokenNameIdentifier	 flags
;	TokenNameSEMICOLON	
public	TokenNamepublic	
T	TokenNameIdentifier	 T
nextFinalOutput	TokenNameIdentifier	 next Final Output
;	TokenNameSEMICOLON	
// address (into the byte[]), or ord/address if label == END_LABEL 	TokenNameCOMMENT_LINE	address (into the byte[]), or ord/address if label == END_LABEL 
int	TokenNameint	
nextArc	TokenNameIdentifier	 next Arc
;	TokenNameSEMICOLON	
// This is non-zero if current arcs are fixed array: 	TokenNameCOMMENT_LINE	This is non-zero if current arcs are fixed array: 
int	TokenNameint	
posArcsStart	TokenNameIdentifier	 pos Arcs Start
;	TokenNameSEMICOLON	
int	TokenNameint	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
;	TokenNameSEMICOLON	
int	TokenNameint	
arcIdx	TokenNameIdentifier	 arc Idx
;	TokenNameSEMICOLON	
int	TokenNameint	
numArcs	TokenNameIdentifier	 num Arcs
;	TokenNameSEMICOLON	
/** Returns this */	TokenNameCOMMENT_JAVADOC	 Returns this 
public	TokenNamepublic	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
copyFrom	TokenNameIdentifier	 copy From
(	TokenNameLPAREN	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
other	TokenNameIdentifier	 other
)	TokenNameRPAREN	
{	TokenNameLBRACE	
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
node	TokenNameIdentifier	 node
;	TokenNameSEMICOLON	
label	TokenNameIdentifier	 label
=	TokenNameEQUAL	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
label	TokenNameIdentifier	 label
;	TokenNameSEMICOLON	
target	TokenNameIdentifier	 target
=	TokenNameEQUAL	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
target	TokenNameIdentifier	 target
;	TokenNameSEMICOLON	
flags	TokenNameIdentifier	 flags
=	TokenNameEQUAL	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
flags	TokenNameIdentifier	 flags
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
output	TokenNameIdentifier	 output
;	TokenNameSEMICOLON	
nextFinalOutput	TokenNameIdentifier	 next Final Output
=	TokenNameEQUAL	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
nextFinalOutput	TokenNameIdentifier	 next Final Output
;	TokenNameSEMICOLON	
nextArc	TokenNameIdentifier	 next Arc
=	TokenNameEQUAL	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
nextArc	TokenNameIdentifier	 next Arc
;	TokenNameSEMICOLON	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
=	TokenNameEQUAL	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
posArcsStart	TokenNameIdentifier	 pos Arcs Start
=	TokenNameEQUAL	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
posArcsStart	TokenNameIdentifier	 pos Arcs Start
;	TokenNameSEMICOLON	
arcIdx	TokenNameIdentifier	 arc Idx
=	TokenNameEQUAL	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
arcIdx	TokenNameIdentifier	 arc Idx
;	TokenNameSEMICOLON	
numArcs	TokenNameIdentifier	 num Arcs
=	TokenNameEQUAL	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
numArcs	TokenNameIdentifier	 num Arcs
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
this	TokenNamethis	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
boolean	TokenNameboolean	
flag	TokenNameIdentifier	 flag
(	TokenNameLPAREN	
int	TokenNameint	
flag	TokenNameIdentifier	 flag
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
flag	TokenNameIdentifier	 flag
(	TokenNameLPAREN	
flags	TokenNameIdentifier	 flags
,	TokenNameCOMMA	
flag	TokenNameIdentifier	 flag
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isLast	TokenNameIdentifier	 is Last
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
flag	TokenNameIdentifier	 flag
(	TokenNameLPAREN	
BIT_LAST_ARC	TokenNameIdentifier	 BIT  LAST  ARC
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isFinal	TokenNameIdentifier	 is Final
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
flag	TokenNameIdentifier	 flag
(	TokenNameLPAREN	
BIT_FINAL_ARC	TokenNameIdentifier	 BIT  FINAL  ARC
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
String	TokenNameIdentifier	 String
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StringBuilder	TokenNameIdentifier	 String Builder
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuilder	TokenNameIdentifier	 String Builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"node="	TokenNameStringLiteral	node=
+	TokenNamePLUS	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" target="	TokenNameStringLiteral	 target=
+	TokenNamePLUS	
target	TokenNameIdentifier	 target
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" label="	TokenNameStringLiteral	 label=
+	TokenNamePLUS	
label	TokenNameIdentifier	 label
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
flag	TokenNameIdentifier	 flag
(	TokenNameLPAREN	
BIT_LAST_ARC	TokenNameIdentifier	 BIT  LAST  ARC
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" last"	TokenNameStringLiteral	 last
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
flag	TokenNameIdentifier	 flag
(	TokenNameLPAREN	
BIT_FINAL_ARC	TokenNameIdentifier	 BIT  FINAL  ARC
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" final"	TokenNameStringLiteral	 final
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
flag	TokenNameIdentifier	 flag
(	TokenNameLPAREN	
BIT_TARGET_NEXT	TokenNameIdentifier	 BIT  TARGET  NEXT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" targetNext"	TokenNameStringLiteral	 targetNext
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
flag	TokenNameIdentifier	 flag
(	TokenNameLPAREN	
BIT_ARC_HAS_OUTPUT	TokenNameIdentifier	 BIT  ARC  HAS  OUTPUT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" output="	TokenNameStringLiteral	 output=
+	TokenNamePLUS	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
flag	TokenNameIdentifier	 flag
(	TokenNameLPAREN	
BIT_ARC_HAS_FINAL_OUTPUT	TokenNameIdentifier	 BIT  ARC  HAS  FINAL  OUTPUT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" nextFinalOutput="	TokenNameStringLiteral	 nextFinalOutput=
+	TokenNamePLUS	
nextFinalOutput	TokenNameIdentifier	 next Final Output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" arcArray(idx="	TokenNameStringLiteral	 arcArray(idx=
+	TokenNamePLUS	
arcIdx	TokenNameIdentifier	 arc Idx
+	TokenNamePLUS	
" of "	TokenNameStringLiteral	 of 
+	TokenNamePLUS	
numArcs	TokenNameIdentifier	 num Arcs
+	TokenNamePLUS	
")"	TokenNameStringLiteral	)
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
static	TokenNamestatic	
boolean	TokenNameboolean	
flag	TokenNameIdentifier	 flag
(	TokenNameLPAREN	
int	TokenNameint	
flags	TokenNameIdentifier	 flags
,	TokenNameCOMMA	
int	TokenNameint	
bit	TokenNameIdentifier	 bit
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
flags	TokenNameIdentifier	 flags
&	TokenNameAND	
bit	TokenNameIdentifier	 bit
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
BytesWriter	TokenNameIdentifier	 Bytes Writer
writer	TokenNameIdentifier	 writer
;	TokenNameSEMICOLON	
// TODO: we can save RAM here by using growable packed 	TokenNameCOMMENT_LINE	TODO: we can save RAM here by using growable packed 
// ints...: 	TokenNameCOMMENT_LINE	ints...: 
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
nodeAddress	TokenNameIdentifier	 node Address
;	TokenNameSEMICOLON	
// TODO: we could be smarter here, and prune periodically 	TokenNameCOMMENT_LINE	TODO: we could be smarter here, and prune periodically 
// as we go; high in-count nodes will "usually" become 	TokenNameCOMMENT_LINE	as we go; high in-count nodes will "usually" become 
// clear early on: 	TokenNameCOMMENT_LINE	clear early on: 
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
inCounts	TokenNameIdentifier	 in Counts
;	TokenNameSEMICOLON	
// make a new empty FST, for building; Builder invokes 	TokenNameCOMMENT_LINE	make a new empty FST, for building; Builder invokes 
// this ctor 	TokenNameCOMMENT_LINE	this ctor 
FST	TokenNameIdentifier	 FST
(	TokenNameLPAREN	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
inputType	TokenNameIdentifier	 input Type
,	TokenNameCOMMA	
Outputs	TokenNameIdentifier	 Outputs
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
outputs	TokenNameIdentifier	 outputs
,	TokenNameCOMMA	
boolean	TokenNameboolean	
willPackFST	TokenNameIdentifier	 will Pack FST
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
inputType	TokenNameIdentifier	 input Type
=	TokenNameEQUAL	
inputType	TokenNameIdentifier	 input Type
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
;	TokenNameSEMICOLON	
bytes	TokenNameIdentifier	 bytes
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
128	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
NO_OUTPUT	TokenNameIdentifier	 NO  OUTPUT
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
getNoOutput	TokenNameIdentifier	 get No Output
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
willPackFST	TokenNameIdentifier	 will Pack FST
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nodeAddress	TokenNameIdentifier	 node Address
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
8	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
inCounts	TokenNameIdentifier	 in Counts
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
8	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
nodeAddress	TokenNameIdentifier	 node Address
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
inCounts	TokenNameIdentifier	 in Counts
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
writer	TokenNameIdentifier	 writer
=	TokenNameEQUAL	
new	TokenNamenew	
BytesWriter	TokenNameIdentifier	 Bytes Writer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
emptyOutput	TokenNameIdentifier	 empty Output
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
packed	TokenNameIdentifier	 packed
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
nodeRefToAddress	TokenNameIdentifier	 node Ref To Address
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Load a previously saved FST. */	TokenNameCOMMENT_JAVADOC	 Load a previously saved FST. 
public	TokenNamepublic	
FST	TokenNameIdentifier	 FST
(	TokenNameLPAREN	
DataInput	TokenNameIdentifier	 Data Input
in	TokenNameIdentifier	 in
,	TokenNameCOMMA	
Outputs	TokenNameIdentifier	 Outputs
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
outputs	TokenNameIdentifier	 outputs
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
;	TokenNameSEMICOLON	
writer	TokenNameIdentifier	 writer
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// NOTE: only reads most recent format; we don't have 	TokenNameCOMMENT_LINE	NOTE: only reads most recent format; we don't have 
// back-compat promise for FSTs (they are experimental): 	TokenNameCOMMENT_LINE	back-compat promise for FSTs (they are experimental): 
CodecUtil	TokenNameIdentifier	 Codec Util
.	TokenNameDOT	
checkHeader	TokenNameIdentifier	 check Header
(	TokenNameLPAREN	
in	TokenNameIdentifier	 in
,	TokenNameCOMMA	
FILE_FORMAT_NAME	TokenNameIdentifier	 FILE  FORMAT  NAME
,	TokenNameCOMMA	
VERSION_PACKED	TokenNameIdentifier	 VERSION  PACKED
,	TokenNameCOMMA	
VERSION_PACKED	TokenNameIdentifier	 VERSION  PACKED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
packed	TokenNameIdentifier	 packed
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readByte	TokenNameIdentifier	 read Byte
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readByte	TokenNameIdentifier	 read Byte
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// accepts empty string 	TokenNameCOMMENT_LINE	accepts empty string 
int	TokenNameint	
numBytes	TokenNameIdentifier	 num Bytes
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// messy 	TokenNameCOMMENT_LINE	messy 
bytes	TokenNameIdentifier	 bytes
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
numBytes	TokenNameIdentifier	 num Bytes
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readBytes	TokenNameIdentifier	 read Bytes
(	TokenNameLPAREN	
bytes	TokenNameIdentifier	 bytes
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
numBytes	TokenNameIdentifier	 num Bytes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
packed	TokenNameIdentifier	 packed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
emptyOutput	TokenNameIdentifier	 empty Output
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
read	TokenNameIdentifier	 read
(	TokenNameLPAREN	
getBytesReader	TokenNameIdentifier	 get Bytes Reader
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
emptyOutput	TokenNameIdentifier	 empty Output
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
read	TokenNameIdentifier	 read
(	TokenNameLPAREN	
getBytesReader	TokenNameIdentifier	 get Bytes Reader
(	TokenNameLPAREN	
numBytes	TokenNameIdentifier	 num Bytes
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
emptyOutput	TokenNameIdentifier	 empty Output
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
byte	TokenNamebyte	
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readByte	TokenNameIdentifier	 read Byte
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
inputType	TokenNameIdentifier	 input Type
=	TokenNameEQUAL	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
.	TokenNameDOT	
BYTE1	TokenNameIdentifier	 BYT E1
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
inputType	TokenNameIdentifier	 input Type
=	TokenNameEQUAL	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
.	TokenNameDOT	
BYTE2	TokenNameIdentifier	 BYT E2
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
2	TokenNameIntegerLiteral	
:	TokenNameCOLON	
inputType	TokenNameIdentifier	 input Type
=	TokenNameEQUAL	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
.	TokenNameDOT	
BYTE4	TokenNameIdentifier	 BYT E4
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
"invalid input type "	TokenNameStringLiteral	invalid input type 
+	TokenNamePLUS	
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
packed	TokenNameIdentifier	 packed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
nodeRefCount	TokenNameIdentifier	 node Ref Count
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
nodeRefToAddress	TokenNameIdentifier	 node Ref To Address
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
nodeRefCount	TokenNameIdentifier	 node Ref Count
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
<	TokenNameLESS	
nodeRefCount	TokenNameIdentifier	 node Ref Count
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nodeRefToAddress	TokenNameIdentifier	 node Ref To Address
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
nodeRefToAddress	TokenNameIdentifier	 node Ref To Address
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
startNode	TokenNameIdentifier	 start Node
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
nodeCount	TokenNameIdentifier	 node Count
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
arcCount	TokenNameIdentifier	 arc Count
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
arcWithOutputCount	TokenNameIdentifier	 arc With Output Count
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bytes	TokenNameIdentifier	 bytes
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readBytes	TokenNameIdentifier	 read Bytes
(	TokenNameLPAREN	
bytes	TokenNameIdentifier	 bytes
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
bytes	TokenNameIdentifier	 bytes
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
NO_OUTPUT	TokenNameIdentifier	 NO  OUTPUT
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
getNoOutput	TokenNameIdentifier	 get No Output
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cacheRootArcs	TokenNameIdentifier	 cache Root Arcs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
getInputType	TokenNameIdentifier	 get Input Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
inputType	TokenNameIdentifier	 input Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Returns bytes used to represent the FST */	TokenNameCOMMENT_JAVADOC	 Returns bytes used to represent the FST 
public	TokenNamepublic	
int	TokenNameint	
sizeInBytes	TokenNameIdentifier	 size In Bytes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
bytes	TokenNameIdentifier	 bytes
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
packed	TokenNameIdentifier	 packed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
size	TokenNameIdentifier	 size
+=	TokenNamePLUS_EQUAL	
nodeRefToAddress	TokenNameIdentifier	 node Ref To Address
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
RamUsageEstimator	TokenNameIdentifier	 Ram Usage Estimator
.	TokenNameDOT	
NUM_BYTES_INT	TokenNameIdentifier	 NUM  BYTES  INT
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
nodeAddress	TokenNameIdentifier	 node Address
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
size	TokenNameIdentifier	 size
+=	TokenNamePLUS_EQUAL	
nodeAddress	TokenNameIdentifier	 node Address
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
RamUsageEstimator	TokenNameIdentifier	 Ram Usage Estimator
.	TokenNameDOT	
NUM_BYTES_INT	TokenNameIdentifier	 NUM  BYTES  INT
;	TokenNameSEMICOLON	
size	TokenNameIdentifier	 size
+=	TokenNamePLUS_EQUAL	
inCounts	TokenNameIdentifier	 in Counts
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
RamUsageEstimator	TokenNameIdentifier	 Ram Usage Estimator
.	TokenNameDOT	
NUM_BYTES_INT	TokenNameIdentifier	 NUM  BYTES  INT
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
void	TokenNamevoid	
finish	TokenNameIdentifier	 finish
(	TokenNameLPAREN	
int	TokenNameint	
startNode	TokenNameIdentifier	 start Node
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
startNode	TokenNameIdentifier	 start Node
==	TokenNameEQUAL_EQUAL	
FINAL_END_NODE	TokenNameIdentifier	 FINAL  END  NODE
&&	TokenNameAND_AND	
emptyOutput	TokenNameIdentifier	 empty Output
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
startNode	TokenNameIdentifier	 start Node
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
startNode	TokenNameIdentifier	 start Node
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
"already finished"	TokenNameStringLiteral	already finished
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
finalBytes	TokenNameIdentifier	 final Bytes
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
posWrite	TokenNameIdentifier	 pos Write
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
bytes	TokenNameIdentifier	 bytes
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
finalBytes	TokenNameIdentifier	 final Bytes
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
posWrite	TokenNameIdentifier	 pos Write
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bytes	TokenNameIdentifier	 bytes
=	TokenNameEQUAL	
finalBytes	TokenNameIdentifier	 final Bytes
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
startNode	TokenNameIdentifier	 start Node
=	TokenNameEQUAL	
startNode	TokenNameIdentifier	 start Node
;	TokenNameSEMICOLON	
cacheRootArcs	TokenNameIdentifier	 cache Root Arcs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
getNodeAddress	TokenNameIdentifier	 get Node Address
(	TokenNameLPAREN	
int	TokenNameint	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
nodeAddress	TokenNameIdentifier	 node Address
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Deref 	TokenNameCOMMENT_LINE	Deref 
return	TokenNamereturn	
nodeAddress	TokenNameIdentifier	 node Address
[	TokenNameLBRACKET	
node	TokenNameIdentifier	 node
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Straight 	TokenNameCOMMENT_LINE	Straight 
return	TokenNamereturn	
node	TokenNameIdentifier	 node
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Caches first 128 labels 	TokenNameCOMMENT_LINE	Caches first 128 labels 
@	TokenNameAT	
SuppressWarnings	TokenNameIdentifier	 Suppress Warnings
(	TokenNameLPAREN	
{	TokenNameLBRACE	
"rawtypes"	TokenNameStringLiteral	rawtypes
,	TokenNameCOMMA	
"unchecked"	TokenNameStringLiteral	unchecked
}	TokenNameRBRACE	
)	TokenNameRPAREN	
private	TokenNameprivate	
void	TokenNamevoid	
cacheRootArcs	TokenNameIdentifier	 cache Root Arcs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
cachedRootArcs	TokenNameIdentifier	 cached Root Arcs
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
new	TokenNamenew	
Arc	TokenNameIdentifier	 Arc
[	TokenNameLBRACKET	
0x80	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
arc	TokenNameIdentifier	 arc
=	TokenNameEQUAL	
new	TokenNamenew	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
getFirstArc	TokenNameIdentifier	 get First Arc
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
BytesReader	TokenNameIdentifier	 Bytes Reader
in	TokenNameIdentifier	 in
=	TokenNameEQUAL	
getBytesReader	TokenNameIdentifier	 get Bytes Reader
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
targetHasArcs	TokenNameIdentifier	 target Has Arcs
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
readFirstRealTargetArc	TokenNameIdentifier	 read First Real Target Arc
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
target	TokenNameIdentifier	 target
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
in	TokenNameIdentifier	 in
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
label	TokenNameIdentifier	 label
!=	TokenNameNOT_EQUAL	
END_LABEL	TokenNameIdentifier	 END  LABEL
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
label	TokenNameIdentifier	 label
<	TokenNameLESS	
cachedRootArcs	TokenNameIdentifier	 cached Root Arcs
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
cachedRootArcs	TokenNameIdentifier	 cached Root Arcs
[	TokenNameLBRACKET	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
label	TokenNameIdentifier	 label
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
copyFrom	TokenNameIdentifier	 copy From
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
isLast	TokenNameIdentifier	 is Last
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
readNextRealArc	TokenNameIdentifier	 read Next Real Arc
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
in	TokenNameIdentifier	 in
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
T	TokenNameIdentifier	 T
getEmptyOutput	TokenNameIdentifier	 get Empty Output
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
emptyOutput	TokenNameIdentifier	 empty Output
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
void	TokenNamevoid	
setEmptyOutput	TokenNameIdentifier	 set Empty Output
(	TokenNameLPAREN	
T	TokenNameIdentifier	 T
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
emptyOutput	TokenNameIdentifier	 empty Output
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
emptyOutput	TokenNameIdentifier	 empty Output
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
merge	TokenNameIdentifier	 merge
(	TokenNameLPAREN	
emptyOutput	TokenNameIdentifier	 empty Output
,	TokenNameCOMMA	
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
emptyOutput	TokenNameIdentifier	 empty Output
=	TokenNameEQUAL	
v	TokenNameIdentifier	 v
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// TODO: this is messy -- replace with sillyBytesWriter; maybe make 	TokenNameCOMMENT_LINE	TODO: this is messy -- replace with sillyBytesWriter; maybe make 
// bytes private 	TokenNameCOMMENT_LINE	bytes private 
final	TokenNamefinal	
int	TokenNameint	
posSave	TokenNameIdentifier	 pos Save
=	TokenNameEQUAL	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
posWrite	TokenNameIdentifier	 pos Write
;	TokenNameSEMICOLON	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
emptyOutput	TokenNameIdentifier	 empty Output
,	TokenNameCOMMA	
writer	TokenNameIdentifier	 writer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
emptyOutputBytes	TokenNameIdentifier	 empty Output Bytes
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
posWrite	TokenNameIdentifier	 pos Write
-	TokenNameMINUS	
posSave	TokenNameIdentifier	 pos Save
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
packed	TokenNameIdentifier	 packed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// reverse 	TokenNameCOMMENT_LINE	reverse 
final	TokenNamefinal	
int	TokenNameint	
stopAt	TokenNameIdentifier	 stop At
=	TokenNameEQUAL	
(	TokenNameLPAREN	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
posWrite	TokenNameIdentifier	 pos Write
-	TokenNameMINUS	
posSave	TokenNameIdentifier	 pos Save
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
upto	TokenNameIdentifier	 upto
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
upto	TokenNameIdentifier	 upto
<	TokenNameLESS	
stopAt	TokenNameIdentifier	 stop At
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
byte	TokenNamebyte	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
bytes	TokenNameIdentifier	 bytes
[	TokenNameLBRACKET	
posSave	TokenNameIdentifier	 pos Save
+	TokenNamePLUS	
upto	TokenNameIdentifier	 upto
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
bytes	TokenNameIdentifier	 bytes
[	TokenNameLBRACKET	
posSave	TokenNameIdentifier	 pos Save
+	TokenNamePLUS	
upto	TokenNameIdentifier	 upto
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
bytes	TokenNameIdentifier	 bytes
[	TokenNameLBRACKET	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
posWrite	TokenNameIdentifier	 pos Write
-	TokenNameMINUS	
upto	TokenNameIdentifier	 upto
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
bytes	TokenNameIdentifier	 bytes
[	TokenNameLBRACKET	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
posWrite	TokenNameIdentifier	 pos Write
-	TokenNameMINUS	
upto	TokenNameIdentifier	 upto
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
upto	TokenNameIdentifier	 upto
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
bytes	TokenNameIdentifier	 bytes
,	TokenNameCOMMA	
posSave	TokenNameIdentifier	 pos Save
,	TokenNameCOMMA	
emptyOutputBytes	TokenNameIdentifier	 empty Output Bytes
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
posWrite	TokenNameIdentifier	 pos Write
-	TokenNameMINUS	
posSave	TokenNameIdentifier	 pos Save
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
posWrite	TokenNameIdentifier	 pos Write
=	TokenNameEQUAL	
posSave	TokenNameIdentifier	 pos Save
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
save	TokenNameIdentifier	 save
(	TokenNameLPAREN	
DataOutput	TokenNameIdentifier	 Data Output
out	TokenNameIdentifier	 out
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
startNode	TokenNameIdentifier	 start Node
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
"call finish first"	TokenNameStringLiteral	call finish first
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
nodeAddress	TokenNameIdentifier	 node Address
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
"cannot save an FST pre-packed FST; it must first be packed"	TokenNameStringLiteral	cannot save an FST pre-packed FST; it must first be packed
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
CodecUtil	TokenNameIdentifier	 Codec Util
.	TokenNameDOT	
writeHeader	TokenNameIdentifier	 write Header
(	TokenNameLPAREN	
out	TokenNameIdentifier	 out
,	TokenNameCOMMA	
FILE_FORMAT_NAME	TokenNameIdentifier	 FILE  FORMAT  NAME
,	TokenNameCOMMA	
VERSION_CURRENT	TokenNameIdentifier	 VERSION  CURRENT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
packed	TokenNameIdentifier	 packed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// TODO: really we should encode this as an arc, arriving 	TokenNameCOMMENT_LINE	TODO: really we should encode this as an arc, arriving 
// to the root node, instead of special casing here: 	TokenNameCOMMENT_LINE	to the root node, instead of special casing here: 
if	TokenNameif	
(	TokenNameLPAREN	
emptyOutput	TokenNameIdentifier	 empty Output
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
writeVInt	TokenNameIdentifier	 write V Int
(	TokenNameLPAREN	
emptyOutputBytes	TokenNameIdentifier	 empty Output Bytes
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
writeBytes	TokenNameIdentifier	 write Bytes
(	TokenNameLPAREN	
emptyOutputBytes	TokenNameIdentifier	 empty Output Bytes
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
emptyOutputBytes	TokenNameIdentifier	 empty Output Bytes
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
byte	TokenNamebyte	
t	TokenNameIdentifier	 t
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
inputType	TokenNameIdentifier	 input Type
==	TokenNameEQUAL_EQUAL	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
.	TokenNameDOT	
BYTE1	TokenNameIdentifier	 BYT E1
)	TokenNameRPAREN	
{	TokenNameLBRACE	
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
inputType	TokenNameIdentifier	 input Type
==	TokenNameEQUAL_EQUAL	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
.	TokenNameDOT	
BYTE2	TokenNameIdentifier	 BYT E2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
packed	TokenNameIdentifier	 packed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
nodeRefToAddress	TokenNameIdentifier	 node Ref To Address
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
writeVInt	TokenNameIdentifier	 write V Int
(	TokenNameLPAREN	
nodeRefToAddress	TokenNameIdentifier	 node Ref To Address
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
<	TokenNameLESS	
nodeRefToAddress	TokenNameIdentifier	 node Ref To Address
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
writeVInt	TokenNameIdentifier	 write V Int
(	TokenNameLPAREN	
nodeRefToAddress	TokenNameIdentifier	 node Ref To Address
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
writeVInt	TokenNameIdentifier	 write V Int
(	TokenNameLPAREN	
startNode	TokenNameIdentifier	 start Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
writeVInt	TokenNameIdentifier	 write V Int
(	TokenNameLPAREN	
nodeCount	TokenNameIdentifier	 node Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
writeVInt	TokenNameIdentifier	 write V Int
(	TokenNameLPAREN	
arcCount	TokenNameIdentifier	 arc Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
writeVInt	TokenNameIdentifier	 write V Int
(	TokenNameLPAREN	
arcWithOutputCount	TokenNameIdentifier	 arc With Output Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
writeVInt	TokenNameIdentifier	 write V Int
(	TokenNameLPAREN	
bytes	TokenNameIdentifier	 bytes
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
writeBytes	TokenNameIdentifier	 write Bytes
(	TokenNameLPAREN	
bytes	TokenNameIdentifier	 bytes
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
bytes	TokenNameIdentifier	 bytes
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Writes an automaton to a file. */	TokenNameCOMMENT_JAVADOC	 Writes an automaton to a file. 
public	TokenNamepublic	
void	TokenNamevoid	
save	TokenNameIdentifier	 save
(	TokenNameLPAREN	
final	TokenNamefinal	
File	TokenNameIdentifier	 File
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
boolean	TokenNameboolean	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
OutputStream	TokenNameIdentifier	 Output Stream
os	TokenNameIdentifier	 os
=	TokenNameEQUAL	
new	TokenNamenew	
BufferedOutputStream	TokenNameIdentifier	 Buffered Output Stream
(	TokenNameLPAREN	
new	TokenNamenew	
FileOutputStream	TokenNameIdentifier	 File Output Stream
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
save	TokenNameIdentifier	 save
(	TokenNameLPAREN	
new	TokenNamenew	
OutputStreamDataOutput	TokenNameIdentifier	 Output Stream Data Output
(	TokenNameLPAREN	
os	TokenNameIdentifier	 os
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
success	TokenNameIdentifier	 success
)	TokenNameRPAREN	
{	TokenNameLBRACE	
IOUtils	TokenNameIdentifier	 IO Utils
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
os	TokenNameIdentifier	 os
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
IOUtils	TokenNameIdentifier	 IO Utils
.	TokenNameDOT	
closeWhileHandlingException	TokenNameIdentifier	 close While Handling Exception
(	TokenNameLPAREN	
os	TokenNameIdentifier	 os
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Reads an automaton from a file. */	TokenNameCOMMENT_JAVADOC	 Reads an automaton from a file. 
public	TokenNamepublic	
static	TokenNamestatic	
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
read	TokenNameIdentifier	 read
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
Outputs	TokenNameIdentifier	 Outputs
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
outputs	TokenNameIdentifier	 outputs
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
InputStream	TokenNameIdentifier	 Input Stream
is	TokenNameIdentifier	 is
=	TokenNameEQUAL	
new	TokenNamenew	
BufferedInputStream	TokenNameIdentifier	 Buffered Input Stream
(	TokenNameLPAREN	
new	TokenNamenew	
FileInputStream	TokenNameIdentifier	 File Input Stream
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
fst	TokenNameIdentifier	 fst
=	TokenNameEQUAL	
new	TokenNamenew	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
(	TokenNameLPAREN	
new	TokenNamenew	
InputStreamDataInput	TokenNameIdentifier	 Input Stream Data Input
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
)	TokenNameRPAREN	
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
fst	TokenNameIdentifier	 fst
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
success	TokenNameIdentifier	 success
)	TokenNameRPAREN	
{	TokenNameLBRACE	
IOUtils	TokenNameIdentifier	 IO Utils
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
IOUtils	TokenNameIdentifier	 IO Utils
.	TokenNameDOT	
closeWhileHandlingException	TokenNameIdentifier	 close While Handling Exception
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
writeLabel	TokenNameIdentifier	 write Label
(	TokenNameLPAREN	
int	TokenNameint	
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
assert	TokenNameassert	
v	TokenNameIdentifier	 v
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
"v="	TokenNameStringLiteral	v=
+	TokenNamePLUS	
v	TokenNameIdentifier	 v
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
inputType	TokenNameIdentifier	 input Type
==	TokenNameEQUAL_EQUAL	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
.	TokenNameDOT	
BYTE1	TokenNameIdentifier	 BYT E1
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
v	TokenNameIdentifier	 v
<=	TokenNameLESS_EQUAL	
255	TokenNameIntegerLiteral	
:	TokenNameCOLON	
"v="	TokenNameStringLiteral	v=
+	TokenNamePLUS	
v	TokenNameIdentifier	 v
;	TokenNameSEMICOLON	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
inputType	TokenNameIdentifier	 input Type
==	TokenNameEQUAL_EQUAL	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
.	TokenNameDOT	
BYTE2	TokenNameIdentifier	 BYT E2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
v	TokenNameIdentifier	 v
<=	TokenNameLESS_EQUAL	
65535	TokenNameIntegerLiteral	
:	TokenNameCOLON	
"v="	TokenNameStringLiteral	v=
+	TokenNamePLUS	
v	TokenNameIdentifier	 v
;	TokenNameSEMICOLON	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
writeShort	TokenNameIdentifier	 write Short
(	TokenNameLPAREN	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
//writeInt(v); 	TokenNameCOMMENT_LINE	writeInt(v); 
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
writeVInt	TokenNameIdentifier	 write V Int
(	TokenNameLPAREN	
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
int	TokenNameint	
readLabel	TokenNameIdentifier	 read Label
(	TokenNameLPAREN	
DataInput	TokenNameIdentifier	 Data Input
in	TokenNameIdentifier	 in
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
v	TokenNameIdentifier	 v
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
inputType	TokenNameIdentifier	 input Type
==	TokenNameEQUAL_EQUAL	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
.	TokenNameDOT	
BYTE1	TokenNameIdentifier	 BYT E1
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Unsigned byte: 	TokenNameCOMMENT_LINE	Unsigned byte: 
v	TokenNameIdentifier	 v
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readByte	TokenNameIdentifier	 read Byte
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
inputType	TokenNameIdentifier	 input Type
==	TokenNameEQUAL_EQUAL	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
.	TokenNameDOT	
BYTE2	TokenNameIdentifier	 BYT E2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Unsigned short: 	TokenNameCOMMENT_LINE	Unsigned short: 
v	TokenNameIdentifier	 v
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readShort	TokenNameIdentifier	 read Short
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFFFF	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
v	TokenNameIdentifier	 v
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
v	TokenNameIdentifier	 v
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// returns true if the node at this address has any 	TokenNameCOMMENT_LINE	returns true if the node at this address has any 
// outgoing arcs 	TokenNameCOMMENT_LINE	outgoing arcs 
public	TokenNamepublic	
static	TokenNamestatic	
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
boolean	TokenNameboolean	
targetHasArcs	TokenNameIdentifier	 target Has Arcs
(	TokenNameLPAREN	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
target	TokenNameIdentifier	 target
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// serializes new node by appending its bytes to the end 	TokenNameCOMMENT_LINE	serializes new node by appending its bytes to the end 
// of the current byte[] 	TokenNameCOMMENT_LINE	of the current byte[] 
int	TokenNameint	
addNode	TokenNameIdentifier	 add Node
(	TokenNameLPAREN	
Builder	TokenNameIdentifier	 Builder
.	TokenNameDOT	
UnCompiledNode	TokenNameIdentifier	 Un Compiled Node
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
nodeIn	TokenNameIdentifier	 node In
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
//System.out.println("FST.addNode pos=" + writer.posWrite + " numArcs=" + nodeIn.numArcs); 	TokenNameCOMMENT_LINE	System.out.println("FST.addNode pos=" + writer.posWrite + " numArcs=" + nodeIn.numArcs); 
if	TokenNameif	
(	TokenNameLPAREN	
nodeIn	TokenNameIdentifier	 node In
.	TokenNameDOT	
numArcs	TokenNameIdentifier	 num Arcs
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
nodeIn	TokenNameIdentifier	 node In
.	TokenNameDOT	
isFinal	TokenNameIdentifier	 is Final
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
FINAL_END_NODE	TokenNameIdentifier	 FINAL  END  NODE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
NON_FINAL_END_NODE	TokenNameIdentifier	 NON  FINAL  END  NODE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
int	TokenNameint	
startAddress	TokenNameIdentifier	 start Address
=	TokenNameEQUAL	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
posWrite	TokenNameIdentifier	 pos Write
;	TokenNameSEMICOLON	
//System.out.println(" startAddr=" + startAddress); 	TokenNameCOMMENT_LINE	System.out.println(" startAddr=" + startAddress); 
final	TokenNamefinal	
boolean	TokenNameboolean	
doFixedArray	TokenNameIdentifier	 do Fixed Array
=	TokenNameEQUAL	
shouldExpand	TokenNameIdentifier	 should Expand
(	TokenNameLPAREN	
nodeIn	TokenNameIdentifier	 node In
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
fixedArrayStart	TokenNameIdentifier	 fixed Array Start
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
doFixedArray	TokenNameIdentifier	 do Fixed Array
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
.	TokenNameDOT	
length	TokenNameIdentifier	 length
<	TokenNameLESS	
nodeIn	TokenNameIdentifier	 node In
.	TokenNameDOT	
numArcs	TokenNameIdentifier	 num Arcs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
ArrayUtil	TokenNameIdentifier	 Array Util
.	TokenNameDOT	
oversize	TokenNameIdentifier	 oversize
(	TokenNameLPAREN	
nodeIn	TokenNameIdentifier	 node In
.	TokenNameDOT	
numArcs	TokenNameIdentifier	 num Arcs
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// write a "false" first arc: 	TokenNameCOMMENT_LINE	write a "false" first arc: 
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
ARCS_AS_FIXED_ARRAY	TokenNameIdentifier	 ARCS  AS  FIXED  ARRAY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
writeVInt	TokenNameIdentifier	 write V Int
(	TokenNameLPAREN	
nodeIn	TokenNameIdentifier	 node In
.	TokenNameDOT	
numArcs	TokenNameIdentifier	 num Arcs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// placeholder -- we'll come back and write the number 	TokenNameCOMMENT_LINE	placeholder -- we'll come back and write the number 
// of bytes per arc (int) here: 	TokenNameCOMMENT_LINE	of bytes per arc (int) here: 
// TODO: we could make this a vInt instead 	TokenNameCOMMENT_LINE	TODO: we could make this a vInt instead 
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
writeInt	TokenNameIdentifier	 write Int
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fixedArrayStart	TokenNameIdentifier	 fixed Array Start
=	TokenNameEQUAL	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
posWrite	TokenNameIdentifier	 pos Write
;	TokenNameSEMICOLON	
//System.out.println(" do fixed arcs array arcsStart=" + fixedArrayStart); 	TokenNameCOMMENT_LINE	System.out.println(" do fixed arcs array arcsStart=" + fixedArrayStart); 
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fixedArrayStart	TokenNameIdentifier	 fixed Array Start
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
arcCount	TokenNameIdentifier	 arc Count
+=	TokenNamePLUS_EQUAL	
nodeIn	TokenNameIdentifier	 node In
.	TokenNameDOT	
numArcs	TokenNameIdentifier	 num Arcs
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
lastArc	TokenNameIdentifier	 last Arc
=	TokenNameEQUAL	
nodeIn	TokenNameIdentifier	 node In
.	TokenNameDOT	
numArcs	TokenNameIdentifier	 num Arcs
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
lastArcStart	TokenNameIdentifier	 last Arc Start
=	TokenNameEQUAL	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
posWrite	TokenNameIdentifier	 pos Write
;	TokenNameSEMICOLON	
int	TokenNameint	
maxBytesPerArc	TokenNameIdentifier	 max Bytes Per Arc
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
arcIdx	TokenNameIdentifier	 arc Idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
arcIdx	TokenNameIdentifier	 arc Idx
<	TokenNameLESS	
nodeIn	TokenNameIdentifier	 node In
.	TokenNameDOT	
numArcs	TokenNameIdentifier	 num Arcs
;	TokenNameSEMICOLON	
arcIdx	TokenNameIdentifier	 arc Idx
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
Builder	TokenNameIdentifier	 Builder
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
arc	TokenNameIdentifier	 arc
=	TokenNameEQUAL	
nodeIn	TokenNameIdentifier	 node In
.	TokenNameDOT	
arcs	TokenNameIdentifier	 arcs
[	TokenNameLBRACKET	
arcIdx	TokenNameIdentifier	 arc Idx
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Builder	TokenNameIdentifier	 Builder
.	TokenNameDOT	
CompiledNode	TokenNameIdentifier	 Compiled Node
target	TokenNameIdentifier	 target
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Builder	TokenNameIdentifier	 Builder
.	TokenNameDOT	
CompiledNode	TokenNameIdentifier	 Compiled Node
)	TokenNameRPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
target	TokenNameIdentifier	 target
;	TokenNameSEMICOLON	
int	TokenNameint	
flags	TokenNameIdentifier	 flags
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
arcIdx	TokenNameIdentifier	 arc Idx
==	TokenNameEQUAL_EQUAL	
lastArc	TokenNameIdentifier	 last Arc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
flags	TokenNameIdentifier	 flags
+=	TokenNamePLUS_EQUAL	
BIT_LAST_ARC	TokenNameIdentifier	 BIT  LAST  ARC
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
lastFrozenNode	TokenNameIdentifier	 last Frozen Node
==	TokenNameEQUAL_EQUAL	
target	TokenNameIdentifier	 target
.	TokenNameDOT	
node	TokenNameIdentifier	 node
&&	TokenNameAND_AND	
!	TokenNameNOT	
doFixedArray	TokenNameIdentifier	 do Fixed Array
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// TODO: for better perf (but more RAM used) we 	TokenNameCOMMENT_LINE	TODO: for better perf (but more RAM used) we 
// could avoid this except when arc is "near" the 	TokenNameCOMMENT_LINE	could avoid this except when arc is "near" the 
// last arc: 	TokenNameCOMMENT_LINE	last arc: 
flags	TokenNameIdentifier	 flags
+=	TokenNamePLUS_EQUAL	
BIT_TARGET_NEXT	TokenNameIdentifier	 BIT  TARGET  NEXT
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
isFinal	TokenNameIdentifier	 is Final
)	TokenNameRPAREN	
{	TokenNameLBRACE	
flags	TokenNameIdentifier	 flags
+=	TokenNamePLUS_EQUAL	
BIT_FINAL_ARC	TokenNameIdentifier	 BIT  FINAL  ARC
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
nextFinalOutput	TokenNameIdentifier	 next Final Output
!=	TokenNameNOT_EQUAL	
NO_OUTPUT	TokenNameIdentifier	 NO  OUTPUT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
flags	TokenNameIdentifier	 flags
+=	TokenNamePLUS_EQUAL	
BIT_ARC_HAS_FINAL_OUTPUT	TokenNameIdentifier	 BIT  ARC  HAS  FINAL  OUTPUT
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
assert	TokenNameassert	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
nextFinalOutput	TokenNameIdentifier	 next Final Output
==	TokenNameEQUAL_EQUAL	
NO_OUTPUT	TokenNameIdentifier	 NO  OUTPUT
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
boolean	TokenNameboolean	
targetHasArcs	TokenNameIdentifier	 target Has Arcs
=	TokenNameEQUAL	
target	TokenNameIdentifier	 target
.	TokenNameDOT	
node	TokenNameIdentifier	 node
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
targetHasArcs	TokenNameIdentifier	 target Has Arcs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
flags	TokenNameIdentifier	 flags
+=	TokenNamePLUS_EQUAL	
BIT_STOP_NODE	TokenNameIdentifier	 BIT  STOP  NODE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
inCounts	TokenNameIdentifier	 in Counts
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
inCounts	TokenNameIdentifier	 in Counts
[	TokenNameLBRACKET	
target	TokenNameIdentifier	 target
.	TokenNameDOT	
node	TokenNameIdentifier	 node
]	TokenNameRBRACKET	
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
output	TokenNameIdentifier	 output
!=	TokenNameNOT_EQUAL	
NO_OUTPUT	TokenNameIdentifier	 NO  OUTPUT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
flags	TokenNameIdentifier	 flags
+=	TokenNamePLUS_EQUAL	
BIT_ARC_HAS_OUTPUT	TokenNameIdentifier	 BIT  ARC  HAS  OUTPUT
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
flags	TokenNameIdentifier	 flags
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeLabel	TokenNameIdentifier	 write Label
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
label	TokenNameIdentifier	 label
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// System.out.println(" write arc: label=" + (char) arc.label + " flags=" + flags + " target=" + target.node + " pos=" + writer.posWrite + " output=" + outputs.outputToString(arc.output)); 	TokenNameCOMMENT_LINE	System.out.println(" write arc: label=" + (char) arc.label + " flags=" + flags + " target=" + target.node + " pos=" + writer.posWrite + " output=" + outputs.outputToString(arc.output)); 
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
output	TokenNameIdentifier	 output
!=	TokenNameNOT_EQUAL	
NO_OUTPUT	TokenNameIdentifier	 NO  OUTPUT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
writer	TokenNameIdentifier	 writer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println(" write output"); 	TokenNameCOMMENT_LINE	System.out.println(" write output"); 
arcWithOutputCount	TokenNameIdentifier	 arc With Output Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
nextFinalOutput	TokenNameIdentifier	 next Final Output
!=	TokenNameNOT_EQUAL	
NO_OUTPUT	TokenNameIdentifier	 NO  OUTPUT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println(" write final output"); 	TokenNameCOMMENT_LINE	System.out.println(" write final output"); 
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
nextFinalOutput	TokenNameIdentifier	 next Final Output
,	TokenNameCOMMA	
writer	TokenNameIdentifier	 writer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
targetHasArcs	TokenNameIdentifier	 target Has Arcs
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
flags	TokenNameIdentifier	 flags
&	TokenNameAND	
BIT_TARGET_NEXT	TokenNameIdentifier	 BIT  TARGET  NEXT
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
target	TokenNameIdentifier	 target
.	TokenNameDOT	
node	TokenNameIdentifier	 node
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
//System.out.println(" write target"); 	TokenNameCOMMENT_LINE	System.out.println(" write target"); 
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
writeInt	TokenNameIdentifier	 write Int
(	TokenNameLPAREN	
target	TokenNameIdentifier	 target
.	TokenNameDOT	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// just write the arcs "like normal" on first pass, 	TokenNameCOMMENT_LINE	just write the arcs "like normal" on first pass, 
// but record how many bytes each one took, and max 	TokenNameCOMMENT_LINE	but record how many bytes each one took, and max 
// byte size: 	TokenNameCOMMENT_LINE	byte size: 
if	TokenNameif	
(	TokenNameLPAREN	
doFixedArray	TokenNameIdentifier	 do Fixed Array
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
[	TokenNameLBRACKET	
arcIdx	TokenNameIdentifier	 arc Idx
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
posWrite	TokenNameIdentifier	 pos Write
-	TokenNameMINUS	
lastArcStart	TokenNameIdentifier	 last Arc Start
;	TokenNameSEMICOLON	
lastArcStart	TokenNameIdentifier	 last Arc Start
=	TokenNameEQUAL	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
posWrite	TokenNameIdentifier	 pos Write
;	TokenNameSEMICOLON	
maxBytesPerArc	TokenNameIdentifier	 max Bytes Per Arc
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
max	TokenNameIdentifier	 max
(	TokenNameLPAREN	
maxBytesPerArc	TokenNameIdentifier	 max Bytes Per Arc
,	TokenNameCOMMA	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
[	TokenNameLBRACKET	
arcIdx	TokenNameIdentifier	 arc Idx
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println(" bytes=" + bytesPerArc[arcIdx]); 	TokenNameCOMMENT_LINE	System.out.println(" bytes=" + bytesPerArc[arcIdx]); 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// TODO: if arc'd arrays will be "too wasteful" by some 	TokenNameCOMMENT_LINE	TODO: if arc'd arrays will be "too wasteful" by some 
// measure, eg if arcs have vastly different sized 	TokenNameCOMMENT_LINE	measure, eg if arcs have vastly different sized 
// outputs, then we should selectively disable array for 	TokenNameCOMMENT_LINE	outputs, then we should selectively disable array for 
// such cases 	TokenNameCOMMENT_LINE	such cases 
if	TokenNameif	
(	TokenNameLPAREN	
doFixedArray	TokenNameIdentifier	 do Fixed Array
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println(" doFixedArray"); 	TokenNameCOMMENT_LINE	System.out.println(" doFixedArray"); 
assert	TokenNameassert	
maxBytesPerArc	TokenNameIdentifier	 max Bytes Per Arc
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// 2nd pass just "expands" all arcs to take up a fixed 	TokenNameCOMMENT_LINE	2nd pass just "expands" all arcs to take up a fixed 
// byte size 	TokenNameCOMMENT_LINE	byte size 
final	TokenNamefinal	
int	TokenNameint	
sizeNeeded	TokenNameIdentifier	 size Needed
=	TokenNameEQUAL	
fixedArrayStart	TokenNameIdentifier	 fixed Array Start
+	TokenNamePLUS	
nodeIn	TokenNameIdentifier	 node In
.	TokenNameDOT	
numArcs	TokenNameIdentifier	 num Arcs
*	TokenNameMULTIPLY	
maxBytesPerArc	TokenNameIdentifier	 max Bytes Per Arc
;	TokenNameSEMICOLON	
bytes	TokenNameIdentifier	 bytes
=	TokenNameEQUAL	
ArrayUtil	TokenNameIdentifier	 Array Util
.	TokenNameDOT	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
bytes	TokenNameIdentifier	 bytes
,	TokenNameCOMMA	
sizeNeeded	TokenNameIdentifier	 size Needed
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// TODO: we could make this a vInt instead 	TokenNameCOMMENT_LINE	TODO: we could make this a vInt instead 
bytes	TokenNameIdentifier	 bytes
[	TokenNameLBRACKET	
fixedArrayStart	TokenNameIdentifier	 fixed Array Start
-	TokenNameMINUS	
4	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
maxBytesPerArc	TokenNameIdentifier	 max Bytes Per Arc
>>	TokenNameRIGHT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bytes	TokenNameIdentifier	 bytes
[	TokenNameLBRACKET	
fixedArrayStart	TokenNameIdentifier	 fixed Array Start
-	TokenNameMINUS	
3	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
maxBytesPerArc	TokenNameIdentifier	 max Bytes Per Arc
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bytes	TokenNameIdentifier	 bytes
[	TokenNameLBRACKET	
fixedArrayStart	TokenNameIdentifier	 fixed Array Start
-	TokenNameMINUS	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
maxBytesPerArc	TokenNameIdentifier	 max Bytes Per Arc
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bytes	TokenNameIdentifier	 bytes
[	TokenNameLBRACKET	
fixedArrayStart	TokenNameIdentifier	 fixed Array Start
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
maxBytesPerArc	TokenNameIdentifier	 max Bytes Per Arc
;	TokenNameSEMICOLON	
// expand the arcs in place, backwards 	TokenNameCOMMENT_LINE	expand the arcs in place, backwards 
int	TokenNameint	
srcPos	TokenNameIdentifier	 src Pos
=	TokenNameEQUAL	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
posWrite	TokenNameIdentifier	 pos Write
;	TokenNameSEMICOLON	
int	TokenNameint	
destPos	TokenNameIdentifier	 dest Pos
=	TokenNameEQUAL	
fixedArrayStart	TokenNameIdentifier	 fixed Array Start
+	TokenNamePLUS	
nodeIn	TokenNameIdentifier	 node In
.	TokenNameDOT	
numArcs	TokenNameIdentifier	 num Arcs
*	TokenNameMULTIPLY	
maxBytesPerArc	TokenNameIdentifier	 max Bytes Per Arc
;	TokenNameSEMICOLON	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
posWrite	TokenNameIdentifier	 pos Write
=	TokenNameEQUAL	
destPos	TokenNameIdentifier	 dest Pos
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
arcIdx	TokenNameIdentifier	 arc Idx
=	TokenNameEQUAL	
nodeIn	TokenNameIdentifier	 node In
.	TokenNameDOT	
numArcs	TokenNameIdentifier	 num Arcs
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
arcIdx	TokenNameIdentifier	 arc Idx
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
arcIdx	TokenNameIdentifier	 arc Idx
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println(" repack arcIdx=" + arcIdx + " srcPos=" + srcPos + " destPos=" + destPos); 	TokenNameCOMMENT_LINE	System.out.println(" repack arcIdx=" + arcIdx + " srcPos=" + srcPos + " destPos=" + destPos); 
destPos	TokenNameIdentifier	 dest Pos
-=	TokenNameMINUS_EQUAL	
maxBytesPerArc	TokenNameIdentifier	 max Bytes Per Arc
;	TokenNameSEMICOLON	
srcPos	TokenNameIdentifier	 src Pos
-=	TokenNameMINUS_EQUAL	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
[	TokenNameLBRACKET	
arcIdx	TokenNameIdentifier	 arc Idx
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
srcPos	TokenNameIdentifier	 src Pos
!=	TokenNameNOT_EQUAL	
destPos	TokenNameIdentifier	 dest Pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
destPos	TokenNameIdentifier	 dest Pos
>	TokenNameGREATER	
srcPos	TokenNameIdentifier	 src Pos
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
bytes	TokenNameIdentifier	 bytes
,	TokenNameCOMMA	
srcPos	TokenNameIdentifier	 src Pos
,	TokenNameCOMMA	
bytes	TokenNameIdentifier	 bytes
,	TokenNameCOMMA	
destPos	TokenNameIdentifier	 dest Pos
,	TokenNameCOMMA	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
[	TokenNameLBRACKET	
arcIdx	TokenNameIdentifier	 arc Idx
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// reverse bytes in-place; we do this so that the 	TokenNameCOMMENT_LINE	reverse bytes in-place; we do this so that the 
// "BIT_TARGET_NEXT" opto can work, ie, it reads the 	TokenNameCOMMENT_LINE	"BIT_TARGET_NEXT" opto can work, ie, it reads the 
// node just before the current one 	TokenNameCOMMENT_LINE	node just before the current one 
final	TokenNamefinal	
int	TokenNameint	
endAddress	TokenNameIdentifier	 end Address
=	TokenNameEQUAL	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
posWrite	TokenNameIdentifier	 pos Write
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
left	TokenNameIdentifier	 left
=	TokenNameEQUAL	
startAddress	TokenNameIdentifier	 start Address
;	TokenNameSEMICOLON	
int	TokenNameint	
right	TokenNameIdentifier	 right
=	TokenNameEQUAL	
endAddress	TokenNameIdentifier	 end Address
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
left	TokenNameIdentifier	 left
<	TokenNameLESS	
right	TokenNameIdentifier	 right
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
byte	TokenNamebyte	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
bytes	TokenNameIdentifier	 bytes
[	TokenNameLBRACKET	
left	TokenNameIdentifier	 left
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
bytes	TokenNameIdentifier	 bytes
[	TokenNameLBRACKET	
left	TokenNameIdentifier	 left
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
bytes	TokenNameIdentifier	 bytes
[	TokenNameLBRACKET	
right	TokenNameIdentifier	 right
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
bytes	TokenNameIdentifier	 bytes
[	TokenNameLBRACKET	
right	TokenNameIdentifier	 right
--	TokenNameMINUS_MINUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//System.out.println(" endAddress=" + endAddress); 	TokenNameCOMMENT_LINE	System.out.println(" endAddress=" + endAddress); 
nodeCount	TokenNameIdentifier	 node Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
node	TokenNameIdentifier	 node
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nodeAddress	TokenNameIdentifier	 node Address
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Nodes are addressed by 1+ord: 	TokenNameCOMMENT_LINE	Nodes are addressed by 1+ord: 
if	TokenNameif	
(	TokenNameLPAREN	
nodeCount	TokenNameIdentifier	 node Count
==	TokenNameEQUAL_EQUAL	
nodeAddress	TokenNameIdentifier	 node Address
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nodeAddress	TokenNameIdentifier	 node Address
=	TokenNameEQUAL	
ArrayUtil	TokenNameIdentifier	 Array Util
.	TokenNameDOT	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
nodeAddress	TokenNameIdentifier	 node Address
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
inCounts	TokenNameIdentifier	 in Counts
=	TokenNameEQUAL	
ArrayUtil	TokenNameIdentifier	 Array Util
.	TokenNameDOT	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
inCounts	TokenNameIdentifier	 in Counts
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
nodeAddress	TokenNameIdentifier	 node Address
[	TokenNameLBRACKET	
nodeCount	TokenNameIdentifier	 node Count
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
endAddress	TokenNameIdentifier	 end Address
;	TokenNameSEMICOLON	
// System.out.println(" write nodeAddress[" + nodeCount + "] = " + endAddress); 	TokenNameCOMMENT_LINE	System.out.println(" write nodeAddress[" + nodeCount + "] = " + endAddress); 
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
nodeCount	TokenNameIdentifier	 node Count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
endAddress	TokenNameIdentifier	 end Address
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
lastFrozenNode	TokenNameIdentifier	 last Frozen Node
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
;	TokenNameSEMICOLON	
return	TokenNamereturn	
node	TokenNameIdentifier	 node
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Fills virtual 'start' arc, ie, an empty incoming arc to * the FST's start node */	TokenNameCOMMENT_JAVADOC	 Fills virtual 'start' arc, ie, an empty incoming arc to the FST's start node 
public	TokenNamepublic	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
getFirstArc	TokenNameIdentifier	 get First Arc
(	TokenNameLPAREN	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
emptyOutput	TokenNameIdentifier	 empty Output
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
flags	TokenNameIdentifier	 flags
=	TokenNameEQUAL	
BIT_FINAL_ARC	TokenNameIdentifier	 BIT  FINAL  ARC
|	TokenNameOR	
BIT_LAST_ARC	TokenNameIdentifier	 BIT  LAST  ARC
;	TokenNameSEMICOLON	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
nextFinalOutput	TokenNameIdentifier	 next Final Output
=	TokenNameEQUAL	
emptyOutput	TokenNameIdentifier	 empty Output
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
flags	TokenNameIdentifier	 flags
=	TokenNameEQUAL	
BIT_LAST_ARC	TokenNameIdentifier	 BIT  LAST  ARC
;	TokenNameSEMICOLON	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
nextFinalOutput	TokenNameIdentifier	 next Final Output
=	TokenNameEQUAL	
NO_OUTPUT	TokenNameIdentifier	 NO  OUTPUT
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
NO_OUTPUT	TokenNameIdentifier	 NO  OUTPUT
;	TokenNameSEMICOLON	
// If there are no nodes, ie, the FST only accepts the 	TokenNameCOMMENT_LINE	If there are no nodes, ie, the FST only accepts the 
// empty string, then startNode is 0 	TokenNameCOMMENT_LINE	empty string, then startNode is 0 
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
target	TokenNameIdentifier	 target
=	TokenNameEQUAL	
startNode	TokenNameIdentifier	 start Node
;	TokenNameSEMICOLON	
return	TokenNamereturn	
arc	TokenNameIdentifier	 arc
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Follows the <code>follow</code> arc and reads the last * arc of its target; this changes the provided * <code>arc</code> (2nd arg) in-place and returns it. * * @return Returns the second argument * (<code>arc</code>). */	TokenNameCOMMENT_JAVADOC	 Follows the <code>follow</code> arc and reads the last arc of its target; this changes the provided <code>arc</code> (2nd arg) in-place and returns it. * @return Returns the second argument (<code>arc</code>). 
public	TokenNamepublic	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
readLastTargetArc	TokenNameIdentifier	 read Last Target Arc
(	TokenNameLPAREN	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
follow	TokenNameIdentifier	 follow
,	TokenNameCOMMA	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
//System.out.println("readLast"); 	TokenNameCOMMENT_LINE	System.out.println("readLast"); 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
targetHasArcs	TokenNameIdentifier	 target Has Arcs
(	TokenNameLPAREN	
follow	TokenNameIdentifier	 follow
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println(" end node"); 	TokenNameCOMMENT_LINE	System.out.println(" end node"); 
assert	TokenNameassert	
follow	TokenNameIdentifier	 follow
.	TokenNameDOT	
isFinal	TokenNameIdentifier	 is Final
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
label	TokenNameIdentifier	 label
=	TokenNameEQUAL	
END_LABEL	TokenNameIdentifier	 END  LABEL
;	TokenNameSEMICOLON	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
target	TokenNameIdentifier	 target
=	TokenNameEQUAL	
FINAL_END_NODE	TokenNameIdentifier	 FINAL  END  NODE
;	TokenNameSEMICOLON	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
follow	TokenNameIdentifier	 follow
.	TokenNameDOT	
nextFinalOutput	TokenNameIdentifier	 next Final Output
;	TokenNameSEMICOLON	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
flags	TokenNameIdentifier	 flags
=	TokenNameEQUAL	
BIT_LAST_ARC	TokenNameIdentifier	 BIT  LAST  ARC
;	TokenNameSEMICOLON	
return	TokenNamereturn	
arc	TokenNameIdentifier	 arc
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
final	TokenNamefinal	
BytesReader	TokenNameIdentifier	 Bytes Reader
in	TokenNameIdentifier	 in
=	TokenNameEQUAL	
getBytesReader	TokenNameIdentifier	 get Bytes Reader
(	TokenNameLPAREN	
getNodeAddress	TokenNameIdentifier	 get Node Address
(	TokenNameLPAREN	
follow	TokenNameIdentifier	 follow
.	TokenNameDOT	
target	TokenNameIdentifier	 target
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
follow	TokenNameIdentifier	 follow
.	TokenNameDOT	
target	TokenNameIdentifier	 target
;	TokenNameSEMICOLON	
final	TokenNamefinal	
byte	TokenNamebyte	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readByte	TokenNameIdentifier	 read Byte
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
==	TokenNameEQUAL_EQUAL	
ARCS_AS_FIXED_ARRAY	TokenNameIdentifier	 ARCS  AS  FIXED  ARRAY
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// array: jump straight to end 	TokenNameCOMMENT_LINE	array: jump straight to end 
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
numArcs	TokenNameIdentifier	 num Arcs
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
packed	TokenNameIdentifier	 packed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readInt	TokenNameIdentifier	 read Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//System.out.println(" array numArcs=" + arc.numArcs + " bpa=" + arc.bytesPerArc); 	TokenNameCOMMENT_LINE	System.out.println(" array numArcs=" + arc.numArcs + " bpa=" + arc.bytesPerArc); 
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
posArcsStart	TokenNameIdentifier	 pos Arcs Start
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
arcIdx	TokenNameIdentifier	 arc Idx
=	TokenNameEQUAL	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
numArcs	TokenNameIdentifier	 num Arcs
-	TokenNameMINUS	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
flags	TokenNameIdentifier	 flags
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
// non-array: linear scan 	TokenNameCOMMENT_LINE	non-array: linear scan 
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
//System.out.println(" scan"); 	TokenNameCOMMENT_LINE	System.out.println(" scan"); 
while	TokenNamewhile	
(	TokenNameLPAREN	
!	TokenNameNOT	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
isLast	TokenNameIdentifier	 is Last
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// skip this arc: 	TokenNameCOMMENT_LINE	skip this arc: 
readLabel	TokenNameIdentifier	 read Label
(	TokenNameLPAREN	
in	TokenNameIdentifier	 in
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
flag	TokenNameIdentifier	 flag
(	TokenNameLPAREN	
BIT_ARC_HAS_OUTPUT	TokenNameIdentifier	 BIT  ARC  HAS  OUTPUT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
read	TokenNameIdentifier	 read
(	TokenNameLPAREN	
in	TokenNameIdentifier	 in
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
flag	TokenNameIdentifier	 flag
(	TokenNameLPAREN	
BIT_ARC_HAS_FINAL_OUTPUT	TokenNameIdentifier	 BIT  ARC  HAS  FINAL  OUTPUT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
read	TokenNameIdentifier	 read
(	TokenNameLPAREN	
in	TokenNameIdentifier	 in
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
flag	TokenNameIdentifier	 flag
(	TokenNameLPAREN	
BIT_STOP_NODE	TokenNameIdentifier	 BIT  STOP  NODE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
flag	TokenNameIdentifier	 flag
(	TokenNameLPAREN	
BIT_TARGET_NEXT	TokenNameIdentifier	 BIT  TARGET  NEXT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
packed	TokenNameIdentifier	 packed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
skip	TokenNameIdentifier	 skip
(	TokenNameLPAREN	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
flags	TokenNameIdentifier	 flags
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readByte	TokenNameIdentifier	 read Byte
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Undo the byte flags we read: 	TokenNameCOMMENT_LINE	Undo the byte flags we read: 
in	TokenNameIdentifier	 in
.	TokenNameDOT	
skip	TokenNameIdentifier	 skip
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
nextArc	TokenNameIdentifier	 next Arc
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
readNextRealArc	TokenNameIdentifier	 read Next Real Arc
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
in	TokenNameIdentifier	 in
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
isLast	TokenNameIdentifier	 is Last
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
arc	TokenNameIdentifier	 arc
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Follow the <code>follow</code> arc and read the first arc of its target; * this changes the provided <code>arc</code> (2nd arg) in-place and returns * it. * * @return Returns the second argument (<code>arc</code>). */	TokenNameCOMMENT_JAVADOC	 Follow the <code>follow</code> arc and read the first arc of its target; this changes the provided <code>arc</code> (2nd arg) in-place and returns it. * @return Returns the second argument (<code>arc</code>). 
public	TokenNamepublic	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
readFirstTargetArc	TokenNameIdentifier	 read First Target Arc
(	TokenNameLPAREN	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
follow	TokenNameIdentifier	 follow
,	TokenNameCOMMA	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
//int pos = address; 	TokenNameCOMMENT_LINE	int pos = address; 
//System.out.println(" readFirstTarget follow.target=" + follow.target + " isFinal=" + follow.isFinal()); 	TokenNameCOMMENT_LINE	System.out.println(" readFirstTarget follow.target=" + follow.target + " isFinal=" + follow.isFinal()); 
if	TokenNameif	
(	TokenNameLPAREN	
follow	TokenNameIdentifier	 follow
.	TokenNameDOT	
isFinal	TokenNameIdentifier	 is Final
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Insert "fake" final first arc: 	TokenNameCOMMENT_LINE	Insert "fake" final first arc: 
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
label	TokenNameIdentifier	 label
=	TokenNameEQUAL	
END_LABEL	TokenNameIdentifier	 END  LABEL
;	TokenNameSEMICOLON	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
follow	TokenNameIdentifier	 follow
.	TokenNameDOT	
nextFinalOutput	TokenNameIdentifier	 next Final Output
;	TokenNameSEMICOLON	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
flags	TokenNameIdentifier	 flags
=	TokenNameEQUAL	
BIT_FINAL_ARC	TokenNameIdentifier	 BIT  FINAL  ARC
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
follow	TokenNameIdentifier	 follow
.	TokenNameDOT	
target	TokenNameIdentifier	 target
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
flags	TokenNameIdentifier	 flags
|=	TokenNameOR_EQUAL	
BIT_LAST_ARC	TokenNameIdentifier	 BIT  LAST  ARC
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
follow	TokenNameIdentifier	 follow
.	TokenNameDOT	
target	TokenNameIdentifier	 target
;	TokenNameSEMICOLON	
// NOTE: nextArc is a node (not an address!) in this case: 	TokenNameCOMMENT_LINE	NOTE: nextArc is a node (not an address!) in this case: 
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
nextArc	TokenNameIdentifier	 next Arc
=	TokenNameEQUAL	
follow	TokenNameIdentifier	 follow
.	TokenNameDOT	
target	TokenNameIdentifier	 target
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
target	TokenNameIdentifier	 target
=	TokenNameEQUAL	
FINAL_END_NODE	TokenNameIdentifier	 FINAL  END  NODE
;	TokenNameSEMICOLON	
//System.out.println(" insert isFinal; nextArc=" + follow.target + " isLast=" + arc.isLast() + " output=" + outputs.outputToString(arc.output)); 	TokenNameCOMMENT_LINE	System.out.println(" insert isFinal; nextArc=" + follow.target + " isLast=" + arc.isLast() + " output=" + outputs.outputToString(arc.output)); 
return	TokenNamereturn	
arc	TokenNameIdentifier	 arc
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
readFirstRealTargetArc	TokenNameIdentifier	 read First Real Target Arc
(	TokenNameLPAREN	
follow	TokenNameIdentifier	 follow
.	TokenNameDOT	
target	TokenNameIdentifier	 target
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
getBytesReader	TokenNameIdentifier	 get Bytes Reader
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
readFirstRealTargetArc	TokenNameIdentifier	 read First Real Target Arc
(	TokenNameLPAREN	
int	TokenNameint	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
final	TokenNamefinal	
BytesReader	TokenNameIdentifier	 Bytes Reader
in	TokenNameIdentifier	 in
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
assert	TokenNameassert	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
bytes	TokenNameIdentifier	 bytes
==	TokenNameEQUAL_EQUAL	
bytes	TokenNameIdentifier	 bytes
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
address	TokenNameIdentifier	 address
=	TokenNameEQUAL	
getNodeAddress	TokenNameIdentifier	 get Node Address
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
address	TokenNameIdentifier	 address
;	TokenNameSEMICOLON	
//System.out.println(" readFirstRealTargtArc address=" 	TokenNameCOMMENT_LINE	System.out.println(" readFirstRealTargtArc address=" 
//+ address); 	TokenNameCOMMENT_LINE	+ address); 
//System.out.println(" flags=" + arc.flags); 	TokenNameCOMMENT_LINE	System.out.println(" flags=" + arc.flags); 
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readByte	TokenNameIdentifier	 read Byte
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
ARCS_AS_FIXED_ARRAY	TokenNameIdentifier	 ARCS  AS  FIXED  ARRAY
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println(" fixedArray"); 	TokenNameCOMMENT_LINE	System.out.println(" fixedArray"); 
// this is first arc in a fixed-array 	TokenNameCOMMENT_LINE	this is first arc in a fixed-array 
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
numArcs	TokenNameIdentifier	 num Arcs
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
packed	TokenNameIdentifier	 packed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readInt	TokenNameIdentifier	 read Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
arcIdx	TokenNameIdentifier	 arc Idx
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
nextArc	TokenNameIdentifier	 next Arc
=	TokenNameEQUAL	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
posArcsStart	TokenNameIdentifier	 pos Arcs Start
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
//System.out.println(" bytesPer=" + arc.bytesPerArc + " numArcs=" + arc.numArcs + " arcsStart=" + pos); 	TokenNameCOMMENT_LINE	System.out.println(" bytesPer=" + arc.bytesPerArc + " numArcs=" + arc.numArcs + " arcsStart=" + pos); 
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
//arc.flags = b; 	TokenNameCOMMENT_LINE	arc.flags = b; 
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
nextArc	TokenNameIdentifier	 next Arc
=	TokenNameEQUAL	
address	TokenNameIdentifier	 address
;	TokenNameSEMICOLON	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
readNextRealArc	TokenNameIdentifier	 read Next Real Arc
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
in	TokenNameIdentifier	 in
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Checks if <code>arc</code>'s target state is in expanded (or vector) format. * * @return Returns <code>true</code> if <code>arc</code> points to a state in an * expanded array format. */	TokenNameCOMMENT_JAVADOC	 Checks if <code>arc</code>'s target state is in expanded (or vector) format. * @return Returns <code>true</code> if <code>arc</code> points to a state in an expanded array format. 
boolean	TokenNameboolean	
isExpandedTarget	TokenNameIdentifier	 is Expanded Target
(	TokenNameLPAREN	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
follow	TokenNameIdentifier	 follow
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
targetHasArcs	TokenNameIdentifier	 target Has Arcs
(	TokenNameLPAREN	
follow	TokenNameIdentifier	 follow
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
final	TokenNamefinal	
BytesReader	TokenNameIdentifier	 Bytes Reader
in	TokenNameIdentifier	 in
=	TokenNameEQUAL	
getBytesReader	TokenNameIdentifier	 get Bytes Reader
(	TokenNameLPAREN	
getNodeAddress	TokenNameIdentifier	 get Node Address
(	TokenNameLPAREN	
follow	TokenNameIdentifier	 follow
.	TokenNameDOT	
target	TokenNameIdentifier	 target
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readByte	TokenNameIdentifier	 read Byte
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
ARCS_AS_FIXED_ARRAY	TokenNameIdentifier	 ARCS  AS  FIXED  ARRAY
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** In-place read; returns the arc. */	TokenNameCOMMENT_JAVADOC	 In-place read; returns the arc. 
public	TokenNamepublic	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
readNextArc	TokenNameIdentifier	 read Next Arc
(	TokenNameLPAREN	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
label	TokenNameIdentifier	 label
==	TokenNameEQUAL_EQUAL	
END_LABEL	TokenNameIdentifier	 END  LABEL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// This was a fake inserted "final" arc 	TokenNameCOMMENT_LINE	This was a fake inserted "final" arc 
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
nextArc	TokenNameIdentifier	 next Arc
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"cannot readNextArc when arc.isLast()=true"	TokenNameStringLiteral	cannot readNextArc when arc.isLast()=true
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
readFirstRealTargetArc	TokenNameIdentifier	 read First Real Target Arc
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
nextArc	TokenNameIdentifier	 next Arc
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
getBytesReader	TokenNameIdentifier	 get Bytes Reader
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
readNextRealArc	TokenNameIdentifier	 read Next Real Arc
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
getBytesReader	TokenNameIdentifier	 get Bytes Reader
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Peeks at next arc's label; does not alter arc. Do * not call this if arc.isLast()! */	TokenNameCOMMENT_JAVADOC	 Peeks at next arc's label; does not alter arc. Do not call this if arc.isLast()! 
public	TokenNamepublic	
int	TokenNameint	
readNextArcLabel	TokenNameIdentifier	 read Next Arc Label
(	TokenNameLPAREN	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
assert	TokenNameassert	
!	TokenNameNOT	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
isLast	TokenNameIdentifier	 is Last
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
BytesReader	TokenNameIdentifier	 Bytes Reader
in	TokenNameIdentifier	 in
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
label	TokenNameIdentifier	 label
==	TokenNameEQUAL_EQUAL	
END_LABEL	TokenNameIdentifier	 END  LABEL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println(" nextArc fake " + arc.nextArc); 	TokenNameCOMMENT_LINE	System.out.println(" nextArc fake " + arc.nextArc); 
in	TokenNameIdentifier	 in
=	TokenNameEQUAL	
getBytesReader	TokenNameIdentifier	 get Bytes Reader
(	TokenNameLPAREN	
getNodeAddress	TokenNameIdentifier	 get Node Address
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
nextArc	TokenNameIdentifier	 next Arc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
byte	TokenNamebyte	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
bytes	TokenNameIdentifier	 bytes
[	TokenNameLBRACKET	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
pos	TokenNameIdentifier	 pos
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
==	TokenNameEQUAL_EQUAL	
ARCS_AS_FIXED_ARRAY	TokenNameIdentifier	 ARCS  AS  FIXED  ARRAY
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println(" nextArc fake array"); 	TokenNameCOMMENT_LINE	System.out.println(" nextArc fake array"); 
in	TokenNameIdentifier	 in
.	TokenNameDOT	
skip	TokenNameIdentifier	 skip
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
packed	TokenNameIdentifier	 packed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readInt	TokenNameIdentifier	 read Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println(" nextArc real array"); 	TokenNameCOMMENT_LINE	System.out.println(" nextArc real array"); 
// arcs are at fixed entries 	TokenNameCOMMENT_LINE	arcs are at fixed entries 
in	TokenNameIdentifier	 in
=	TokenNameEQUAL	
getBytesReader	TokenNameIdentifier	 get Bytes Reader
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
posArcsStart	TokenNameIdentifier	 pos Arcs Start
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
skip	TokenNameIdentifier	 skip
(	TokenNameLPAREN	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
arcIdx	TokenNameIdentifier	 arc Idx
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// arcs are packed 	TokenNameCOMMENT_LINE	arcs are packed 
//System.out.println(" nextArc real packed"); 	TokenNameCOMMENT_LINE	System.out.println(" nextArc real packed"); 
in	TokenNameIdentifier	 in
=	TokenNameEQUAL	
getBytesReader	TokenNameIdentifier	 get Bytes Reader
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
nextArc	TokenNameIdentifier	 next Arc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// skip flags 	TokenNameCOMMENT_LINE	skip flags 
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readByte	TokenNameIdentifier	 read Byte
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
readLabel	TokenNameIdentifier	 read Label
(	TokenNameLPAREN	
in	TokenNameIdentifier	 in
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Never returns null, but you should never call this if * arc.isLast() is true. */	TokenNameCOMMENT_JAVADOC	 Never returns null, but you should never call this if arc.isLast() is true. 
public	TokenNamepublic	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
readNextRealArc	TokenNameIdentifier	 read Next Real Arc
(	TokenNameLPAREN	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
final	TokenNamefinal	
BytesReader	TokenNameIdentifier	 Bytes Reader
in	TokenNameIdentifier	 in
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
assert	TokenNameassert	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
bytes	TokenNameIdentifier	 bytes
==	TokenNameEQUAL_EQUAL	
bytes	TokenNameIdentifier	 bytes
;	TokenNameSEMICOLON	
// TODO: can't assert this because we call from readFirstArc 	TokenNameCOMMENT_LINE	TODO: can't assert this because we call from readFirstArc 
// assert !flag(arc.flags, BIT_LAST_ARC); 	TokenNameCOMMENT_LINE	assert !flag(arc.flags, BIT_LAST_ARC); 
// this is a continuing arc in a fixed array 	TokenNameCOMMENT_LINE	this is a continuing arc in a fixed array 
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// arcs are at fixed entries 	TokenNameCOMMENT_LINE	arcs are at fixed entries 
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
arcIdx	TokenNameIdentifier	 arc Idx
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
arcIdx	TokenNameIdentifier	 arc Idx
<	TokenNameLESS	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
numArcs	TokenNameIdentifier	 num Arcs
;	TokenNameSEMICOLON	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
skip	TokenNameIdentifier	 skip
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
posArcsStart	TokenNameIdentifier	 pos Arcs Start
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
arcIdx	TokenNameIdentifier	 arc Idx
*	TokenNameMULTIPLY	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// arcs are packed 	TokenNameCOMMENT_LINE	arcs are packed 
in	TokenNameIdentifier	 in
.	TokenNameDOT	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
nextArc	TokenNameIdentifier	 next Arc
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
flags	TokenNameIdentifier	 flags
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readByte	TokenNameIdentifier	 read Byte
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
label	TokenNameIdentifier	 label
=	TokenNameEQUAL	
readLabel	TokenNameIdentifier	 read Label
(	TokenNameLPAREN	
in	TokenNameIdentifier	 in
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
flag	TokenNameIdentifier	 flag
(	TokenNameLPAREN	
BIT_ARC_HAS_OUTPUT	TokenNameIdentifier	 BIT  ARC  HAS  OUTPUT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
read	TokenNameIdentifier	 read
(	TokenNameLPAREN	
in	TokenNameIdentifier	 in
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
getNoOutput	TokenNameIdentifier	 get No Output
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
flag	TokenNameIdentifier	 flag
(	TokenNameLPAREN	
BIT_ARC_HAS_FINAL_OUTPUT	TokenNameIdentifier	 BIT  ARC  HAS  FINAL  OUTPUT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
nextFinalOutput	TokenNameIdentifier	 next Final Output
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
read	TokenNameIdentifier	 read
(	TokenNameLPAREN	
in	TokenNameIdentifier	 in
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
nextFinalOutput	TokenNameIdentifier	 next Final Output
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
getNoOutput	TokenNameIdentifier	 get No Output
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
flag	TokenNameIdentifier	 flag
(	TokenNameLPAREN	
BIT_STOP_NODE	TokenNameIdentifier	 BIT  STOP  NODE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
flag	TokenNameIdentifier	 flag
(	TokenNameLPAREN	
BIT_FINAL_ARC	TokenNameIdentifier	 BIT  FINAL  ARC
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
target	TokenNameIdentifier	 target
=	TokenNameEQUAL	
FINAL_END_NODE	TokenNameIdentifier	 FINAL  END  NODE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
target	TokenNameIdentifier	 target
=	TokenNameEQUAL	
NON_FINAL_END_NODE	TokenNameIdentifier	 NON  FINAL  END  NODE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
nextArc	TokenNameIdentifier	 next Arc
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
flag	TokenNameIdentifier	 flag
(	TokenNameLPAREN	
BIT_TARGET_NEXT	TokenNameIdentifier	 BIT  TARGET  NEXT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
nextArc	TokenNameIdentifier	 next Arc
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
// TODO: would be nice to make this lazy -- maybe 	TokenNameCOMMENT_LINE	TODO: would be nice to make this lazy -- maybe 
// caller doesn't need the target and is scanning arcs... 	TokenNameCOMMENT_LINE	caller doesn't need the target and is scanning arcs... 
if	TokenNameif	
(	TokenNameLPAREN	
nodeAddress	TokenNameIdentifier	 node Address
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
flag	TokenNameIdentifier	 flag
(	TokenNameLPAREN	
BIT_LAST_ARC	TokenNameIdentifier	 BIT  LAST  ARC
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// must scan 	TokenNameCOMMENT_LINE	must scan 
seekToNextNode	TokenNameIdentifier	 seek To Next Node
(	TokenNameLPAREN	
in	TokenNameIdentifier	 in
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
skip	TokenNameIdentifier	 skip
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
posArcsStart	TokenNameIdentifier	 pos Arcs Start
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
*	TokenNameMULTIPLY	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
numArcs	TokenNameIdentifier	 num Arcs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
target	TokenNameIdentifier	 target
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
target	TokenNameIdentifier	 target
=	TokenNameEQUAL	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
node	TokenNameIdentifier	 node
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
target	TokenNameIdentifier	 target
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
packed	TokenNameIdentifier	 packed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
code	TokenNameIdentifier	 code
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
flag	TokenNameIdentifier	 flag
(	TokenNameLPAREN	
BIT_TARGET_DELTA	TokenNameIdentifier	 BIT  TARGET  DELTA
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Address is delta-coded from current address: 	TokenNameCOMMENT_LINE	Address is delta-coded from current address: 
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
target	TokenNameIdentifier	 target
=	TokenNameEQUAL	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
code	TokenNameIdentifier	 code
;	TokenNameSEMICOLON	
//System.out.println(" delta pos=" + pos + " delta=" + code + " target=" + arc.target); 	TokenNameCOMMENT_LINE	System.out.println(" delta pos=" + pos + " delta=" + code + " target=" + arc.target); 
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
code	TokenNameIdentifier	 code
<	TokenNameLESS	
nodeRefToAddress	TokenNameIdentifier	 node Ref To Address
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Deref 	TokenNameCOMMENT_LINE	Deref 
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
target	TokenNameIdentifier	 target
=	TokenNameEQUAL	
nodeRefToAddress	TokenNameIdentifier	 node Ref To Address
[	TokenNameLBRACKET	
code	TokenNameIdentifier	 code
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
//System.out.println(" deref code=" + code + " target=" + arc.target); 	TokenNameCOMMENT_LINE	System.out.println(" deref code=" + code + " target=" + arc.target); 
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Absolute 	TokenNameCOMMENT_LINE	Absolute 
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
target	TokenNameIdentifier	 target
=	TokenNameEQUAL	
code	TokenNameIdentifier	 code
;	TokenNameSEMICOLON	
//System.out.println(" abs code=" + code + " derefLen=" + nodeRefToAddress.length); 	TokenNameCOMMENT_LINE	System.out.println(" abs code=" + code + " derefLen=" + nodeRefToAddress.length); 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
target	TokenNameIdentifier	 target
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readInt	TokenNameIdentifier	 read Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
nextArc	TokenNameIdentifier	 next Arc
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
arc	TokenNameIdentifier	 arc
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Finds an arc leaving the incoming arc, replacing the arc in place. * This returns null if the arc was not found, else the incoming arc. */	TokenNameCOMMENT_JAVADOC	 Finds an arc leaving the incoming arc, replacing the arc in place. This returns null if the arc was not found, else the incoming arc. 
public	TokenNamepublic	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
findTargetArc	TokenNameIdentifier	 find Target Arc
(	TokenNameLPAREN	
int	TokenNameint	
labelToMatch	TokenNameIdentifier	 label To Match
,	TokenNameCOMMA	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
follow	TokenNameIdentifier	 follow
,	TokenNameCOMMA	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
BytesReader	TokenNameIdentifier	 Bytes Reader
in	TokenNameIdentifier	 in
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
assert	TokenNameassert	
cachedRootArcs	TokenNameIdentifier	 cached Root Arcs
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
bytes	TokenNameIdentifier	 bytes
==	TokenNameEQUAL_EQUAL	
bytes	TokenNameIdentifier	 bytes
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
labelToMatch	TokenNameIdentifier	 label To Match
==	TokenNameEQUAL_EQUAL	
END_LABEL	TokenNameIdentifier	 END  LABEL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
follow	TokenNameIdentifier	 follow
.	TokenNameDOT	
isFinal	TokenNameIdentifier	 is Final
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
follow	TokenNameIdentifier	 follow
.	TokenNameDOT	
target	TokenNameIdentifier	 target
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
flags	TokenNameIdentifier	 flags
=	TokenNameEQUAL	
BIT_LAST_ARC	TokenNameIdentifier	 BIT  LAST  ARC
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
flags	TokenNameIdentifier	 flags
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// NOTE: nextArc is a node (not an address!) in this case: 	TokenNameCOMMENT_LINE	NOTE: nextArc is a node (not an address!) in this case: 
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
nextArc	TokenNameIdentifier	 next Arc
=	TokenNameEQUAL	
follow	TokenNameIdentifier	 follow
.	TokenNameDOT	
target	TokenNameIdentifier	 target
;	TokenNameSEMICOLON	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
follow	TokenNameIdentifier	 follow
.	TokenNameDOT	
target	TokenNameIdentifier	 target
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
follow	TokenNameIdentifier	 follow
.	TokenNameDOT	
nextFinalOutput	TokenNameIdentifier	 next Final Output
;	TokenNameSEMICOLON	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
label	TokenNameIdentifier	 label
=	TokenNameEQUAL	
END_LABEL	TokenNameIdentifier	 END  LABEL
;	TokenNameSEMICOLON	
return	TokenNamereturn	
arc	TokenNameIdentifier	 arc
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Short-circuit if this arc is in the root arc cache: 	TokenNameCOMMENT_LINE	Short-circuit if this arc is in the root arc cache: 
if	TokenNameif	
(	TokenNameLPAREN	
follow	TokenNameIdentifier	 follow
.	TokenNameDOT	
target	TokenNameIdentifier	 target
==	TokenNameEQUAL_EQUAL	
startNode	TokenNameIdentifier	 start Node
&&	TokenNameAND_AND	
labelToMatch	TokenNameIdentifier	 label To Match
<	TokenNameLESS	
cachedRootArcs	TokenNameIdentifier	 cached Root Arcs
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
cachedRootArcs	TokenNameIdentifier	 cached Root Arcs
[	TokenNameLBRACKET	
labelToMatch	TokenNameIdentifier	 label To Match
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
result	TokenNameIdentifier	 result
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
copyFrom	TokenNameIdentifier	 copy From
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
arc	TokenNameIdentifier	 arc
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
targetHasArcs	TokenNameIdentifier	 target Has Arcs
(	TokenNameLPAREN	
follow	TokenNameIdentifier	 follow
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
getNodeAddress	TokenNameIdentifier	 get Node Address
(	TokenNameLPAREN	
follow	TokenNameIdentifier	 follow
.	TokenNameDOT	
target	TokenNameIdentifier	 target
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
follow	TokenNameIdentifier	 follow
.	TokenNameDOT	
target	TokenNameIdentifier	 target
;	TokenNameSEMICOLON	
// System.out.println("fta label=" + (char) labelToMatch); 	TokenNameCOMMENT_LINE	System.out.println("fta label=" + (char) labelToMatch); 
if	TokenNameif	
(	TokenNameLPAREN	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readByte	TokenNameIdentifier	 read Byte
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
ARCS_AS_FIXED_ARRAY	TokenNameIdentifier	 ARCS  AS  FIXED  ARRAY
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Arcs are full array; do binary search: 	TokenNameCOMMENT_LINE	Arcs are full array; do binary search: 
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
numArcs	TokenNameIdentifier	 num Arcs
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
packed	TokenNameIdentifier	 packed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readInt	TokenNameIdentifier	 read Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
posArcsStart	TokenNameIdentifier	 pos Arcs Start
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
int	TokenNameint	
low	TokenNameIdentifier	 low
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
high	TokenNameIdentifier	 high
=	TokenNameEQUAL	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
numArcs	TokenNameIdentifier	 num Arcs
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
low	TokenNameIdentifier	 low
<=	TokenNameLESS_EQUAL	
high	TokenNameIdentifier	 high
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println(" cycle"); 	TokenNameCOMMENT_LINE	System.out.println(" cycle"); 
int	TokenNameint	
mid	TokenNameIdentifier	 mid
=	TokenNameEQUAL	
(	TokenNameLPAREN	
low	TokenNameIdentifier	 low
+	TokenNamePLUS	
high	TokenNameIdentifier	 high
)	TokenNameRPAREN	
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
skip	TokenNameIdentifier	 skip
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
posArcsStart	TokenNameIdentifier	 pos Arcs Start
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
*	TokenNameMULTIPLY	
mid	TokenNameIdentifier	 mid
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
midLabel	TokenNameIdentifier	 mid Label
=	TokenNameEQUAL	
readLabel	TokenNameIdentifier	 read Label
(	TokenNameLPAREN	
in	TokenNameIdentifier	 in
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
cmp	TokenNameIdentifier	 cmp
=	TokenNameEQUAL	
midLabel	TokenNameIdentifier	 mid Label
-	TokenNameMINUS	
labelToMatch	TokenNameIdentifier	 label To Match
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cmp	TokenNameIdentifier	 cmp
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
low	TokenNameIdentifier	 low
=	TokenNameEQUAL	
mid	TokenNameIdentifier	 mid
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
cmp	TokenNameIdentifier	 cmp
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
high	TokenNameIdentifier	 high
=	TokenNameEQUAL	
mid	TokenNameIdentifier	 mid
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
arcIdx	TokenNameIdentifier	 arc Idx
=	TokenNameEQUAL	
mid	TokenNameIdentifier	 mid
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
//System.out.println(" found!"); 	TokenNameCOMMENT_LINE	System.out.println(" found!"); 
return	TokenNamereturn	
readNextRealArc	TokenNameIdentifier	 read Next Real Arc
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
in	TokenNameIdentifier	 in
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Linear scan 	TokenNameCOMMENT_LINE	Linear scan 
readFirstRealTargetArc	TokenNameIdentifier	 read First Real Target Arc
(	TokenNameLPAREN	
follow	TokenNameIdentifier	 follow
.	TokenNameDOT	
target	TokenNameIdentifier	 target
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
in	TokenNameIdentifier	 in
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println(" non-bs cycle"); 	TokenNameCOMMENT_LINE	System.out.println(" non-bs cycle"); 
// TODO: we should fix this code to not have to create 	TokenNameCOMMENT_LINE	TODO: we should fix this code to not have to create 
// object for the output of every arc we scan... only 	TokenNameCOMMENT_LINE	object for the output of every arc we scan... only 
// for the matching arc, if found 	TokenNameCOMMENT_LINE	for the matching arc, if found 
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
label	TokenNameIdentifier	 label
==	TokenNameEQUAL_EQUAL	
labelToMatch	TokenNameIdentifier	 label To Match
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println(" found!"); 	TokenNameCOMMENT_LINE	System.out.println(" found!"); 
return	TokenNamereturn	
arc	TokenNameIdentifier	 arc
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
label	TokenNameIdentifier	 label
>	TokenNameGREATER	
labelToMatch	TokenNameIdentifier	 label To Match
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
isLast	TokenNameIdentifier	 is Last
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
readNextRealArc	TokenNameIdentifier	 read Next Real Arc
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
in	TokenNameIdentifier	 in
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
seekToNextNode	TokenNameIdentifier	 seek To Next Node
(	TokenNameLPAREN	
BytesReader	TokenNameIdentifier	 Bytes Reader
in	TokenNameIdentifier	 in
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
flags	TokenNameIdentifier	 flags
=	TokenNameEQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readByte	TokenNameIdentifier	 read Byte
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
readLabel	TokenNameIdentifier	 read Label
(	TokenNameLPAREN	
in	TokenNameIdentifier	 in
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
flag	TokenNameIdentifier	 flag
(	TokenNameLPAREN	
flags	TokenNameIdentifier	 flags
,	TokenNameCOMMA	
BIT_ARC_HAS_OUTPUT	TokenNameIdentifier	 BIT  ARC  HAS  OUTPUT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
read	TokenNameIdentifier	 read
(	TokenNameLPAREN	
in	TokenNameIdentifier	 in
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
flag	TokenNameIdentifier	 flag
(	TokenNameLPAREN	
flags	TokenNameIdentifier	 flags
,	TokenNameCOMMA	
BIT_ARC_HAS_FINAL_OUTPUT	TokenNameIdentifier	 BIT  ARC  HAS  FINAL  OUTPUT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
read	TokenNameIdentifier	 read
(	TokenNameLPAREN	
in	TokenNameIdentifier	 in
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
flag	TokenNameIdentifier	 flag
(	TokenNameLPAREN	
flags	TokenNameIdentifier	 flags
,	TokenNameCOMMA	
BIT_STOP_NODE	TokenNameIdentifier	 BIT  STOP  NODE
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
flag	TokenNameIdentifier	 flag
(	TokenNameLPAREN	
flags	TokenNameIdentifier	 flags
,	TokenNameCOMMA	
BIT_TARGET_NEXT	TokenNameIdentifier	 BIT  TARGET  NEXT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
packed	TokenNameIdentifier	 packed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readVInt	TokenNameIdentifier	 read V Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readInt	TokenNameIdentifier	 read Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
flag	TokenNameIdentifier	 flag
(	TokenNameLPAREN	
flags	TokenNameIdentifier	 flags
,	TokenNameCOMMA	
BIT_LAST_ARC	TokenNameIdentifier	 BIT  LAST  ARC
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getNodeCount	TokenNameIdentifier	 get Node Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 1+ in order to count the -1 implicit final node 	TokenNameCOMMENT_LINE	1+ in order to count the -1 implicit final node 
return	TokenNamereturn	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
nodeCount	TokenNameIdentifier	 node Count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getArcCount	TokenNameIdentifier	 get Arc Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
arcCount	TokenNameIdentifier	 arc Count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getArcWithOutputCount	TokenNameIdentifier	 get Arc With Output Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
arcWithOutputCount	TokenNameIdentifier	 arc With Output Count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setAllowArrayArcs	TokenNameIdentifier	 set Allow Array Arcs
(	TokenNameLPAREN	
boolean	TokenNameboolean	
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
{	TokenNameLBRACE	
allowArrayArcs	TokenNameIdentifier	 allow Array Arcs
=	TokenNameEQUAL	
v	TokenNameIdentifier	 v
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Nodes will be expanded if their depth (distance from the root node) is * &lt;= this value and their number of arcs is &gt;= * {@link #FIXED_ARRAY_NUM_ARCS_SHALLOW}. * * <p> * Fixed array consumes more RAM but enables binary search on the arcs * (instead of a linear scan) on lookup by arc label. * * @return <code>true</code> if <code>node</code> should be stored in an * expanded (array) form. * * @see #FIXED_ARRAY_NUM_ARCS_DEEP * @see Builder.UnCompiledNode#depth */	TokenNameCOMMENT_JAVADOC	 Nodes will be expanded if their depth (distance from the root node) is &lt;= this value and their number of arcs is &gt;= {@link #FIXED_ARRAY_NUM_ARCS_SHALLOW}. * <p> Fixed array consumes more RAM but enables binary search on the arcs (instead of a linear scan) on lookup by arc label. * @return <code>true</code> if <code>node</code> should be stored in an expanded (array) form. * @see #FIXED_ARRAY_NUM_ARCS_DEEP @see Builder.UnCompiledNode#depth 
private	TokenNameprivate	
boolean	TokenNameboolean	
shouldExpand	TokenNameIdentifier	 should Expand
(	TokenNameLPAREN	
UnCompiledNode	TokenNameIdentifier	 Un Compiled Node
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
allowArrayArcs	TokenNameIdentifier	 allow Array Arcs
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
depth	TokenNameIdentifier	 depth
<=	TokenNameLESS_EQUAL	
FIXED_ARRAY_SHALLOW_DISTANCE	TokenNameIdentifier	 FIXED  ARRAY  SHALLOW  DISTANCE
&&	TokenNameAND_AND	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
numArcs	TokenNameIdentifier	 num Arcs
>=	TokenNameGREATER_EQUAL	
FIXED_ARRAY_NUM_ARCS_SHALLOW	TokenNameIdentifier	 FIXED  ARRAY  NUM  ARCS  SHALLOW
)	TokenNameRPAREN	
||	TokenNameOR_OR	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
numArcs	TokenNameIdentifier	 num Arcs
>=	TokenNameGREATER_EQUAL	
FIXED_ARRAY_NUM_ARCS_DEEP	TokenNameIdentifier	 FIXED  ARRAY  NUM  ARCS  DEEP
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Non-static: writes to FST's byte[] 	TokenNameCOMMENT_LINE	Non-static: writes to FST's byte[] 
class	TokenNameclass	
BytesWriter	TokenNameIdentifier	 Bytes Writer
extends	TokenNameextends	
DataOutput	TokenNameIdentifier	 Data Output
{	TokenNameLBRACE	
int	TokenNameint	
posWrite	TokenNameIdentifier	 pos Write
;	TokenNameSEMICOLON	
public	TokenNamepublic	
BytesWriter	TokenNameIdentifier	 Bytes Writer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// pad: ensure no node gets address 0 which is reserved to mean 	TokenNameCOMMENT_LINE	pad: ensure no node gets address 0 which is reserved to mean 
// the stop state w/ no arcs 	TokenNameCOMMENT_LINE	the stop state w/ no arcs 
posWrite	TokenNameIdentifier	 pos Write
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
byte	TokenNamebyte	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
posWrite	TokenNameIdentifier	 pos Write
<=	TokenNameLESS_EQUAL	
bytes	TokenNameIdentifier	 bytes
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
bytes	TokenNameIdentifier	 bytes
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
posWrite	TokenNameIdentifier	 pos Write
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bytes	TokenNameIdentifier	 bytes
=	TokenNameEQUAL	
ArrayUtil	TokenNameIdentifier	 Array Util
.	TokenNameDOT	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
bytes	TokenNameIdentifier	 bytes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
assert	TokenNameassert	
posWrite	TokenNameIdentifier	 pos Write
<	TokenNameLESS	
bytes	TokenNameIdentifier	 bytes
.	TokenNameDOT	
length	TokenNameIdentifier	 length
:	TokenNameCOLON	
"posWrite="	TokenNameStringLiteral	posWrite=
+	TokenNamePLUS	
posWrite	TokenNameIdentifier	 pos Write
+	TokenNamePLUS	
" bytes.length="	TokenNameStringLiteral	 bytes.length=
+	TokenNamePLUS	
bytes	TokenNameIdentifier	 bytes
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
bytes	TokenNameIdentifier	 bytes
[	TokenNameLBRACKET	
posWrite	TokenNameIdentifier	 pos Write
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setPosWrite	TokenNameIdentifier	 set Pos Write
(	TokenNameLPAREN	
int	TokenNameint	
posWrite	TokenNameIdentifier	 pos Write
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
posWrite	TokenNameIdentifier	 pos Write
=	TokenNameEQUAL	
posWrite	TokenNameIdentifier	 pos Write
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
bytes	TokenNameIdentifier	 bytes
.	TokenNameDOT	
length	TokenNameIdentifier	 length
<	TokenNameLESS	
posWrite	TokenNameIdentifier	 pos Write
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bytes	TokenNameIdentifier	 bytes
=	TokenNameEQUAL	
ArrayUtil	TokenNameIdentifier	 Array Util
.	TokenNameDOT	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
bytes	TokenNameIdentifier	 bytes
,	TokenNameCOMMA	
posWrite	TokenNameIdentifier	 pos Write
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
writeBytes	TokenNameIdentifier	 write Bytes
(	TokenNameLPAREN	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
int	TokenNameint	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
int	TokenNameint	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
posWrite	TokenNameIdentifier	 pos Write
+	TokenNamePLUS	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
bytes	TokenNameIdentifier	 bytes
=	TokenNameEQUAL	
ArrayUtil	TokenNameIdentifier	 Array Util
.	TokenNameDOT	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
bytes	TokenNameIdentifier	 bytes
,	TokenNameCOMMA	
size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
bytes	TokenNameIdentifier	 bytes
,	TokenNameCOMMA	
posWrite	TokenNameIdentifier	 pos Write
,	TokenNameCOMMA	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
posWrite	TokenNameIdentifier	 pos Write
+=	TokenNamePLUS_EQUAL	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
final	TokenNamefinal	
BytesReader	TokenNameIdentifier	 Bytes Reader
getBytesReader	TokenNameIdentifier	 get Bytes Reader
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// TODO: maybe re-use via ThreadLocal? 	TokenNameCOMMENT_LINE	TODO: maybe re-use via ThreadLocal? 
if	TokenNameif	
(	TokenNameLPAREN	
packed	TokenNameIdentifier	 packed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
ForwardBytesReader	TokenNameIdentifier	 Forward Bytes Reader
(	TokenNameLPAREN	
bytes	TokenNameIdentifier	 bytes
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
ReverseBytesReader	TokenNameIdentifier	 Reverse Bytes Reader
(	TokenNameLPAREN	
bytes	TokenNameIdentifier	 bytes
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Reads the bytes from this FST. Use {@link * #getBytesReader(int)} to obtain an instance for this * FST; re-use across calls (but only within a single * thread) for better performance. */	TokenNameCOMMENT_JAVADOC	 Reads the bytes from this FST. Use {@link #getBytesReader(int)} to obtain an instance for this FST; re-use across calls (but only within a single thread) for better performance. 
public	TokenNamepublic	
static	TokenNamestatic	
abstract	TokenNameabstract	
class	TokenNameclass	
BytesReader	TokenNameIdentifier	 Bytes Reader
extends	TokenNameextends	
DataInput	TokenNameIdentifier	 Data Input
{	TokenNameLBRACE	
protected	TokenNameprotected	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
final	TokenNamefinal	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bytes	TokenNameIdentifier	 bytes
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
BytesReader	TokenNameIdentifier	 Bytes Reader
(	TokenNameLPAREN	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bytes	TokenNameIdentifier	 bytes
,	TokenNameCOMMA	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
bytes	TokenNameIdentifier	 bytes
=	TokenNameEQUAL	
bytes	TokenNameIdentifier	 bytes
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
abstract	TokenNameabstract	
void	TokenNamevoid	
skip	TokenNameIdentifier	 skip
(	TokenNameLPAREN	
int	TokenNameint	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
abstract	TokenNameabstract	
void	TokenNamevoid	
skip	TokenNameIdentifier	 skip
(	TokenNameLPAREN	
int	TokenNameint	
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
int	TokenNameint	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
static	TokenNamestatic	
class	TokenNameclass	
ReverseBytesReader	TokenNameIdentifier	 Reverse Bytes Reader
extends	TokenNameextends	
BytesReader	TokenNameIdentifier	 Bytes Reader
{	TokenNameLBRACE	
public	TokenNamepublic	
ReverseBytesReader	TokenNameIdentifier	 Reverse Bytes Reader
(	TokenNameLPAREN	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bytes	TokenNameIdentifier	 bytes
,	TokenNameCOMMA	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
bytes	TokenNameIdentifier	 bytes
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
byte	TokenNamebyte	
readByte	TokenNameIdentifier	 read Byte
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
bytes	TokenNameIdentifier	 bytes
[	TokenNameLBRACKET	
pos	TokenNameIdentifier	 pos
--	TokenNameMINUS_MINUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
readBytes	TokenNameIdentifier	 read Bytes
(	TokenNameLPAREN	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
int	TokenNameint	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
int	TokenNameint	
len	TokenNameIdentifier	 len
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
[	TokenNameLBRACKET	
offset	TokenNameIdentifier	 offset
+	TokenNamePLUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
bytes	TokenNameIdentifier	 bytes
[	TokenNameLBRACKET	
pos	TokenNameIdentifier	 pos
--	TokenNameMINUS_MINUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
skip	TokenNameIdentifier	 skip
(	TokenNameLPAREN	
int	TokenNameint	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pos	TokenNameIdentifier	 pos
-=	TokenNameMINUS_EQUAL	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
skip	TokenNameIdentifier	 skip
(	TokenNameLPAREN	
int	TokenNameint	
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
int	TokenNameint	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
base	TokenNameIdentifier	 base
-	TokenNameMINUS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// TODO: can we use just ByteArrayDataInput...? need to 	TokenNameCOMMENT_LINE	TODO: can we use just ByteArrayDataInput...? need to 
// add a .skipBytes to DataInput.. hmm and .setPosition 	TokenNameCOMMENT_LINE	add a .skipBytes to DataInput.. hmm and .setPosition 
final	TokenNamefinal	
static	TokenNamestatic	
class	TokenNameclass	
ForwardBytesReader	TokenNameIdentifier	 Forward Bytes Reader
extends	TokenNameextends	
BytesReader	TokenNameIdentifier	 Bytes Reader
{	TokenNameLBRACE	
public	TokenNamepublic	
ForwardBytesReader	TokenNameIdentifier	 Forward Bytes Reader
(	TokenNameLPAREN	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bytes	TokenNameIdentifier	 bytes
,	TokenNameCOMMA	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
bytes	TokenNameIdentifier	 bytes
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
byte	TokenNamebyte	
readByte	TokenNameIdentifier	 read Byte
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
bytes	TokenNameIdentifier	 bytes
[	TokenNameLBRACKET	
pos	TokenNameIdentifier	 pos
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
readBytes	TokenNameIdentifier	 read Bytes
(	TokenNameLPAREN	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
int	TokenNameint	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
int	TokenNameint	
len	TokenNameIdentifier	 len
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
bytes	TokenNameIdentifier	 bytes
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
len	TokenNameIdentifier	 len
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pos	TokenNameIdentifier	 pos
+=	TokenNamePLUS_EQUAL	
len	TokenNameIdentifier	 len
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
skip	TokenNameIdentifier	 skip
(	TokenNameLPAREN	
int	TokenNameint	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pos	TokenNameIdentifier	 pos
+=	TokenNamePLUS_EQUAL	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
skip	TokenNameIdentifier	 skip
(	TokenNameLPAREN	
int	TokenNameint	
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
int	TokenNameint	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
base	TokenNameIdentifier	 base
+	TokenNamePLUS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
ArcAndState	TokenNameIdentifier	 Arc And State
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
{	TokenNameLBRACE	
final	TokenNamefinal	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
arc	TokenNameIdentifier	 arc
;	TokenNameSEMICOLON	
final	TokenNamefinal	
IntsRef	TokenNameIdentifier	 Ints Ref
chain	TokenNameIdentifier	 chain
;	TokenNameSEMICOLON	
public	TokenNamepublic	
ArcAndState	TokenNameIdentifier	 Arc And State
(	TokenNameLPAREN	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
IntsRef	TokenNameIdentifier	 Ints Ref
chain	TokenNameIdentifier	 chain
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
arc	TokenNameIdentifier	 arc
=	TokenNameEQUAL	
arc	TokenNameIdentifier	 arc
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
chain	TokenNameIdentifier	 chain
=	TokenNameEQUAL	
chain	TokenNameIdentifier	 chain
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* public void countSingleChains() throws IOException { // TODO: must assert this FST was built with // "willRewrite" final List<ArcAndState<T>> queue = new ArrayList<ArcAndState<T>>(); // TODO: use bitset to not revisit nodes already // visited FixedBitSet seen = new FixedBitSet(1+nodeCount); int saved = 0; queue.add(new ArcAndState<T>(getFirstArc(new Arc<T>()), new IntsRef())); Arc<T> scratchArc = new Arc<T>(); while(queue.size() > 0) { //System.out.println("cycle size=" + queue.size()); //for(ArcAndState<T> ent : queue) { // System.out.println(" " + Util.toBytesRef(ent.chain, new BytesRef())); // } final ArcAndState<T> arcAndState = queue.get(queue.size()-1); seen.set(arcAndState.arc.node); final BytesRef br = Util.toBytesRef(arcAndState.chain, new BytesRef()); if (br.length > 0 && br.bytes[br.length-1] == -1) { br.length--; } //System.out.println(" top node=" + arcAndState.arc.target + " chain=" + br.utf8ToString()); if (targetHasArcs(arcAndState.arc) && !seen.get(arcAndState.arc.target)) { // push readFirstTargetArc(arcAndState.arc, scratchArc); //System.out.println(" push label=" + (char) scratchArc.label); //System.out.println(" tonode=" + scratchArc.target + " last?=" + scratchArc.isLast()); final IntsRef chain = IntsRef.deepCopyOf(arcAndState.chain); chain.grow(1+chain.length); // TODO //assert scratchArc.label != END_LABEL; chain.ints[chain.length] = scratchArc.label; chain.length++; if (scratchArc.isLast()) { if (scratchArc.target != -1 && inCounts[scratchArc.target] == 1) { //System.out.println(" append"); } else { if (arcAndState.chain.length > 1) { saved += chain.length-2; try { System.out.println("chain: " + Util.toBytesRef(chain, new BytesRef()).utf8ToString()); } catch (AssertionError ae) { System.out.println("chain: " + Util.toBytesRef(chain, new BytesRef())); } } chain.length = 0; } } else { //System.out.println(" reset"); if (arcAndState.chain.length > 1) { saved += arcAndState.chain.length-2; try { System.out.println("chain: " + Util.toBytesRef(arcAndState.chain, new BytesRef()).utf8ToString()); } catch (AssertionError ae) { System.out.println("chain: " + Util.toBytesRef(arcAndState.chain, new BytesRef())); } } if (scratchArc.target != -1 && inCounts[scratchArc.target] != 1) { chain.length = 0; } else { chain.ints[0] = scratchArc.label; chain.length = 1; } } // TODO: instead of new Arc() we can re-use from // a by-depth array queue.add(new ArcAndState<T>(new Arc<T>().copyFrom(scratchArc), chain)); } else if (!arcAndState.arc.isLast()) { // next readNextArc(arcAndState.arc); //System.out.println(" next label=" + (char) arcAndState.arc.label + " len=" + arcAndState.chain.length); if (arcAndState.chain.length != 0) { arcAndState.chain.ints[arcAndState.chain.length-1] = arcAndState.arc.label; } } else { if (arcAndState.chain.length > 1) { saved += arcAndState.chain.length-2; System.out.println("chain: " + Util.toBytesRef(arcAndState.chain, new BytesRef()).utf8ToString()); } // pop //System.out.println(" pop"); queue.remove(queue.size()-1); while(queue.size() > 0 && queue.get(queue.size()-1).arc.isLast()) { queue.remove(queue.size()-1); } if (queue.size() > 0) { final ArcAndState<T> arcAndState2 = queue.get(queue.size()-1); readNextArc(arcAndState2.arc); //System.out.println(" read next=" + (char) arcAndState2.arc.label + " queue=" + queue.size()); assert arcAndState2.arc.label != END_LABEL; if (arcAndState2.chain.length != 0) { arcAndState2.chain.ints[arcAndState2.chain.length-1] = arcAndState2.arc.label; } } } } System.out.println("TOT saved " + saved); } */	TokenNameCOMMENT_BLOCK	 public void countSingleChains() throws IOException { // TODO: must assert this FST was built with // "willRewrite" final List<ArcAndState<T>> queue = new ArrayList<ArcAndState<T>>(); // TODO: use bitset to not revisit nodes already // visited FixedBitSet seen = new FixedBitSet(1+nodeCount); int saved = 0; queue.add(new ArcAndState<T>(getFirstArc(new Arc<T>()), new IntsRef())); Arc<T> scratchArc = new Arc<T>(); while(queue.size() > 0) { //System.out.println("cycle size=" + queue.size()); //for(ArcAndState<T> ent : queue) { // System.out.println(" " + Util.toBytesRef(ent.chain, new BytesRef())); // } final ArcAndState<T> arcAndState = queue.get(queue.size()-1); seen.set(arcAndState.arc.node); final BytesRef br = Util.toBytesRef(arcAndState.chain, new BytesRef()); if (br.length > 0 && br.bytes[br.length-1] == -1) { br.length--; } //System.out.println(" top node=" + arcAndState.arc.target + " chain=" + br.utf8ToString()); if (targetHasArcs(arcAndState.arc) && !seen.get(arcAndState.arc.target)) { // push readFirstTargetArc(arcAndState.arc, scratchArc); //System.out.println(" push label=" + (char) scratchArc.label); //System.out.println(" tonode=" + scratchArc.target + " last?=" + scratchArc.isLast()); final IntsRef chain = IntsRef.deepCopyOf(arcAndState.chain); chain.grow(1+chain.length); // TODO //assert scratchArc.label != END_LABEL; chain.ints[chain.length] = scratchArc.label; chain.length++; if (scratchArc.isLast()) { if (scratchArc.target != -1 && inCounts[scratchArc.target] == 1) { //System.out.println(" append"); } else { if (arcAndState.chain.length > 1) { saved += chain.length-2; try { System.out.println("chain: " + Util.toBytesRef(chain, new BytesRef()).utf8ToString()); } catch (AssertionError ae) { System.out.println("chain: " + Util.toBytesRef(chain, new BytesRef())); } } chain.length = 0; } } else { //System.out.println(" reset"); if (arcAndState.chain.length > 1) { saved += arcAndState.chain.length-2; try { System.out.println("chain: " + Util.toBytesRef(arcAndState.chain, new BytesRef()).utf8ToString()); } catch (AssertionError ae) { System.out.println("chain: " + Util.toBytesRef(arcAndState.chain, new BytesRef())); } } if (scratchArc.target != -1 && inCounts[scratchArc.target] != 1) { chain.length = 0; } else { chain.ints[0] = scratchArc.label; chain.length = 1; } } // TODO: instead of new Arc() we can re-use from // a by-depth array queue.add(new ArcAndState<T>(new Arc<T>().copyFrom(scratchArc), chain)); } else if (!arcAndState.arc.isLast()) { // next readNextArc(arcAndState.arc); //System.out.println(" next label=" + (char) arcAndState.arc.label + " len=" + arcAndState.chain.length); if (arcAndState.chain.length != 0) { arcAndState.chain.ints[arcAndState.chain.length-1] = arcAndState.arc.label; } } else { if (arcAndState.chain.length > 1) { saved += arcAndState.chain.length-2; System.out.println("chain: " + Util.toBytesRef(arcAndState.chain, new BytesRef()).utf8ToString()); } // pop //System.out.println(" pop"); queue.remove(queue.size()-1); while(queue.size() > 0 && queue.get(queue.size()-1).arc.isLast()) { queue.remove(queue.size()-1); } if (queue.size() > 0) { final ArcAndState<T> arcAndState2 = queue.get(queue.size()-1); readNextArc(arcAndState2.arc); //System.out.println(" read next=" + (char) arcAndState2.arc.label + " queue=" + queue.size()); assert arcAndState2.arc.label != END_LABEL; if (arcAndState2.chain.length != 0) { arcAndState2.chain.ints[arcAndState2.chain.length-1] = arcAndState2.arc.label; } } } } System.out.println("TOT saved " + saved); } 
// Creates a packed FST 	TokenNameCOMMENT_LINE	Creates a packed FST 
private	TokenNameprivate	
FST	TokenNameIdentifier	 FST
(	TokenNameLPAREN	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
inputType	TokenNameIdentifier	 input Type
,	TokenNameCOMMA	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
nodeRefToAddress	TokenNameIdentifier	 node Ref To Address
,	TokenNameCOMMA	
Outputs	TokenNameIdentifier	 Outputs
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
outputs	TokenNameIdentifier	 outputs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
packed	TokenNameIdentifier	 packed
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
inputType	TokenNameIdentifier	 input Type
=	TokenNameEQUAL	
inputType	TokenNameIdentifier	 input Type
;	TokenNameSEMICOLON	
bytes	TokenNameIdentifier	 bytes
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
128	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
nodeRefToAddress	TokenNameIdentifier	 node Ref To Address
=	TokenNameEQUAL	
nodeRefToAddress	TokenNameIdentifier	 node Ref To Address
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
;	TokenNameSEMICOLON	
NO_OUTPUT	TokenNameIdentifier	 NO  OUTPUT
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
getNoOutput	TokenNameIdentifier	 get No Output
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writer	TokenNameIdentifier	 writer
=	TokenNameEQUAL	
new	TokenNamenew	
BytesWriter	TokenNameIdentifier	 Bytes Writer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Expert: creates an FST by packing this one. This * process requires substantial additional RAM (currently * ~8 bytes per node), but then should produce a smaller FST. */	TokenNameCOMMENT_JAVADOC	 Expert: creates an FST by packing this one. This process requires substantial additional RAM (currently ~8 bytes per node), but then should produce a smaller FST. 
public	TokenNamepublic	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
pack	TokenNameIdentifier	 pack
(	TokenNameLPAREN	
int	TokenNameint	
minInCountDeref	TokenNameIdentifier	 min In Count Deref
,	TokenNameCOMMA	
int	TokenNameint	
maxDerefNodes	TokenNameIdentifier	 max Deref Nodes
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// TODO: other things to try 	TokenNameCOMMENT_LINE	TODO: other things to try 
// - renumber the nodes to get more next / better locality? 	TokenNameCOMMENT_LINE	- renumber the nodes to get more next / better locality? 
// - allow multiple input labels on an arc, so 	TokenNameCOMMENT_LINE	- allow multiple input labels on an arc, so 
// singular chain of inputs can take one arc (on 	TokenNameCOMMENT_LINE	singular chain of inputs can take one arc (on 
// wikipedia terms this could save another ~6%) 	TokenNameCOMMENT_LINE	wikipedia terms this could save another ~6%) 
// - in the ord case, the output '1' is presumably 	TokenNameCOMMENT_LINE	- in the ord case, the output '1' is presumably 
// very common (after NO_OUTPUT)... maybe use a bit 	TokenNameCOMMENT_LINE	very common (after NO_OUTPUT)... maybe use a bit 
// for it..? 	TokenNameCOMMENT_LINE	for it..? 
// - use spare bits in flags.... for top few labels / 	TokenNameCOMMENT_LINE	- use spare bits in flags.... for top few labels / 
// outputs / targets 	TokenNameCOMMENT_LINE	outputs / targets 
if	TokenNameif	
(	TokenNameLPAREN	
nodeAddress	TokenNameIdentifier	 node Address
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"this FST was not built with willPackFST=true"	TokenNameStringLiteral	this FST was not built with willPackFST=true
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
arc	TokenNameIdentifier	 arc
=	TokenNameEQUAL	
new	TokenNamenew	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
BytesReader	TokenNameIdentifier	 Bytes Reader
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
getBytesReader	TokenNameIdentifier	 get Bytes Reader
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
topN	TokenNameIdentifier	 top N
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
min	TokenNameIdentifier	 min
(	TokenNameLPAREN	
maxDerefNodes	TokenNameIdentifier	 max Deref Nodes
,	TokenNameCOMMA	
inCounts	TokenNameIdentifier	 in Counts
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Find top nodes with highest number of incoming arcs: 	TokenNameCOMMENT_LINE	Find top nodes with highest number of incoming arcs: 
NodeQueue	TokenNameIdentifier	 Node Queue
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
new	TokenNamenew	
NodeQueue	TokenNameIdentifier	 Node Queue
(	TokenNameLPAREN	
topN	TokenNameIdentifier	 top N
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// TODO: we could use more RAM efficient selection algo here... 	TokenNameCOMMENT_LINE	TODO: we could use more RAM efficient selection algo here... 
NodeAndInCount	TokenNameIdentifier	 Node And In Count
bottom	TokenNameIdentifier	 bottom
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
node	TokenNameIdentifier	 node
<	TokenNameLESS	
inCounts	TokenNameIdentifier	 in Counts
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
node	TokenNameIdentifier	 node
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
inCounts	TokenNameIdentifier	 in Counts
[	TokenNameLBRACKET	
node	TokenNameIdentifier	 node
]	TokenNameRBRACKET	
>=	TokenNameGREATER_EQUAL	
minInCountDeref	TokenNameIdentifier	 min In Count Deref
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
bottom	TokenNameIdentifier	 bottom
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
q	TokenNameIdentifier	 q
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
NodeAndInCount	TokenNameIdentifier	 Node And In Count
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
inCounts	TokenNameIdentifier	 in Counts
[	TokenNameLBRACKET	
node	TokenNameIdentifier	 node
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
q	TokenNameIdentifier	 q
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
topN	TokenNameIdentifier	 top N
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bottom	TokenNameIdentifier	 bottom
=	TokenNameEQUAL	
q	TokenNameIdentifier	 q
.	TokenNameDOT	
top	TokenNameIdentifier	 top
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
inCounts	TokenNameIdentifier	 in Counts
[	TokenNameLBRACKET	
node	TokenNameIdentifier	 node
]	TokenNameRBRACKET	
>	TokenNameGREATER	
bottom	TokenNameIdentifier	 bottom
.	TokenNameDOT	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
q	TokenNameIdentifier	 q
.	TokenNameDOT	
insertWithOverflow	TokenNameIdentifier	 insert With Overflow
(	TokenNameLPAREN	
new	TokenNamenew	
NodeAndInCount	TokenNameIdentifier	 Node And In Count
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
inCounts	TokenNameIdentifier	 in Counts
[	TokenNameLBRACKET	
node	TokenNameIdentifier	 node
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Free up RAM: 	TokenNameCOMMENT_LINE	Free up RAM: 
inCounts	TokenNameIdentifier	 in Counts
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
topNodeMap	TokenNameIdentifier	 top Node Map
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
downTo	TokenNameIdentifier	 down To
=	TokenNameEQUAL	
q	TokenNameIdentifier	 q
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
downTo	TokenNameIdentifier	 down To
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
downTo	TokenNameIdentifier	 down To
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
NodeAndInCount	TokenNameIdentifier	 Node And In Count
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
q	TokenNameIdentifier	 q
.	TokenNameDOT	
pop	TokenNameIdentifier	 pop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
topNodeMap	TokenNameIdentifier	 top Node Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
.	TokenNameDOT	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
downTo	TokenNameIdentifier	 down To
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println("map node=" + n.node + " inCount=" + n.count + " to newID=" + downTo); 	TokenNameCOMMENT_LINE	System.out.println("map node=" + n.node + " inCount=" + n.count + " to newID=" + downTo); 
}	TokenNameRBRACE	
// TODO: we can use packed ints: 	TokenNameCOMMENT_LINE	TODO: we can use packed ints: 
// +1 because node ords start at 1 (0 is reserved as 	TokenNameCOMMENT_LINE	+1 because node ords start at 1 (0 is reserved as 
// stop node): 	TokenNameCOMMENT_LINE	stop node): 
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
nodeRefToAddressIn	TokenNameIdentifier	 node Ref To Address In
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
topNodeMap	TokenNameIdentifier	 top Node Map
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
fst	TokenNameIdentifier	 fst
=	TokenNameEQUAL	
new	TokenNamenew	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
(	TokenNameLPAREN	
inputType	TokenNameIdentifier	 input Type
,	TokenNameCOMMA	
nodeRefToAddressIn	TokenNameIdentifier	 node Ref To Address In
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
BytesWriter	TokenNameIdentifier	 Bytes Writer
writer	TokenNameIdentifier	 writer
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
writer	TokenNameIdentifier	 writer
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newNodeAddress	TokenNameIdentifier	 new Node Address
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
nodeCount	TokenNameIdentifier	 node Count
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// Fill initial coarse guess: 	TokenNameCOMMENT_LINE	Fill initial coarse guess: 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
node	TokenNameIdentifier	 node
<=	TokenNameLESS_EQUAL	
nodeCount	TokenNameIdentifier	 node Count
;	TokenNameSEMICOLON	
node	TokenNameIdentifier	 node
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
newNodeAddress	TokenNameIdentifier	 new Node Address
[	TokenNameLBRACKET	
node	TokenNameIdentifier	 node
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
bytes	TokenNameIdentifier	 bytes
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
nodeAddress	TokenNameIdentifier	 node Address
[	TokenNameLBRACKET	
node	TokenNameIdentifier	 node
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
absCount	TokenNameIdentifier	 abs Count
;	TokenNameSEMICOLON	
int	TokenNameint	
deltaCount	TokenNameIdentifier	 delta Count
;	TokenNameSEMICOLON	
int	TokenNameint	
topCount	TokenNameIdentifier	 top Count
;	TokenNameSEMICOLON	
int	TokenNameint	
nextCount	TokenNameIdentifier	 next Count
;	TokenNameSEMICOLON	
// Iterate until we converge: 	TokenNameCOMMENT_LINE	Iterate until we converge: 
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println("\nITER"); 	TokenNameCOMMENT_LINE	System.out.println("\nITER"); 
boolean	TokenNameboolean	
changed	TokenNameIdentifier	 changed
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// for assert: 	TokenNameCOMMENT_LINE	for assert: 
boolean	TokenNameboolean	
negDelta	TokenNameIdentifier	 neg Delta
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
posWrite	TokenNameIdentifier	 pos Write
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Skip 0 byte since 0 is reserved target: 	TokenNameCOMMENT_LINE	Skip 0 byte since 0 is reserved target: 
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
arcWithOutputCount	TokenNameIdentifier	 arc With Output Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
nodeCount	TokenNameIdentifier	 node Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
arcCount	TokenNameIdentifier	 arc Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
absCount	TokenNameIdentifier	 abs Count
=	TokenNameEQUAL	
deltaCount	TokenNameIdentifier	 delta Count
=	TokenNameEQUAL	
topCount	TokenNameIdentifier	 top Count
=	TokenNameEQUAL	
nextCount	TokenNameIdentifier	 next Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
changedCount	TokenNameIdentifier	 changed Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
addressError	TokenNameIdentifier	 address Error
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
//int totWasted = 0; 	TokenNameCOMMENT_LINE	int totWasted = 0; 
// Since we re-reverse the bytes, we now write the 	TokenNameCOMMENT_LINE	Since we re-reverse the bytes, we now write the 
// nodes backwards, so that BIT_TARGET_NEXT is 	TokenNameCOMMENT_LINE	nodes backwards, so that BIT_TARGET_NEXT is 
// unchanged: 	TokenNameCOMMENT_LINE	unchanged: 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
nodeCount	TokenNameIdentifier	 node Count
;	TokenNameSEMICOLON	
node	TokenNameIdentifier	 node
>=	TokenNameGREATER_EQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
node	TokenNameIdentifier	 node
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
nodeCount	TokenNameIdentifier	 node Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
address	TokenNameIdentifier	 address
=	TokenNameEQUAL	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
posWrite	TokenNameIdentifier	 pos Write
;	TokenNameSEMICOLON	
//System.out.println(" node: " + node + " address=" + address); 	TokenNameCOMMENT_LINE	System.out.println(" node: " + node + " address=" + address); 
if	TokenNameif	
(	TokenNameLPAREN	
address	TokenNameIdentifier	 address
!=	TokenNameNOT_EQUAL	
newNodeAddress	TokenNameIdentifier	 new Node Address
[	TokenNameLBRACKET	
node	TokenNameIdentifier	 node
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addressError	TokenNameIdentifier	 address Error
=	TokenNameEQUAL	
address	TokenNameIdentifier	 address
-	TokenNameMINUS	
newNodeAddress	TokenNameIdentifier	 new Node Address
[	TokenNameLBRACKET	
node	TokenNameIdentifier	 node
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
//System.out.println(" change: " + (address - newNodeAddress[node])); 	TokenNameCOMMENT_LINE	System.out.println(" change: " + (address - newNodeAddress[node])); 
changed	TokenNameIdentifier	 changed
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
newNodeAddress	TokenNameIdentifier	 new Node Address
[	TokenNameLBRACKET	
node	TokenNameIdentifier	 node
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
address	TokenNameIdentifier	 address
;	TokenNameSEMICOLON	
changedCount	TokenNameIdentifier	 changed Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
nodeArcCount	TokenNameIdentifier	 node Arc Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
retry	TokenNameIdentifier	 retry
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// for assert: 	TokenNameCOMMENT_LINE	for assert: 
boolean	TokenNameboolean	
anyNegDelta	TokenNameIdentifier	 any Neg Delta
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// Retry loop: possibly iterate more than once, if 	TokenNameCOMMENT_LINE	Retry loop: possibly iterate more than once, if 
// this is an array'd node and bytesPerArc changes: 	TokenNameCOMMENT_LINE	this is an array'd node and bytesPerArc changes: 
writeNode	TokenNameIdentifier	 write Node
:	TokenNameCOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// retry writing this node 	TokenNameCOMMENT_LINE	retry writing this node 
readFirstRealTargetArc	TokenNameIdentifier	 read First Real Target Arc
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
boolean	TokenNameboolean	
useArcArray	TokenNameIdentifier	 use Arc Array
=	TokenNameEQUAL	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
useArcArray	TokenNameIdentifier	 use Arc Array
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Write false first arc: 	TokenNameCOMMENT_LINE	Write false first arc: 
if	TokenNameif	
(	TokenNameLPAREN	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
=	TokenNameEQUAL	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
ARCS_AS_FIXED_ARRAY	TokenNameIdentifier	 ARCS  AS  FIXED  ARRAY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
writeVInt	TokenNameIdentifier	 write V Int
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
numArcs	TokenNameIdentifier	 num Arcs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
writeVInt	TokenNameIdentifier	 write V Int
(	TokenNameLPAREN	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println("node " + node + ": " + arc.numArcs + " arcs"); 	TokenNameCOMMENT_LINE	System.out.println("node " + node + ": " + arc.numArcs + " arcs"); 
}	TokenNameRBRACE	
int	TokenNameint	
maxBytesPerArc	TokenNameIdentifier	 max Bytes Per Arc
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
//int wasted = 0; 	TokenNameCOMMENT_LINE	int wasted = 0; 
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// iterate over all arcs for this node 	TokenNameCOMMENT_LINE	iterate over all arcs for this node 
//System.out.println(" arc label=" + arc.label + " target=" + arc.target + " pos=" + writer.posWrite); 	TokenNameCOMMENT_LINE	System.out.println(" arc label=" + arc.label + " target=" + arc.target + " pos=" + writer.posWrite); 
final	TokenNamefinal	
int	TokenNameint	
arcStartPos	TokenNameIdentifier	 arc Start Pos
=	TokenNameEQUAL	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
posWrite	TokenNameIdentifier	 pos Write
;	TokenNameSEMICOLON	
nodeArcCount	TokenNameIdentifier	 node Arc Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
flags	TokenNameIdentifier	 flags
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
isLast	TokenNameIdentifier	 is Last
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
flags	TokenNameIdentifier	 flags
+=	TokenNamePLUS_EQUAL	
BIT_LAST_ARC	TokenNameIdentifier	 BIT  LAST  ARC
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) { flags += BIT_TARGET_NEXT; } */	TokenNameCOMMENT_BLOCK	 if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) { flags += BIT_TARGET_NEXT; } 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
useArcArray	TokenNameIdentifier	 use Arc Array
&&	TokenNameAND_AND	
node	TokenNameIdentifier	 node
!=	TokenNameNOT_EQUAL	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
target	TokenNameIdentifier	 target
==	TokenNameEQUAL_EQUAL	
node	TokenNameIdentifier	 node
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
flags	TokenNameIdentifier	 flags
+=	TokenNamePLUS_EQUAL	
BIT_TARGET_NEXT	TokenNameIdentifier	 BIT  TARGET  NEXT
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
retry	TokenNameIdentifier	 retry
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nextCount	TokenNameIdentifier	 next Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
isFinal	TokenNameIdentifier	 is Final
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
flags	TokenNameIdentifier	 flags
+=	TokenNamePLUS_EQUAL	
BIT_FINAL_ARC	TokenNameIdentifier	 BIT  FINAL  ARC
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
nextFinalOutput	TokenNameIdentifier	 next Final Output
!=	TokenNameNOT_EQUAL	
NO_OUTPUT	TokenNameIdentifier	 NO  OUTPUT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
flags	TokenNameIdentifier	 flags
+=	TokenNamePLUS_EQUAL	
BIT_ARC_HAS_FINAL_OUTPUT	TokenNameIdentifier	 BIT  ARC  HAS  FINAL  OUTPUT
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
assert	TokenNameassert	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
nextFinalOutput	TokenNameIdentifier	 next Final Output
==	TokenNameEQUAL_EQUAL	
NO_OUTPUT	TokenNameIdentifier	 NO  OUTPUT
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
targetHasArcs	TokenNameIdentifier	 target Has Arcs
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
flags	TokenNameIdentifier	 flags
+=	TokenNamePLUS_EQUAL	
BIT_STOP_NODE	TokenNameIdentifier	 BIT  STOP  NODE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
output	TokenNameIdentifier	 output
!=	TokenNameNOT_EQUAL	
NO_OUTPUT	TokenNameIdentifier	 NO  OUTPUT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
flags	TokenNameIdentifier	 flags
+=	TokenNamePLUS_EQUAL	
BIT_ARC_HAS_OUTPUT	TokenNameIdentifier	 BIT  ARC  HAS  OUTPUT
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
Integer	TokenNameIdentifier	 Integer
ptr	TokenNameIdentifier	 ptr
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
absPtr	TokenNameIdentifier	 abs Ptr
;	TokenNameSEMICOLON	
final	TokenNamefinal	
boolean	TokenNameboolean	
doWriteTarget	TokenNameIdentifier	 do Write Target
=	TokenNameEQUAL	
targetHasArcs	TokenNameIdentifier	 target Has Arcs
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
flags	TokenNameIdentifier	 flags
&	TokenNameAND	
BIT_TARGET_NEXT	TokenNameIdentifier	 BIT  TARGET  NEXT
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
doWriteTarget	TokenNameIdentifier	 do Write Target
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ptr	TokenNameIdentifier	 ptr
=	TokenNameEQUAL	
topNodeMap	TokenNameIdentifier	 top Node Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
target	TokenNameIdentifier	 target
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ptr	TokenNameIdentifier	 ptr
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
absPtr	TokenNameIdentifier	 abs Ptr
=	TokenNameEQUAL	
ptr	TokenNameIdentifier	 ptr
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
absPtr	TokenNameIdentifier	 abs Ptr
=	TokenNameEQUAL	
topNodeMap	TokenNameIdentifier	 top Node Map
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
newNodeAddress	TokenNameIdentifier	 new Node Address
[	TokenNameLBRACKET	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
target	TokenNameIdentifier	 target
]	TokenNameRBRACKET	
+	TokenNamePLUS	
addressError	TokenNameIdentifier	 address Error
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
delta	TokenNameIdentifier	 delta
=	TokenNameEQUAL	
newNodeAddress	TokenNameIdentifier	 new Node Address
[	TokenNameLBRACKET	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
target	TokenNameIdentifier	 target
]	TokenNameRBRACKET	
+	TokenNamePLUS	
addressError	TokenNameIdentifier	 address Error
-	TokenNameMINUS	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
posWrite	TokenNameIdentifier	 pos Write
-	TokenNameMINUS	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
delta	TokenNameIdentifier	 delta
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println("neg: " + delta); 	TokenNameCOMMENT_LINE	System.out.println("neg: " + delta); 
anyNegDelta	TokenNameIdentifier	 any Neg Delta
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
delta	TokenNameIdentifier	 delta
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
delta	TokenNameIdentifier	 delta
<	TokenNameLESS	
absPtr	TokenNameIdentifier	 abs Ptr
)	TokenNameRPAREN	
{	TokenNameLBRACE	
flags	TokenNameIdentifier	 flags
|=	TokenNameOR_EQUAL	
BIT_TARGET_DELTA	TokenNameIdentifier	 BIT  TARGET  DELTA
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
ptr	TokenNameIdentifier	 ptr
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
absPtr	TokenNameIdentifier	 abs Ptr
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
flags	TokenNameIdentifier	 flags
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
writeLabel	TokenNameIdentifier	 write Label
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
label	TokenNameIdentifier	 label
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
output	TokenNameIdentifier	 output
!=	TokenNameNOT_EQUAL	
NO_OUTPUT	TokenNameIdentifier	 NO  OUTPUT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
writer	TokenNameIdentifier	 writer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
retry	TokenNameIdentifier	 retry
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
arcWithOutputCount	TokenNameIdentifier	 arc With Output Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
nextFinalOutput	TokenNameIdentifier	 next Final Output
!=	TokenNameNOT_EQUAL	
NO_OUTPUT	TokenNameIdentifier	 NO  OUTPUT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
nextFinalOutput	TokenNameIdentifier	 next Final Output
,	TokenNameCOMMA	
writer	TokenNameIdentifier	 writer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
doWriteTarget	TokenNameIdentifier	 do Write Target
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
delta	TokenNameIdentifier	 delta
=	TokenNameEQUAL	
newNodeAddress	TokenNameIdentifier	 new Node Address
[	TokenNameLBRACKET	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
target	TokenNameIdentifier	 target
]	TokenNameRBRACKET	
+	TokenNamePLUS	
addressError	TokenNameIdentifier	 address Error
-	TokenNameMINUS	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
posWrite	TokenNameIdentifier	 pos Write
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
delta	TokenNameIdentifier	 delta
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
anyNegDelta	TokenNameIdentifier	 any Neg Delta
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
//System.out.println("neg: " + delta); 	TokenNameCOMMENT_LINE	System.out.println("neg: " + delta); 
delta	TokenNameIdentifier	 delta
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
flag	TokenNameIdentifier	 flag
(	TokenNameLPAREN	
flags	TokenNameIdentifier	 flags
,	TokenNameCOMMA	
BIT_TARGET_DELTA	TokenNameIdentifier	 BIT  TARGET  DELTA
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println(" delta"); 	TokenNameCOMMENT_LINE	System.out.println(" delta"); 
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
writeVInt	TokenNameIdentifier	 write V Int
(	TokenNameLPAREN	
delta	TokenNameIdentifier	 delta
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
retry	TokenNameIdentifier	 retry
)	TokenNameRPAREN	
{	TokenNameLBRACE	
deltaCount	TokenNameIdentifier	 delta Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
/* if (ptr != null) { System.out.println(" deref"); } else { System.out.println(" abs"); } */	TokenNameCOMMENT_BLOCK	 if (ptr != null) { System.out.println(" deref"); } else { System.out.println(" abs"); } 
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
writeVInt	TokenNameIdentifier	 write V Int
(	TokenNameLPAREN	
absPtr	TokenNameIdentifier	 abs Ptr
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
retry	TokenNameIdentifier	 retry
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
absPtr	TokenNameIdentifier	 abs Ptr
>=	TokenNameGREATER_EQUAL	
topNodeMap	TokenNameIdentifier	 top Node Map
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
absCount	TokenNameIdentifier	 abs Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
topCount	TokenNameIdentifier	 top Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
useArcArray	TokenNameIdentifier	 use Arc Array
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
arcBytes	TokenNameIdentifier	 arc Bytes
=	TokenNameEQUAL	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
posWrite	TokenNameIdentifier	 pos Write
-	TokenNameMINUS	
arcStartPos	TokenNameIdentifier	 arc Start Pos
;	TokenNameSEMICOLON	
//System.out.println(" " + arcBytes + " bytes"); 	TokenNameCOMMENT_LINE	System.out.println(" " + arcBytes + " bytes"); 
maxBytesPerArc	TokenNameIdentifier	 max Bytes Per Arc
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
max	TokenNameIdentifier	 max
(	TokenNameLPAREN	
maxBytesPerArc	TokenNameIdentifier	 max Bytes Per Arc
,	TokenNameCOMMA	
arcBytes	TokenNameIdentifier	 arc Bytes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// NOTE: this may in fact go "backwards", if 	TokenNameCOMMENT_LINE	NOTE: this may in fact go "backwards", if 
// somehow (rarely, possibly never) we use 	TokenNameCOMMENT_LINE	somehow (rarely, possibly never) we use 
// more bytesPerArc in this rewrite than the 	TokenNameCOMMENT_LINE	more bytesPerArc in this rewrite than the 
// incoming FST did... but in this case we 	TokenNameCOMMENT_LINE	incoming FST did... but in this case we 
// will retry (below) so it's OK to ovewrite 	TokenNameCOMMENT_LINE	will retry (below) so it's OK to ovewrite 
// bytes: 	TokenNameCOMMENT_LINE	bytes: 
//wasted += bytesPerArc - arcBytes; 	TokenNameCOMMENT_LINE	wasted += bytesPerArc - arcBytes; 
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
setPosWrite	TokenNameIdentifier	 set Pos Write
(	TokenNameLPAREN	
arcStartPos	TokenNameIdentifier	 arc Start Pos
+	TokenNamePLUS	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
isLast	TokenNameIdentifier	 is Last
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
readNextRealArc	TokenNameIdentifier	 read Next Real Arc
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
useArcArray	TokenNameIdentifier	 use Arc Array
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
maxBytesPerArc	TokenNameIdentifier	 max Bytes Per Arc
==	TokenNameEQUAL_EQUAL	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
||	TokenNameOR_OR	
(	TokenNameLPAREN	
retry	TokenNameIdentifier	 retry
&&	TokenNameAND_AND	
maxBytesPerArc	TokenNameIdentifier	 max Bytes Per Arc
<=	TokenNameLESS_EQUAL	
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// converged 	TokenNameCOMMENT_LINE	converged 
//System.out.println(" bba=" + bytesPerArc + " wasted=" + wasted); 	TokenNameCOMMENT_LINE	System.out.println(" bba=" + bytesPerArc + " wasted=" + wasted); 
//totWasted += wasted; 	TokenNameCOMMENT_LINE	totWasted += wasted; 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//System.out.println(" retry this node maxBytesPerArc=" + maxBytesPerArc + " vs " + bytesPerArc); 	TokenNameCOMMENT_LINE	System.out.println(" retry this node maxBytesPerArc=" + maxBytesPerArc + " vs " + bytesPerArc); 
// Retry: 	TokenNameCOMMENT_LINE	Retry: 
bytesPerArc	TokenNameIdentifier	 bytes Per Arc
=	TokenNameEQUAL	
maxBytesPerArc	TokenNameIdentifier	 max Bytes Per Arc
;	TokenNameSEMICOLON	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
posWrite	TokenNameIdentifier	 pos Write
=	TokenNameEQUAL	
address	TokenNameIdentifier	 address
;	TokenNameSEMICOLON	
nodeArcCount	TokenNameIdentifier	 node Arc Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
retry	TokenNameIdentifier	 retry
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
anyNegDelta	TokenNameIdentifier	 any Neg Delta
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
negDelta	TokenNameIdentifier	 neg Delta
|=	TokenNameOR_EQUAL	
anyNegDelta	TokenNameIdentifier	 any Neg Delta
;	TokenNameSEMICOLON	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
arcCount	TokenNameIdentifier	 arc Count
+=	TokenNamePLUS_EQUAL	
nodeArcCount	TokenNameIdentifier	 node Arc Count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
changed	TokenNameIdentifier	 changed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// We don't renumber the nodes (just reverse their 	TokenNameCOMMENT_LINE	We don't renumber the nodes (just reverse their 
// order) so nodes should only point forward to 	TokenNameCOMMENT_LINE	order) so nodes should only point forward to 
// other nodes because we only produce acyclic FSTs 	TokenNameCOMMENT_LINE	other nodes because we only produce acyclic FSTs 
// w/ nodes only pointing "forwards": 	TokenNameCOMMENT_LINE	w/ nodes only pointing "forwards": 
assert	TokenNameassert	
!	TokenNameNOT	
negDelta	TokenNameIdentifier	 neg Delta
;	TokenNameSEMICOLON	
//System.out.println("TOT wasted=" + totWasted); 	TokenNameCOMMENT_LINE	System.out.println("TOT wasted=" + totWasted); 
// Converged! 	TokenNameCOMMENT_LINE	Converged! 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//System.out.println(" " + changedCount + " of " + fst.nodeCount + " changed; retry"); 	TokenNameCOMMENT_LINE	System.out.println(" " + changedCount + " of " + fst.nodeCount + " changed; retry"); 
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
ent	TokenNameIdentifier	 ent
:	TokenNameCOLON	
topNodeMap	TokenNameIdentifier	 top Node Map
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nodeRefToAddressIn	TokenNameIdentifier	 node Ref To Address In
[	TokenNameLBRACKET	
ent	TokenNameIdentifier	 ent
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
newNodeAddress	TokenNameIdentifier	 new Node Address
[	TokenNameLBRACKET	
ent	TokenNameIdentifier	 ent
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
startNode	TokenNameIdentifier	 start Node
=	TokenNameEQUAL	
newNodeAddress	TokenNameIdentifier	 new Node Address
[	TokenNameLBRACKET	
startNode	TokenNameIdentifier	 start Node
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
//System.out.println("new startNode=" + fst.startNode + " old startNode=" + startNode); 	TokenNameCOMMENT_LINE	System.out.println("new startNode=" + fst.startNode + " old startNode=" + startNode); 
if	TokenNameif	
(	TokenNameLPAREN	
emptyOutput	TokenNameIdentifier	 empty Output
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
setEmptyOutput	TokenNameIdentifier	 set Empty Output
(	TokenNameLPAREN	
emptyOutput	TokenNameIdentifier	 empty Output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
assert	TokenNameassert	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
nodeCount	TokenNameIdentifier	 node Count
==	TokenNameEQUAL_EQUAL	
nodeCount	TokenNameIdentifier	 node Count
:	TokenNameCOLON	
"fst.nodeCount="	TokenNameStringLiteral	fst.nodeCount=
+	TokenNamePLUS	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
nodeCount	TokenNameIdentifier	 node Count
+	TokenNamePLUS	
" nodeCount="	TokenNameStringLiteral	 nodeCount=
+	TokenNamePLUS	
nodeCount	TokenNameIdentifier	 node Count
;	TokenNameSEMICOLON	
assert	TokenNameassert	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
arcCount	TokenNameIdentifier	 arc Count
==	TokenNameEQUAL_EQUAL	
arcCount	TokenNameIdentifier	 arc Count
;	TokenNameSEMICOLON	
assert	TokenNameassert	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
arcWithOutputCount	TokenNameIdentifier	 arc With Output Count
==	TokenNameEQUAL_EQUAL	
arcWithOutputCount	TokenNameIdentifier	 arc With Output Count
:	TokenNameCOLON	
"fst.arcWithOutputCount="	TokenNameStringLiteral	fst.arcWithOutputCount=
+	TokenNamePLUS	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
arcWithOutputCount	TokenNameIdentifier	 arc With Output Count
+	TokenNamePLUS	
" arcWithOutputCount="	TokenNameStringLiteral	 arcWithOutputCount=
+	TokenNamePLUS	
arcWithOutputCount	TokenNameIdentifier	 arc With Output Count
;	TokenNameSEMICOLON	
final	TokenNamefinal	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
finalBytes	TokenNameIdentifier	 final Bytes
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
posWrite	TokenNameIdentifier	 pos Write
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
//System.out.println("resize " + fst.bytes.length + " down to " + writer.posWrite); 	TokenNameCOMMENT_LINE	System.out.println("resize " + fst.bytes.length + " down to " + writer.posWrite); 
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
bytes	TokenNameIdentifier	 bytes
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
finalBytes	TokenNameIdentifier	 final Bytes
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
posWrite	TokenNameIdentifier	 pos Write
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
bytes	TokenNameIdentifier	 bytes
=	TokenNameEQUAL	
finalBytes	TokenNameIdentifier	 final Bytes
;	TokenNameSEMICOLON	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
cacheRootArcs	TokenNameIdentifier	 cache Root Arcs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//final int size = fst.sizeInBytes(); 	TokenNameCOMMENT_LINE	final int size = fst.sizeInBytes(); 
//System.out.println("nextCount=" + nextCount + " topCount=" + topCount + " deltaCount=" + deltaCount + " absCount=" + absCount); 	TokenNameCOMMENT_LINE	System.out.println("nextCount=" + nextCount + " topCount=" + topCount + " deltaCount=" + deltaCount + " absCount=" + absCount); 
return	TokenNamereturn	
fst	TokenNameIdentifier	 fst
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
NodeAndInCount	TokenNameIdentifier	 Node And In Count
implements	TokenNameimplements	
Comparable	TokenNameIdentifier	 Comparable
<	TokenNameLESS	
NodeAndInCount	TokenNameIdentifier	 Node And In Count
>	TokenNameGREATER	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
node	TokenNameIdentifier	 node
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
public	TokenNamepublic	
NodeAndInCount	TokenNameIdentifier	 Node And In Count
(	TokenNameLPAREN	
int	TokenNameint	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
int	TokenNameint	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//@Override 	TokenNameCOMMENT_LINE	@Override 
public	TokenNamepublic	
int	TokenNameint	
compareTo	TokenNameIdentifier	 compare To
(	TokenNameLPAREN	
NodeAndInCount	TokenNameIdentifier	 Node And In Count
other	TokenNameIdentifier	 other
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
>	TokenNameGREATER	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
<	TokenNameLESS	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Tie-break: smaller node compares as greater than 	TokenNameCOMMENT_LINE	Tie-break: smaller node compares as greater than 
return	TokenNamereturn	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
node	TokenNameIdentifier	 node
-	TokenNameMINUS	
node	TokenNameIdentifier	 node
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
NodeQueue	TokenNameIdentifier	 Node Queue
extends	TokenNameextends	
PriorityQueue	TokenNameIdentifier	 Priority Queue
<	TokenNameLESS	
NodeAndInCount	TokenNameIdentifier	 Node And In Count
>	TokenNameGREATER	
{	TokenNameLBRACE	
public	TokenNamepublic	
NodeQueue	TokenNameIdentifier	 Node Queue
(	TokenNameLPAREN	
int	TokenNameint	
topN	TokenNameIdentifier	 top N
)	TokenNameRPAREN	
{	TokenNameLBRACE	
initialize	TokenNameIdentifier	 initialize
(	TokenNameLPAREN	
topN	TokenNameIdentifier	 top N
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
boolean	TokenNameboolean	
lessThan	TokenNameIdentifier	 less Than
(	TokenNameLPAREN	
NodeAndInCount	TokenNameIdentifier	 Node And In Count
a	TokenNameIdentifier	 a
,	TokenNameCOMMA	
NodeAndInCount	TokenNameIdentifier	 Node And In Count
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
cmp	TokenNameIdentifier	 cmp
=	TokenNameEQUAL	
a	TokenNameIdentifier	 a
.	TokenNameDOT	
compareTo	TokenNameIdentifier	 compare To
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
cmp	TokenNameIdentifier	 cmp
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
cmp	TokenNameIdentifier	 cmp
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
