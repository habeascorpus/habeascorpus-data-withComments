/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xinclude	TokenNameIdentifier	 xinclude
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
CharConversionException	TokenNameIdentifier	 Char Conversion Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Enumeration	TokenNameIdentifier	 Enumeration
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Locale	TokenNameIdentifier	 Locale
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Stack	TokenNameIdentifier	 Stack
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
StringTokenizer	TokenNameIdentifier	 String Tokenizer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
Constants	TokenNameIdentifier	 Constants
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
XMLEntityManager	TokenNameIdentifier	 XML Entity Manager
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
MalformedByteSequenceException	TokenNameIdentifier	 Malformed Byte Sequence Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
msg	TokenNameIdentifier	 msg
.	TokenNameDOT	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
AugmentationsImpl	TokenNameIdentifier	 Augmentations Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
HTTPInputSource	TokenNameIdentifier	 HTTP Input Source
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
IntStack	TokenNameIdentifier	 Int Stack
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ParserConfigurationSettings	TokenNameIdentifier	 Parser Configuration Settings
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
SecurityManager	TokenNameIdentifier	 Security Manager
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
SymbolTable	TokenNameIdentifier	 Symbol Table
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
URI	TokenNameIdentifier	 URI
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
XMLAttributesImpl	TokenNameIdentifier	 XML Attributes Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
XMLChar	TokenNameIdentifier	 XML Char
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
XMLLocatorWrapper	TokenNameIdentifier	 XML Locator Wrapper
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
XMLResourceIdentifierImpl	TokenNameIdentifier	 XML Resource Identifier Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
XMLSymbols	TokenNameIdentifier	 XML Symbols
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
URI	TokenNameIdentifier	 URI
.	TokenNameDOT	
MalformedURIException	TokenNameIdentifier	 Malformed URI Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
Augmentations	TokenNameIdentifier	 Augmentations
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
NamespaceContext	TokenNameIdentifier	 Namespace Context
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
QName	TokenNameIdentifier	 Q Name
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XMLAttributes	TokenNameIdentifier	 XML Attributes
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XMLDTDHandler	TokenNameIdentifier	 XMLDTD Handler
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XMLDocumentHandler	TokenNameIdentifier	 XML Document Handler
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XMLLocator	TokenNameIdentifier	 XML Locator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XMLResourceIdentifier	TokenNameIdentifier	 XML Resource Identifier
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XMLString	TokenNameIdentifier	 XML String
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XNIException	TokenNameIdentifier	 XNI Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLComponent	TokenNameIdentifier	 XML Component
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLComponentManager	TokenNameIdentifier	 XML Component Manager
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLDTDFilter	TokenNameIdentifier	 XMLDTD Filter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLDTDSource	TokenNameIdentifier	 XMLDTD Source
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLDocumentFilter	TokenNameIdentifier	 XML Document Filter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLDocumentSource	TokenNameIdentifier	 XML Document Source
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLEntityResolver	TokenNameIdentifier	 XML Entity Resolver
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLInputSource	TokenNameIdentifier	 XML Input Source
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLParserConfiguration	TokenNameIdentifier	 XML Parser Configuration
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xpointer	TokenNameIdentifier	 xpointer
.	TokenNameDOT	
XPointerHandler	TokenNameIdentifier	 X Pointer Handler
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xpointer	TokenNameIdentifier	 xpointer
.	TokenNameDOT	
XPointerProcessor	TokenNameIdentifier	 X Pointer Processor
;	TokenNameSEMICOLON	
/** * <p> * This is a pipeline component which performs XInclude handling, according to the * W3C specification for XML Inclusions. * </p> * <p> * This component analyzes each event in the pipeline, looking for &lt;include&gt; * elements. An &lt;include&gt; element is one which has a namespace of * <code>http://www.w3.org/2001/XInclude</code> and a localname of <code>include</code>. * When it finds an &lt;include&gt; element, it attempts to include the file specified * in the <code>href</code> attribute of the element. If inclusion succeeds, all * children of the &lt;include&gt; element are ignored (with the exception of * checking for invalid children as outlined in the specification). If the inclusion * fails, the &lt;fallback&gt; child of the &lt;include&gt; element is processed. * </p> * <p> * See the <a href="http://www.w3.org/TR/xinclude/">XInclude specification</a> for * more information on how XInclude is to be used. * </p> * <p> * This component requires the following features and properties from the * component manager that uses it: * <ul> * <li>http://xml.org/sax/features/allow-dtd-events-after-endDTD</li> * <li>http://apache.org/xml/properties/internal/error-reporter</li> * <li>http://apache.org/xml/properties/internal/entity-resolver</li> * </ul> * Optional property: * <ul> * <li>http://apache.org/xml/properties/input-buffer-size</li> * </ul> * * Furthermore, the <code>NamespaceContext</code> used in the pipeline is required * to be an instance of <code>XIncludeNamespaceSupport</code>. * </p> * <p> * Currently, this implementation has only partial support for the XInclude specification. * Specifically, it is missing support for XPointer document fragments. Thus, only whole * documents can be included using this component in the pipeline. * </p> * * @author Peter McCracken, IBM * @author Michael Glavassevich, IBM * * @version $Id: XIncludeHandler.java 778245 2009-05-24 22:27:32Z mrglavas $ * * @see XIncludeNamespaceSupport */	TokenNameCOMMENT_JAVADOC	 <p> This is a pipeline component which performs XInclude handling, according to the W3C specification for XML Inclusions. </p> <p> This component analyzes each event in the pipeline, looking for &lt;include&gt; elements. An &lt;include&gt; element is one which has a namespace of <code>http://www.w3.org/2001/XInclude</code> and a localname of <code>include</code>. When it finds an &lt;include&gt; element, it attempts to include the file specified in the <code>href</code> attribute of the element. If inclusion succeeds, all children of the &lt;include&gt; element are ignored (with the exception of checking for invalid children as outlined in the specification). If the inclusion fails, the &lt;fallback&gt; child of the &lt;include&gt; element is processed. </p> <p> See the <a href="http://www.w3.org/TR/xinclude/">XInclude specification</a> for more information on how XInclude is to be used. </p> <p> This component requires the following features and properties from the component manager that uses it: <ul> <li>http://xml.org/sax/features/allow-dtd-events-after-endDTD</li> <li>http://apache.org/xml/properties/internal/error-reporter</li> <li>http://apache.org/xml/properties/internal/entity-resolver</li> </ul> Optional property: <ul> <li>http://apache.org/xml/properties/input-buffer-size</li> </ul> * Furthermore, the <code>NamespaceContext</code> used in the pipeline is required to be an instance of <code>XIncludeNamespaceSupport</code>. </p> <p> Currently, this implementation has only partial support for the XInclude specification. Specifically, it is missing support for XPointer document fragments. Thus, only whole documents can be included using this component in the pipeline. </p> * @author Peter McCracken, IBM @author Michael Glavassevich, IBM * @version $Id: XIncludeHandler.java 778245 2009-05-24 22:27:32Z mrglavas $ * @see XIncludeNamespaceSupport 
public	TokenNamepublic	
class	TokenNameclass	
XIncludeHandler	TokenNameIdentifier	 X Include Handler
implements	TokenNameimplements	
XMLComponent	TokenNameIdentifier	 XML Component
,	TokenNameCOMMA	
XMLDocumentFilter	TokenNameIdentifier	 XML Document Filter
,	TokenNameCOMMA	
XMLDTDFilter	TokenNameIdentifier	 XMLDTD Filter
{	TokenNameLBRACE	
public	TokenNamepublic	
final	TokenNamefinal	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
XINCLUDE_DEFAULT_CONFIGURATION	TokenNameIdentifier	 XINCLUDE  DEFAULT  CONFIGURATION
=	TokenNameEQUAL	
"org.apache.xerces.parsers.XIncludeParserConfiguration"	TokenNameStringLiteral	org.apache.xerces.parsers.XIncludeParserConfiguration
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
HTTP_ACCEPT	TokenNameIdentifier	 HTTP  ACCEPT
=	TokenNameEQUAL	
"Accept"	TokenNameStringLiteral	Accept
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
HTTP_ACCEPT_LANGUAGE	TokenNameIdentifier	 HTTP  ACCEPT  LANGUAGE
=	TokenNameEQUAL	
"Accept-Language"	TokenNameStringLiteral	Accept-Language
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
XPOINTER	TokenNameIdentifier	 XPOINTER
=	TokenNameEQUAL	
"xpointer"	TokenNameStringLiteral	xpointer
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
XINCLUDE_NS_URI	TokenNameIdentifier	 XINCLUDE  NS  URI
=	TokenNameEQUAL	
"http://www.w3.org/2001/XInclude"	TokenNameStringLiteral	http://www.w3.org/2001/XInclude
.	TokenNameDOT	
intern	TokenNameIdentifier	 intern
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
XINCLUDE_INCLUDE	TokenNameIdentifier	 XINCLUDE  INCLUDE
=	TokenNameEQUAL	
"include"	TokenNameStringLiteral	include
.	TokenNameDOT	
intern	TokenNameIdentifier	 intern
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
XINCLUDE_FALLBACK	TokenNameIdentifier	 XINCLUDE  FALLBACK
=	TokenNameEQUAL	
"fallback"	TokenNameStringLiteral	fallback
.	TokenNameDOT	
intern	TokenNameIdentifier	 intern
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
XINCLUDE_PARSE_XML	TokenNameIdentifier	 XINCLUDE  PARSE  XML
=	TokenNameEQUAL	
"xml"	TokenNameStringLiteral	xml
.	TokenNameDOT	
intern	TokenNameIdentifier	 intern
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
XINCLUDE_PARSE_TEXT	TokenNameIdentifier	 XINCLUDE  PARSE  TEXT
=	TokenNameEQUAL	
"text"	TokenNameStringLiteral	text
.	TokenNameDOT	
intern	TokenNameIdentifier	 intern
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
XINCLUDE_ATTR_HREF	TokenNameIdentifier	 XINCLUDE  ATTR  HREF
=	TokenNameEQUAL	
"href"	TokenNameStringLiteral	href
.	TokenNameDOT	
intern	TokenNameIdentifier	 intern
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
XINCLUDE_ATTR_PARSE	TokenNameIdentifier	 XINCLUDE  ATTR  PARSE
=	TokenNameEQUAL	
"parse"	TokenNameStringLiteral	parse
.	TokenNameDOT	
intern	TokenNameIdentifier	 intern
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
XINCLUDE_ATTR_ENCODING	TokenNameIdentifier	 XINCLUDE  ATTR  ENCODING
=	TokenNameEQUAL	
"encoding"	TokenNameStringLiteral	encoding
.	TokenNameDOT	
intern	TokenNameIdentifier	 intern
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
XINCLUDE_ATTR_ACCEPT	TokenNameIdentifier	 XINCLUDE  ATTR  ACCEPT
=	TokenNameEQUAL	
"accept"	TokenNameStringLiteral	accept
.	TokenNameDOT	
intern	TokenNameIdentifier	 intern
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
XINCLUDE_ATTR_ACCEPT_LANGUAGE	TokenNameIdentifier	 XINCLUDE  ATTR  ACCEPT  LANGUAGE
=	TokenNameEQUAL	
"accept-language"	TokenNameStringLiteral	accept-language
.	TokenNameDOT	
intern	TokenNameIdentifier	 intern
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Top Level Information Items have [included] property in infoset 	TokenNameCOMMENT_LINE	Top Level Information Items have [included] property in infoset 
public	TokenNamepublic	
final	TokenNamefinal	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
XINCLUDE_INCLUDED	TokenNameIdentifier	 XINCLUDE  INCLUDED
=	TokenNameEQUAL	
"[included]"	TokenNameStringLiteral	[included]
.	TokenNameDOT	
intern	TokenNameIdentifier	 intern
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** The identifier for the Augmentation that contains the current base URI */	TokenNameCOMMENT_JAVADOC	 The identifier for the Augmentation that contains the current base URI 
public	TokenNamepublic	
final	TokenNamefinal	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
CURRENT_BASE_URI	TokenNameIdentifier	 CURRENT  BASE  URI
=	TokenNameEQUAL	
"currentBaseURI"	TokenNameStringLiteral	currentBaseURI
;	TokenNameSEMICOLON	
// used for adding [base URI] attributes 	TokenNameCOMMENT_LINE	used for adding [base URI] attributes 
private	TokenNameprivate	
final	TokenNamefinal	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
XINCLUDE_BASE	TokenNameIdentifier	 XINCLUDE  BASE
=	TokenNameEQUAL	
"base"	TokenNameStringLiteral	base
.	TokenNameDOT	
intern	TokenNameIdentifier	 intern
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
static	TokenNamestatic	
QName	TokenNameIdentifier	 Q Name
XML_BASE_QNAME	TokenNameIdentifier	 XML  BASE  QNAME
=	TokenNameEQUAL	
new	TokenNamenew	
QName	TokenNameIdentifier	 Q Name
(	TokenNameLPAREN	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
PREFIX_XML	TokenNameIdentifier	 PREFIX  XML
,	TokenNameCOMMA	
XINCLUDE_BASE	TokenNameIdentifier	 XINCLUDE  BASE
,	TokenNameCOMMA	
(	TokenNameLPAREN	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
PREFIX_XML	TokenNameIdentifier	 PREFIX  XML
+	TokenNamePLUS	
":"	TokenNameStringLiteral	:
+	TokenNamePLUS	
XINCLUDE_BASE	TokenNameIdentifier	 XINCLUDE  BASE
)	TokenNameRPAREN	
.	TokenNameDOT	
intern	TokenNameIdentifier	 intern
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
NamespaceContext	TokenNameIdentifier	 Namespace Context
.	TokenNameDOT	
XML_URI	TokenNameIdentifier	 XML  URI
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// used for adding [language] attributes 	TokenNameCOMMENT_LINE	used for adding [language] attributes 
private	TokenNameprivate	
final	TokenNamefinal	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
XINCLUDE_LANG	TokenNameIdentifier	 XINCLUDE  LANG
=	TokenNameEQUAL	
"lang"	TokenNameStringLiteral	lang
.	TokenNameDOT	
intern	TokenNameIdentifier	 intern
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
static	TokenNamestatic	
QName	TokenNameIdentifier	 Q Name
XML_LANG_QNAME	TokenNameIdentifier	 XML  LANG  QNAME
=	TokenNameEQUAL	
new	TokenNamenew	
QName	TokenNameIdentifier	 Q Name
(	TokenNameLPAREN	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
PREFIX_XML	TokenNameIdentifier	 PREFIX  XML
,	TokenNameCOMMA	
XINCLUDE_LANG	TokenNameIdentifier	 XINCLUDE  LANG
,	TokenNameCOMMA	
(	TokenNameLPAREN	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
PREFIX_XML	TokenNameIdentifier	 PREFIX  XML
+	TokenNamePLUS	
":"	TokenNameStringLiteral	:
+	TokenNamePLUS	
XINCLUDE_LANG	TokenNameIdentifier	 XINCLUDE  LANG
)	TokenNameRPAREN	
.	TokenNameDOT	
intern	TokenNameIdentifier	 intern
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
NamespaceContext	TokenNameIdentifier	 Namespace Context
.	TokenNameDOT	
XML_URI	TokenNameIdentifier	 XML  URI
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
static	TokenNamestatic	
QName	TokenNameIdentifier	 Q Name
NEW_NS_ATTR_QNAME	TokenNameIdentifier	 NEW  NS  ATTR  QNAME
=	TokenNameEQUAL	
new	TokenNamenew	
QName	TokenNameIdentifier	 Q Name
(	TokenNameLPAREN	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
PREFIX_XMLNS	TokenNameIdentifier	 PREFIX  XMLNS
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
,	TokenNameCOMMA	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
PREFIX_XMLNS	TokenNameIdentifier	 PREFIX  XMLNS
+	TokenNamePLUS	
":"	TokenNameStringLiteral	:
,	TokenNameCOMMA	
NamespaceContext	TokenNameIdentifier	 Namespace Context
.	TokenNameDOT	
XMLNS_URI	TokenNameIdentifier	 XMLNS  URI
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Processing States 	TokenNameCOMMENT_LINE	Processing States 
private	TokenNameprivate	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
STATE_NORMAL_PROCESSING	TokenNameIdentifier	 STATE  NORMAL  PROCESSING
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// we go into this state after a successful include (thus we ignore the children 	TokenNameCOMMENT_LINE	we go into this state after a successful include (thus we ignore the children 
// of the include) or after a fallback 	TokenNameCOMMENT_LINE	of the include) or after a fallback 
private	TokenNameprivate	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
STATE_IGNORE	TokenNameIdentifier	 STATE  IGNORE
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// we go into this state after a failed include. If we don't encounter a fallback 	TokenNameCOMMENT_LINE	we go into this state after a failed include. If we don't encounter a fallback 
// before we reach the end include tag, it's a fatal error 	TokenNameCOMMENT_LINE	before we reach the end include tag, it's a fatal error 
private	TokenNameprivate	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
STATE_EXPECT_FALLBACK	TokenNameIdentifier	 STATE  EXPECT  FALLBACK
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// recognized features and properties 	TokenNameCOMMENT_LINE	recognized features and properties 
/** Feature identifier: validation. */	TokenNameCOMMENT_JAVADOC	 Feature identifier: validation. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
VALIDATION	TokenNameIdentifier	 VALIDATION
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SAX_FEATURE_PREFIX	TokenNameIdentifier	 SAX  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
VALIDATION_FEATURE	TokenNameIdentifier	 VALIDATION  FEATURE
;	TokenNameSEMICOLON	
/** Feature identifier: schema validation. */	TokenNameCOMMENT_JAVADOC	 Feature identifier: schema validation. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
SCHEMA_VALIDATION	TokenNameIdentifier	 SCHEMA  VALIDATION
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SCHEMA_VALIDATION_FEATURE	TokenNameIdentifier	 SCHEMA  VALIDATION  FEATURE
;	TokenNameSEMICOLON	
/** Feature identifier: dynamic validation. */	TokenNameCOMMENT_JAVADOC	 Feature identifier: dynamic validation. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
DYNAMIC_VALIDATION	TokenNameIdentifier	 DYNAMIC  VALIDATION
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
DYNAMIC_VALIDATION_FEATURE	TokenNameIdentifier	 DYNAMIC  VALIDATION  FEATURE
;	TokenNameSEMICOLON	
/** Feature identifier: allow notation and unparsed entity events to be sent out of order. */	TokenNameCOMMENT_JAVADOC	 Feature identifier: allow notation and unparsed entity events to be sent out of order. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
ALLOW_UE_AND_NOTATION_EVENTS	TokenNameIdentifier	 ALLOW  UE  AND  NOTATION  EVENTS
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SAX_FEATURE_PREFIX	TokenNameIdentifier	 SAX  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ALLOW_DTD_EVENTS_AFTER_ENDDTD_FEATURE	TokenNameIdentifier	 ALLOW  DTD  EVENTS  AFTER  ENDDTD  FEATURE
;	TokenNameSEMICOLON	
/** Feature identifier: fixup base URIs. */	TokenNameCOMMENT_JAVADOC	 Feature identifier: fixup base URIs. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
XINCLUDE_FIXUP_BASE_URIS	TokenNameIdentifier	 XINCLUDE  FIXUP  BASE  URIS
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XINCLUDE_FIXUP_BASE_URIS_FEATURE	TokenNameIdentifier	 XINCLUDE  FIXUP  BASE  URIS  FEATURE
;	TokenNameSEMICOLON	
/** Feature identifier: fixup language. */	TokenNameCOMMENT_JAVADOC	 Feature identifier: fixup language. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
XINCLUDE_FIXUP_LANGUAGE	TokenNameIdentifier	 XINCLUDE  FIXUP  LANGUAGE
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XINCLUDE_FIXUP_LANGUAGE_FEATURE	TokenNameIdentifier	 XINCLUDE  FIXUP  LANGUAGE  FEATURE
;	TokenNameSEMICOLON	
/** Property identifier: JAXP schema language. */	TokenNameCOMMENT_JAVADOC	 Property identifier: JAXP schema language. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
JAXP_SCHEMA_LANGUAGE	TokenNameIdentifier	 JAXP  SCHEMA  LANGUAGE
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
JAXP_PROPERTY_PREFIX	TokenNameIdentifier	 JAXP  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SCHEMA_LANGUAGE	TokenNameIdentifier	 SCHEMA  LANGUAGE
;	TokenNameSEMICOLON	
/** Property identifier: symbol table. */	TokenNameCOMMENT_JAVADOC	 Property identifier: symbol table. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
SYMBOL_TABLE	TokenNameIdentifier	 SYMBOL  TABLE
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SYMBOL_TABLE_PROPERTY	TokenNameIdentifier	 SYMBOL  TABLE  PROPERTY
;	TokenNameSEMICOLON	
/** Property identifier: error reporter. */	TokenNameCOMMENT_JAVADOC	 Property identifier: error reporter. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
ERROR_REPORTER	TokenNameIdentifier	 ERROR  REPORTER
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ERROR_REPORTER_PROPERTY	TokenNameIdentifier	 ERROR  REPORTER  PROPERTY
;	TokenNameSEMICOLON	
/** Property identifier: entity resolver. */	TokenNameCOMMENT_JAVADOC	 Property identifier: entity resolver. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
ENTITY_RESOLVER	TokenNameIdentifier	 ENTITY  RESOLVER
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ENTITY_RESOLVER_PROPERTY	TokenNameIdentifier	 ENTITY  RESOLVER  PROPERTY
;	TokenNameSEMICOLON	
/** property identifier: security manager. */	TokenNameCOMMENT_JAVADOC	 property identifier: security manager. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
SECURITY_MANAGER	TokenNameIdentifier	 SECURITY  MANAGER
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SECURITY_MANAGER_PROPERTY	TokenNameIdentifier	 SECURITY  MANAGER  PROPERTY
;	TokenNameSEMICOLON	
/** property identifier: buffer size. */	TokenNameCOMMENT_JAVADOC	 property identifier: buffer size. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
BUFFER_SIZE	TokenNameIdentifier	 BUFFER  SIZE
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
BUFFER_SIZE_PROPERTY	TokenNameIdentifier	 BUFFER  SIZE  PROPERTY
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
PARSER_SETTINGS	TokenNameIdentifier	 PARSER  SETTINGS
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
PARSER_SETTINGS	TokenNameIdentifier	 PARSER  SETTINGS
;	TokenNameSEMICOLON	
/** Recognized features. */	TokenNameCOMMENT_JAVADOC	 Recognized features. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
RECOGNIZED_FEATURES	TokenNameIdentifier	 RECOGNIZED  FEATURES
=	TokenNameEQUAL	
{	TokenNameLBRACE	
ALLOW_UE_AND_NOTATION_EVENTS	TokenNameIdentifier	 ALLOW  UE  AND  NOTATION  EVENTS
,	TokenNameCOMMA	
XINCLUDE_FIXUP_BASE_URIS	TokenNameIdentifier	 XINCLUDE  FIXUP  BASE  URIS
,	TokenNameCOMMA	
XINCLUDE_FIXUP_LANGUAGE	TokenNameIdentifier	 XINCLUDE  FIXUP  LANGUAGE
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** Feature defaults. */	TokenNameCOMMENT_JAVADOC	 Feature defaults. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Boolean	TokenNameIdentifier	 Boolean
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
FEATURE_DEFAULTS	TokenNameIdentifier	 FEATURE  DEFAULTS
=	TokenNameEQUAL	
{	TokenNameLBRACE	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
TRUE	TokenNameIdentifier	 TRUE
,	TokenNameCOMMA	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
TRUE	TokenNameIdentifier	 TRUE
,	TokenNameCOMMA	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
TRUE	TokenNameIdentifier	 TRUE
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** Recognized properties. */	TokenNameCOMMENT_JAVADOC	 Recognized properties. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
RECOGNIZED_PROPERTIES	TokenNameIdentifier	 RECOGNIZED  PROPERTIES
=	TokenNameEQUAL	
{	TokenNameLBRACE	
ERROR_REPORTER	TokenNameIdentifier	 ERROR  REPORTER
,	TokenNameCOMMA	
ENTITY_RESOLVER	TokenNameIdentifier	 ENTITY  RESOLVER
,	TokenNameCOMMA	
SECURITY_MANAGER	TokenNameIdentifier	 SECURITY  MANAGER
,	TokenNameCOMMA	
BUFFER_SIZE	TokenNameIdentifier	 BUFFER  SIZE
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** Property defaults. */	TokenNameCOMMENT_JAVADOC	 Property defaults. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
PROPERTY_DEFAULTS	TokenNameIdentifier	 PROPERTY  DEFAULTS
=	TokenNameEQUAL	
{	TokenNameLBRACE	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
new	TokenNamenew	
Integer	TokenNameIdentifier	 Integer
(	TokenNameLPAREN	
XMLEntityManager	TokenNameIdentifier	 XML Entity Manager
.	TokenNameDOT	
DEFAULT_BUFFER_SIZE	TokenNameIdentifier	 DEFAULT  BUFFER  SIZE
)	TokenNameRPAREN	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
// instance variables 	TokenNameCOMMENT_LINE	instance variables 
// for XMLDocumentFilter 	TokenNameCOMMENT_LINE	for XMLDocumentFilter 
protected	TokenNameprotected	
XMLDocumentHandler	TokenNameIdentifier	 XML Document Handler
fDocumentHandler	TokenNameIdentifier	 f Document Handler
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
XMLDocumentSource	TokenNameIdentifier	 XML Document Source
fDocumentSource	TokenNameIdentifier	 f Document Source
;	TokenNameSEMICOLON	
// for XMLDTDFilter 	TokenNameCOMMENT_LINE	for XMLDTDFilter 
protected	TokenNameprotected	
XMLDTDHandler	TokenNameIdentifier	 XMLDTD Handler
fDTDHandler	TokenNameIdentifier	 f DTD Handler
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
XMLDTDSource	TokenNameIdentifier	 XMLDTD Source
fDTDSource	TokenNameIdentifier	 f DTD Source
;	TokenNameSEMICOLON	
// for XIncludeHandler 	TokenNameCOMMENT_LINE	for XIncludeHandler 
protected	TokenNameprotected	
XIncludeHandler	TokenNameIdentifier	 X Include Handler
fParentXIncludeHandler	TokenNameIdentifier	 f Parent X Include Handler
;	TokenNameSEMICOLON	
// for buffer size in XIncludeTextReader 	TokenNameCOMMENT_LINE	for buffer size in XIncludeTextReader 
protected	TokenNameprotected	
int	TokenNameint	
fBufferSize	TokenNameIdentifier	 f Buffer Size
=	TokenNameEQUAL	
XMLEntityManager	TokenNameIdentifier	 XML Entity Manager
.	TokenNameDOT	
DEFAULT_BUFFER_SIZE	TokenNameIdentifier	 DEFAULT  BUFFER  SIZE
;	TokenNameSEMICOLON	
// It "feels wrong" to store this value here. However, 	TokenNameCOMMENT_LINE	It "feels wrong" to store this value here. However, 
// calculating it can be time consuming, so we cache it. 	TokenNameCOMMENT_LINE	calculating it can be time consuming, so we cache it. 
// It's never going to change in the lifetime of this XIncludeHandler 	TokenNameCOMMENT_LINE	It's never going to change in the lifetime of this XIncludeHandler 
protected	TokenNameprotected	
String	TokenNameIdentifier	 String
fParentRelativeURI	TokenNameIdentifier	 f Parent Relative URI
;	TokenNameSEMICOLON	
// we cache the child parser configuration, so we don't have to re-create 	TokenNameCOMMENT_LINE	we cache the child parser configuration, so we don't have to re-create 
// the objects when the parser is re-used 	TokenNameCOMMENT_LINE	the objects when the parser is re-used 
protected	TokenNameprotected	
XMLParserConfiguration	TokenNameIdentifier	 XML Parser Configuration
fChildConfig	TokenNameIdentifier	 f Child Config
;	TokenNameSEMICOLON	
// The cached child parser configuration, may contain a 	TokenNameCOMMENT_LINE	The cached child parser configuration, may contain a 
// XInclude or XPointer Handler. Cache both these 	TokenNameCOMMENT_LINE	XInclude or XPointer Handler. Cache both these 
protected	TokenNameprotected	
XMLParserConfiguration	TokenNameIdentifier	 XML Parser Configuration
fXIncludeChildConfig	TokenNameIdentifier	 f X Include Child Config
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
XMLParserConfiguration	TokenNameIdentifier	 XML Parser Configuration
fXPointerChildConfig	TokenNameIdentifier	 f X Pointer Child Config
;	TokenNameSEMICOLON	
// The XPointerProcessor 	TokenNameCOMMENT_LINE	The XPointerProcessor 
protected	TokenNameprotected	
XPointerProcessor	TokenNameIdentifier	 X Pointer Processor
fXPtrProcessor	TokenNameIdentifier	 f X Ptr Processor
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
XMLLocator	TokenNameIdentifier	 XML Locator
fDocLocation	TokenNameIdentifier	 f Doc Location
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
XMLLocatorWrapper	TokenNameIdentifier	 XML Locator Wrapper
fXIncludeLocator	TokenNameIdentifier	 f X Include Locator
=	TokenNameEQUAL	
new	TokenNamenew	
XMLLocatorWrapper	TokenNameIdentifier	 XML Locator Wrapper
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
XIncludeMessageFormatter	TokenNameIdentifier	 X Include Message Formatter
fXIncludeMessageFormatter	TokenNameIdentifier	 f X Include Message Formatter
=	TokenNameEQUAL	
new	TokenNamenew	
XIncludeMessageFormatter	TokenNameIdentifier	 X Include Message Formatter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
XIncludeNamespaceSupport	TokenNameIdentifier	 X Include Namespace Support
fNamespaceContext	TokenNameIdentifier	 f Namespace Context
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
SymbolTable	TokenNameIdentifier	 Symbol Table
fSymbolTable	TokenNameIdentifier	 f Symbol Table
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
fErrorReporter	TokenNameIdentifier	 f Error Reporter
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
XMLEntityResolver	TokenNameIdentifier	 XML Entity Resolver
fEntityResolver	TokenNameIdentifier	 f Entity Resolver
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
SecurityManager	TokenNameIdentifier	 Security Manager
fSecurityManager	TokenNameIdentifier	 f Security Manager
;	TokenNameSEMICOLON	
// these are needed for text include processing 	TokenNameCOMMENT_LINE	these are needed for text include processing 
protected	TokenNameprotected	
XIncludeTextReader	TokenNameIdentifier	 X Include Text Reader
fXInclude10TextReader	TokenNameIdentifier	 f X Include10 Text Reader
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
XIncludeTextReader	TokenNameIdentifier	 X Include Text Reader
fXInclude11TextReader	TokenNameIdentifier	 f X Include11 Text Reader
;	TokenNameSEMICOLON	
// these are needed for XML Base processing 	TokenNameCOMMENT_LINE	these are needed for XML Base processing 
protected	TokenNameprotected	
final	TokenNamefinal	
XMLResourceIdentifier	TokenNameIdentifier	 XML Resource Identifier
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
final	TokenNamefinal	
IntStack	TokenNameIdentifier	 Int Stack
fBaseURIScope	TokenNameIdentifier	 f Base URI Scope
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
final	TokenNamefinal	
Stack	TokenNameIdentifier	 Stack
fBaseURI	TokenNameIdentifier	 f Base URI
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
final	TokenNamefinal	
Stack	TokenNameIdentifier	 Stack
fLiteralSystemID	TokenNameIdentifier	 f Literal System ID
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
final	TokenNamefinal	
Stack	TokenNameIdentifier	 Stack
fExpandedSystemID	TokenNameIdentifier	 f Expanded System ID
;	TokenNameSEMICOLON	
// these are needed for Language Fixup 	TokenNameCOMMENT_LINE	these are needed for Language Fixup 
protected	TokenNameprotected	
final	TokenNamefinal	
IntStack	TokenNameIdentifier	 Int Stack
fLanguageScope	TokenNameIdentifier	 f Language Scope
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
final	TokenNamefinal	
Stack	TokenNameIdentifier	 Stack
fLanguageStack	TokenNameIdentifier	 f Language Stack
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
String	TokenNameIdentifier	 String
fCurrentLanguage	TokenNameIdentifier	 f Current Language
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
String	TokenNameIdentifier	 String
fHrefFromParent	TokenNameIdentifier	 f Href From Parent
;	TokenNameSEMICOLON	
// used for passing features on to child XIncludeHandler objects 	TokenNameCOMMENT_LINE	used for passing features on to child XIncludeHandler objects 
protected	TokenNameprotected	
ParserConfigurationSettings	TokenNameIdentifier	 Parser Configuration Settings
fSettings	TokenNameIdentifier	 f Settings
;	TokenNameSEMICOLON	
// The current element depth. We start at depth 0 (before we've reached any elements). 	TokenNameCOMMENT_LINE	The current element depth. We start at depth 0 (before we've reached any elements). 
// The first element is at depth 1. 	TokenNameCOMMENT_LINE	The first element is at depth 1. 
private	TokenNameprivate	
int	TokenNameint	
fDepth	TokenNameIdentifier	 f Depth
;	TokenNameSEMICOLON	
// The current element depth of the result infoset. 	TokenNameCOMMENT_LINE	The current element depth of the result infoset. 
private	TokenNameprivate	
int	TokenNameint	
fResultDepth	TokenNameIdentifier	 f Result Depth
;	TokenNameSEMICOLON	
// this value must be at least 1 	TokenNameCOMMENT_LINE	this value must be at least 1 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
INITIAL_SIZE	TokenNameIdentifier	 INITIAL  SIZE
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Used to ensure that fallbacks are always children of include elements, 	TokenNameCOMMENT_LINE	Used to ensure that fallbacks are always children of include elements, 
// and that include elements are never children of other include elements. 	TokenNameCOMMENT_LINE	and that include elements are never children of other include elements. 
// An index contains true if the ancestor of the current element which resides 	TokenNameCOMMENT_LINE	An index contains true if the ancestor of the current element which resides 
// at that depth was an include element. 	TokenNameCOMMENT_LINE	at that depth was an include element. 
private	TokenNameprivate	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fSawInclude	TokenNameIdentifier	 f Saw Include
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
INITIAL_SIZE	TokenNameIdentifier	 INITIAL  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// Ensures that only one fallback element can be at a single depth. 	TokenNameCOMMENT_LINE	Ensures that only one fallback element can be at a single depth. 
// An index contains true if we have seen any fallback elements at that depth, 	TokenNameCOMMENT_LINE	An index contains true if we have seen any fallback elements at that depth, 
// and it is only reset to false when the end tag of the parent is encountered. 	TokenNameCOMMENT_LINE	and it is only reset to false when the end tag of the parent is encountered. 
private	TokenNameprivate	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fSawFallback	TokenNameIdentifier	 f Saw Fallback
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
INITIAL_SIZE	TokenNameIdentifier	 INITIAL  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// The state of the processor at each given depth. 	TokenNameCOMMENT_LINE	The state of the processor at each given depth. 
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fState	TokenNameIdentifier	 f State
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
INITIAL_SIZE	TokenNameIdentifier	 INITIAL  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// buffering the necessary DTD events 	TokenNameCOMMENT_LINE	buffering the necessary DTD events 
private	TokenNameprivate	
final	TokenNamefinal	
ArrayList	TokenNameIdentifier	 Array List
fNotations	TokenNameIdentifier	 f Notations
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
ArrayList	TokenNameIdentifier	 Array List
fUnparsedEntities	TokenNameIdentifier	 f Unparsed Entities
;	TokenNameSEMICOLON	
// flags which control whether base URI or language fixup is performed. 	TokenNameCOMMENT_LINE	flags which control whether base URI or language fixup is performed. 
private	TokenNameprivate	
boolean	TokenNameboolean	
fFixupBaseURIs	TokenNameIdentifier	 f Fixup Base UR Is
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
fFixupLanguage	TokenNameIdentifier	 f Fixup Language
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// for SAX compatibility. 	TokenNameCOMMENT_LINE	for SAX compatibility. 
// Has the value of the ALLOW_UE_AND_NOTATION_EVENTS feature 	TokenNameCOMMENT_LINE	Has the value of the ALLOW_UE_AND_NOTATION_EVENTS feature 
private	TokenNameprivate	
boolean	TokenNameboolean	
fSendUEAndNotationEvents	TokenNameIdentifier	 f Send UE And Notation Events
;	TokenNameSEMICOLON	
// track the version of the document being parsed 	TokenNameCOMMENT_LINE	track the version of the document being parsed 
private	TokenNameprivate	
boolean	TokenNameboolean	
fIsXML11	TokenNameIdentifier	 f Is XM L11
;	TokenNameSEMICOLON	
// track whether a DTD is being parsed 	TokenNameCOMMENT_LINE	track whether a DTD is being parsed 
private	TokenNameprivate	
boolean	TokenNameboolean	
fInDTD	TokenNameIdentifier	 f In DTD
;	TokenNameSEMICOLON	
// tracks whether content has been reported on the child pipeline 	TokenNameCOMMENT_LINE	tracks whether content has been reported on the child pipeline 
boolean	TokenNameboolean	
fHasIncludeReportedContent	TokenNameIdentifier	 f Has Include Reported Content
;	TokenNameSEMICOLON	
// track whether the root element of the result infoset has been processed 	TokenNameCOMMENT_LINE	track whether the root element of the result infoset has been processed 
private	TokenNameprivate	
boolean	TokenNameboolean	
fSeenRootElement	TokenNameIdentifier	 f Seen Root Element
;	TokenNameSEMICOLON	
// track whether the child config needs its features refreshed 	TokenNameCOMMENT_LINE	track whether the child config needs its features refreshed 
private	TokenNameprivate	
boolean	TokenNameboolean	
fNeedCopyFeatures	TokenNameIdentifier	 f Need Copy Features
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// Constructors 	TokenNameCOMMENT_LINE	Constructors 
public	TokenNamepublic	
XIncludeHandler	TokenNameIdentifier	 X Include Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDepth	TokenNameIdentifier	 f Depth
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fSawFallback	TokenNameIdentifier	 f Saw Fallback
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fSawInclude	TokenNameIdentifier	 f Saw Include
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fState	TokenNameIdentifier	 f State
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
STATE_NORMAL_PROCESSING	TokenNameIdentifier	 STATE  NORMAL  PROCESSING
;	TokenNameSEMICOLON	
fNotations	TokenNameIdentifier	 f Notations
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fUnparsedEntities	TokenNameIdentifier	 f Unparsed Entities
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fBaseURIScope	TokenNameIdentifier	 f Base URI Scope
=	TokenNameEQUAL	
new	TokenNamenew	
IntStack	TokenNameIdentifier	 Int Stack
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fBaseURI	TokenNameIdentifier	 f Base URI
=	TokenNameEQUAL	
new	TokenNamenew	
Stack	TokenNameIdentifier	 Stack
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fLiteralSystemID	TokenNameIdentifier	 f Literal System ID
=	TokenNameEQUAL	
new	TokenNamenew	
Stack	TokenNameIdentifier	 Stack
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fExpandedSystemID	TokenNameIdentifier	 f Expanded System ID
=	TokenNameEQUAL	
new	TokenNamenew	
Stack	TokenNameIdentifier	 Stack
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
=	TokenNameEQUAL	
new	TokenNamenew	
XMLResourceIdentifierImpl	TokenNameIdentifier	 XML Resource Identifier Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fLanguageScope	TokenNameIdentifier	 f Language Scope
=	TokenNameEQUAL	
new	TokenNamenew	
IntStack	TokenNameIdentifier	 Int Stack
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fLanguageStack	TokenNameIdentifier	 f Language Stack
=	TokenNameEQUAL	
new	TokenNamenew	
Stack	TokenNameIdentifier	 Stack
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fCurrentLanguage	TokenNameIdentifier	 f Current Language
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// XMLComponent methods 	TokenNameCOMMENT_LINE	XMLComponent methods 
public	TokenNamepublic	
void	TokenNamevoid	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
XMLComponentManager	TokenNameIdentifier	 XML Component Manager
componentManager	TokenNameIdentifier	 component Manager
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
fNamespaceContext	TokenNameIdentifier	 f Namespace Context
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fDepth	TokenNameIdentifier	 f Depth
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fResultDepth	TokenNameIdentifier	 f Result Depth
=	TokenNameEQUAL	
isRootDocument	TokenNameIdentifier	 is Root Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
fParentXIncludeHandler	TokenNameIdentifier	 f Parent X Include Handler
.	TokenNameDOT	
getResultDepth	TokenNameIdentifier	 get Result Depth
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fNotations	TokenNameIdentifier	 f Notations
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fUnparsedEntities	TokenNameIdentifier	 f Unparsed Entities
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fParentRelativeURI	TokenNameIdentifier	 f Parent Relative URI
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fIsXML11	TokenNameIdentifier	 f Is XM L11
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fInDTD	TokenNameIdentifier	 f In DTD
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fSeenRootElement	TokenNameIdentifier	 f Seen Root Element
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fBaseURIScope	TokenNameIdentifier	 f Base URI Scope
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fBaseURI	TokenNameIdentifier	 f Base URI
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fLiteralSystemID	TokenNameIdentifier	 f Literal System ID
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fExpandedSystemID	TokenNameIdentifier	 f Expanded System ID
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fLanguageScope	TokenNameIdentifier	 f Language Scope
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fLanguageStack	TokenNameIdentifier	 f Language Stack
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// REVISIT: Find a better method for maintaining 	TokenNameCOMMENT_LINE	REVISIT: Find a better method for maintaining 
// the state of the XInclude processor. These arrays 	TokenNameCOMMENT_LINE	the state of the XInclude processor. These arrays 
// can potentially grow quite large. Cleaning them 	TokenNameCOMMENT_LINE	can potentially grow quite large. Cleaning them 
// out on reset may be very time consuming. -- mrglavas 	TokenNameCOMMENT_LINE	out on reset may be very time consuming. -- mrglavas 
// 	TokenNameCOMMENT_LINE	 
// clear the previous settings from the arrays 	TokenNameCOMMENT_LINE	clear the previous settings from the arrays 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fState	TokenNameIdentifier	 f State
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fState	TokenNameIdentifier	 f State
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
STATE_NORMAL_PROCESSING	TokenNameIdentifier	 STATE  NORMAL  PROCESSING
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fSawFallback	TokenNameIdentifier	 f Saw Fallback
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSawFallback	TokenNameIdentifier	 f Saw Fallback
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fSawInclude	TokenNameIdentifier	 f Saw Include
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSawInclude	TokenNameIdentifier	 f Saw Include
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
PARSER_SETTINGS	TokenNameIdentifier	 PARSER  SETTINGS
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if parser settings have not changed return. 	TokenNameCOMMENT_LINE	if parser settings have not changed return. 
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
// parser settings changed. Need to refresh features on child config. 	TokenNameCOMMENT_LINE	parser settings changed. Need to refresh features on child config. 
fNeedCopyFeatures	TokenNameIdentifier	 f Need Copy Features
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
fSendUEAndNotationEvents	TokenNameIdentifier	 f Send UE And Notation Events
=	TokenNameEQUAL	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
ALLOW_UE_AND_NOTATION_EVENTS	TokenNameIdentifier	 ALLOW  UE  AND  NOTATION  EVENTS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fChildConfig	TokenNameIdentifier	 f Child Config
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fChildConfig	TokenNameIdentifier	 f Child Config
.	TokenNameDOT	
setFeature	TokenNameIdentifier	 set Feature
(	TokenNameLPAREN	
ALLOW_UE_AND_NOTATION_EVENTS	TokenNameIdentifier	 ALLOW  UE  AND  NOTATION  EVENTS
,	TokenNameCOMMA	
fSendUEAndNotationEvents	TokenNameIdentifier	 f Send UE And Notation Events
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fFixupBaseURIs	TokenNameIdentifier	 f Fixup Base UR Is
=	TokenNameEQUAL	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
XINCLUDE_FIXUP_BASE_URIS	TokenNameIdentifier	 XINCLUDE  FIXUP  BASE  URIS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fChildConfig	TokenNameIdentifier	 f Child Config
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fChildConfig	TokenNameIdentifier	 f Child Config
.	TokenNameDOT	
setFeature	TokenNameIdentifier	 set Feature
(	TokenNameLPAREN	
XINCLUDE_FIXUP_BASE_URIS	TokenNameIdentifier	 XINCLUDE  FIXUP  BASE  URIS
,	TokenNameCOMMA	
fFixupBaseURIs	TokenNameIdentifier	 f Fixup Base UR Is
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fFixupBaseURIs	TokenNameIdentifier	 f Fixup Base UR Is
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fFixupLanguage	TokenNameIdentifier	 f Fixup Language
=	TokenNameEQUAL	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
XINCLUDE_FIXUP_LANGUAGE	TokenNameIdentifier	 XINCLUDE  FIXUP  LANGUAGE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fChildConfig	TokenNameIdentifier	 f Child Config
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fChildConfig	TokenNameIdentifier	 f Child Config
.	TokenNameDOT	
setFeature	TokenNameIdentifier	 set Feature
(	TokenNameLPAREN	
XINCLUDE_FIXUP_LANGUAGE	TokenNameIdentifier	 XINCLUDE  FIXUP  LANGUAGE
,	TokenNameCOMMA	
fFixupLanguage	TokenNameIdentifier	 f Fixup Language
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fFixupLanguage	TokenNameIdentifier	 f Fixup Language
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Get symbol table. 	TokenNameCOMMENT_LINE	Get symbol table. 
try	TokenNametry	
{	TokenNameLBRACE	
SymbolTable	TokenNameIdentifier	 Symbol Table
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
(	TokenNameLPAREN	
SymbolTable	TokenNameIdentifier	 Symbol Table
)	TokenNameRPAREN	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
SYMBOL_TABLE	TokenNameIdentifier	 SYMBOL  TABLE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
=	TokenNameEQUAL	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fChildConfig	TokenNameIdentifier	 f Child Config
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fChildConfig	TokenNameIdentifier	 f Child Config
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
SYMBOL_TABLE	TokenNameIdentifier	 SYMBOL  TABLE
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Get error reporter. 	TokenNameCOMMENT_LINE	Get error reporter. 
try	TokenNametry	
{	TokenNameLBRACE	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
)	TokenNameRPAREN	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
ERROR_REPORTER	TokenNameIdentifier	 ERROR  REPORTER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
setErrorReporter	TokenNameIdentifier	 set Error Reporter
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fChildConfig	TokenNameIdentifier	 f Child Config
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fChildConfig	TokenNameIdentifier	 f Child Config
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
ERROR_REPORTER	TokenNameIdentifier	 ERROR  REPORTER
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Get entity resolver. 	TokenNameCOMMENT_LINE	Get entity resolver. 
try	TokenNametry	
{	TokenNameLBRACE	
XMLEntityResolver	TokenNameIdentifier	 XML Entity Resolver
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XMLEntityResolver	TokenNameIdentifier	 XML Entity Resolver
)	TokenNameRPAREN	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
ENTITY_RESOLVER	TokenNameIdentifier	 ENTITY  RESOLVER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fEntityResolver	TokenNameIdentifier	 f Entity Resolver
=	TokenNameEQUAL	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fChildConfig	TokenNameIdentifier	 f Child Config
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fChildConfig	TokenNameIdentifier	 f Child Config
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
ENTITY_RESOLVER	TokenNameIdentifier	 ENTITY  RESOLVER
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fEntityResolver	TokenNameIdentifier	 f Entity Resolver
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Get security manager. 	TokenNameCOMMENT_LINE	Get security manager. 
try	TokenNametry	
{	TokenNameLBRACE	
SecurityManager	TokenNameIdentifier	 Security Manager
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
(	TokenNameLPAREN	
SecurityManager	TokenNameIdentifier	 Security Manager
)	TokenNameRPAREN	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
SECURITY_MANAGER	TokenNameIdentifier	 SECURITY  MANAGER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSecurityManager	TokenNameIdentifier	 f Security Manager
=	TokenNameEQUAL	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fChildConfig	TokenNameIdentifier	 f Child Config
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fChildConfig	TokenNameIdentifier	 f Child Config
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
SECURITY_MANAGER	TokenNameIdentifier	 SECURITY  MANAGER
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSecurityManager	TokenNameIdentifier	 f Security Manager
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Get buffer size. 	TokenNameCOMMENT_LINE	Get buffer size. 
try	TokenNametry	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Integer	TokenNameIdentifier	 Integer
)	TokenNameRPAREN	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
BUFFER_SIZE	TokenNameIdentifier	 BUFFER  SIZE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
intValue	TokenNameIdentifier	 int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fBufferSize	TokenNameIdentifier	 f Buffer Size
=	TokenNameEQUAL	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
intValue	TokenNameIdentifier	 int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fChildConfig	TokenNameIdentifier	 f Child Config
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fChildConfig	TokenNameIdentifier	 f Child Config
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
BUFFER_SIZE	TokenNameIdentifier	 BUFFER  SIZE
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fBufferSize	TokenNameIdentifier	 f Buffer Size
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Integer	TokenNameIdentifier	 Integer
)	TokenNameRPAREN	
getPropertyDefault	TokenNameIdentifier	 get Property Default
(	TokenNameLPAREN	
BUFFER_SIZE	TokenNameIdentifier	 BUFFER  SIZE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
intValue	TokenNameIdentifier	 int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fBufferSize	TokenNameIdentifier	 f Buffer Size
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Integer	TokenNameIdentifier	 Integer
)	TokenNameRPAREN	
getPropertyDefault	TokenNameIdentifier	 get Property Default
(	TokenNameLPAREN	
BUFFER_SIZE	TokenNameIdentifier	 BUFFER  SIZE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
intValue	TokenNameIdentifier	 int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Reset XML 1.0 text reader. 	TokenNameCOMMENT_LINE	Reset XML 1.0 text reader. 
if	TokenNameif	
(	TokenNameLPAREN	
fXInclude10TextReader	TokenNameIdentifier	 f X Include10 Text Reader
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fXInclude10TextReader	TokenNameIdentifier	 f X Include10 Text Reader
.	TokenNameDOT	
setBufferSize	TokenNameIdentifier	 set Buffer Size
(	TokenNameLPAREN	
fBufferSize	TokenNameIdentifier	 f Buffer Size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Reset XML 1.1 text reader. 	TokenNameCOMMENT_LINE	Reset XML 1.1 text reader. 
if	TokenNameif	
(	TokenNameLPAREN	
fXInclude11TextReader	TokenNameIdentifier	 f X Include11 Text Reader
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fXInclude11TextReader	TokenNameIdentifier	 f X Include11 Text Reader
.	TokenNameDOT	
setBufferSize	TokenNameIdentifier	 set Buffer Size
(	TokenNameLPAREN	
fBufferSize	TokenNameIdentifier	 f Buffer Size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fSettings	TokenNameIdentifier	 f Settings
=	TokenNameEQUAL	
new	TokenNamenew	
ParserConfigurationSettings	TokenNameIdentifier	 Parser Configuration Settings
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
copyFeatures	TokenNameIdentifier	 copy Features
(	TokenNameLPAREN	
componentManager	TokenNameIdentifier	 component Manager
,	TokenNameCOMMA	
fSettings	TokenNameIdentifier	 f Settings
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// We don't want a schema validator on the new pipeline, 	TokenNameCOMMENT_LINE	We don't want a schema validator on the new pipeline, 
// so if it was enabled, we set the feature to false. 	TokenNameCOMMENT_LINE	so if it was enabled, we set the feature to false. 
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
SCHEMA_VALIDATION	TokenNameIdentifier	 SCHEMA  VALIDATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSettings	TokenNameIdentifier	 f Settings
.	TokenNameDOT	
setFeature	TokenNameIdentifier	 set Feature
(	TokenNameLPAREN	
SCHEMA_VALIDATION	TokenNameIdentifier	 SCHEMA  VALIDATION
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// If the value of the JAXP 1.2 schema language property 	TokenNameCOMMENT_LINE	If the value of the JAXP 1.2 schema language property 
// is http://www.w3.org/2001/XMLSchema we're only validating 	TokenNameCOMMENT_LINE	is http://www.w3.org/2001/XMLSchema we're only validating 
// against XML schema so we disable validation on the new pipeline. 	TokenNameCOMMENT_LINE	against XML schema so we disable validation on the new pipeline. 
if	TokenNameif	
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
NS_XMLSCHEMA	TokenNameIdentifier	 NS  XMLSCHEMA
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
JAXP_SCHEMA_LANGUAGE	TokenNameIdentifier	 JAXP  SCHEMA  LANGUAGE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSettings	TokenNameIdentifier	 f Settings
.	TokenNameDOT	
setFeature	TokenNameIdentifier	 set Feature
(	TokenNameLPAREN	
VALIDATION	TokenNameIdentifier	 VALIDATION
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// If the validation feature was also enabled we turn on 	TokenNameCOMMENT_LINE	If the validation feature was also enabled we turn on 
// dynamic validation, so that DTD validation is performed 	TokenNameCOMMENT_LINE	dynamic validation, so that DTD validation is performed 
// on the included documents only if they have a DOCTYPE. 	TokenNameCOMMENT_LINE	on the included documents only if they have a DOCTYPE. 
// This is consistent with the behaviour on the main pipeline. 	TokenNameCOMMENT_LINE	This is consistent with the behaviour on the main pipeline. 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
VALIDATION	TokenNameIdentifier	 VALIDATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSettings	TokenNameIdentifier	 f Settings
.	TokenNameDOT	
setFeature	TokenNameIdentifier	 set Feature
(	TokenNameLPAREN	
DYNAMIC_VALIDATION	TokenNameIdentifier	 DYNAMIC  VALIDATION
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
// Don't reset fChildConfig -- we don't want it to share the same components. 	TokenNameCOMMENT_LINE	Don't reset fChildConfig -- we don't want it to share the same components. 
// It will be reset when it is actually used to parse something. 	TokenNameCOMMENT_LINE	It will be reset when it is actually used to parse something. 
}	TokenNameRBRACE	
// reset(XMLComponentManager) 	TokenNameCOMMENT_LINE	reset(XMLComponentManager) 
/** * Returns a list of feature identifiers that are recognized by * this component. This method may return null if no features * are recognized by this component. */	TokenNameCOMMENT_JAVADOC	 Returns a list of feature identifiers that are recognized by this component. This method may return null if no features are recognized by this component. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getRecognizedFeatures	TokenNameIdentifier	 get Recognized Features
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
RECOGNIZED_FEATURES	TokenNameIdentifier	 RECOGNIZED  FEATURES
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getRecognizedFeatures():String[] 	TokenNameCOMMENT_LINE	getRecognizedFeatures():String[] 
/** * Sets the state of a feature. This method is called by the component * manager any time after reset when a feature changes state. * <p> * <strong>Note:</strong> Components should silently ignore features * that do not affect the operation of the component. * * @param featureId The feature identifier. * @param state The state of the feature. * * @throws SAXNotRecognizedException The component should not throw * this exception. * @throws SAXNotSupportedException The component should not throw * this exception. */	TokenNameCOMMENT_JAVADOC	 Sets the state of a feature. This method is called by the component manager any time after reset when a feature changes state. <p> <strong>Note:</strong> Components should silently ignore features that do not affect the operation of the component. * @param featureId The feature identifier. @param state The state of the feature. * @throws SAXNotRecognizedException The component should not throw this exception. @throws SAXNotSupportedException The component should not throw this exception. 
public	TokenNamepublic	
void	TokenNamevoid	
setFeature	TokenNameIdentifier	 set Feature
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
featureId	TokenNameIdentifier	 feature Id
,	TokenNameCOMMA	
boolean	TokenNameboolean	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
throws	TokenNamethrows	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
featureId	TokenNameIdentifier	 feature Id
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
ALLOW_UE_AND_NOTATION_EVENTS	TokenNameIdentifier	 ALLOW  UE  AND  NOTATION  EVENTS
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSendUEAndNotationEvents	TokenNameIdentifier	 f Send UE And Notation Events
=	TokenNameEQUAL	
state	TokenNameIdentifier	 state
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fSettings	TokenNameIdentifier	 f Settings
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fNeedCopyFeatures	TokenNameIdentifier	 f Need Copy Features
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
fSettings	TokenNameIdentifier	 f Settings
.	TokenNameDOT	
setFeature	TokenNameIdentifier	 set Feature
(	TokenNameLPAREN	
featureId	TokenNameIdentifier	 feature Id
,	TokenNameCOMMA	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// setFeature(String,boolean) 	TokenNameCOMMENT_LINE	setFeature(String,boolean) 
/** * Returns a list of property identifiers that are recognized by * this component. This method may return null if no properties * are recognized by this component. */	TokenNameCOMMENT_JAVADOC	 Returns a list of property identifiers that are recognized by this component. This method may return null if no properties are recognized by this component. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getRecognizedProperties	TokenNameIdentifier	 get Recognized Properties
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
RECOGNIZED_PROPERTIES	TokenNameIdentifier	 RECOGNIZED  PROPERTIES
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getRecognizedProperties():String[] 	TokenNameCOMMENT_LINE	getRecognizedProperties():String[] 
/** * Sets the value of a property. This method is called by the component * manager any time after reset when a property changes value. * <p> * <strong>Note:</strong> Components should silently ignore properties * that do not affect the operation of the component. * * @param propertyId The property identifier. * @param value The value of the property. * * @throws SAXNotRecognizedException The component should not throw * this exception. * @throws SAXNotSupportedException The component should not throw * this exception. */	TokenNameCOMMENT_JAVADOC	 Sets the value of a property. This method is called by the component manager any time after reset when a property changes value. <p> <strong>Note:</strong> Components should silently ignore properties that do not affect the operation of the component. * @param propertyId The property identifier. @param value The value of the property. * @throws SAXNotRecognizedException The component should not throw this exception. @throws SAXNotSupportedException The component should not throw this exception. 
public	TokenNamepublic	
void	TokenNamevoid	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
propertyId	TokenNameIdentifier	 property Id
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
throws	TokenNamethrows	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
propertyId	TokenNameIdentifier	 property Id
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SYMBOL_TABLE	TokenNameIdentifier	 SYMBOL  TABLE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
=	TokenNameEQUAL	
(	TokenNameLPAREN	
SymbolTable	TokenNameIdentifier	 Symbol Table
)	TokenNameRPAREN	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fChildConfig	TokenNameIdentifier	 f Child Config
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fChildConfig	TokenNameIdentifier	 f Child Config
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
propertyId	TokenNameIdentifier	 property Id
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
propertyId	TokenNameIdentifier	 property Id
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
ERROR_REPORTER	TokenNameIdentifier	 ERROR  REPORTER
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
setErrorReporter	TokenNameIdentifier	 set Error Reporter
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
)	TokenNameRPAREN	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fChildConfig	TokenNameIdentifier	 f Child Config
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fChildConfig	TokenNameIdentifier	 f Child Config
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
propertyId	TokenNameIdentifier	 property Id
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
propertyId	TokenNameIdentifier	 property Id
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
ENTITY_RESOLVER	TokenNameIdentifier	 ENTITY  RESOLVER
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fEntityResolver	TokenNameIdentifier	 f Entity Resolver
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XMLEntityResolver	TokenNameIdentifier	 XML Entity Resolver
)	TokenNameRPAREN	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fChildConfig	TokenNameIdentifier	 f Child Config
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fChildConfig	TokenNameIdentifier	 f Child Config
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
propertyId	TokenNameIdentifier	 property Id
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
propertyId	TokenNameIdentifier	 property Id
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SECURITY_MANAGER	TokenNameIdentifier	 SECURITY  MANAGER
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSecurityManager	TokenNameIdentifier	 f Security Manager
=	TokenNameEQUAL	
(	TokenNameLPAREN	
SecurityManager	TokenNameIdentifier	 Security Manager
)	TokenNameRPAREN	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fChildConfig	TokenNameIdentifier	 f Child Config
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fChildConfig	TokenNameIdentifier	 f Child Config
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
propertyId	TokenNameIdentifier	 property Id
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
propertyId	TokenNameIdentifier	 property Id
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
BUFFER_SIZE	TokenNameIdentifier	 BUFFER  SIZE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
bufferSize	TokenNameIdentifier	 buffer Size
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Integer	TokenNameIdentifier	 Integer
)	TokenNameRPAREN	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fChildConfig	TokenNameIdentifier	 f Child Config
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fChildConfig	TokenNameIdentifier	 f Child Config
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
propertyId	TokenNameIdentifier	 property Id
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
bufferSize	TokenNameIdentifier	 buffer Size
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
bufferSize	TokenNameIdentifier	 buffer Size
.	TokenNameDOT	
intValue	TokenNameIdentifier	 int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fBufferSize	TokenNameIdentifier	 f Buffer Size
=	TokenNameEQUAL	
bufferSize	TokenNameIdentifier	 buffer Size
.	TokenNameDOT	
intValue	TokenNameIdentifier	 int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Reset XML 1.0 text reader. 	TokenNameCOMMENT_LINE	Reset XML 1.0 text reader. 
if	TokenNameif	
(	TokenNameLPAREN	
fXInclude10TextReader	TokenNameIdentifier	 f X Include10 Text Reader
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fXInclude10TextReader	TokenNameIdentifier	 f X Include10 Text Reader
.	TokenNameDOT	
setBufferSize	TokenNameIdentifier	 set Buffer Size
(	TokenNameLPAREN	
fBufferSize	TokenNameIdentifier	 f Buffer Size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Reset XML 1.1 text reader. 	TokenNameCOMMENT_LINE	Reset XML 1.1 text reader. 
if	TokenNameif	
(	TokenNameLPAREN	
fXInclude11TextReader	TokenNameIdentifier	 f X Include11 Text Reader
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fXInclude11TextReader	TokenNameIdentifier	 f X Include11 Text Reader
.	TokenNameDOT	
setBufferSize	TokenNameIdentifier	 set Buffer Size
(	TokenNameLPAREN	
fBufferSize	TokenNameIdentifier	 f Buffer Size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// setProperty(String,Object) 	TokenNameCOMMENT_LINE	setProperty(String,Object) 
/** * Returns the default state for a feature, or null if this * component does not want to report a default value for this * feature. * * @param featureId The feature identifier. * * @since Xerces 2.2.0 */	TokenNameCOMMENT_JAVADOC	 Returns the default state for a feature, or null if this component does not want to report a default value for this feature. * @param featureId The feature identifier. * @since Xerces 2.2.0 
public	TokenNamepublic	
Boolean	TokenNameIdentifier	 Boolean
getFeatureDefault	TokenNameIdentifier	 get Feature Default
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
featureId	TokenNameIdentifier	 feature Id
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
RECOGNIZED_FEATURES	TokenNameIdentifier	 RECOGNIZED  FEATURES
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
RECOGNIZED_FEATURES	TokenNameIdentifier	 RECOGNIZED  FEATURES
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
featureId	TokenNameIdentifier	 feature Id
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
FEATURE_DEFAULTS	TokenNameIdentifier	 FEATURE  DEFAULTS
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getFeatureDefault(String):Boolean 	TokenNameCOMMENT_LINE	getFeatureDefault(String):Boolean 
/** * Returns the default state for a property, or null if this * component does not want to report a default value for this * property. * * @param propertyId The property identifier. * * @since Xerces 2.2.0 */	TokenNameCOMMENT_JAVADOC	 Returns the default state for a property, or null if this component does not want to report a default value for this property. * @param propertyId The property identifier. * @since Xerces 2.2.0 
public	TokenNamepublic	
Object	TokenNameIdentifier	 Object
getPropertyDefault	TokenNameIdentifier	 get Property Default
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
propertyId	TokenNameIdentifier	 property Id
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
RECOGNIZED_PROPERTIES	TokenNameIdentifier	 RECOGNIZED  PROPERTIES
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
RECOGNIZED_PROPERTIES	TokenNameIdentifier	 RECOGNIZED  PROPERTIES
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
propertyId	TokenNameIdentifier	 property Id
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
PROPERTY_DEFAULTS	TokenNameIdentifier	 PROPERTY  DEFAULTS
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getPropertyDefault(String):Object 	TokenNameCOMMENT_LINE	getPropertyDefault(String):Object 
public	TokenNamepublic	
void	TokenNamevoid	
setDocumentHandler	TokenNameIdentifier	 set Document Handler
(	TokenNameLPAREN	
XMLDocumentHandler	TokenNameIdentifier	 XML Document Handler
handler	TokenNameIdentifier	 handler
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
handler	TokenNameIdentifier	 handler
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
=	TokenNameEQUAL	
handler	TokenNameIdentifier	 handler
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fXIncludeChildConfig	TokenNameIdentifier	 f X Include Child Config
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fXIncludeChildConfig	TokenNameIdentifier	 f X Include Child Config
.	TokenNameDOT	
setDocumentHandler	TokenNameIdentifier	 set Document Handler
(	TokenNameLPAREN	
handler	TokenNameIdentifier	 handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fXPointerChildConfig	TokenNameIdentifier	 f X Pointer Child Config
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fXPointerChildConfig	TokenNameIdentifier	 f X Pointer Child Config
.	TokenNameDOT	
setDocumentHandler	TokenNameIdentifier	 set Document Handler
(	TokenNameLPAREN	
handler	TokenNameIdentifier	 handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
XMLDocumentHandler	TokenNameIdentifier	 XML Document Handler
getDocumentHandler	TokenNameIdentifier	 get Document Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// XMLDocumentHandler methods 	TokenNameCOMMENT_LINE	XMLDocumentHandler methods 
/** * Event sent at the start of the document. * * A fatal error will occur here, if it is detected that this document has been processed * before. * * This event is only passed on to the document handler if this is the root document. */	TokenNameCOMMENT_JAVADOC	 Event sent at the start of the document. * A fatal error will occur here, if it is detected that this document has been processed before. * This event is only passed on to the document handler if this is the root document. 
public	TokenNamepublic	
void	TokenNamevoid	
startDocument	TokenNameIdentifier	 start Document
(	TokenNameLPAREN	
XMLLocator	TokenNameIdentifier	 XML Locator
locator	TokenNameIdentifier	 locator
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
NamespaceContext	TokenNameIdentifier	 Namespace Context
namespaceContext	TokenNameIdentifier	 namespace Context
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
// we do this to ensure that the proper location is reported in errors 	TokenNameCOMMENT_LINE	we do this to ensure that the proper location is reported in errors 
// otherwise, the locator from the root document would always be used 	TokenNameCOMMENT_LINE	otherwise, the locator from the root document would always be used 
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
setDocumentLocator	TokenNameIdentifier	 set Document Locator
(	TokenNameLPAREN	
locator	TokenNameIdentifier	 locator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
namespaceContext	TokenNameIdentifier	 namespace Context
instanceof	TokenNameinstanceof	
XIncludeNamespaceSupport	TokenNameIdentifier	 X Include Namespace Support
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"IncompatibleNamespaceContext"	TokenNameStringLiteral	IncompatibleNamespaceContext
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fNamespaceContext	TokenNameIdentifier	 f Namespace Context
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XIncludeNamespaceSupport	TokenNameIdentifier	 X Include Namespace Support
)	TokenNameRPAREN	
namespaceContext	TokenNameIdentifier	 namespace Context
;	TokenNameSEMICOLON	
fDocLocation	TokenNameIdentifier	 f Doc Location
=	TokenNameEQUAL	
locator	TokenNameIdentifier	 locator
;	TokenNameSEMICOLON	
fXIncludeLocator	TokenNameIdentifier	 f X Include Locator
.	TokenNameDOT	
setLocator	TokenNameIdentifier	 set Locator
(	TokenNameLPAREN	
fDocLocation	TokenNameIdentifier	 f Doc Location
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// initialize the current base URI 	TokenNameCOMMENT_LINE	initialize the current base URI 
setupCurrentBaseURI	TokenNameIdentifier	 setup Current Base URI
(	TokenNameLPAREN	
locator	TokenNameIdentifier	 locator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
saveBaseURI	TokenNameIdentifier	 save Base URI
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
augs	TokenNameIdentifier	 augs
=	TokenNameEQUAL	
new	TokenNamenew	
AugmentationsImpl	TokenNameIdentifier	 Augmentations Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
augs	TokenNameIdentifier	 augs
.	TokenNameDOT	
putItem	TokenNameIdentifier	 put Item
(	TokenNameLPAREN	
CURRENT_BASE_URI	TokenNameIdentifier	 CURRENT  BASE  URI
,	TokenNameCOMMA	
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// abort here if we detect a recursive include 	TokenNameCOMMENT_LINE	abort here if we detect a recursive include 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isRootDocument	TokenNameIdentifier	 is Root Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fParentXIncludeHandler	TokenNameIdentifier	 f Parent X Include Handler
.	TokenNameDOT	
fHasIncludeReportedContent	TokenNameIdentifier	 f Has Include Reported Content
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fParentXIncludeHandler	TokenNameIdentifier	 f Parent X Include Handler
.	TokenNameDOT	
searchForRecursiveIncludes	TokenNameIdentifier	 search For Recursive Includes
(	TokenNameLPAREN	
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
.	TokenNameDOT	
getExpandedSystemId	TokenNameIdentifier	 get Expanded System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"RecursiveInclude"	TokenNameStringLiteral	RecursiveInclude
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
.	TokenNameDOT	
getExpandedSystemId	TokenNameIdentifier	 get Expanded System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// initialize the current language 	TokenNameCOMMENT_LINE	initialize the current language 
fCurrentLanguage	TokenNameIdentifier	 f Current Language
=	TokenNameEQUAL	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
EMPTY_STRING	TokenNameIdentifier	 EMPTY  STRING
;	TokenNameSEMICOLON	
saveLanguage	TokenNameIdentifier	 save Language
(	TokenNameLPAREN	
fCurrentLanguage	TokenNameIdentifier	 f Current Language
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isRootDocument	TokenNameIdentifier	 is Root Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
startDocument	TokenNameIdentifier	 start Document
(	TokenNameLPAREN	
fXIncludeLocator	TokenNameIdentifier	 f X Include Locator
,	TokenNameCOMMA	
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
namespaceContext	TokenNameIdentifier	 namespace Context
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
xmlDecl	TokenNameIdentifier	 xml Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
version	TokenNameIdentifier	 version
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
standalone	TokenNameIdentifier	 standalone
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
fIsXML11	TokenNameIdentifier	 f Is XM L11
=	TokenNameEQUAL	
"1.1"	TokenNameStringLiteral	1.1
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
version	TokenNameIdentifier	 version
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isRootDocument	TokenNameIdentifier	 is Root Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
xmlDecl	TokenNameIdentifier	 xml Decl
(	TokenNameLPAREN	
version	TokenNameIdentifier	 version
,	TokenNameCOMMA	
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
standalone	TokenNameIdentifier	 standalone
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
doctypeDecl	TokenNameIdentifier	 doctype Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
rootElement	TokenNameIdentifier	 root Element
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
publicId	TokenNameIdentifier	 public Id
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
systemId	TokenNameIdentifier	 system Id
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isRootDocument	TokenNameIdentifier	 is Root Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
doctypeDecl	TokenNameIdentifier	 doctype Decl
(	TokenNameLPAREN	
rootElement	TokenNameIdentifier	 root Element
,	TokenNameCOMMA	
publicId	TokenNameIdentifier	 public Id
,	TokenNameCOMMA	
systemId	TokenNameIdentifier	 system Id
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
comment	TokenNameIdentifier	 comment
(	TokenNameLPAREN	
XMLString	TokenNameIdentifier	 XML String
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fInDTD	TokenNameIdentifier	 f In DTD
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
getState	TokenNameIdentifier	 get State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
STATE_NORMAL_PROCESSING	TokenNameIdentifier	 STATE  NORMAL  PROCESSING
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDepth	TokenNameIdentifier	 f Depth
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
augs	TokenNameIdentifier	 augs
=	TokenNameEQUAL	
modifyAugmentations	TokenNameIdentifier	 modify Augmentations
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
comment	TokenNameIdentifier	 comment
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fDepth	TokenNameIdentifier	 f Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
comment	TokenNameIdentifier	 comment
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
processingInstruction	TokenNameIdentifier	 processing Instruction
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
target	TokenNameIdentifier	 target
,	TokenNameCOMMA	
XMLString	TokenNameIdentifier	 XML String
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fInDTD	TokenNameIdentifier	 f In DTD
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
getState	TokenNameIdentifier	 get State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
STATE_NORMAL_PROCESSING	TokenNameIdentifier	 STATE  NORMAL  PROCESSING
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// we need to change the depth like this so that modifyAugmentations() works 	TokenNameCOMMENT_LINE	we need to change the depth like this so that modifyAugmentations() works 
fDepth	TokenNameIdentifier	 f Depth
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
augs	TokenNameIdentifier	 augs
=	TokenNameEQUAL	
modifyAugmentations	TokenNameIdentifier	 modify Augmentations
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
processingInstruction	TokenNameIdentifier	 processing Instruction
(	TokenNameLPAREN	
target	TokenNameIdentifier	 target
,	TokenNameCOMMA	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fDepth	TokenNameIdentifier	 f Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
processingInstruction	TokenNameIdentifier	 processing Instruction
(	TokenNameLPAREN	
target	TokenNameIdentifier	 target
,	TokenNameCOMMA	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
startElement	TokenNameIdentifier	 start Element
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
XMLAttributes	TokenNameIdentifier	 XML Attributes
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
fDepth	TokenNameIdentifier	 f Depth
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
int	TokenNameint	
lastState	TokenNameIdentifier	 last State
=	TokenNameEQUAL	
getState	TokenNameIdentifier	 get State
(	TokenNameLPAREN	
fDepth	TokenNameIdentifier	 f Depth
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// If the last two states were fallback then this must be a descendant of an include 	TokenNameCOMMENT_LINE	If the last two states were fallback then this must be a descendant of an include 
// child which isn't a fallback. The specification says we should ignore such elements 	TokenNameCOMMENT_LINE	child which isn't a fallback. The specification says we should ignore such elements 
// and their children. 	TokenNameCOMMENT_LINE	and their children. 
if	TokenNameif	
(	TokenNameLPAREN	
lastState	TokenNameIdentifier	 last State
==	TokenNameEQUAL_EQUAL	
STATE_EXPECT_FALLBACK	TokenNameIdentifier	 STATE  EXPECT  FALLBACK
&&	TokenNameAND_AND	
getState	TokenNameIdentifier	 get State
(	TokenNameLPAREN	
fDepth	TokenNameIdentifier	 f Depth
-	TokenNameMINUS	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
STATE_EXPECT_FALLBACK	TokenNameIdentifier	 STATE  EXPECT  FALLBACK
)	TokenNameRPAREN	
{	TokenNameLBRACE	
setState	TokenNameIdentifier	 set State
(	TokenNameLPAREN	
STATE_IGNORE	TokenNameIdentifier	 STATE  IGNORE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
setState	TokenNameIdentifier	 set State
(	TokenNameLPAREN	
lastState	TokenNameIdentifier	 last State
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// we process the xml:base and xml:lang attributes regardless 	TokenNameCOMMENT_LINE	we process the xml:base and xml:lang attributes regardless 
// of what type of element it is. 	TokenNameCOMMENT_LINE	of what type of element it is. 
processXMLBaseAttributes	TokenNameIdentifier	 process XML Base Attributes
(	TokenNameLPAREN	
attributes	TokenNameIdentifier	 attributes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fFixupLanguage	TokenNameIdentifier	 f Fixup Language
)	TokenNameRPAREN	
{	TokenNameLBRACE	
processXMLLangAttributes	TokenNameIdentifier	 process XML Lang Attributes
(	TokenNameLPAREN	
attributes	TokenNameIdentifier	 attributes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isIncludeElement	TokenNameIdentifier	 is Include Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
this	TokenNamethis	
.	TokenNameDOT	
handleIncludeElement	TokenNameIdentifier	 handle Include Element
(	TokenNameLPAREN	
attributes	TokenNameIdentifier	 attributes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
success	TokenNameIdentifier	 success
)	TokenNameRPAREN	
{	TokenNameLBRACE	
setState	TokenNameIdentifier	 set State
(	TokenNameLPAREN	
STATE_IGNORE	TokenNameIdentifier	 STATE  IGNORE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
setState	TokenNameIdentifier	 set State
(	TokenNameLPAREN	
STATE_EXPECT_FALLBACK	TokenNameIdentifier	 STATE  EXPECT  FALLBACK
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
isFallbackElement	TokenNameIdentifier	 is Fallback Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
handleFallbackElement	TokenNameIdentifier	 handle Fallback Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
hasXIncludeNamespace	TokenNameIdentifier	 has X Include Namespace
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
getSawInclude	TokenNameIdentifier	 get Saw Include
(	TokenNameLPAREN	
fDepth	TokenNameIdentifier	 f Depth
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"IncludeChild"	TokenNameStringLiteral	IncludeChild
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
getSawFallback	TokenNameIdentifier	 get Saw Fallback
(	TokenNameLPAREN	
fDepth	TokenNameIdentifier	 f Depth
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"FallbackChild"	TokenNameStringLiteral	FallbackChild
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
getState	TokenNameIdentifier	 get State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
STATE_NORMAL_PROCESSING	TokenNameIdentifier	 STATE  NORMAL  PROCESSING
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fResultDepth	TokenNameIdentifier	 f Result Depth
++	TokenNamePLUS_PLUS	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
checkMultipleRootElements	TokenNameIdentifier	 check Multiple Root Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
augs	TokenNameIdentifier	 augs
=	TokenNameEQUAL	
modifyAugmentations	TokenNameIdentifier	 modify Augmentations
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
attributes	TokenNameIdentifier	 attributes
=	TokenNameEQUAL	
processAttributes	TokenNameIdentifier	 process Attributes
(	TokenNameLPAREN	
attributes	TokenNameIdentifier	 attributes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
startElement	TokenNameIdentifier	 start Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
getState	TokenNameIdentifier	 get State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
STATE_NORMAL_PROCESSING	TokenNameIdentifier	 STATE  NORMAL  PROCESSING
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fResultDepth	TokenNameIdentifier	 f Result Depth
++	TokenNamePLUS_PLUS	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
checkMultipleRootElements	TokenNameIdentifier	 check Multiple Root Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
augs	TokenNameIdentifier	 augs
=	TokenNameEQUAL	
modifyAugmentations	TokenNameIdentifier	 modify Augmentations
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
attributes	TokenNameIdentifier	 attributes
=	TokenNameEQUAL	
processAttributes	TokenNameIdentifier	 process Attributes
(	TokenNameLPAREN	
attributes	TokenNameIdentifier	 attributes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
startElement	TokenNameIdentifier	 start Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
emptyElement	TokenNameIdentifier	 empty Element
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
XMLAttributes	TokenNameIdentifier	 XML Attributes
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
fDepth	TokenNameIdentifier	 f Depth
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
int	TokenNameint	
lastState	TokenNameIdentifier	 last State
=	TokenNameEQUAL	
getState	TokenNameIdentifier	 get State
(	TokenNameLPAREN	
fDepth	TokenNameIdentifier	 f Depth
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// If the last two states were fallback then this must be a descendant of an include 	TokenNameCOMMENT_LINE	If the last two states were fallback then this must be a descendant of an include 
// child which isn't a fallback. The specification says we should ignore such elements 	TokenNameCOMMENT_LINE	child which isn't a fallback. The specification says we should ignore such elements 
// and their children. 	TokenNameCOMMENT_LINE	and their children. 
if	TokenNameif	
(	TokenNameLPAREN	
lastState	TokenNameIdentifier	 last State
==	TokenNameEQUAL_EQUAL	
STATE_EXPECT_FALLBACK	TokenNameIdentifier	 STATE  EXPECT  FALLBACK
&&	TokenNameAND_AND	
getState	TokenNameIdentifier	 get State
(	TokenNameLPAREN	
fDepth	TokenNameIdentifier	 f Depth
-	TokenNameMINUS	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
STATE_EXPECT_FALLBACK	TokenNameIdentifier	 STATE  EXPECT  FALLBACK
)	TokenNameRPAREN	
{	TokenNameLBRACE	
setState	TokenNameIdentifier	 set State
(	TokenNameLPAREN	
STATE_IGNORE	TokenNameIdentifier	 STATE  IGNORE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
setState	TokenNameIdentifier	 set State
(	TokenNameLPAREN	
lastState	TokenNameIdentifier	 last State
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// we process the xml:base and xml:lang attributes regardless 	TokenNameCOMMENT_LINE	we process the xml:base and xml:lang attributes regardless 
// of what type of element it is. 	TokenNameCOMMENT_LINE	of what type of element it is. 
processXMLBaseAttributes	TokenNameIdentifier	 process XML Base Attributes
(	TokenNameLPAREN	
attributes	TokenNameIdentifier	 attributes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fFixupLanguage	TokenNameIdentifier	 f Fixup Language
)	TokenNameRPAREN	
{	TokenNameLBRACE	
processXMLLangAttributes	TokenNameIdentifier	 process XML Lang Attributes
(	TokenNameLPAREN	
attributes	TokenNameIdentifier	 attributes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isIncludeElement	TokenNameIdentifier	 is Include Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
this	TokenNamethis	
.	TokenNameDOT	
handleIncludeElement	TokenNameIdentifier	 handle Include Element
(	TokenNameLPAREN	
attributes	TokenNameIdentifier	 attributes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
success	TokenNameIdentifier	 success
)	TokenNameRPAREN	
{	TokenNameLBRACE	
setState	TokenNameIdentifier	 set State
(	TokenNameLPAREN	
STATE_IGNORE	TokenNameIdentifier	 STATE  IGNORE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"NoFallback"	TokenNameStringLiteral	NoFallback
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
isFallbackElement	TokenNameIdentifier	 is Fallback Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
handleFallbackElement	TokenNameIdentifier	 handle Fallback Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
hasXIncludeNamespace	TokenNameIdentifier	 has X Include Namespace
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
getSawInclude	TokenNameIdentifier	 get Saw Include
(	TokenNameLPAREN	
fDepth	TokenNameIdentifier	 f Depth
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"IncludeChild"	TokenNameStringLiteral	IncludeChild
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
getSawFallback	TokenNameIdentifier	 get Saw Fallback
(	TokenNameLPAREN	
fDepth	TokenNameIdentifier	 f Depth
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"FallbackChild"	TokenNameStringLiteral	FallbackChild
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
getState	TokenNameIdentifier	 get State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
STATE_NORMAL_PROCESSING	TokenNameIdentifier	 STATE  NORMAL  PROCESSING
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fResultDepth	TokenNameIdentifier	 f Result Depth
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
checkMultipleRootElements	TokenNameIdentifier	 check Multiple Root Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
augs	TokenNameIdentifier	 augs
=	TokenNameEQUAL	
modifyAugmentations	TokenNameIdentifier	 modify Augmentations
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
attributes	TokenNameIdentifier	 attributes
=	TokenNameEQUAL	
processAttributes	TokenNameIdentifier	 process Attributes
(	TokenNameLPAREN	
attributes	TokenNameIdentifier	 attributes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
emptyElement	TokenNameIdentifier	 empty Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
getState	TokenNameIdentifier	 get State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
STATE_NORMAL_PROCESSING	TokenNameIdentifier	 STATE  NORMAL  PROCESSING
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fResultDepth	TokenNameIdentifier	 f Result Depth
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
checkMultipleRootElements	TokenNameIdentifier	 check Multiple Root Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
augs	TokenNameIdentifier	 augs
=	TokenNameEQUAL	
modifyAugmentations	TokenNameIdentifier	 modify Augmentations
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
attributes	TokenNameIdentifier	 attributes
=	TokenNameEQUAL	
processAttributes	TokenNameIdentifier	 process Attributes
(	TokenNameLPAREN	
attributes	TokenNameIdentifier	 attributes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
emptyElement	TokenNameIdentifier	 empty Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// reset the out of scope stack elements 	TokenNameCOMMENT_LINE	reset the out of scope stack elements 
setSawFallback	TokenNameIdentifier	 set Saw Fallback
(	TokenNameLPAREN	
fDepth	TokenNameIdentifier	 f Depth
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setSawInclude	TokenNameIdentifier	 set Saw Include
(	TokenNameLPAREN	
fDepth	TokenNameIdentifier	 f Depth
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// check if an xml:base has gone out of scope 	TokenNameCOMMENT_LINE	check if an xml:base has gone out of scope 
if	TokenNameif	
(	TokenNameLPAREN	
fBaseURIScope	TokenNameIdentifier	 f Base URI Scope
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
fDepth	TokenNameIdentifier	 f Depth
==	TokenNameEQUAL_EQUAL	
fBaseURIScope	TokenNameIdentifier	 f Base URI Scope
.	TokenNameDOT	
peek	TokenNameIdentifier	 peek
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// pop the values from the stack 	TokenNameCOMMENT_LINE	pop the values from the stack 
restoreBaseURI	TokenNameIdentifier	 restore Base URI
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fDepth	TokenNameIdentifier	 f Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
endElement	TokenNameIdentifier	 end Element
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isIncludeElement	TokenNameIdentifier	 is Include Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if we're ending an include element, and we were expecting a fallback 	TokenNameCOMMENT_LINE	if we're ending an include element, and we were expecting a fallback 
// we check to see if the children of this include element contained a fallback 	TokenNameCOMMENT_LINE	we check to see if the children of this include element contained a fallback 
if	TokenNameif	
(	TokenNameLPAREN	
getState	TokenNameIdentifier	 get State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
STATE_EXPECT_FALLBACK	TokenNameIdentifier	 STATE  EXPECT  FALLBACK
&&	TokenNameAND_AND	
!	TokenNameNOT	
getSawFallback	TokenNameIdentifier	 get Saw Fallback
(	TokenNameLPAREN	
fDepth	TokenNameIdentifier	 f Depth
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"NoFallback"	TokenNameStringLiteral	NoFallback
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isFallbackElement	TokenNameIdentifier	 is Fallback Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// the state would have been set to normal processing if we were expecting the fallback element 	TokenNameCOMMENT_LINE	the state would have been set to normal processing if we were expecting the fallback element 
// now that we're done processing it, we should ignore all the other children of the include element 	TokenNameCOMMENT_LINE	now that we're done processing it, we should ignore all the other children of the include element 
if	TokenNameif	
(	TokenNameLPAREN	
getState	TokenNameIdentifier	 get State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
STATE_NORMAL_PROCESSING	TokenNameIdentifier	 STATE  NORMAL  PROCESSING
)	TokenNameRPAREN	
{	TokenNameLBRACE	
setState	TokenNameIdentifier	 set State
(	TokenNameLPAREN	
STATE_IGNORE	TokenNameIdentifier	 STATE  IGNORE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
getState	TokenNameIdentifier	 get State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
STATE_NORMAL_PROCESSING	TokenNameIdentifier	 STATE  NORMAL  PROCESSING
)	TokenNameRPAREN	
{	TokenNameLBRACE	
--	TokenNameMINUS_MINUS	
fResultDepth	TokenNameIdentifier	 f Result Depth
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
endElement	TokenNameIdentifier	 end Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// reset the out of scope stack elements 	TokenNameCOMMENT_LINE	reset the out of scope stack elements 
setSawFallback	TokenNameIdentifier	 set Saw Fallback
(	TokenNameLPAREN	
fDepth	TokenNameIdentifier	 f Depth
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setSawInclude	TokenNameIdentifier	 set Saw Include
(	TokenNameLPAREN	
fDepth	TokenNameIdentifier	 f Depth
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// check if an xml:base has gone out of scope 	TokenNameCOMMENT_LINE	check if an xml:base has gone out of scope 
if	TokenNameif	
(	TokenNameLPAREN	
fBaseURIScope	TokenNameIdentifier	 f Base URI Scope
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
fDepth	TokenNameIdentifier	 f Depth
==	TokenNameEQUAL_EQUAL	
fBaseURIScope	TokenNameIdentifier	 f Base URI Scope
.	TokenNameDOT	
peek	TokenNameIdentifier	 peek
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// pop the values from the stack 	TokenNameCOMMENT_LINE	pop the values from the stack 
restoreBaseURI	TokenNameIdentifier	 restore Base URI
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// check if an xml:lang has gone out of scope 	TokenNameCOMMENT_LINE	check if an xml:lang has gone out of scope 
if	TokenNameif	
(	TokenNameLPAREN	
fLanguageScope	TokenNameIdentifier	 f Language Scope
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
fDepth	TokenNameIdentifier	 f Depth
==	TokenNameEQUAL_EQUAL	
fLanguageScope	TokenNameIdentifier	 f Language Scope
.	TokenNameDOT	
peek	TokenNameIdentifier	 peek
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// pop the language from the stack 	TokenNameCOMMENT_LINE	pop the language from the stack 
fCurrentLanguage	TokenNameIdentifier	 f Current Language
=	TokenNameEQUAL	
restoreLanguage	TokenNameIdentifier	 restore Language
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fDepth	TokenNameIdentifier	 f Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
startGeneralEntity	TokenNameIdentifier	 start General Entity
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
XMLResourceIdentifier	TokenNameIdentifier	 XML Resource Identifier
resId	TokenNameIdentifier	 res Id
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
getState	TokenNameIdentifier	 get State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
STATE_NORMAL_PROCESSING	TokenNameIdentifier	 STATE  NORMAL  PROCESSING
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fResultDepth	TokenNameIdentifier	 f Result Depth
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
TRUE	TokenNameIdentifier	 TRUE
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
.	TokenNameDOT	
getItem	TokenNameIdentifier	 get Item
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ENTITY_SKIPPED	TokenNameIdentifier	 ENTITY  SKIPPED
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"UnexpandedEntityReferenceIllegal"	TokenNameStringLiteral	UnexpandedEntityReferenceIllegal
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
startGeneralEntity	TokenNameIdentifier	 start General Entity
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
resId	TokenNameIdentifier	 res Id
,	TokenNameCOMMA	
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
textDecl	TokenNameIdentifier	 text Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
version	TokenNameIdentifier	 version
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
getState	TokenNameIdentifier	 get State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
STATE_NORMAL_PROCESSING	TokenNameIdentifier	 STATE  NORMAL  PROCESSING
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
textDecl	TokenNameIdentifier	 text Decl
(	TokenNameLPAREN	
version	TokenNameIdentifier	 version
,	TokenNameCOMMA	
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
endGeneralEntity	TokenNameIdentifier	 end General Entity
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
getState	TokenNameIdentifier	 get State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
STATE_NORMAL_PROCESSING	TokenNameIdentifier	 STATE  NORMAL  PROCESSING
&&	TokenNameAND_AND	
fResultDepth	TokenNameIdentifier	 f Result Depth
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
endGeneralEntity	TokenNameIdentifier	 end General Entity
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
characters	TokenNameIdentifier	 characters
(	TokenNameLPAREN	
XMLString	TokenNameIdentifier	 XML String
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
getState	TokenNameIdentifier	 get State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
STATE_NORMAL_PROCESSING	TokenNameIdentifier	 STATE  NORMAL  PROCESSING
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fResultDepth	TokenNameIdentifier	 f Result Depth
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
checkWhitespace	TokenNameIdentifier	 check Whitespace
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// we need to change the depth like this so that modifyAugmentations() works 	TokenNameCOMMENT_LINE	we need to change the depth like this so that modifyAugmentations() works 
fDepth	TokenNameIdentifier	 f Depth
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
augs	TokenNameIdentifier	 augs
=	TokenNameEQUAL	
modifyAugmentations	TokenNameIdentifier	 modify Augmentations
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
characters	TokenNameIdentifier	 characters
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fDepth	TokenNameIdentifier	 f Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
ignorableWhitespace	TokenNameIdentifier	 ignorable Whitespace
(	TokenNameLPAREN	
XMLString	TokenNameIdentifier	 XML String
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
getState	TokenNameIdentifier	 get State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
STATE_NORMAL_PROCESSING	TokenNameIdentifier	 STATE  NORMAL  PROCESSING
&&	TokenNameAND_AND	
fResultDepth	TokenNameIdentifier	 f Result Depth
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
ignorableWhitespace	TokenNameIdentifier	 ignorable Whitespace
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
startCDATA	TokenNameIdentifier	 start CDATA
(	TokenNameLPAREN	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
getState	TokenNameIdentifier	 get State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
STATE_NORMAL_PROCESSING	TokenNameIdentifier	 STATE  NORMAL  PROCESSING
&&	TokenNameAND_AND	
fResultDepth	TokenNameIdentifier	 f Result Depth
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
startCDATA	TokenNameIdentifier	 start CDATA
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
endCDATA	TokenNameIdentifier	 end CDATA
(	TokenNameLPAREN	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
getState	TokenNameIdentifier	 get State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
STATE_NORMAL_PROCESSING	TokenNameIdentifier	 STATE  NORMAL  PROCESSING
&&	TokenNameAND_AND	
fResultDepth	TokenNameIdentifier	 f Result Depth
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
endCDATA	TokenNameIdentifier	 end CDATA
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
endDocument	TokenNameIdentifier	 end Document
(	TokenNameLPAREN	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isRootDocument	TokenNameIdentifier	 is Root Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fSeenRootElement	TokenNameIdentifier	 f Seen Root Element
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"RootElementRequired"	TokenNameStringLiteral	RootElementRequired
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
endDocument	TokenNameIdentifier	 end Document
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setDocumentSource	TokenNameIdentifier	 set Document Source
(	TokenNameLPAREN	
XMLDocumentSource	TokenNameIdentifier	 XML Document Source
source	TokenNameIdentifier	 source
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentSource	TokenNameIdentifier	 f Document Source
=	TokenNameEQUAL	
source	TokenNameIdentifier	 source
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
XMLDocumentSource	TokenNameIdentifier	 XML Document Source
getDocumentSource	TokenNameIdentifier	 get Document Source
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fDocumentSource	TokenNameIdentifier	 f Document Source
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// DTDHandler methods 	TokenNameCOMMENT_LINE	DTDHandler methods 
// We are only interested in the notation and unparsed entity declarations, 	TokenNameCOMMENT_LINE	We are only interested in the notation and unparsed entity declarations, 
// the rest we just pass on 	TokenNameCOMMENT_LINE	the rest we just pass on 
/* (non-Javadoc) * @see org.apache.xerces.xni.XMLDTDHandler#attributeDecl(java.lang.String, java.lang.String, java.lang.String, java.lang.String[], java.lang.String, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations) */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xni.XMLDTDHandler#attributeDecl(java.lang.String, java.lang.String, java.lang.String, java.lang.String[], java.lang.String, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations) 
public	TokenNamepublic	
void	TokenNamevoid	
attributeDecl	TokenNameIdentifier	 attribute Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
elementName	TokenNameIdentifier	 element Name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
attributeName	TokenNameIdentifier	 attribute Name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
enumeration	TokenNameIdentifier	 enumeration
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
defaultType	TokenNameIdentifier	 default Type
,	TokenNameCOMMA	
XMLString	TokenNameIdentifier	 XML String
defaultValue	TokenNameIdentifier	 default Value
,	TokenNameCOMMA	
XMLString	TokenNameIdentifier	 XML String
nonNormalizedDefaultValue	TokenNameIdentifier	 non Normalized Default Value
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
attributeDecl	TokenNameIdentifier	 attribute Decl
(	TokenNameLPAREN	
elementName	TokenNameIdentifier	 element Name
,	TokenNameCOMMA	
attributeName	TokenNameIdentifier	 attribute Name
,	TokenNameCOMMA	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
enumeration	TokenNameIdentifier	 enumeration
,	TokenNameCOMMA	
defaultType	TokenNameIdentifier	 default Type
,	TokenNameCOMMA	
defaultValue	TokenNameIdentifier	 default Value
,	TokenNameCOMMA	
nonNormalizedDefaultValue	TokenNameIdentifier	 non Normalized Default Value
,	TokenNameCOMMA	
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xni.XMLDTDHandler#elementDecl(java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations) */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xni.XMLDTDHandler#elementDecl(java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations) 
public	TokenNamepublic	
void	TokenNamevoid	
elementDecl	TokenNameIdentifier	 element Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
contentModel	TokenNameIdentifier	 content Model
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
elementDecl	TokenNameIdentifier	 element Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
contentModel	TokenNameIdentifier	 content Model
,	TokenNameCOMMA	
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xni.XMLDTDHandler#endAttlist(org.apache.xerces.xni.Augmentations) */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xni.XMLDTDHandler#endAttlist(org.apache.xerces.xni.Augmentations) 
public	TokenNamepublic	
void	TokenNamevoid	
endAttlist	TokenNameIdentifier	 end Attlist
(	TokenNameLPAREN	
Augmentations	TokenNameIdentifier	 Augmentations
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
endAttlist	TokenNameIdentifier	 end Attlist
(	TokenNameLPAREN	
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xni.XMLDTDHandler#endConditional(org.apache.xerces.xni.Augmentations) */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xni.XMLDTDHandler#endConditional(org.apache.xerces.xni.Augmentations) 
public	TokenNamepublic	
void	TokenNamevoid	
endConditional	TokenNameIdentifier	 end Conditional
(	TokenNameLPAREN	
Augmentations	TokenNameIdentifier	 Augmentations
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
endConditional	TokenNameIdentifier	 end Conditional
(	TokenNameLPAREN	
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xni.XMLDTDHandler#endDTD(org.apache.xerces.xni.Augmentations) */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xni.XMLDTDHandler#endDTD(org.apache.xerces.xni.Augmentations) 
public	TokenNamepublic	
void	TokenNamevoid	
endDTD	TokenNameIdentifier	 end DTD
(	TokenNameLPAREN	
Augmentations	TokenNameIdentifier	 Augmentations
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
endDTD	TokenNameIdentifier	 end DTD
(	TokenNameLPAREN	
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fInDTD	TokenNameIdentifier	 f In DTD
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xni.XMLDTDHandler#endExternalSubset(org.apache.xerces.xni.Augmentations) */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xni.XMLDTDHandler#endExternalSubset(org.apache.xerces.xni.Augmentations) 
public	TokenNamepublic	
void	TokenNamevoid	
endExternalSubset	TokenNameIdentifier	 end External Subset
(	TokenNameLPAREN	
Augmentations	TokenNameIdentifier	 Augmentations
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
endExternalSubset	TokenNameIdentifier	 end External Subset
(	TokenNameLPAREN	
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xni.XMLDTDHandler#endParameterEntity(java.lang.String, org.apache.xerces.xni.Augmentations) */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xni.XMLDTDHandler#endParameterEntity(java.lang.String, org.apache.xerces.xni.Augmentations) 
public	TokenNamepublic	
void	TokenNamevoid	
endParameterEntity	TokenNameIdentifier	 end Parameter Entity
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
endParameterEntity	TokenNameIdentifier	 end Parameter Entity
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xni.XMLDTDHandler#externalEntityDecl(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, org.apache.xerces.xni.Augmentations) */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xni.XMLDTDHandler#externalEntityDecl(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, org.apache.xerces.xni.Augmentations) 
public	TokenNamepublic	
void	TokenNamevoid	
externalEntityDecl	TokenNameIdentifier	 external Entity Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
XMLResourceIdentifier	TokenNameIdentifier	 XML Resource Identifier
identifier	TokenNameIdentifier	 identifier
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
externalEntityDecl	TokenNameIdentifier	 external Entity Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
identifier	TokenNameIdentifier	 identifier
,	TokenNameCOMMA	
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xni.XMLDTDHandler#getDTDSource() */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xni.XMLDTDHandler#getDTDSource() 
public	TokenNamepublic	
XMLDTDSource	TokenNameIdentifier	 XMLDTD Source
getDTDSource	TokenNameIdentifier	 get DTD Source
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fDTDSource	TokenNameIdentifier	 f DTD Source
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xni.XMLDTDHandler#ignoredCharacters(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations) */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xni.XMLDTDHandler#ignoredCharacters(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations) 
public	TokenNamepublic	
void	TokenNamevoid	
ignoredCharacters	TokenNameIdentifier	 ignored Characters
(	TokenNameLPAREN	
XMLString	TokenNameIdentifier	 XML String
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
ignoredCharacters	TokenNameIdentifier	 ignored Characters
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xni.XMLDTDHandler#internalEntityDecl(java.lang.String, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations) */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xni.XMLDTDHandler#internalEntityDecl(java.lang.String, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations) 
public	TokenNamepublic	
void	TokenNamevoid	
internalEntityDecl	TokenNameIdentifier	 internal Entity Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
XMLString	TokenNameIdentifier	 XML String
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
XMLString	TokenNameIdentifier	 XML String
nonNormalizedText	TokenNameIdentifier	 non Normalized Text
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
internalEntityDecl	TokenNameIdentifier	 internal Entity Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
nonNormalizedText	TokenNameIdentifier	 non Normalized Text
,	TokenNameCOMMA	
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xni.XMLDTDHandler#notationDecl(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, org.apache.xerces.xni.Augmentations) */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xni.XMLDTDHandler#notationDecl(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, org.apache.xerces.xni.Augmentations) 
public	TokenNamepublic	
void	TokenNamevoid	
notationDecl	TokenNameIdentifier	 notation Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
XMLResourceIdentifier	TokenNameIdentifier	 XML Resource Identifier
identifier	TokenNameIdentifier	 identifier
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
addNotation	TokenNameIdentifier	 add Notation
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
identifier	TokenNameIdentifier	 identifier
,	TokenNameCOMMA	
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
notationDecl	TokenNameIdentifier	 notation Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
identifier	TokenNameIdentifier	 identifier
,	TokenNameCOMMA	
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xni.XMLDTDHandler#setDTDSource(org.apache.xerces.xni.parser.XMLDTDSource) */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xni.XMLDTDHandler#setDTDSource(org.apache.xerces.xni.parser.XMLDTDSource) 
public	TokenNamepublic	
void	TokenNamevoid	
setDTDSource	TokenNameIdentifier	 set DTD Source
(	TokenNameLPAREN	
XMLDTDSource	TokenNameIdentifier	 XMLDTD Source
source	TokenNameIdentifier	 source
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDSource	TokenNameIdentifier	 f DTD Source
=	TokenNameEQUAL	
source	TokenNameIdentifier	 source
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xni.XMLDTDHandler#startAttlist(java.lang.String, org.apache.xerces.xni.Augmentations) */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xni.XMLDTDHandler#startAttlist(java.lang.String, org.apache.xerces.xni.Augmentations) 
public	TokenNamepublic	
void	TokenNamevoid	
startAttlist	TokenNameIdentifier	 start Attlist
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
elementName	TokenNameIdentifier	 element Name
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
startAttlist	TokenNameIdentifier	 start Attlist
(	TokenNameLPAREN	
elementName	TokenNameIdentifier	 element Name
,	TokenNameCOMMA	
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xni.XMLDTDHandler#startConditional(short, org.apache.xerces.xni.Augmentations) */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xni.XMLDTDHandler#startConditional(short, org.apache.xerces.xni.Augmentations) 
public	TokenNamepublic	
void	TokenNamevoid	
startConditional	TokenNameIdentifier	 start Conditional
(	TokenNameLPAREN	
short	TokenNameshort	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
startConditional	TokenNameIdentifier	 start Conditional
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xni.XMLDTDHandler#startDTD(org.apache.xerces.xni.XMLLocator, org.apache.xerces.xni.Augmentations) */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xni.XMLDTDHandler#startDTD(org.apache.xerces.xni.XMLLocator, org.apache.xerces.xni.Augmentations) 
public	TokenNamepublic	
void	TokenNamevoid	
startDTD	TokenNameIdentifier	 start DTD
(	TokenNameLPAREN	
XMLLocator	TokenNameIdentifier	 XML Locator
locator	TokenNameIdentifier	 locator
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
fInDTD	TokenNameIdentifier	 f In DTD
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
startDTD	TokenNameIdentifier	 start DTD
(	TokenNameLPAREN	
locator	TokenNameIdentifier	 locator
,	TokenNameCOMMA	
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xni.XMLDTDHandler#startExternalSubset(org.apache.xerces.xni.XMLResourceIdentifier, org.apache.xerces.xni.Augmentations) */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xni.XMLDTDHandler#startExternalSubset(org.apache.xerces.xni.XMLResourceIdentifier, org.apache.xerces.xni.Augmentations) 
public	TokenNamepublic	
void	TokenNamevoid	
startExternalSubset	TokenNameIdentifier	 start External Subset
(	TokenNameLPAREN	
XMLResourceIdentifier	TokenNameIdentifier	 XML Resource Identifier
identifier	TokenNameIdentifier	 identifier
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
startExternalSubset	TokenNameIdentifier	 start External Subset
(	TokenNameLPAREN	
identifier	TokenNameIdentifier	 identifier
,	TokenNameCOMMA	
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xni.XMLDTDHandler#startParameterEntity(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations) */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xni.XMLDTDHandler#startParameterEntity(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations) 
public	TokenNamepublic	
void	TokenNamevoid	
startParameterEntity	TokenNameIdentifier	 start Parameter Entity
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
XMLResourceIdentifier	TokenNameIdentifier	 XML Resource Identifier
identifier	TokenNameIdentifier	 identifier
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
startParameterEntity	TokenNameIdentifier	 start Parameter Entity
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
identifier	TokenNameIdentifier	 identifier
,	TokenNameCOMMA	
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xni.XMLDTDHandler#unparsedEntityDecl(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations) */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xni.XMLDTDHandler#unparsedEntityDecl(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations) 
public	TokenNamepublic	
void	TokenNamevoid	
unparsedEntityDecl	TokenNameIdentifier	 unparsed Entity Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
XMLResourceIdentifier	TokenNameIdentifier	 XML Resource Identifier
identifier	TokenNameIdentifier	 identifier
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
notation	TokenNameIdentifier	 notation
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
addUnparsedEntity	TokenNameIdentifier	 add Unparsed Entity
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
identifier	TokenNameIdentifier	 identifier
,	TokenNameCOMMA	
notation	TokenNameIdentifier	 notation
,	TokenNameCOMMA	
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
unparsedEntityDecl	TokenNameIdentifier	 unparsed Entity Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
identifier	TokenNameIdentifier	 identifier
,	TokenNameCOMMA	
notation	TokenNameIdentifier	 notation
,	TokenNameCOMMA	
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xni.parser.XMLDTDSource#getDTDHandler() */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xni.parser.XMLDTDSource#getDTDHandler() 
public	TokenNamepublic	
XMLDTDHandler	TokenNameIdentifier	 XMLDTD Handler
getDTDHandler	TokenNameIdentifier	 get DTD Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xni.parser.XMLDTDSource#setDTDHandler(org.apache.xerces.xni.XMLDTDHandler) */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xni.parser.XMLDTDSource#setDTDHandler(org.apache.xerces.xni.XMLDTDHandler) 
public	TokenNamepublic	
void	TokenNamevoid	
setDTDHandler	TokenNameIdentifier	 set DTD Handler
(	TokenNameLPAREN	
XMLDTDHandler	TokenNameIdentifier	 XMLDTD Handler
handler	TokenNameIdentifier	 handler
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
=	TokenNameEQUAL	
handler	TokenNameIdentifier	 handler
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// XIncludeHandler methods 	TokenNameCOMMENT_LINE	XIncludeHandler methods 
private	TokenNameprivate	
void	TokenNamevoid	
setErrorReporter	TokenNameIdentifier	 set Error Reporter
(	TokenNameLPAREN	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
reporter	TokenNameIdentifier	 reporter
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
=	TokenNameEQUAL	
reporter	TokenNameIdentifier	 reporter
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
putMessageFormatter	TokenNameIdentifier	 put Message Formatter
(	TokenNameLPAREN	
XIncludeMessageFormatter	TokenNameIdentifier	 X Include Message Formatter
.	TokenNameDOT	
XINCLUDE_DOMAIN	TokenNameIdentifier	 XINCLUDE  DOMAIN
,	TokenNameCOMMA	
fXIncludeMessageFormatter	TokenNameIdentifier	 f X Include Message Formatter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// this ensures the proper location is displayed in error messages 	TokenNameCOMMENT_LINE	this ensures the proper location is displayed in error messages 
if	TokenNameif	
(	TokenNameLPAREN	
fDocLocation	TokenNameIdentifier	 f Doc Location
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
setDocumentLocator	TokenNameIdentifier	 set Document Locator
(	TokenNameLPAREN	
fDocLocation	TokenNameIdentifier	 f Doc Location
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
handleFallbackElement	TokenNameIdentifier	 handle Fallback Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
getSawInclude	TokenNameIdentifier	 get Saw Include
(	TokenNameLPAREN	
fDepth	TokenNameIdentifier	 f Depth
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
getState	TokenNameIdentifier	 get State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
STATE_IGNORE	TokenNameIdentifier	 STATE  IGNORE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"FallbackParent"	TokenNameStringLiteral	FallbackParent
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
setSawInclude	TokenNameIdentifier	 set Saw Include
(	TokenNameLPAREN	
fDepth	TokenNameIdentifier	 f Depth
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fNamespaceContext	TokenNameIdentifier	 f Namespace Context
.	TokenNameDOT	
setContextInvalid	TokenNameIdentifier	 set Context Invalid
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
getSawFallback	TokenNameIdentifier	 get Saw Fallback
(	TokenNameLPAREN	
fDepth	TokenNameIdentifier	 f Depth
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MultipleFallbacks"	TokenNameStringLiteral	MultipleFallbacks
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
setSawFallback	TokenNameIdentifier	 set Saw Fallback
(	TokenNameLPAREN	
fDepth	TokenNameIdentifier	 f Depth
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Either the state is STATE_EXPECT_FALLBACK or it's STATE_IGNORE. 	TokenNameCOMMENT_LINE	Either the state is STATE_EXPECT_FALLBACK or it's STATE_IGNORE. 
// If we're ignoring, we want to stay ignoring. But if we're expecting this fallback element, 	TokenNameCOMMENT_LINE	If we're ignoring, we want to stay ignoring. But if we're expecting this fallback element, 
// we want to signal that we should process the children. 	TokenNameCOMMENT_LINE	we want to signal that we should process the children. 
if	TokenNameif	
(	TokenNameLPAREN	
getState	TokenNameIdentifier	 get State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
STATE_EXPECT_FALLBACK	TokenNameIdentifier	 STATE  EXPECT  FALLBACK
)	TokenNameRPAREN	
{	TokenNameLBRACE	
setState	TokenNameIdentifier	 set State
(	TokenNameLPAREN	
STATE_NORMAL_PROCESSING	TokenNameIdentifier	 STATE  NORMAL  PROCESSING
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
protected	TokenNameprotected	
boolean	TokenNameboolean	
handleIncludeElement	TokenNameIdentifier	 handle Include Element
(	TokenNameLPAREN	
XMLAttributes	TokenNameIdentifier	 XML Attributes
attributes	TokenNameIdentifier	 attributes
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
getSawInclude	TokenNameIdentifier	 get Saw Include
(	TokenNameLPAREN	
fDepth	TokenNameIdentifier	 f Depth
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"IncludeChild"	TokenNameStringLiteral	IncludeChild
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
XINCLUDE_INCLUDE	TokenNameIdentifier	 XINCLUDE  INCLUDE
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
getState	TokenNameIdentifier	 get State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
STATE_IGNORE	TokenNameIdentifier	 STATE  IGNORE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
setSawInclude	TokenNameIdentifier	 set Saw Include
(	TokenNameLPAREN	
fDepth	TokenNameIdentifier	 f Depth
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fNamespaceContext	TokenNameIdentifier	 f Namespace Context
.	TokenNameDOT	
setContextInvalid	TokenNameIdentifier	 set Context Invalid
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// TODO: does Java use IURIs by default? 	TokenNameCOMMENT_LINE	TODO: does Java use IURIs by default? 
// [Definition: An internationalized URI reference, or IURI, is a URI reference that directly uses [Unicode] characters.] 	TokenNameCOMMENT_LINE	[Definition: An internationalized URI reference, or IURI, is a URI reference that directly uses [Unicode] characters.] 
// TODO: figure out what section 4.1.1 of the XInclude spec is talking about 	TokenNameCOMMENT_LINE	TODO: figure out what section 4.1.1 of the XInclude spec is talking about 
// has to do with disallowed ASCII character escaping 	TokenNameCOMMENT_LINE	has to do with disallowed ASCII character escaping 
// this ties in with the above IURI section, but I suspect Java already does it 	TokenNameCOMMENT_LINE	this ties in with the above IURI section, but I suspect Java already does it 
String	TokenNameIdentifier	 String
href	TokenNameIdentifier	 href
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
XINCLUDE_ATTR_HREF	TokenNameIdentifier	 XINCLUDE  ATTR  HREF
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
parse	TokenNameIdentifier	 parse
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
XINCLUDE_ATTR_PARSE	TokenNameIdentifier	 XINCLUDE  ATTR  PARSE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
xpointer	TokenNameIdentifier	 xpointer
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
XPOINTER	TokenNameIdentifier	 XPOINTER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
accept	TokenNameIdentifier	 accept
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
XINCLUDE_ATTR_ACCEPT	TokenNameIdentifier	 XINCLUDE  ATTR  ACCEPT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
acceptLanguage	TokenNameIdentifier	 accept Language
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
XINCLUDE_ATTR_ACCEPT_LANGUAGE	TokenNameIdentifier	 XINCLUDE  ATTR  ACCEPT  LANGUAGE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
parse	TokenNameIdentifier	 parse
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
parse	TokenNameIdentifier	 parse
=	TokenNameEQUAL	
XINCLUDE_PARSE_XML	TokenNameIdentifier	 XINCLUDE  PARSE  XML
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
href	TokenNameIdentifier	 href
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
href	TokenNameIdentifier	 href
=	TokenNameEQUAL	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
EMPTY_STRING	TokenNameIdentifier	 EMPTY  STRING
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
href	TokenNameIdentifier	 href
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
XINCLUDE_PARSE_XML	TokenNameIdentifier	 XINCLUDE  PARSE  XML
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
parse	TokenNameIdentifier	 parse
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
xpointer	TokenNameIdentifier	 xpointer
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"XpointerMissing"	TokenNameStringLiteral	XpointerMissing
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// When parse="xml" and an xpointer is specified treat 	TokenNameCOMMENT_LINE	When parse="xml" and an xpointer is specified treat 
// all absences of the href attribute as a resource error. 	TokenNameCOMMENT_LINE	all absences of the href attribute as a resource error. 
Locale	TokenNameIdentifier	 Locale
locale	TokenNameIdentifier	 locale
=	TokenNameEQUAL	
(	TokenNameLPAREN	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
getLocale	TokenNameIdentifier	 get Locale
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
null	TokenNamenull	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
reason	TokenNameIdentifier	 reason
=	TokenNameEQUAL	
fXIncludeMessageFormatter	TokenNameIdentifier	 f X Include Message Formatter
.	TokenNameDOT	
formatMessage	TokenNameIdentifier	 format Message
(	TokenNameLPAREN	
locale	TokenNameIdentifier	 locale
,	TokenNameCOMMA	
"XPointerStreamability"	TokenNameStringLiteral	XPointerStreamability
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reportResourceError	TokenNameIdentifier	 report Resource Error
(	TokenNameLPAREN	
"XMLResourceError"	TokenNameStringLiteral	XMLResourceError
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
href	TokenNameIdentifier	 href
,	TokenNameCOMMA	
reason	TokenNameIdentifier	 reason
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
URI	TokenNameIdentifier	 URI
hrefURI	TokenNameIdentifier	 href URI
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// Check whether href is correct and perform escaping as per section 4.1.1 of the XInclude spec. 	TokenNameCOMMENT_LINE	Check whether href is correct and perform escaping as per section 4.1.1 of the XInclude spec. 
// Report fatal error if the href value contains a fragment identifier or if the value after 	TokenNameCOMMENT_LINE	Report fatal error if the href value contains a fragment identifier or if the value after 
// escaping is a syntactically invalid URI or IRI. 	TokenNameCOMMENT_LINE	escaping is a syntactically invalid URI or IRI. 
try	TokenNametry	
{	TokenNameLBRACE	
hrefURI	TokenNameIdentifier	 href URI
=	TokenNameEQUAL	
new	TokenNamenew	
URI	TokenNameIdentifier	 URI
(	TokenNameLPAREN	
href	TokenNameIdentifier	 href
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
hrefURI	TokenNameIdentifier	 href URI
.	TokenNameDOT	
getFragment	TokenNameIdentifier	 get Fragment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"HrefFragmentIdentifierIllegal"	TokenNameStringLiteral	HrefFragmentIdentifierIllegal
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
href	TokenNameIdentifier	 href
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
URI	TokenNameIdentifier	 URI
.	TokenNameDOT	
MalformedURIException	TokenNameIdentifier	 Malformed URI Exception
exc	TokenNameIdentifier	 exc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
newHref	TokenNameIdentifier	 new Href
=	TokenNameEQUAL	
escapeHref	TokenNameIdentifier	 escape Href
(	TokenNameLPAREN	
href	TokenNameIdentifier	 href
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
href	TokenNameIdentifier	 href
!=	TokenNameNOT_EQUAL	
newHref	TokenNameIdentifier	 new Href
)	TokenNameRPAREN	
{	TokenNameLBRACE	
href	TokenNameIdentifier	 href
=	TokenNameEQUAL	
newHref	TokenNameIdentifier	 new Href
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
hrefURI	TokenNameIdentifier	 href URI
=	TokenNameEQUAL	
new	TokenNamenew	
URI	TokenNameIdentifier	 URI
(	TokenNameLPAREN	
href	TokenNameIdentifier	 href
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
hrefURI	TokenNameIdentifier	 href URI
.	TokenNameDOT	
getFragment	TokenNameIdentifier	 get Fragment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"HrefFragmentIdentifierIllegal"	TokenNameStringLiteral	HrefFragmentIdentifierIllegal
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
href	TokenNameIdentifier	 href
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
URI	TokenNameIdentifier	 URI
.	TokenNameDOT	
MalformedURIException	TokenNameIdentifier	 Malformed URI Exception
exc2	TokenNameIdentifier	 exc2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"HrefSyntacticallyInvalid"	TokenNameStringLiteral	HrefSyntacticallyInvalid
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
href	TokenNameIdentifier	 href
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"HrefSyntacticallyInvalid"	TokenNameStringLiteral	HrefSyntacticallyInvalid
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
href	TokenNameIdentifier	 href
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Verify that if an accept and/or an accept-language attribute exist 	TokenNameCOMMENT_LINE	Verify that if an accept and/or an accept-language attribute exist 
// that the value(s) don't contain disallowed characters. 	TokenNameCOMMENT_LINE	that the value(s) don't contain disallowed characters. 
if	TokenNameif	
(	TokenNameLPAREN	
accept	TokenNameIdentifier	 accept
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
isValidInHTTPHeader	TokenNameIdentifier	 is Valid In HTTP Header
(	TokenNameLPAREN	
accept	TokenNameIdentifier	 accept
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"AcceptMalformed"	TokenNameStringLiteral	AcceptMalformed
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
accept	TokenNameIdentifier	 accept
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
acceptLanguage	TokenNameIdentifier	 accept Language
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
isValidInHTTPHeader	TokenNameIdentifier	 is Valid In HTTP Header
(	TokenNameLPAREN	
acceptLanguage	TokenNameIdentifier	 accept Language
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"AcceptLanguageMalformed"	TokenNameStringLiteral	AcceptLanguageMalformed
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
acceptLanguage	TokenNameIdentifier	 accept Language
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
XMLInputSource	TokenNameIdentifier	 XML Input Source
includedSource	TokenNameIdentifier	 included Source
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityResolver	TokenNameIdentifier	 f Entity Resolver
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
XMLResourceIdentifier	TokenNameIdentifier	 XML Resource Identifier
resourceIdentifier	TokenNameIdentifier	 resource Identifier
=	TokenNameEQUAL	
new	TokenNamenew	
XMLResourceIdentifierImpl	TokenNameIdentifier	 XML Resource Identifier Impl
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
href	TokenNameIdentifier	 href
,	TokenNameCOMMA	
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
.	TokenNameDOT	
getExpandedSystemId	TokenNameIdentifier	 get Expanded System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
XMLEntityManager	TokenNameIdentifier	 XML Entity Manager
.	TokenNameDOT	
expandSystemId	TokenNameIdentifier	 expand System Id
(	TokenNameLPAREN	
href	TokenNameIdentifier	 href
,	TokenNameCOMMA	
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
.	TokenNameDOT	
getExpandedSystemId	TokenNameIdentifier	 get Expanded System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
includedSource	TokenNameIdentifier	 included Source
=	TokenNameEQUAL	
fEntityResolver	TokenNameIdentifier	 f Entity Resolver
.	TokenNameDOT	
resolveEntity	TokenNameIdentifier	 resolve Entity
(	TokenNameLPAREN	
resourceIdentifier	TokenNameIdentifier	 resource Identifier
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
includedSource	TokenNameIdentifier	 included Source
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
(	TokenNameLPAREN	
includedSource	TokenNameIdentifier	 included Source
instanceof	TokenNameinstanceof	
HTTPInputSource	TokenNameIdentifier	 HTTP Input Source
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
accept	TokenNameIdentifier	 accept
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
acceptLanguage	TokenNameIdentifier	 accept Language
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
includedSource	TokenNameIdentifier	 included Source
.	TokenNameDOT	
getCharacterStream	TokenNameIdentifier	 get Character Stream
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
includedSource	TokenNameIdentifier	 included Source
.	TokenNameDOT	
getByteStream	TokenNameIdentifier	 get Byte Stream
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
includedSource	TokenNameIdentifier	 included Source
=	TokenNameEQUAL	
createInputSource	TokenNameIdentifier	 create Input Source
(	TokenNameLPAREN	
includedSource	TokenNameIdentifier	 included Source
.	TokenNameDOT	
getPublicId	TokenNameIdentifier	 get Public Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
includedSource	TokenNameIdentifier	 included Source
.	TokenNameDOT	
getSystemId	TokenNameIdentifier	 get System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
includedSource	TokenNameIdentifier	 included Source
.	TokenNameDOT	
getBaseSystemId	TokenNameIdentifier	 get Base System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
accept	TokenNameIdentifier	 accept
,	TokenNameCOMMA	
acceptLanguage	TokenNameIdentifier	 accept Language
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportResourceError	TokenNameIdentifier	 report Resource Error
(	TokenNameLPAREN	
"XMLResourceError"	TokenNameStringLiteral	XMLResourceError
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
href	TokenNameIdentifier	 href
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
includedSource	TokenNameIdentifier	 included Source
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// setup an HTTPInputSource if either of the content negotation attributes were specified. 	TokenNameCOMMENT_LINE	setup an HTTPInputSource if either of the content negotation attributes were specified. 
if	TokenNameif	
(	TokenNameLPAREN	
accept	TokenNameIdentifier	 accept
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
acceptLanguage	TokenNameIdentifier	 accept Language
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
includedSource	TokenNameIdentifier	 included Source
=	TokenNameEQUAL	
createInputSource	TokenNameIdentifier	 create Input Source
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
href	TokenNameIdentifier	 href
,	TokenNameCOMMA	
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
.	TokenNameDOT	
getExpandedSystemId	TokenNameIdentifier	 get Expanded System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
accept	TokenNameIdentifier	 accept
,	TokenNameCOMMA	
acceptLanguage	TokenNameIdentifier	 accept Language
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
includedSource	TokenNameIdentifier	 included Source
=	TokenNameEQUAL	
new	TokenNamenew	
XMLInputSource	TokenNameIdentifier	 XML Input Source
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
href	TokenNameIdentifier	 href
,	TokenNameCOMMA	
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
.	TokenNameDOT	
getExpandedSystemId	TokenNameIdentifier	 get Expanded System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
parse	TokenNameIdentifier	 parse
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
XINCLUDE_PARSE_XML	TokenNameIdentifier	 XINCLUDE  PARSE  XML
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Instead of always creating a new configuration, the first one can be reused 	TokenNameCOMMENT_LINE	Instead of always creating a new configuration, the first one can be reused 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
xpointer	TokenNameIdentifier	 xpointer
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
fXPointerChildConfig	TokenNameIdentifier	 f X Pointer Child Config
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
xpointer	TokenNameIdentifier	 xpointer
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
fXIncludeChildConfig	TokenNameIdentifier	 f X Include Child Config
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
parserName	TokenNameIdentifier	 parser Name
=	TokenNameEQUAL	
XINCLUDE_DEFAULT_CONFIGURATION	TokenNameIdentifier	 XINCLUDE  DEFAULT  CONFIGURATION
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
xpointer	TokenNameIdentifier	 xpointer
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
parserName	TokenNameIdentifier	 parser Name
=	TokenNameEQUAL	
"org.apache.xerces.parsers.XPointerParserConfiguration"	TokenNameStringLiteral	org.apache.xerces.parsers.XPointerParserConfiguration
;	TokenNameSEMICOLON	
fChildConfig	TokenNameIdentifier	 f Child Config
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XMLParserConfiguration	TokenNameIdentifier	 XML Parser Configuration
)	TokenNameRPAREN	
ObjectFactory	TokenNameIdentifier	 Object Factory
.	TokenNameDOT	
newInstance	TokenNameIdentifier	 new Instance
(	TokenNameLPAREN	
parserName	TokenNameIdentifier	 parser Name
,	TokenNameCOMMA	
ObjectFactory	TokenNameIdentifier	 Object Factory
.	TokenNameDOT	
findClassLoader	TokenNameIdentifier	 find Class Loader
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// use the same symbol table, error reporter, entity resolver, security manager and buffer size. 	TokenNameCOMMENT_LINE	use the same symbol table, error reporter, entity resolver, security manager and buffer size. 
if	TokenNameif	
(	TokenNameLPAREN	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
fChildConfig	TokenNameIdentifier	 f Child Config
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
SYMBOL_TABLE	TokenNameIdentifier	 SYMBOL  TABLE
,	TokenNameCOMMA	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
fChildConfig	TokenNameIdentifier	 f Child Config
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
ERROR_REPORTER	TokenNameIdentifier	 ERROR  REPORTER
,	TokenNameCOMMA	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityResolver	TokenNameIdentifier	 f Entity Resolver
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
fChildConfig	TokenNameIdentifier	 f Child Config
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
ENTITY_RESOLVER	TokenNameIdentifier	 ENTITY  RESOLVER
,	TokenNameCOMMA	
fEntityResolver	TokenNameIdentifier	 f Entity Resolver
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fChildConfig	TokenNameIdentifier	 f Child Config
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
SECURITY_MANAGER	TokenNameIdentifier	 SECURITY  MANAGER
,	TokenNameCOMMA	
fSecurityManager	TokenNameIdentifier	 f Security Manager
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fChildConfig	TokenNameIdentifier	 f Child Config
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
BUFFER_SIZE	TokenNameIdentifier	 BUFFER  SIZE
,	TokenNameCOMMA	
new	TokenNamenew	
Integer	TokenNameIdentifier	 Integer
(	TokenNameLPAREN	
fBufferSize	TokenNameIdentifier	 f Buffer Size
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// features must be copied to child configuration 	TokenNameCOMMENT_LINE	features must be copied to child configuration 
fNeedCopyFeatures	TokenNameIdentifier	 f Need Copy Features
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// use the same namespace context 	TokenNameCOMMENT_LINE	use the same namespace context 
fChildConfig	TokenNameIdentifier	 f Child Config
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
NAMESPACE_CONTEXT_PROPERTY	TokenNameIdentifier	 NAMESPACE  CONTEXT  PROPERTY
,	TokenNameCOMMA	
fNamespaceContext	TokenNameIdentifier	 f Namespace Context
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fChildConfig	TokenNameIdentifier	 f Child Config
.	TokenNameDOT	
setFeature	TokenNameIdentifier	 set Feature
(	TokenNameLPAREN	
XINCLUDE_FIXUP_BASE_URIS	TokenNameIdentifier	 XINCLUDE  FIXUP  BASE  URIS
,	TokenNameCOMMA	
fFixupBaseURIs	TokenNameIdentifier	 f Fixup Base UR Is
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fChildConfig	TokenNameIdentifier	 f Child Config
.	TokenNameDOT	
setFeature	TokenNameIdentifier	 set Feature
(	TokenNameLPAREN	
XINCLUDE_FIXUP_LANGUAGE	TokenNameIdentifier	 XINCLUDE  FIXUP  LANGUAGE
,	TokenNameCOMMA	
fFixupLanguage	TokenNameIdentifier	 f Fixup Language
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// If the xpointer attribute is present 	TokenNameCOMMENT_LINE	If the xpointer attribute is present 
if	TokenNameif	
(	TokenNameLPAREN	
xpointer	TokenNameIdentifier	 xpointer
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XPointerHandler	TokenNameIdentifier	 X Pointer Handler
newHandler	TokenNameIdentifier	 new Handler
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XPointerHandler	TokenNameIdentifier	 X Pointer Handler
)	TokenNameRPAREN	
fChildConfig	TokenNameIdentifier	 f Child Config
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XPOINTER_HANDLER_PROPERTY	TokenNameIdentifier	 XPOINTER  HANDLER  PROPERTY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fXPtrProcessor	TokenNameIdentifier	 f X Ptr Processor
=	TokenNameEQUAL	
newHandler	TokenNameIdentifier	 new Handler
;	TokenNameSEMICOLON	
// ??? 	TokenNameCOMMENT_LINE	??? 
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XPointerHandler	TokenNameIdentifier	 X Pointer Handler
)	TokenNameRPAREN	
fXPtrProcessor	TokenNameIdentifier	 f X Ptr Processor
)	TokenNameRPAREN	
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
NAMESPACE_CONTEXT_PROPERTY	TokenNameIdentifier	 NAMESPACE  CONTEXT  PROPERTY
,	TokenNameCOMMA	
fNamespaceContext	TokenNameIdentifier	 f Namespace Context
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XPointerHandler	TokenNameIdentifier	 X Pointer Handler
)	TokenNameRPAREN	
fXPtrProcessor	TokenNameIdentifier	 f X Ptr Processor
)	TokenNameRPAREN	
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
XINCLUDE_FIXUP_BASE_URIS	TokenNameIdentifier	 XINCLUDE  FIXUP  BASE  URIS
,	TokenNameCOMMA	
fFixupBaseURIs	TokenNameIdentifier	 f Fixup Base UR Is
?	TokenNameQUESTION	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
TRUE	TokenNameIdentifier	 TRUE
:	TokenNameCOLON	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
FALSE	TokenNameIdentifier	 FALSE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XPointerHandler	TokenNameIdentifier	 X Pointer Handler
)	TokenNameRPAREN	
fXPtrProcessor	TokenNameIdentifier	 f X Ptr Processor
)	TokenNameRPAREN	
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
XINCLUDE_FIXUP_LANGUAGE	TokenNameIdentifier	 XINCLUDE  FIXUP  LANGUAGE
,	TokenNameCOMMA	
fFixupLanguage	TokenNameIdentifier	 f Fixup Language
?	TokenNameQUESTION	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
TRUE	TokenNameIdentifier	 TRUE
:	TokenNameCOLON	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
FALSE	TokenNameIdentifier	 FALSE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XPointerHandler	TokenNameIdentifier	 X Pointer Handler
)	TokenNameRPAREN	
fXPtrProcessor	TokenNameIdentifier	 f X Ptr Processor
)	TokenNameRPAREN	
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
ERROR_REPORTER	TokenNameIdentifier	 ERROR  REPORTER
,	TokenNameCOMMA	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// ??? 	TokenNameCOMMENT_LINE	??? 
newHandler	TokenNameIdentifier	 new Handler
.	TokenNameDOT	
setParent	TokenNameIdentifier	 set Parent
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
newHandler	TokenNameIdentifier	 new Handler
.	TokenNameDOT	
setHref	TokenNameIdentifier	 set Href
(	TokenNameLPAREN	
href	TokenNameIdentifier	 href
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
newHandler	TokenNameIdentifier	 new Handler
.	TokenNameDOT	
setXIncludeLocator	TokenNameIdentifier	 set X Include Locator
(	TokenNameLPAREN	
fXIncludeLocator	TokenNameIdentifier	 f X Include Locator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
newHandler	TokenNameIdentifier	 new Handler
.	TokenNameDOT	
setDocumentHandler	TokenNameIdentifier	 set Document Handler
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
getDocumentHandler	TokenNameIdentifier	 get Document Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fXPointerChildConfig	TokenNameIdentifier	 f X Pointer Child Config
=	TokenNameEQUAL	
fChildConfig	TokenNameIdentifier	 f Child Config
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
XIncludeHandler	TokenNameIdentifier	 X Include Handler
newHandler	TokenNameIdentifier	 new Handler
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XIncludeHandler	TokenNameIdentifier	 X Include Handler
)	TokenNameRPAREN	
fChildConfig	TokenNameIdentifier	 f Child Config
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XINCLUDE_HANDLER_PROPERTY	TokenNameIdentifier	 XINCLUDE  HANDLER  PROPERTY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
newHandler	TokenNameIdentifier	 new Handler
.	TokenNameDOT	
setParent	TokenNameIdentifier	 set Parent
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
newHandler	TokenNameIdentifier	 new Handler
.	TokenNameDOT	
setHref	TokenNameIdentifier	 set Href
(	TokenNameLPAREN	
href	TokenNameIdentifier	 href
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
newHandler	TokenNameIdentifier	 new Handler
.	TokenNameDOT	
setXIncludeLocator	TokenNameIdentifier	 set X Include Locator
(	TokenNameLPAREN	
fXIncludeLocator	TokenNameIdentifier	 f X Include Locator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
newHandler	TokenNameIdentifier	 new Handler
.	TokenNameDOT	
setDocumentHandler	TokenNameIdentifier	 set Document Handler
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
getDocumentHandler	TokenNameIdentifier	 get Document Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fXIncludeChildConfig	TokenNameIdentifier	 f X Include Child Config
=	TokenNameEQUAL	
fChildConfig	TokenNameIdentifier	 f Child Config
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// If an xpointer attribute is present 	TokenNameCOMMENT_LINE	If an xpointer attribute is present 
if	TokenNameif	
(	TokenNameLPAREN	
xpointer	TokenNameIdentifier	 xpointer
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fChildConfig	TokenNameIdentifier	 f Child Config
=	TokenNameEQUAL	
fXPointerChildConfig	TokenNameIdentifier	 f X Pointer Child Config
;	TokenNameSEMICOLON	
// Parse the XPointer expression 	TokenNameCOMMENT_LINE	Parse the XPointer expression 
try	TokenNametry	
{	TokenNameLBRACE	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XPointerProcessor	TokenNameIdentifier	 X Pointer Processor
)	TokenNameRPAREN	
fXPtrProcessor	TokenNameIdentifier	 f X Ptr Processor
)	TokenNameRPAREN	
.	TokenNameDOT	
parseXPointer	TokenNameIdentifier	 parse X Pointer
(	TokenNameLPAREN	
xpointer	TokenNameIdentifier	 xpointer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XNIException	TokenNameIdentifier	 XNI Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// report the XPointer error as a resource error 	TokenNameCOMMENT_LINE	report the XPointer error as a resource error 
reportResourceError	TokenNameIdentifier	 report Resource Error
(	TokenNameLPAREN	
"XMLResourceError"	TokenNameStringLiteral	XMLResourceError
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
href	TokenNameIdentifier	 href
,	TokenNameCOMMA	
ex	TokenNameIdentifier	 ex
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fChildConfig	TokenNameIdentifier	 f Child Config
=	TokenNameEQUAL	
fXIncludeChildConfig	TokenNameIdentifier	 f X Include Child Config
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// set all features on parserConfig to match this parser configuration 	TokenNameCOMMENT_LINE	set all features on parserConfig to match this parser configuration 
if	TokenNameif	
(	TokenNameLPAREN	
fNeedCopyFeatures	TokenNameIdentifier	 f Need Copy Features
)	TokenNameRPAREN	
{	TokenNameLBRACE	
copyFeatures	TokenNameIdentifier	 copy Features
(	TokenNameLPAREN	
fSettings	TokenNameIdentifier	 f Settings
,	TokenNameCOMMA	
fChildConfig	TokenNameIdentifier	 f Child Config
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fNeedCopyFeatures	TokenNameIdentifier	 f Need Copy Features
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
fHasIncludeReportedContent	TokenNameIdentifier	 f Has Include Reported Content
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fNamespaceContext	TokenNameIdentifier	 f Namespace Context
.	TokenNameDOT	
pushScope	TokenNameIdentifier	 push Scope
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fChildConfig	TokenNameIdentifier	 f Child Config
.	TokenNameDOT	
parse	TokenNameIdentifier	 parse
(	TokenNameLPAREN	
includedSource	TokenNameIdentifier	 included Source
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// necessary to make sure proper location is reported to the application and in errors 	TokenNameCOMMENT_LINE	necessary to make sure proper location is reported to the application and in errors 
fXIncludeLocator	TokenNameIdentifier	 f X Include Locator
.	TokenNameDOT	
setLocator	TokenNameIdentifier	 set Locator
(	TokenNameLPAREN	
fDocLocation	TokenNameIdentifier	 f Doc Location
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
setDocumentLocator	TokenNameIdentifier	 set Document Locator
(	TokenNameLPAREN	
fDocLocation	TokenNameIdentifier	 f Doc Location
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// If the xpointer attribute is present 	TokenNameCOMMENT_LINE	If the xpointer attribute is present 
if	TokenNameif	
(	TokenNameLPAREN	
xpointer	TokenNameIdentifier	 xpointer
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// and it was not resolved 	TokenNameCOMMENT_LINE	and it was not resolved 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XPointerProcessor	TokenNameIdentifier	 X Pointer Processor
)	TokenNameRPAREN	
fXPtrProcessor	TokenNameIdentifier	 f X Ptr Processor
)	TokenNameRPAREN	
.	TokenNameDOT	
isXPointerResolved	TokenNameIdentifier	 is X Pointer Resolved
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Locale	TokenNameIdentifier	 Locale
locale	TokenNameIdentifier	 locale
=	TokenNameEQUAL	
(	TokenNameLPAREN	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
getLocale	TokenNameIdentifier	 get Locale
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
null	TokenNamenull	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
reason	TokenNameIdentifier	 reason
=	TokenNameEQUAL	
fXIncludeMessageFormatter	TokenNameIdentifier	 f X Include Message Formatter
.	TokenNameDOT	
formatMessage	TokenNameIdentifier	 format Message
(	TokenNameLPAREN	
locale	TokenNameIdentifier	 locale
,	TokenNameCOMMA	
"XPointerResolutionUnsuccessful"	TokenNameStringLiteral	XPointerResolutionUnsuccessful
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reportResourceError	TokenNameIdentifier	 report Resource Error
(	TokenNameLPAREN	
"XMLResourceError"	TokenNameStringLiteral	XMLResourceError
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
href	TokenNameIdentifier	 href
,	TokenNameCOMMA	
reason	TokenNameIdentifier	 reason
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// use the fallback 	TokenNameCOMMENT_LINE	use the fallback 
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XNIException	TokenNameIdentifier	 XNI Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// necessary to make sure proper location is reported to the application and in errors 	TokenNameCOMMENT_LINE	necessary to make sure proper location is reported to the application and in errors 
fXIncludeLocator	TokenNameIdentifier	 f X Include Locator
.	TokenNameDOT	
setLocator	TokenNameIdentifier	 set Locator
(	TokenNameLPAREN	
fDocLocation	TokenNameIdentifier	 f Doc Location
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
setDocumentLocator	TokenNameIdentifier	 set Document Locator
(	TokenNameLPAREN	
fDocLocation	TokenNameIdentifier	 f Doc Location
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"XMLParseError"	TokenNameStringLiteral	XMLParseError
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
href	TokenNameIdentifier	 href
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// necessary to make sure proper location is reported to the application and in errors 	TokenNameCOMMENT_LINE	necessary to make sure proper location is reported to the application and in errors 
fXIncludeLocator	TokenNameIdentifier	 f X Include Locator
.	TokenNameDOT	
setLocator	TokenNameIdentifier	 set Locator
(	TokenNameLPAREN	
fDocLocation	TokenNameIdentifier	 f Doc Location
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
setDocumentLocator	TokenNameIdentifier	 set Document Locator
(	TokenNameLPAREN	
fDocLocation	TokenNameIdentifier	 f Doc Location
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// If the start document event has been seen on the child pipeline it 	TokenNameCOMMENT_LINE	If the start document event has been seen on the child pipeline it 
// means the resource was successfully opened and we started reporting 	TokenNameCOMMENT_LINE	means the resource was successfully opened and we started reporting 
// document events. If an IOException is thrown after the start document 	TokenNameCOMMENT_LINE	document events. If an IOException is thrown after the start document 
// event we had a failure midstream and cannot recover. 	TokenNameCOMMENT_LINE	event we had a failure midstream and cannot recover. 
if	TokenNameif	
(	TokenNameLPAREN	
fHasIncludeReportedContent	TokenNameIdentifier	 f Has Include Reported Content
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XNIException	TokenNameIdentifier	 XNI Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// In other circumstances an IOException indicates that we had trouble 	TokenNameCOMMENT_LINE	In other circumstances an IOException indicates that we had trouble 
// accessing or opening the file, not that it was an invalid XML file. So we 	TokenNameCOMMENT_LINE	accessing or opening the file, not that it was an invalid XML file. So we 
// send a resource error, not a fatal error. 	TokenNameCOMMENT_LINE	send a resource error, not a fatal error. 
reportResourceError	TokenNameIdentifier	 report Resource Error
(	TokenNameLPAREN	
"XMLResourceError"	TokenNameStringLiteral	XMLResourceError
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
href	TokenNameIdentifier	 href
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
fNamespaceContext	TokenNameIdentifier	 f Namespace Context
.	TokenNameDOT	
popScope	TokenNameIdentifier	 pop Scope
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
parse	TokenNameIdentifier	 parse
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
XINCLUDE_PARSE_TEXT	TokenNameIdentifier	 XINCLUDE  PARSE  TEXT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// we only care about encoding for parse="text" 	TokenNameCOMMENT_LINE	we only care about encoding for parse="text" 
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
XINCLUDE_ATTR_ENCODING	TokenNameIdentifier	 XINCLUDE  ATTR  ENCODING
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
includedSource	TokenNameIdentifier	 included Source
.	TokenNameDOT	
setEncoding	TokenNameIdentifier	 set Encoding
(	TokenNameLPAREN	
encoding	TokenNameIdentifier	 encoding
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XIncludeTextReader	TokenNameIdentifier	 X Include Text Reader
textReader	TokenNameIdentifier	 text Reader
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
fHasIncludeReportedContent	TokenNameIdentifier	 f Has Include Reported Content
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// Setup the appropriate text reader. 	TokenNameCOMMENT_LINE	Setup the appropriate text reader. 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fIsXML11	TokenNameIdentifier	 f Is XM L11
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fXInclude10TextReader	TokenNameIdentifier	 f X Include10 Text Reader
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fXInclude10TextReader	TokenNameIdentifier	 f X Include10 Text Reader
=	TokenNameEQUAL	
new	TokenNamenew	
XIncludeTextReader	TokenNameIdentifier	 X Include Text Reader
(	TokenNameLPAREN	
includedSource	TokenNameIdentifier	 included Source
,	TokenNameCOMMA	
this	TokenNamethis	
,	TokenNameCOMMA	
fBufferSize	TokenNameIdentifier	 f Buffer Size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fXInclude10TextReader	TokenNameIdentifier	 f X Include10 Text Reader
.	TokenNameDOT	
setInputSource	TokenNameIdentifier	 set Input Source
(	TokenNameLPAREN	
includedSource	TokenNameIdentifier	 included Source
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
textReader	TokenNameIdentifier	 text Reader
=	TokenNameEQUAL	
fXInclude10TextReader	TokenNameIdentifier	 f X Include10 Text Reader
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fXInclude11TextReader	TokenNameIdentifier	 f X Include11 Text Reader
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fXInclude11TextReader	TokenNameIdentifier	 f X Include11 Text Reader
=	TokenNameEQUAL	
new	TokenNamenew	
XInclude11TextReader	TokenNameIdentifier	 X Include11 Text Reader
(	TokenNameLPAREN	
includedSource	TokenNameIdentifier	 included Source
,	TokenNameCOMMA	
this	TokenNamethis	
,	TokenNameCOMMA	
fBufferSize	TokenNameIdentifier	 f Buffer Size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fXInclude11TextReader	TokenNameIdentifier	 f X Include11 Text Reader
.	TokenNameDOT	
setInputSource	TokenNameIdentifier	 set Input Source
(	TokenNameLPAREN	
includedSource	TokenNameIdentifier	 included Source
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
textReader	TokenNameIdentifier	 text Reader
=	TokenNameEQUAL	
fXInclude11TextReader	TokenNameIdentifier	 f X Include11 Text Reader
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
textReader	TokenNameIdentifier	 text Reader
.	TokenNameDOT	
setErrorReporter	TokenNameIdentifier	 set Error Reporter
(	TokenNameLPAREN	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
textReader	TokenNameIdentifier	 text Reader
.	TokenNameDOT	
parse	TokenNameIdentifier	 parse
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// encoding errors 	TokenNameCOMMENT_LINE	encoding errors 
catch	TokenNamecatch	
(	TokenNameLPAREN	
MalformedByteSequenceException	TokenNameIdentifier	 Malformed Byte Sequence Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
ex	TokenNameIdentifier	 ex
.	TokenNameDOT	
getDomain	TokenNameIdentifier	 get Domain
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ex	TokenNameIdentifier	 ex
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ex	TokenNameIdentifier	 ex
.	TokenNameDOT	
getArguments	TokenNameIdentifier	 get Arguments
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_FATAL_ERROR	TokenNameIdentifier	 SEVERITY  FATAL  ERROR
,	TokenNameCOMMA	
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
CharConversionException	TokenNameIdentifier	 Char Conversion Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
"CharConversionFailure"	TokenNameStringLiteral	CharConversionFailure
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_FATAL_ERROR	TokenNameIdentifier	 SEVERITY  FATAL  ERROR
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If a characters event has already been sent down the pipeline it 	TokenNameCOMMENT_LINE	If a characters event has already been sent down the pipeline it 
// means the resource was successfully opened and that this IOException 	TokenNameCOMMENT_LINE	means the resource was successfully opened and that this IOException 
// is from a failure midstream from which we cannot recover. 	TokenNameCOMMENT_LINE	is from a failure midstream from which we cannot recover. 
if	TokenNameif	
(	TokenNameLPAREN	
fHasIncludeReportedContent	TokenNameIdentifier	 f Has Include Reported Content
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
XNIException	TokenNameIdentifier	 XNI Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
reportResourceError	TokenNameIdentifier	 report Resource Error
(	TokenNameLPAREN	
"TextResourceError"	TokenNameStringLiteral	TextResourceError
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
href	TokenNameIdentifier	 href
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
textReader	TokenNameIdentifier	 text Reader
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
textReader	TokenNameIdentifier	 text Reader
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportResourceError	TokenNameIdentifier	 report Resource Error
(	TokenNameLPAREN	
"TextResourceError"	TokenNameStringLiteral	TextResourceError
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
href	TokenNameIdentifier	 href
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"InvalidParseValue"	TokenNameStringLiteral	InvalidParseValue
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
parse	TokenNameIdentifier	 parse
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns true if the element has the namespace "http://www.w3.org/2001/XInclude" * @param element the element to check * @return true if the element has the namespace "http://www.w3.org/2001/XInclude" */	TokenNameCOMMENT_JAVADOC	 Returns true if the element has the namespace "http://www.w3.org/2001/XInclude" @param element the element to check @return true if the element has the namespace "http://www.w3.org/2001/XInclude" 
protected	TokenNameprotected	
boolean	TokenNameboolean	
hasXIncludeNamespace	TokenNameIdentifier	 has X Include Namespace
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// REVISIT: The namespace of this element should be bound 	TokenNameCOMMENT_LINE	REVISIT: The namespace of this element should be bound 
// already. Why are we looking it up from the namespace 	TokenNameCOMMENT_LINE	already. Why are we looking it up from the namespace 
// context? -- mrglavas 	TokenNameCOMMENT_LINE	context? -- mrglavas 
return	TokenNamereturn	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
==	TokenNameEQUAL_EQUAL	
XINCLUDE_NS_URI	TokenNameIdentifier	 XINCLUDE  NS  URI
||	TokenNameOR_OR	
fNamespaceContext	TokenNameIdentifier	 f Namespace Context
.	TokenNameDOT	
getURI	TokenNameIdentifier	 get URI
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
prefix	TokenNameIdentifier	 prefix
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XINCLUDE_NS_URI	TokenNameIdentifier	 XINCLUDE  NS  URI
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Checks if the element is an &lt;include&gt; element. The element must have * the XInclude namespace, and a local name of "include". * * @param element the element to check * @return true if the element is an &lt;include&gt; element * @see #hasXIncludeNamespace(QName) */	TokenNameCOMMENT_JAVADOC	 Checks if the element is an &lt;include&gt; element. The element must have the XInclude namespace, and a local name of "include". * @param element the element to check @return true if the element is an &lt;include&gt; element @see #hasXIncludeNamespace(QName) 
protected	TokenNameprotected	
boolean	TokenNameboolean	
isIncludeElement	TokenNameIdentifier	 is Include Element
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
XINCLUDE_INCLUDE	TokenNameIdentifier	 XINCLUDE  INCLUDE
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
hasXIncludeNamespace	TokenNameIdentifier	 has X Include Namespace
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Checks if the element is an &lt;fallback&gt; element. The element must have * the XInclude namespace, and a local name of "fallback". * * @param element the element to check * @return true if the element is an &lt;fallback; element * @see #hasXIncludeNamespace(QName) */	TokenNameCOMMENT_JAVADOC	 Checks if the element is an &lt;fallback&gt; element. The element must have the XInclude namespace, and a local name of "fallback". * @param element the element to check @return true if the element is an &lt;fallback; element @see #hasXIncludeNamespace(QName) 
protected	TokenNameprotected	
boolean	TokenNameboolean	
isFallbackElement	TokenNameIdentifier	 is Fallback Element
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
XINCLUDE_FALLBACK	TokenNameIdentifier	 XINCLUDE  FALLBACK
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
hasXIncludeNamespace	TokenNameIdentifier	 has X Include Namespace
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns true if the current [base URI] is the same as the [base URI] that * was in effect on the include parent. This method should <em>only</em> be called * when the current element is a top level included element, i.e. the direct child * of a fallback element, or the root elements in an included document. * The "include parent" is the element which, in the result infoset, will be the * direct parent of the current element. * @return true if the [base URIs] are the same string */	TokenNameCOMMENT_JAVADOC	 Returns true if the current [base URI] is the same as the [base URI] that was in effect on the include parent. This method should <em>only</em> be called when the current element is a top level included element, i.e. the direct child of a fallback element, or the root elements in an included document. The "include parent" is the element which, in the result infoset, will be the direct parent of the current element. @return true if the [base URIs] are the same string 
protected	TokenNameprotected	
boolean	TokenNameboolean	
sameBaseURIAsIncludeParent	TokenNameIdentifier	 same Base URI As Include Parent
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
parentBaseURI	TokenNameIdentifier	 parent Base URI
=	TokenNameEQUAL	
getIncludeParentBaseURI	TokenNameIdentifier	 get Include Parent Base URI
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
baseURI	TokenNameIdentifier	 base URI
=	TokenNameEQUAL	
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
.	TokenNameDOT	
getExpandedSystemId	TokenNameIdentifier	 get Expanded System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// REVISIT: should we use File#sameFile() ? 	TokenNameCOMMENT_LINE	REVISIT: should we use File#sameFile() ? 
// I think the benefit of using it is that it resolves host names 	TokenNameCOMMENT_LINE	I think the benefit of using it is that it resolves host names 
// instead of just doing a string comparison. 	TokenNameCOMMENT_LINE	instead of just doing a string comparison. 
// TODO: [base URI] is still an open issue with the working group. 	TokenNameCOMMENT_LINE	TODO: [base URI] is still an open issue with the working group. 
// They're deciding if xml:base should be added if the [base URI] is different in terms 	TokenNameCOMMENT_LINE	They're deciding if xml:base should be added if the [base URI] is different in terms 
// of resolving relative references, or if it should be added if they are different at all. 	TokenNameCOMMENT_LINE	of resolving relative references, or if it should be added if they are different at all. 
// Revisit this after a final decision has been made. 	TokenNameCOMMENT_LINE	Revisit this after a final decision has been made. 
// The decision also affects whether we output the file name of the URI, or just the path. 	TokenNameCOMMENT_LINE	The decision also affects whether we output the file name of the URI, or just the path. 
return	TokenNamereturn	
parentBaseURI	TokenNameIdentifier	 parent Base URI
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
parentBaseURI	TokenNameIdentifier	 parent Base URI
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
baseURI	TokenNameIdentifier	 base URI
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns true if the current [language] is equivalent to the [language] that * was in effect on the include parent, taking case-insensitivity into account * as per [RFC 3066]. This method should <em>only</em> be called when the * current element is a top level included element, i.e. the direct child * of a fallback element, or the root elements in an included document. * The "include parent" is the element which, in the result infoset, will be the * direct parent of the current element. * * @return true if the [language] properties have the same value * taking case-insensitivity into account as per [RFC 3066]. */	TokenNameCOMMENT_JAVADOC	 Returns true if the current [language] is equivalent to the [language] that was in effect on the include parent, taking case-insensitivity into account as per [RFC 3066]. This method should <em>only</em> be called when the current element is a top level included element, i.e. the direct child of a fallback element, or the root elements in an included document. The "include parent" is the element which, in the result infoset, will be the direct parent of the current element. * @return true if the [language] properties have the same value taking case-insensitivity into account as per [RFC 3066]. 
protected	TokenNameprotected	
boolean	TokenNameboolean	
sameLanguageAsIncludeParent	TokenNameIdentifier	 same Language As Include Parent
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
parentLanguage	TokenNameIdentifier	 parent Language
=	TokenNameEQUAL	
getIncludeParentLanguage	TokenNameIdentifier	 get Include Parent Language
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
parentLanguage	TokenNameIdentifier	 parent Language
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
parentLanguage	TokenNameIdentifier	 parent Language
.	TokenNameDOT	
equalsIgnoreCase	TokenNameIdentifier	 equals Ignore Case
(	TokenNameLPAREN	
fCurrentLanguage	TokenNameIdentifier	 f Current Language
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
setupCurrentBaseURI	TokenNameIdentifier	 setup Current Base URI
(	TokenNameLPAREN	
XMLLocator	TokenNameIdentifier	 XML Locator
locator	TokenNameIdentifier	 locator
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
.	TokenNameDOT	
setBaseSystemId	TokenNameIdentifier	 set Base System Id
(	TokenNameLPAREN	
locator	TokenNameIdentifier	 locator
.	TokenNameDOT	
getBaseSystemId	TokenNameIdentifier	 get Base System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
locator	TokenNameIdentifier	 locator
.	TokenNameDOT	
getLiteralSystemId	TokenNameIdentifier	 get Literal System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
.	TokenNameDOT	
setLiteralSystemId	TokenNameIdentifier	 set Literal System Id
(	TokenNameLPAREN	
locator	TokenNameIdentifier	 locator
.	TokenNameDOT	
getLiteralSystemId	TokenNameIdentifier	 get Literal System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
.	TokenNameDOT	
setLiteralSystemId	TokenNameIdentifier	 set Literal System Id
(	TokenNameLPAREN	
fHrefFromParent	TokenNameIdentifier	 f Href From Parent
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
expandedSystemId	TokenNameIdentifier	 expanded System Id
=	TokenNameEQUAL	
locator	TokenNameIdentifier	 locator
.	TokenNameDOT	
getExpandedSystemId	TokenNameIdentifier	 get Expanded System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
expandedSystemId	TokenNameIdentifier	 expanded System Id
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// attempt to expand it ourselves 	TokenNameCOMMENT_LINE	attempt to expand it ourselves 
try	TokenNametry	
{	TokenNameLBRACE	
expandedSystemId	TokenNameIdentifier	 expanded System Id
=	TokenNameEQUAL	
XMLEntityManager	TokenNameIdentifier	 XML Entity Manager
.	TokenNameDOT	
expandSystemId	TokenNameIdentifier	 expand System Id
(	TokenNameLPAREN	
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
.	TokenNameDOT	
getLiteralSystemId	TokenNameIdentifier	 get Literal System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
.	TokenNameDOT	
getBaseSystemId	TokenNameIdentifier	 get Base System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
expandedSystemId	TokenNameIdentifier	 expanded System Id
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
expandedSystemId	TokenNameIdentifier	 expanded System Id
=	TokenNameEQUAL	
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
.	TokenNameDOT	
getLiteralSystemId	TokenNameIdentifier	 get Literal System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
MalformedURIException	TokenNameIdentifier	 Malformed URI Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"ExpandedSystemId"	TokenNameStringLiteral	ExpandedSystemId
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
.	TokenNameDOT	
setExpandedSystemId	TokenNameIdentifier	 set Expanded System Id
(	TokenNameLPAREN	
expandedSystemId	TokenNameIdentifier	 expanded System Id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Checks if the file indicated by the given system id has already been * included in the current stack. * @param includedSysId the system id to check for inclusion * @return true if the source has already been included */	TokenNameCOMMENT_JAVADOC	 Checks if the file indicated by the given system id has already been included in the current stack. @param includedSysId the system id to check for inclusion @return true if the source has already been included 
protected	TokenNameprotected	
boolean	TokenNameboolean	
searchForRecursiveIncludes	TokenNameIdentifier	 search For Recursive Includes
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
includedSysId	TokenNameIdentifier	 included Sys Id
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
includedSysId	TokenNameIdentifier	 included Sys Id
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
.	TokenNameDOT	
getExpandedSystemId	TokenNameIdentifier	 get Expanded System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fParentXIncludeHandler	TokenNameIdentifier	 f Parent X Include Handler
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
fParentXIncludeHandler	TokenNameIdentifier	 f Parent X Include Handler
.	TokenNameDOT	
searchForRecursiveIncludes	TokenNameIdentifier	 search For Recursive Includes
(	TokenNameLPAREN	
includedSysId	TokenNameIdentifier	 included Sys Id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Returns true if the current element is a top level included item. This means * it's either the child of a fallback element, or the top level item in an * included document * @return true if the current element is a top level included item */	TokenNameCOMMENT_JAVADOC	 Returns true if the current element is a top level included item. This means it's either the child of a fallback element, or the top level item in an included document @return true if the current element is a top level included item 
protected	TokenNameprotected	
boolean	TokenNameboolean	
isTopLevelIncludedItem	TokenNameIdentifier	 is Top Level Included Item
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
isTopLevelIncludedItemViaInclude	TokenNameIdentifier	 is Top Level Included Item Via Include
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
isTopLevelIncludedItemViaFallback	TokenNameIdentifier	 is Top Level Included Item Via Fallback
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
boolean	TokenNameboolean	
isTopLevelIncludedItemViaInclude	TokenNameIdentifier	 is Top Level Included Item Via Include
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fDepth	TokenNameIdentifier	 f Depth
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
!	TokenNameNOT	
isRootDocument	TokenNameIdentifier	 is Root Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
boolean	TokenNameboolean	
isTopLevelIncludedItemViaFallback	TokenNameIdentifier	 is Top Level Included Item Via Fallback
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Technically, this doesn't check if the parent was a fallback, it also 	TokenNameCOMMENT_LINE	Technically, this doesn't check if the parent was a fallback, it also 
// would return true if any of the parent's sibling elements were fallbacks. 	TokenNameCOMMENT_LINE	would return true if any of the parent's sibling elements were fallbacks. 
// However, this doesn't matter, since we will always be ignoring elements 	TokenNameCOMMENT_LINE	However, this doesn't matter, since we will always be ignoring elements 
// whose parent's siblings were fallbacks. 	TokenNameCOMMENT_LINE	whose parent's siblings were fallbacks. 
return	TokenNamereturn	
getSawFallback	TokenNameIdentifier	 get Saw Fallback
(	TokenNameLPAREN	
fDepth	TokenNameIdentifier	 f Depth
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Processes the XMLAttributes object of startElement() calls. Performs the following tasks: * <ul> * <li> If the element is a top level included item whose [base URI] is different from the * [base URI] of the include parent, then an xml:base attribute is added to specify the * true [base URI] * <li> For all namespace prefixes which are in-scope in an included item, but not in scope * in the include parent, a xmlns:prefix attribute is added * <li> For all attributes with a type of ENTITY, ENTITIES or NOTATIONS, the notations and * unparsed entities are processed as described in the spec, sections 4.5.1 and 4.5.2 * </ul> * @param attributes * @return the processed XMLAttributes */	TokenNameCOMMENT_JAVADOC	 Processes the XMLAttributes object of startElement() calls. Performs the following tasks: <ul> <li> If the element is a top level included item whose [base URI] is different from the [base URI] of the include parent, then an xml:base attribute is added to specify the true [base URI] <li> For all namespace prefixes which are in-scope in an included item, but not in scope in the include parent, a xmlns:prefix attribute is added <li> For all attributes with a type of ENTITY, ENTITIES or NOTATIONS, the notations and unparsed entities are processed as described in the spec, sections 4.5.1 and 4.5.2 </ul> @param attributes @return the processed XMLAttributes 
protected	TokenNameprotected	
XMLAttributes	TokenNameIdentifier	 XML Attributes
processAttributes	TokenNameIdentifier	 process Attributes
(	TokenNameLPAREN	
XMLAttributes	TokenNameIdentifier	 XML Attributes
attributes	TokenNameIdentifier	 attributes
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isTopLevelIncludedItem	TokenNameIdentifier	 is Top Level Included Item
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Modify attributes to fix the base URI (spec 4.5.5). 	TokenNameCOMMENT_LINE	Modify attributes to fix the base URI (spec 4.5.5). 
// We only do it to top level included elements, which have a different 	TokenNameCOMMENT_LINE	We only do it to top level included elements, which have a different 
// base URI than their include parent. 	TokenNameCOMMENT_LINE	base URI than their include parent. 
if	TokenNameif	
(	TokenNameLPAREN	
fFixupBaseURIs	TokenNameIdentifier	 f Fixup Base UR Is
&&	TokenNameAND_AND	
!	TokenNameNOT	
sameBaseURIAsIncludeParent	TokenNameIdentifier	 same Base URI As Include Parent
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
attributes	TokenNameIdentifier	 attributes
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
attributes	TokenNameIdentifier	 attributes
=	TokenNameEQUAL	
new	TokenNamenew	
XMLAttributesImpl	TokenNameIdentifier	 XML Attributes Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// This causes errors with schema validation, if the schema doesn't 	TokenNameCOMMENT_LINE	This causes errors with schema validation, if the schema doesn't 
// specify that these elements can have an xml:base attribute 	TokenNameCOMMENT_LINE	specify that these elements can have an xml:base attribute 
String	TokenNameIdentifier	 String
uri	TokenNameIdentifier	 uri
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
uri	TokenNameIdentifier	 uri
=	TokenNameEQUAL	
this	TokenNamethis	
.	TokenNameDOT	
getRelativeBaseURI	TokenNameIdentifier	 get Relative Base URI
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
MalformedURIException	TokenNameIdentifier	 Malformed URI Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// this shouldn't ever happen, since by definition, we had to traverse 	TokenNameCOMMENT_LINE	this shouldn't ever happen, since by definition, we had to traverse 
// the same URIs to even get to this place 	TokenNameCOMMENT_LINE	the same URIs to even get to this place 
uri	TokenNameIdentifier	 uri
=	TokenNameEQUAL	
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
.	TokenNameDOT	
getExpandedSystemId	TokenNameIdentifier	 get Expanded System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
XML_BASE_QNAME	TokenNameIdentifier	 XML  BASE  QNAME
,	TokenNameCOMMA	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
fCDATASymbol	TokenNameIdentifier	 f CDATA Symbol
,	TokenNameCOMMA	
uri	TokenNameIdentifier	 uri
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
setSpecified	TokenNameIdentifier	 set Specified
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Modify attributes to perform language-fixup (spec 4.5.6). 	TokenNameCOMMENT_LINE	Modify attributes to perform language-fixup (spec 4.5.6). 
// We only do it to top level included elements, which have a different 	TokenNameCOMMENT_LINE	We only do it to top level included elements, which have a different 
// [language] than their include parent. 	TokenNameCOMMENT_LINE	[language] than their include parent. 
if	TokenNameif	
(	TokenNameLPAREN	
fFixupLanguage	TokenNameIdentifier	 f Fixup Language
&&	TokenNameAND_AND	
!	TokenNameNOT	
sameLanguageAsIncludeParent	TokenNameIdentifier	 same Language As Include Parent
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
attributes	TokenNameIdentifier	 attributes
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
attributes	TokenNameIdentifier	 attributes
=	TokenNameEQUAL	
new	TokenNamenew	
XMLAttributesImpl	TokenNameIdentifier	 XML Attributes Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
XML_LANG_QNAME	TokenNameIdentifier	 XML  LANG  QNAME
,	TokenNameCOMMA	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
fCDATASymbol	TokenNameIdentifier	 f CDATA Symbol
,	TokenNameCOMMA	
fCurrentLanguage	TokenNameIdentifier	 f Current Language
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
setSpecified	TokenNameIdentifier	 set Specified
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Modify attributes of included items to do namespace-fixup. (spec 4.5.4) 	TokenNameCOMMENT_LINE	Modify attributes of included items to do namespace-fixup. (spec 4.5.4) 
Enumeration	TokenNameIdentifier	 Enumeration
inscopeNS	TokenNameIdentifier	 inscope NS
=	TokenNameEQUAL	
fNamespaceContext	TokenNameIdentifier	 f Namespace Context
.	TokenNameDOT	
getAllPrefixes	TokenNameIdentifier	 get All Prefixes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
inscopeNS	TokenNameIdentifier	 inscope NS
.	TokenNameDOT	
hasMoreElements	TokenNameIdentifier	 has More Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
prefix	TokenNameIdentifier	 prefix
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
inscopeNS	TokenNameIdentifier	 inscope NS
.	TokenNameDOT	
nextElement	TokenNameIdentifier	 next Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
parentURI	TokenNameIdentifier	 parent URI
=	TokenNameEQUAL	
fNamespaceContext	TokenNameIdentifier	 f Namespace Context
.	TokenNameDOT	
getURIFromIncludeParent	TokenNameIdentifier	 get URI From Include Parent
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
uri	TokenNameIdentifier	 uri
=	TokenNameEQUAL	
fNamespaceContext	TokenNameIdentifier	 f Namespace Context
.	TokenNameDOT	
getURI	TokenNameIdentifier	 get URI
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
parentURI	TokenNameIdentifier	 parent URI
!=	TokenNameNOT_EQUAL	
uri	TokenNameIdentifier	 uri
&&	TokenNameAND_AND	
attributes	TokenNameIdentifier	 attributes
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
==	TokenNameEQUAL_EQUAL	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
EMPTY_STRING	TokenNameIdentifier	 EMPTY  STRING
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
NamespaceContext	TokenNameIdentifier	 Namespace Context
.	TokenNameDOT	
XMLNS_URI	TokenNameIdentifier	 XMLNS  URI
,	TokenNameCOMMA	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
PREFIX_XMLNS	TokenNameIdentifier	 PREFIX  XMLNS
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
attributes	TokenNameIdentifier	 attributes
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
attributes	TokenNameIdentifier	 attributes
=	TokenNameEQUAL	
new	TokenNamenew	
XMLAttributesImpl	TokenNameIdentifier	 XML Attributes Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
QName	TokenNameIdentifier	 Q Name
ns	TokenNameIdentifier	 ns
=	TokenNameEQUAL	
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
)	TokenNameRPAREN	
NEW_NS_ATTR_QNAME	TokenNameIdentifier	 NEW  NS  ATTR  QNAME
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ns	TokenNameIdentifier	 ns
.	TokenNameDOT	
prefix	TokenNameIdentifier	 prefix
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
ns	TokenNameIdentifier	 ns
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
=	TokenNameEQUAL	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
PREFIX_XMLNS	TokenNameIdentifier	 PREFIX  XMLNS
;	TokenNameSEMICOLON	
ns	TokenNameIdentifier	 ns
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
=	TokenNameEQUAL	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
PREFIX_XMLNS	TokenNameIdentifier	 PREFIX  XMLNS
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
ns	TokenNameIdentifier	 ns
,	TokenNameCOMMA	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
fCDATASymbol	TokenNameIdentifier	 f CDATA Symbol
,	TokenNameCOMMA	
uri	TokenNameIdentifier	 uri
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
uri	TokenNameIdentifier	 uri
:	TokenNameCOLON	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
EMPTY_STRING	TokenNameIdentifier	 EMPTY  STRING
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
setSpecified	TokenNameIdentifier	 set Specified
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Need to re-declare this prefix in the current context 	TokenNameCOMMENT_LINE	Need to re-declare this prefix in the current context 
// in order for the SAX parser to report the appropriate 	TokenNameCOMMENT_LINE	in order for the SAX parser to report the appropriate 
// start and end prefix mapping events. -- mrglavas 	TokenNameCOMMENT_LINE	start and end prefix mapping events. -- mrglavas 
fNamespaceContext	TokenNameIdentifier	 f Namespace Context
.	TokenNameDOT	
declarePrefix	TokenNameIdentifier	 declare Prefix
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
,	TokenNameCOMMA	
uri	TokenNameIdentifier	 uri
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
NamespaceContext	TokenNameIdentifier	 Namespace Context
.	TokenNameDOT	
XMLNS_URI	TokenNameIdentifier	 XMLNS  URI
,	TokenNameCOMMA	
prefix	TokenNameIdentifier	 prefix
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
attributes	TokenNameIdentifier	 attributes
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
attributes	TokenNameIdentifier	 attributes
=	TokenNameEQUAL	
new	TokenNamenew	
XMLAttributesImpl	TokenNameIdentifier	 XML Attributes Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
QName	TokenNameIdentifier	 Q Name
ns	TokenNameIdentifier	 ns
=	TokenNameEQUAL	
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
)	TokenNameRPAREN	
NEW_NS_ATTR_QNAME	TokenNameIdentifier	 NEW  NS  ATTR  QNAME
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ns	TokenNameIdentifier	 ns
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
=	TokenNameEQUAL	
prefix	TokenNameIdentifier	 prefix
;	TokenNameSEMICOLON	
ns	TokenNameIdentifier	 ns
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
+=	TokenNamePLUS_EQUAL	
prefix	TokenNameIdentifier	 prefix
;	TokenNameSEMICOLON	
ns	TokenNameIdentifier	 ns
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
=	TokenNameEQUAL	
(	TokenNameLPAREN	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
.	TokenNameDOT	
addSymbol	TokenNameIdentifier	 add Symbol
(	TokenNameLPAREN	
ns	TokenNameIdentifier	 ns
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
)	TokenNameRPAREN	
:	TokenNameCOLON	
ns	TokenNameIdentifier	 ns
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
.	TokenNameDOT	
intern	TokenNameIdentifier	 intern
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
ns	TokenNameIdentifier	 ns
,	TokenNameCOMMA	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
fCDATASymbol	TokenNameIdentifier	 f CDATA Symbol
,	TokenNameCOMMA	
uri	TokenNameIdentifier	 uri
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
uri	TokenNameIdentifier	 uri
:	TokenNameCOLON	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
EMPTY_STRING	TokenNameIdentifier	 EMPTY  STRING
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
setSpecified	TokenNameIdentifier	 set Specified
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Need to re-declare this prefix in the current context 	TokenNameCOMMENT_LINE	Need to re-declare this prefix in the current context 
// in order for the SAX parser to report the appropriate 	TokenNameCOMMENT_LINE	in order for the SAX parser to report the appropriate 
// start and end prefix mapping events. -- mrglavas 	TokenNameCOMMENT_LINE	start and end prefix mapping events. -- mrglavas 
fNamespaceContext	TokenNameIdentifier	 f Namespace Context
.	TokenNameDOT	
declarePrefix	TokenNameIdentifier	 declare Prefix
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
,	TokenNameCOMMA	
uri	TokenNameIdentifier	 uri
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
attributes	TokenNameIdentifier	 attributes
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
fENTITYSymbol	TokenNameIdentifier	 f ENTITY Symbol
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
checkUnparsedEntity	TokenNameIdentifier	 check Unparsed Entity
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
fENTITIESSymbol	TokenNameIdentifier	 f ENTITIES Symbol
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 4.5.1 - Unparsed Entities 	TokenNameCOMMENT_LINE	4.5.1 - Unparsed Entities 
StringTokenizer	TokenNameIdentifier	 String Tokenizer
st	TokenNameIdentifier	 st
=	TokenNameEQUAL	
new	TokenNamenew	
StringTokenizer	TokenNameIdentifier	 String Tokenizer
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
st	TokenNameIdentifier	 st
.	TokenNameDOT	
hasMoreTokens	TokenNameIdentifier	 has More Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
entName	TokenNameIdentifier	 ent Name
=	TokenNameEQUAL	
st	TokenNameIdentifier	 st
.	TokenNameDOT	
nextToken	TokenNameIdentifier	 next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
checkUnparsedEntity	TokenNameIdentifier	 check Unparsed Entity
(	TokenNameLPAREN	
entName	TokenNameIdentifier	 ent Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
fNOTATIONSymbol	TokenNameIdentifier	 f NOTATION Symbol
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 4.5.2 - Notations 	TokenNameCOMMENT_LINE	4.5.2 - Notations 
this	TokenNamethis	
.	TokenNameDOT	
checkNotation	TokenNameIdentifier	 check Notation
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* We actually don't need to do anything for 4.5.3, because at this stage the * value of the attribute is just a string. It will be taken care of later * in the pipeline, when the IDREFs are actually resolved against IDs. * * if (type == XMLSymbols.fIDREFSymbol || type == XMLSymbols.fIDREFSSymbol) { } */	TokenNameCOMMENT_BLOCK	 We actually don't need to do anything for 4.5.3, because at this stage the value of the attribute is just a string. It will be taken care of later in the pipeline, when the IDREFs are actually resolved against IDs. * if (type == XMLSymbols.fIDREFSymbol || type == XMLSymbols.fIDREFSSymbol) { } 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
attributes	TokenNameIdentifier	 attributes
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns a URI, relative to the include parent's base URI, of the current * [base URI]. For instance, if the current [base URI] was "dir1/dir2/file.xml" * and the include parent's [base URI] was "dir/", this would return "dir2/file.xml". * @return the relative URI */	TokenNameCOMMENT_JAVADOC	 Returns a URI, relative to the include parent's base URI, of the current [base URI]. For instance, if the current [base URI] was "dir1/dir2/file.xml" and the include parent's [base URI] was "dir/", this would return "dir2/file.xml". @return the relative URI 
protected	TokenNameprotected	
String	TokenNameIdentifier	 String
getRelativeBaseURI	TokenNameIdentifier	 get Relative Base URI
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
MalformedURIException	TokenNameIdentifier	 Malformed URI Exception
{	TokenNameLBRACE	
int	TokenNameint	
includeParentDepth	TokenNameIdentifier	 include Parent Depth
=	TokenNameEQUAL	
getIncludeParentDepth	TokenNameIdentifier	 get Include Parent Depth
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
relativeURI	TokenNameIdentifier	 relative URI
=	TokenNameEQUAL	
this	TokenNamethis	
.	TokenNameDOT	
getRelativeURI	TokenNameIdentifier	 get Relative URI
(	TokenNameLPAREN	
includeParentDepth	TokenNameIdentifier	 include Parent Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isRootDocument	TokenNameIdentifier	 is Root Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
relativeURI	TokenNameIdentifier	 relative URI
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
relativeURI	TokenNameIdentifier	 relative URI
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
relativeURI	TokenNameIdentifier	 relative URI
=	TokenNameEQUAL	
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
.	TokenNameDOT	
getLiteralSystemId	TokenNameIdentifier	 get Literal System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
includeParentDepth	TokenNameIdentifier	 include Parent Depth
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fParentRelativeURI	TokenNameIdentifier	 f Parent Relative URI
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fParentRelativeURI	TokenNameIdentifier	 f Parent Relative URI
=	TokenNameEQUAL	
fParentXIncludeHandler	TokenNameIdentifier	 f Parent X Include Handler
.	TokenNameDOT	
getRelativeBaseURI	TokenNameIdentifier	 get Relative Base URI
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fParentRelativeURI	TokenNameIdentifier	 f Parent Relative URI
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
relativeURI	TokenNameIdentifier	 relative URI
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
URI	TokenNameIdentifier	 URI
base	TokenNameIdentifier	 base
=	TokenNameEQUAL	
new	TokenNamenew	
URI	TokenNameIdentifier	 URI
(	TokenNameLPAREN	
fParentRelativeURI	TokenNameIdentifier	 f Parent Relative URI
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
URI	TokenNameIdentifier	 URI
uri	TokenNameIdentifier	 uri
=	TokenNameEQUAL	
new	TokenNamenew	
URI	TokenNameIdentifier	 URI
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
relativeURI	TokenNameIdentifier	 relative URI
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Check whether the scheme components are equal. */	TokenNameCOMMENT_JAVADOC	 Check whether the scheme components are equal. 
final	TokenNamefinal	
String	TokenNameIdentifier	 String
baseScheme	TokenNameIdentifier	 base Scheme
=	TokenNameEQUAL	
base	TokenNameIdentifier	 base
.	TokenNameDOT	
getScheme	TokenNameIdentifier	 get Scheme
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
literalScheme	TokenNameIdentifier	 literal Scheme
=	TokenNameEQUAL	
uri	TokenNameIdentifier	 uri
.	TokenNameDOT	
getScheme	TokenNameIdentifier	 get Scheme
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isEqual	TokenNameIdentifier	 is Equal
(	TokenNameLPAREN	
baseScheme	TokenNameIdentifier	 base Scheme
,	TokenNameCOMMA	
literalScheme	TokenNameIdentifier	 literal Scheme
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
relativeURI	TokenNameIdentifier	 relative URI
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Check whether the authority components are equal. */	TokenNameCOMMENT_JAVADOC	 Check whether the authority components are equal. 
final	TokenNamefinal	
String	TokenNameIdentifier	 String
baseAuthority	TokenNameIdentifier	 base Authority
=	TokenNameEQUAL	
base	TokenNameIdentifier	 base
.	TokenNameDOT	
getAuthority	TokenNameIdentifier	 get Authority
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
literalAuthority	TokenNameIdentifier	 literal Authority
=	TokenNameEQUAL	
uri	TokenNameIdentifier	 uri
.	TokenNameDOT	
getAuthority	TokenNameIdentifier	 get Authority
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isEqual	TokenNameIdentifier	 is Equal
(	TokenNameLPAREN	
baseAuthority	TokenNameIdentifier	 base Authority
,	TokenNameCOMMA	
literalAuthority	TokenNameIdentifier	 literal Authority
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
uri	TokenNameIdentifier	 uri
.	TokenNameDOT	
getSchemeSpecificPart	TokenNameIdentifier	 get Scheme Specific Part
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The scheme and authority components are equal, * return the path and the possible query and/or * fragment which follow. */	TokenNameCOMMENT_JAVADOC	 The scheme and authority components are equal, return the path and the possible query and/or fragment which follow. 
final	TokenNamefinal	
String	TokenNameIdentifier	 String
literalPath	TokenNameIdentifier	 literal Path
=	TokenNameEQUAL	
uri	TokenNameIdentifier	 uri
.	TokenNameDOT	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
literalQuery	TokenNameIdentifier	 literal Query
=	TokenNameEQUAL	
uri	TokenNameIdentifier	 uri
.	TokenNameDOT	
getQueryString	TokenNameIdentifier	 get Query String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
literalFragment	TokenNameIdentifier	 literal Fragment
=	TokenNameEQUAL	
uri	TokenNameIdentifier	 uri
.	TokenNameDOT	
getFragment	TokenNameIdentifier	 get Fragment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
literalQuery	TokenNameIdentifier	 literal Query
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
literalFragment	TokenNameIdentifier	 literal Fragment
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StringBuffer	TokenNameIdentifier	 String Buffer
buffer	TokenNameIdentifier	 buffer
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
literalPath	TokenNameIdentifier	 literal Path
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
literalPath	TokenNameIdentifier	 literal Path
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
literalQuery	TokenNameIdentifier	 literal Query
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'?'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
literalQuery	TokenNameIdentifier	 literal Query
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
literalFragment	TokenNameIdentifier	 literal Fragment
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'#'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
literalFragment	TokenNameIdentifier	 literal Fragment
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
literalPath	TokenNameIdentifier	 literal Path
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
relativeURI	TokenNameIdentifier	 relative URI
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Returns the [base URI] of the include parent. * @return the base URI of the include parent. */	TokenNameCOMMENT_JAVADOC	 Returns the [base URI] of the include parent. @return the base URI of the include parent. 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
getIncludeParentBaseURI	TokenNameIdentifier	 get Include Parent Base URI
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
depth	TokenNameIdentifier	 depth
=	TokenNameEQUAL	
getIncludeParentDepth	TokenNameIdentifier	 get Include Parent Depth
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isRootDocument	TokenNameIdentifier	 is Root Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
depth	TokenNameIdentifier	 depth
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fParentXIncludeHandler	TokenNameIdentifier	 f Parent X Include Handler
.	TokenNameDOT	
getIncludeParentBaseURI	TokenNameIdentifier	 get Include Parent Base URI
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
this	TokenNamethis	
.	TokenNameDOT	
getBaseURI	TokenNameIdentifier	 get Base URI
(	TokenNameLPAREN	
depth	TokenNameIdentifier	 depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Returns the [language] of the include parent. * * @return the language property of the include parent. */	TokenNameCOMMENT_JAVADOC	 Returns the [language] of the include parent. * @return the language property of the include parent. 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
getIncludeParentLanguage	TokenNameIdentifier	 get Include Parent Language
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
depth	TokenNameIdentifier	 depth
=	TokenNameEQUAL	
getIncludeParentDepth	TokenNameIdentifier	 get Include Parent Depth
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isRootDocument	TokenNameIdentifier	 is Root Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
depth	TokenNameIdentifier	 depth
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fParentXIncludeHandler	TokenNameIdentifier	 f Parent X Include Handler
.	TokenNameDOT	
getIncludeParentLanguage	TokenNameIdentifier	 get Include Parent Language
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
getLanguage	TokenNameIdentifier	 get Language
(	TokenNameLPAREN	
depth	TokenNameIdentifier	 depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Returns the depth of the include parent. Here, the include parent is * calculated as the last non-include or non-fallback element. It is assumed * this method is called when the current element is a top level included item. * Returning 0 indicates that the top level element in this document * was an include element. * @return the depth of the top level include element */	TokenNameCOMMENT_JAVADOC	 Returns the depth of the include parent. Here, the include parent is calculated as the last non-include or non-fallback element. It is assumed this method is called when the current element is a top level included item. Returning 0 indicates that the top level element in this document was an include element. @return the depth of the top level include element 
private	TokenNameprivate	
int	TokenNameint	
getIncludeParentDepth	TokenNameIdentifier	 get Include Parent Depth
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// We don't start at fDepth, since it is either the top level included item, 	TokenNameCOMMENT_LINE	We don't start at fDepth, since it is either the top level included item, 
// or an include element, when this method is called. 	TokenNameCOMMENT_LINE	or an include element, when this method is called. 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
fDepth	TokenNameIdentifier	 f Depth
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// This technically might not always return the first non-include/fallback 	TokenNameCOMMENT_LINE	This technically might not always return the first non-include/fallback 
// element that it comes to, since sawFallback() returns true if a fallback 	TokenNameCOMMENT_LINE	element that it comes to, since sawFallback() returns true if a fallback 
// was ever encountered at that depth. However, if a fallback was encountered 	TokenNameCOMMENT_LINE	was ever encountered at that depth. However, if a fallback was encountered 
// at that depth, and it wasn't the direct descendant of the current element 	TokenNameCOMMENT_LINE	at that depth, and it wasn't the direct descendant of the current element 
// then we can't be in a situation where we're calling this method (because 	TokenNameCOMMENT_LINE	then we can't be in a situation where we're calling this method (because 
// we'll always be in STATE_IGNORE) 	TokenNameCOMMENT_LINE	we'll always be in STATE_IGNORE) 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
getSawInclude	TokenNameIdentifier	 get Saw Include
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
getSawFallback	TokenNameIdentifier	 get Saw Fallback
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// shouldn't get here, since depth 0 should never have an include element or 	TokenNameCOMMENT_LINE	shouldn't get here, since depth 0 should never have an include element or 
// a fallback element 	TokenNameCOMMENT_LINE	a fallback element 
return	TokenNamereturn	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the current element depth of the result infoset. */	TokenNameCOMMENT_JAVADOC	 Returns the current element depth of the result infoset. 
private	TokenNameprivate	
int	TokenNameint	
getResultDepth	TokenNameIdentifier	 get Result Depth
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fResultDepth	TokenNameIdentifier	 f Result Depth
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Modify the augmentations. Add an [included] infoset item, if the current * element is a top level included item. * @param augs the Augmentations to modify. * @return the modified Augmentations */	TokenNameCOMMENT_JAVADOC	 Modify the augmentations. Add an [included] infoset item, if the current element is a top level included item. @param augs the Augmentations to modify. @return the modified Augmentations 
protected	TokenNameprotected	
Augmentations	TokenNameIdentifier	 Augmentations
modifyAugmentations	TokenNameIdentifier	 modify Augmentations
(	TokenNameLPAREN	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
modifyAugmentations	TokenNameIdentifier	 modify Augmentations
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Modify the augmentations. Add an [included] infoset item, if <code>force</code> * is true, or if the current element is a top level included item. * @param augs the Augmentations to modify. * @param force whether to force modification * @return the modified Augmentations */	TokenNameCOMMENT_JAVADOC	 Modify the augmentations. Add an [included] infoset item, if <code>force</code> is true, or if the current element is a top level included item. @param augs the Augmentations to modify. @param force whether to force modification @return the modified Augmentations 
protected	TokenNameprotected	
Augmentations	TokenNameIdentifier	 Augmentations
modifyAugmentations	TokenNameIdentifier	 modify Augmentations
(	TokenNameLPAREN	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
,	TokenNameCOMMA	
boolean	TokenNameboolean	
force	TokenNameIdentifier	 force
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
force	TokenNameIdentifier	 force
||	TokenNameOR_OR	
isTopLevelIncludedItem	TokenNameIdentifier	 is Top Level Included Item
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
augs	TokenNameIdentifier	 augs
=	TokenNameEQUAL	
new	TokenNamenew	
AugmentationsImpl	TokenNameIdentifier	 Augmentations Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
augs	TokenNameIdentifier	 augs
.	TokenNameDOT	
putItem	TokenNameIdentifier	 put Item
(	TokenNameLPAREN	
XINCLUDE_INCLUDED	TokenNameIdentifier	 XINCLUDE  INCLUDED
,	TokenNameCOMMA	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
TRUE	TokenNameIdentifier	 TRUE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
augs	TokenNameIdentifier	 augs
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
int	TokenNameint	
getState	TokenNameIdentifier	 get State
(	TokenNameLPAREN	
int	TokenNameint	
depth	TokenNameIdentifier	 depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fState	TokenNameIdentifier	 f State
[	TokenNameLBRACKET	
depth	TokenNameIdentifier	 depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
int	TokenNameint	
getState	TokenNameIdentifier	 get State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fState	TokenNameIdentifier	 f State
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
setState	TokenNameIdentifier	 set State
(	TokenNameLPAREN	
int	TokenNameint	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDepth	TokenNameIdentifier	 f Depth
>=	TokenNameGREATER_EQUAL	
fState	TokenNameIdentifier	 f State
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newarray	TokenNameIdentifier	 newarray
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fState	TokenNameIdentifier	 f State
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newarray	TokenNameIdentifier	 newarray
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fState	TokenNameIdentifier	 f State
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fState	TokenNameIdentifier	 f State
=	TokenNameEQUAL	
newarray	TokenNameIdentifier	 newarray
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fState	TokenNameIdentifier	 f State
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
state	TokenNameIdentifier	 state
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Records that an &lt;fallback&gt; was encountered at the specified depth, * as an ancestor of the current element, or as a sibling of an ancestor of the * current element. * * @param depth * @param val */	TokenNameCOMMENT_JAVADOC	 Records that an &lt;fallback&gt; was encountered at the specified depth, as an ancestor of the current element, or as a sibling of an ancestor of the current element. * @param depth @param val 
protected	TokenNameprotected	
void	TokenNamevoid	
setSawFallback	TokenNameIdentifier	 set Saw Fallback
(	TokenNameLPAREN	
int	TokenNameint	
depth	TokenNameIdentifier	 depth
,	TokenNameCOMMA	
boolean	TokenNameboolean	
val	TokenNameIdentifier	 val
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
depth	TokenNameIdentifier	 depth
>=	TokenNameGREATER_EQUAL	
fSawFallback	TokenNameIdentifier	 f Saw Fallback
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newarray	TokenNameIdentifier	 newarray
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
depth	TokenNameIdentifier	 depth
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fSawFallback	TokenNameIdentifier	 f Saw Fallback
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newarray	TokenNameIdentifier	 newarray
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fSawFallback	TokenNameIdentifier	 f Saw Fallback
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fSawFallback	TokenNameIdentifier	 f Saw Fallback
=	TokenNameEQUAL	
newarray	TokenNameIdentifier	 newarray
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fSawFallback	TokenNameIdentifier	 f Saw Fallback
[	TokenNameLBRACKET	
depth	TokenNameIdentifier	 depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
val	TokenNameIdentifier	 val
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns whether an &lt;fallback&gt; was encountered at the specified depth, * as an ancestor of the current element, or as a sibling of an ancestor of the * current element. * * @param depth */	TokenNameCOMMENT_JAVADOC	 Returns whether an &lt;fallback&gt; was encountered at the specified depth, as an ancestor of the current element, or as a sibling of an ancestor of the current element. * @param depth 
protected	TokenNameprotected	
boolean	TokenNameboolean	
getSawFallback	TokenNameIdentifier	 get Saw Fallback
(	TokenNameLPAREN	
int	TokenNameint	
depth	TokenNameIdentifier	 depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
depth	TokenNameIdentifier	 depth
>=	TokenNameGREATER_EQUAL	
fSawFallback	TokenNameIdentifier	 f Saw Fallback
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
fSawFallback	TokenNameIdentifier	 f Saw Fallback
[	TokenNameLBRACKET	
depth	TokenNameIdentifier	 depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Records that an &lt;include&gt; was encountered at the specified depth, * as an ancestor of the current item. * * @param depth * @param val */	TokenNameCOMMENT_JAVADOC	 Records that an &lt;include&gt; was encountered at the specified depth, as an ancestor of the current item. * @param depth @param val 
protected	TokenNameprotected	
void	TokenNamevoid	
setSawInclude	TokenNameIdentifier	 set Saw Include
(	TokenNameLPAREN	
int	TokenNameint	
depth	TokenNameIdentifier	 depth
,	TokenNameCOMMA	
boolean	TokenNameboolean	
val	TokenNameIdentifier	 val
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
depth	TokenNameIdentifier	 depth
>=	TokenNameGREATER_EQUAL	
fSawInclude	TokenNameIdentifier	 f Saw Include
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newarray	TokenNameIdentifier	 newarray
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
depth	TokenNameIdentifier	 depth
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fSawInclude	TokenNameIdentifier	 f Saw Include
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newarray	TokenNameIdentifier	 newarray
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fSawInclude	TokenNameIdentifier	 f Saw Include
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fSawInclude	TokenNameIdentifier	 f Saw Include
=	TokenNameEQUAL	
newarray	TokenNameIdentifier	 newarray
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fSawInclude	TokenNameIdentifier	 f Saw Include
[	TokenNameLBRACKET	
depth	TokenNameIdentifier	 depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
val	TokenNameIdentifier	 val
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return whether an &lt;include&gt; was encountered at the specified depth, * as an ancestor of the current item. * * @param depth * @return true if an include was seen at the given depth, false otherwise */	TokenNameCOMMENT_JAVADOC	 Return whether an &lt;include&gt; was encountered at the specified depth, as an ancestor of the current item. * @param depth @return true if an include was seen at the given depth, false otherwise 
protected	TokenNameprotected	
boolean	TokenNameboolean	
getSawInclude	TokenNameIdentifier	 get Saw Include
(	TokenNameLPAREN	
int	TokenNameint	
depth	TokenNameIdentifier	 depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
depth	TokenNameIdentifier	 depth
>=	TokenNameGREATER_EQUAL	
fSawInclude	TokenNameIdentifier	 f Saw Include
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
fSawInclude	TokenNameIdentifier	 f Saw Include
[	TokenNameLBRACKET	
depth	TokenNameIdentifier	 depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
reportResourceError	TokenNameIdentifier	 report Resource Error
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
reportResourceError	TokenNameIdentifier	 report Resource Error
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
reportResourceError	TokenNameIdentifier	 report Resource Error
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
args	TokenNameIdentifier	 args
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
reportResourceError	TokenNameIdentifier	 report Resource Error
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
args	TokenNameIdentifier	 args
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
reportResourceError	TokenNameIdentifier	 report Resource Error
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
args	TokenNameIdentifier	 args
,	TokenNameCOMMA	
Exception	TokenNameIdentifier	 Exception
exception	TokenNameIdentifier	 exception
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
args	TokenNameIdentifier	 args
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_WARNING	TokenNameIdentifier	 SEVERITY  WARNING
,	TokenNameCOMMA	
exception	TokenNameIdentifier	 exception
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
args	TokenNameIdentifier	 args
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
args	TokenNameIdentifier	 args
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
args	TokenNameIdentifier	 args
,	TokenNameCOMMA	
Exception	TokenNameIdentifier	 Exception
exception	TokenNameIdentifier	 exception
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
args	TokenNameIdentifier	 args
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_FATAL_ERROR	TokenNameIdentifier	 SEVERITY  FATAL  ERROR
,	TokenNameCOMMA	
exception	TokenNameIdentifier	 exception
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
args	TokenNameIdentifier	 args
,	TokenNameCOMMA	
short	TokenNameshort	
severity	TokenNameIdentifier	 severity
,	TokenNameCOMMA	
Exception	TokenNameIdentifier	 Exception
exception	TokenNameIdentifier	 exception
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XIncludeMessageFormatter	TokenNameIdentifier	 X Include Message Formatter
.	TokenNameDOT	
XINCLUDE_DOMAIN	TokenNameIdentifier	 XINCLUDE  DOMAIN
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
args	TokenNameIdentifier	 args
,	TokenNameCOMMA	
severity	TokenNameIdentifier	 severity
,	TokenNameCOMMA	
exception	TokenNameIdentifier	 exception
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// we won't worry about when error reporter is null, since there should always be 	TokenNameCOMMENT_LINE	we won't worry about when error reporter is null, since there should always be 
// at least the default error reporter 	TokenNameCOMMENT_LINE	at least the default error reporter 
}	TokenNameRBRACE	
/** * Set the parent of this XIncludeHandler in the tree * @param parent */	TokenNameCOMMENT_JAVADOC	 Set the parent of this XIncludeHandler in the tree @param parent 
protected	TokenNameprotected	
void	TokenNamevoid	
setParent	TokenNameIdentifier	 set Parent
(	TokenNameLPAREN	
XIncludeHandler	TokenNameIdentifier	 X Include Handler
parent	TokenNameIdentifier	 parent
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fParentXIncludeHandler	TokenNameIdentifier	 f Parent X Include Handler
=	TokenNameEQUAL	
parent	TokenNameIdentifier	 parent
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
setHref	TokenNameIdentifier	 set Href
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
href	TokenNameIdentifier	 href
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fHrefFromParent	TokenNameIdentifier	 f Href From Parent
=	TokenNameEQUAL	
href	TokenNameIdentifier	 href
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
setXIncludeLocator	TokenNameIdentifier	 set X Include Locator
(	TokenNameLPAREN	
XMLLocatorWrapper	TokenNameIdentifier	 XML Locator Wrapper
locator	TokenNameIdentifier	 locator
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fXIncludeLocator	TokenNameIdentifier	 f X Include Locator
=	TokenNameEQUAL	
locator	TokenNameIdentifier	 locator
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// used to know whether to pass declarations to the document handler 	TokenNameCOMMENT_LINE	used to know whether to pass declarations to the document handler 
protected	TokenNameprotected	
boolean	TokenNameboolean	
isRootDocument	TokenNameIdentifier	 is Root Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fParentXIncludeHandler	TokenNameIdentifier	 f Parent X Include Handler
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Caches an unparsed entity. * @param name the name of the unparsed entity * @param identifier the location of the unparsed entity * @param augmentations any Augmentations that were on the original unparsed entity declaration */	TokenNameCOMMENT_JAVADOC	 Caches an unparsed entity. @param name the name of the unparsed entity @param identifier the location of the unparsed entity @param augmentations any Augmentations that were on the original unparsed entity declaration 
protected	TokenNameprotected	
void	TokenNamevoid	
addUnparsedEntity	TokenNameIdentifier	 add Unparsed Entity
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
XMLResourceIdentifier	TokenNameIdentifier	 XML Resource Identifier
identifier	TokenNameIdentifier	 identifier
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
notation	TokenNameIdentifier	 notation
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
{	TokenNameLBRACE	
UnparsedEntity	TokenNameIdentifier	 Unparsed Entity
ent	TokenNameIdentifier	 ent
=	TokenNameEQUAL	
new	TokenNamenew	
UnparsedEntity	TokenNameIdentifier	 Unparsed Entity
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ent	TokenNameIdentifier	 ent
.	TokenNameDOT	
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
name	TokenNameIdentifier	 name
;	TokenNameSEMICOLON	
ent	TokenNameIdentifier	 ent
.	TokenNameDOT	
systemId	TokenNameIdentifier	 system Id
=	TokenNameEQUAL	
identifier	TokenNameIdentifier	 identifier
.	TokenNameDOT	
getLiteralSystemId	TokenNameIdentifier	 get Literal System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ent	TokenNameIdentifier	 ent
.	TokenNameDOT	
publicId	TokenNameIdentifier	 public Id
=	TokenNameEQUAL	
identifier	TokenNameIdentifier	 identifier
.	TokenNameDOT	
getPublicId	TokenNameIdentifier	 get Public Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ent	TokenNameIdentifier	 ent
.	TokenNameDOT	
baseURI	TokenNameIdentifier	 base URI
=	TokenNameEQUAL	
identifier	TokenNameIdentifier	 identifier
.	TokenNameDOT	
getBaseSystemId	TokenNameIdentifier	 get Base System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ent	TokenNameIdentifier	 ent
.	TokenNameDOT	
expandedSystemId	TokenNameIdentifier	 expanded System Id
=	TokenNameEQUAL	
identifier	TokenNameIdentifier	 identifier
.	TokenNameDOT	
getExpandedSystemId	TokenNameIdentifier	 get Expanded System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ent	TokenNameIdentifier	 ent
.	TokenNameDOT	
notation	TokenNameIdentifier	 notation
=	TokenNameEQUAL	
notation	TokenNameIdentifier	 notation
;	TokenNameSEMICOLON	
ent	TokenNameIdentifier	 ent
.	TokenNameDOT	
augmentations	TokenNameIdentifier	 augmentations
=	TokenNameEQUAL	
augmentations	TokenNameIdentifier	 augmentations
;	TokenNameSEMICOLON	
fUnparsedEntities	TokenNameIdentifier	 f Unparsed Entities
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
ent	TokenNameIdentifier	 ent
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Caches a notation. * @param name the name of the notation * @param identifier the location of the notation * @param augmentations any Augmentations that were on the original notation declaration */	TokenNameCOMMENT_JAVADOC	 Caches a notation. @param name the name of the notation @param identifier the location of the notation @param augmentations any Augmentations that were on the original notation declaration 
protected	TokenNameprotected	
void	TokenNamevoid	
addNotation	TokenNameIdentifier	 add Notation
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
XMLResourceIdentifier	TokenNameIdentifier	 XML Resource Identifier
identifier	TokenNameIdentifier	 identifier
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Notation	TokenNameIdentifier	 Notation
not	TokenNameIdentifier	 not
=	TokenNameEQUAL	
new	TokenNamenew	
Notation	TokenNameIdentifier	 Notation
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
not	TokenNameIdentifier	 not
.	TokenNameDOT	
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
name	TokenNameIdentifier	 name
;	TokenNameSEMICOLON	
not	TokenNameIdentifier	 not
.	TokenNameDOT	
systemId	TokenNameIdentifier	 system Id
=	TokenNameEQUAL	
identifier	TokenNameIdentifier	 identifier
.	TokenNameDOT	
getLiteralSystemId	TokenNameIdentifier	 get Literal System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
not	TokenNameIdentifier	 not
.	TokenNameDOT	
publicId	TokenNameIdentifier	 public Id
=	TokenNameEQUAL	
identifier	TokenNameIdentifier	 identifier
.	TokenNameDOT	
getPublicId	TokenNameIdentifier	 get Public Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
not	TokenNameIdentifier	 not
.	TokenNameDOT	
baseURI	TokenNameIdentifier	 base URI
=	TokenNameEQUAL	
identifier	TokenNameIdentifier	 identifier
.	TokenNameDOT	
getBaseSystemId	TokenNameIdentifier	 get Base System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
not	TokenNameIdentifier	 not
.	TokenNameDOT	
expandedSystemId	TokenNameIdentifier	 expanded System Id
=	TokenNameEQUAL	
identifier	TokenNameIdentifier	 identifier
.	TokenNameDOT	
getExpandedSystemId	TokenNameIdentifier	 get Expanded System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
not	TokenNameIdentifier	 not
.	TokenNameDOT	
augmentations	TokenNameIdentifier	 augmentations
=	TokenNameEQUAL	
augmentations	TokenNameIdentifier	 augmentations
;	TokenNameSEMICOLON	
fNotations	TokenNameIdentifier	 f Notations
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
not	TokenNameIdentifier	 not
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Checks if an UnparsedEntity with the given name was declared in the DTD of the document * for the current pipeline. If so, then the notation for the UnparsedEntity is checked. * If that turns out okay, then the UnparsedEntity is passed to the root pipeline to * be checked for conflicts, and sent to the root DTDHandler. * * @param entName the name of the UnparsedEntity to check */	TokenNameCOMMENT_JAVADOC	 Checks if an UnparsedEntity with the given name was declared in the DTD of the document for the current pipeline. If so, then the notation for the UnparsedEntity is checked. If that turns out okay, then the UnparsedEntity is passed to the root pipeline to be checked for conflicts, and sent to the root DTDHandler. * @param entName the name of the UnparsedEntity to check 
protected	TokenNameprotected	
void	TokenNamevoid	
checkUnparsedEntity	TokenNameIdentifier	 check Unparsed Entity
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
entName	TokenNameIdentifier	 ent Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
UnparsedEntity	TokenNameIdentifier	 Unparsed Entity
ent	TokenNameIdentifier	 ent
=	TokenNameEQUAL	
new	TokenNamenew	
UnparsedEntity	TokenNameIdentifier	 Unparsed Entity
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ent	TokenNameIdentifier	 ent
.	TokenNameDOT	
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
entName	TokenNameIdentifier	 ent Name
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
fUnparsedEntities	TokenNameIdentifier	 f Unparsed Entities
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
ent	TokenNameIdentifier	 ent
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ent	TokenNameIdentifier	 ent
=	TokenNameEQUAL	
(	TokenNameLPAREN	
UnparsedEntity	TokenNameIdentifier	 Unparsed Entity
)	TokenNameRPAREN	
fUnparsedEntities	TokenNameIdentifier	 f Unparsed Entities
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// first check the notation of the unparsed entity 	TokenNameCOMMENT_LINE	first check the notation of the unparsed entity 
checkNotation	TokenNameIdentifier	 check Notation
(	TokenNameLPAREN	
ent	TokenNameIdentifier	 ent
.	TokenNameDOT	
notation	TokenNameIdentifier	 notation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
checkAndSendUnparsedEntity	TokenNameIdentifier	 check And Send Unparsed Entity
(	TokenNameLPAREN	
ent	TokenNameIdentifier	 ent
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Checks if a Notation with the given name was declared in the DTD of the document * for the current pipeline. If so, that Notation is passed to the root pipeline to * be checked for conflicts, and sent to the root DTDHandler * * @param notName the name of the Notation to check */	TokenNameCOMMENT_JAVADOC	 Checks if a Notation with the given name was declared in the DTD of the document for the current pipeline. If so, that Notation is passed to the root pipeline to be checked for conflicts, and sent to the root DTDHandler * @param notName the name of the Notation to check 
protected	TokenNameprotected	
void	TokenNamevoid	
checkNotation	TokenNameIdentifier	 check Notation
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
notName	TokenNameIdentifier	 not Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Notation	TokenNameIdentifier	 Notation
not	TokenNameIdentifier	 not
=	TokenNameEQUAL	
new	TokenNamenew	
Notation	TokenNameIdentifier	 Notation
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
not	TokenNameIdentifier	 not
.	TokenNameDOT	
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
notName	TokenNameIdentifier	 not Name
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
fNotations	TokenNameIdentifier	 f Notations
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
not	TokenNameIdentifier	 not
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
not	TokenNameIdentifier	 not
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Notation	TokenNameIdentifier	 Notation
)	TokenNameRPAREN	
fNotations	TokenNameIdentifier	 f Notations
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
checkAndSendNotation	TokenNameIdentifier	 check And Send Notation
(	TokenNameLPAREN	
not	TokenNameIdentifier	 not
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * The purpose of this method is to check if an UnparsedEntity conflicts with a previously * declared entity in the current pipeline stack. If there is no conflict, the * UnparsedEntity is sent by the root pipeline. * * @param ent the UnparsedEntity to check for conflicts */	TokenNameCOMMENT_JAVADOC	 The purpose of this method is to check if an UnparsedEntity conflicts with a previously declared entity in the current pipeline stack. If there is no conflict, the UnparsedEntity is sent by the root pipeline. * @param ent the UnparsedEntity to check for conflicts 
protected	TokenNameprotected	
void	TokenNamevoid	
checkAndSendUnparsedEntity	TokenNameIdentifier	 check And Send Unparsed Entity
(	TokenNameLPAREN	
UnparsedEntity	TokenNameIdentifier	 Unparsed Entity
ent	TokenNameIdentifier	 ent
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isRootDocument	TokenNameIdentifier	 is Root Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
fUnparsedEntities	TokenNameIdentifier	 f Unparsed Entities
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
ent	TokenNameIdentifier	 ent
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// There is no unparsed entity with the same name that we have sent. 	TokenNameCOMMENT_LINE	There is no unparsed entity with the same name that we have sent. 
// Calling unparsedEntityDecl() will add the entity to our local store, 	TokenNameCOMMENT_LINE	Calling unparsedEntityDecl() will add the entity to our local store, 
// and also send the unparsed entity to the DTDHandler 	TokenNameCOMMENT_LINE	and also send the unparsed entity to the DTDHandler 
XMLResourceIdentifier	TokenNameIdentifier	 XML Resource Identifier
id	TokenNameIdentifier	 id
=	TokenNameEQUAL	
new	TokenNamenew	
XMLResourceIdentifierImpl	TokenNameIdentifier	 XML Resource Identifier Impl
(	TokenNameLPAREN	
ent	TokenNameIdentifier	 ent
.	TokenNameDOT	
publicId	TokenNameIdentifier	 public Id
,	TokenNameCOMMA	
ent	TokenNameIdentifier	 ent
.	TokenNameDOT	
systemId	TokenNameIdentifier	 system Id
,	TokenNameCOMMA	
ent	TokenNameIdentifier	 ent
.	TokenNameDOT	
baseURI	TokenNameIdentifier	 base URI
,	TokenNameCOMMA	
ent	TokenNameIdentifier	 ent
.	TokenNameDOT	
expandedSystemId	TokenNameIdentifier	 expanded System Id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
addUnparsedEntity	TokenNameIdentifier	 add Unparsed Entity
(	TokenNameLPAREN	
ent	TokenNameIdentifier	 ent
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
id	TokenNameIdentifier	 id
,	TokenNameCOMMA	
ent	TokenNameIdentifier	 ent
.	TokenNameDOT	
notation	TokenNameIdentifier	 notation
,	TokenNameCOMMA	
ent	TokenNameIdentifier	 ent
.	TokenNameDOT	
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fSendUEAndNotationEvents	TokenNameIdentifier	 f Send UE And Notation Events
&&	TokenNameAND_AND	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
unparsedEntityDecl	TokenNameIdentifier	 unparsed Entity Decl
(	TokenNameLPAREN	
ent	TokenNameIdentifier	 ent
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
id	TokenNameIdentifier	 id
,	TokenNameCOMMA	
ent	TokenNameIdentifier	 ent
.	TokenNameDOT	
notation	TokenNameIdentifier	 notation
,	TokenNameCOMMA	
ent	TokenNameIdentifier	 ent
.	TokenNameDOT	
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
UnparsedEntity	TokenNameIdentifier	 Unparsed Entity
localEntity	TokenNameIdentifier	 local Entity
=	TokenNameEQUAL	
(	TokenNameLPAREN	
UnparsedEntity	TokenNameIdentifier	 Unparsed Entity
)	TokenNameRPAREN	
fUnparsedEntities	TokenNameIdentifier	 f Unparsed Entities
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
ent	TokenNameIdentifier	 ent
.	TokenNameDOT	
isDuplicate	TokenNameIdentifier	 is Duplicate
(	TokenNameLPAREN	
localEntity	TokenNameIdentifier	 local Entity
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"NonDuplicateUnparsedEntity"	TokenNameStringLiteral	NonDuplicateUnparsedEntity
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
ent	TokenNameIdentifier	 ent
.	TokenNameDOT	
name	TokenNameIdentifier	 name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fParentXIncludeHandler	TokenNameIdentifier	 f Parent X Include Handler
.	TokenNameDOT	
checkAndSendUnparsedEntity	TokenNameIdentifier	 check And Send Unparsed Entity
(	TokenNameLPAREN	
ent	TokenNameIdentifier	 ent
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * The purpose of this method is to check if a Notation conflicts with a previously * declared notation in the current pipeline stack. If there is no conflict, the * Notation is sent by the root pipeline. * * @param not the Notation to check for conflicts */	TokenNameCOMMENT_JAVADOC	 The purpose of this method is to check if a Notation conflicts with a previously declared notation in the current pipeline stack. If there is no conflict, the Notation is sent by the root pipeline. * @param not the Notation to check for conflicts 
protected	TokenNameprotected	
void	TokenNamevoid	
checkAndSendNotation	TokenNameIdentifier	 check And Send Notation
(	TokenNameLPAREN	
Notation	TokenNameIdentifier	 Notation
not	TokenNameIdentifier	 not
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isRootDocument	TokenNameIdentifier	 is Root Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
fNotations	TokenNameIdentifier	 f Notations
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
not	TokenNameIdentifier	 not
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// There is no notation with the same name that we have sent. 	TokenNameCOMMENT_LINE	There is no notation with the same name that we have sent. 
XMLResourceIdentifier	TokenNameIdentifier	 XML Resource Identifier
id	TokenNameIdentifier	 id
=	TokenNameEQUAL	
new	TokenNamenew	
XMLResourceIdentifierImpl	TokenNameIdentifier	 XML Resource Identifier Impl
(	TokenNameLPAREN	
not	TokenNameIdentifier	 not
.	TokenNameDOT	
publicId	TokenNameIdentifier	 public Id
,	TokenNameCOMMA	
not	TokenNameIdentifier	 not
.	TokenNameDOT	
systemId	TokenNameIdentifier	 system Id
,	TokenNameCOMMA	
not	TokenNameIdentifier	 not
.	TokenNameDOT	
baseURI	TokenNameIdentifier	 base URI
,	TokenNameCOMMA	
not	TokenNameIdentifier	 not
.	TokenNameDOT	
expandedSystemId	TokenNameIdentifier	 expanded System Id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
addNotation	TokenNameIdentifier	 add Notation
(	TokenNameLPAREN	
not	TokenNameIdentifier	 not
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
id	TokenNameIdentifier	 id
,	TokenNameCOMMA	
not	TokenNameIdentifier	 not
.	TokenNameDOT	
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fSendUEAndNotationEvents	TokenNameIdentifier	 f Send UE And Notation Events
&&	TokenNameAND_AND	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDHandler	TokenNameIdentifier	 f DTD Handler
.	TokenNameDOT	
notationDecl	TokenNameIdentifier	 notation Decl
(	TokenNameLPAREN	
not	TokenNameIdentifier	 not
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
id	TokenNameIdentifier	 id
,	TokenNameCOMMA	
not	TokenNameIdentifier	 not
.	TokenNameDOT	
augmentations	TokenNameIdentifier	 augmentations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
Notation	TokenNameIdentifier	 Notation
localNotation	TokenNameIdentifier	 local Notation
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Notation	TokenNameIdentifier	 Notation
)	TokenNameRPAREN	
fNotations	TokenNameIdentifier	 f Notations
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
not	TokenNameIdentifier	 not
.	TokenNameDOT	
isDuplicate	TokenNameIdentifier	 is Duplicate
(	TokenNameLPAREN	
localNotation	TokenNameIdentifier	 local Notation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"NonDuplicateNotation"	TokenNameStringLiteral	NonDuplicateNotation
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
not	TokenNameIdentifier	 not
.	TokenNameDOT	
name	TokenNameIdentifier	 name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fParentXIncludeHandler	TokenNameIdentifier	 f Parent X Include Handler
.	TokenNameDOT	
checkAndSendNotation	TokenNameIdentifier	 check And Send Notation
(	TokenNameLPAREN	
not	TokenNameIdentifier	 not
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Checks whether the string only contains white space characters. * * @param value the text to check */	TokenNameCOMMENT_JAVADOC	 Checks whether the string only contains white space characters. * @param value the text to check 
private	TokenNameprivate	
void	TokenNamevoid	
checkWhitespace	TokenNameIdentifier	 check Whitespace
(	TokenNameLPAREN	
XMLString	TokenNameIdentifier	 XML String
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
end	TokenNameIdentifier	 end
=	TokenNameEQUAL	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
+	TokenNamePLUS	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
end	TokenNameIdentifier	 end
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
XMLChar	TokenNameIdentifier	 XML Char
.	TokenNameDOT	
isSpace	TokenNameIdentifier	 is Space
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"ContentIllegalAtTopLevel"	TokenNameStringLiteral	ContentIllegalAtTopLevel
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Checks whether the root element has already been processed. */	TokenNameCOMMENT_JAVADOC	 Checks whether the root element has already been processed. 
private	TokenNameprivate	
void	TokenNamevoid	
checkMultipleRootElements	TokenNameIdentifier	 check Multiple Root Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
getRootElementProcessed	TokenNameIdentifier	 get Root Element Processed
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportFatalError	TokenNameIdentifier	 report Fatal Error
(	TokenNameLPAREN	
"MultipleRootElements"	TokenNameStringLiteral	MultipleRootElements
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
setRootElementProcessed	TokenNameIdentifier	 set Root Element Processed
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets whether the root element has been processed. */	TokenNameCOMMENT_JAVADOC	 Sets whether the root element has been processed. 
private	TokenNameprivate	
void	TokenNamevoid	
setRootElementProcessed	TokenNameIdentifier	 set Root Element Processed
(	TokenNameLPAREN	
boolean	TokenNameboolean	
seenRoot	TokenNameIdentifier	 seen Root
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isRootDocument	TokenNameIdentifier	 is Root Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSeenRootElement	TokenNameIdentifier	 f Seen Root Element
=	TokenNameEQUAL	
seenRoot	TokenNameIdentifier	 seen Root
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fParentXIncludeHandler	TokenNameIdentifier	 f Parent X Include Handler
.	TokenNameDOT	
setRootElementProcessed	TokenNameIdentifier	 set Root Element Processed
(	TokenNameLPAREN	
seenRoot	TokenNameIdentifier	 seen Root
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns whether the root element has been processed. */	TokenNameCOMMENT_JAVADOC	 Returns whether the root element has been processed. 
private	TokenNameprivate	
boolean	TokenNameboolean	
getRootElementProcessed	TokenNameIdentifier	 get Root Element Processed
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
isRootDocument	TokenNameIdentifier	 is Root Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
fSeenRootElement	TokenNameIdentifier	 f Seen Root Element
:	TokenNameCOLON	
fParentXIncludeHandler	TokenNameIdentifier	 f Parent X Include Handler
.	TokenNameDOT	
getRootElementProcessed	TokenNameIdentifier	 get Root Element Processed
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// It would be nice if we didn't have to repeat code like this, but there's no interface that has 	TokenNameCOMMENT_LINE	It would be nice if we didn't have to repeat code like this, but there's no interface that has 
// setFeature() and addRecognizedFeatures() that the objects have in common. 	TokenNameCOMMENT_LINE	setFeature() and addRecognizedFeatures() that the objects have in common. 
protected	TokenNameprotected	
void	TokenNamevoid	
copyFeatures	TokenNameIdentifier	 copy Features
(	TokenNameLPAREN	
XMLComponentManager	TokenNameIdentifier	 XML Component Manager
from	TokenNameIdentifier	 from
,	TokenNameCOMMA	
ParserConfigurationSettings	TokenNameIdentifier	 Parser Configuration Settings
to	TokenNameIdentifier	 to
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Enumeration	TokenNameIdentifier	 Enumeration
features	TokenNameIdentifier	 features
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
getXercesFeatures	TokenNameIdentifier	 get Xerces Features
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
copyFeatures1	TokenNameIdentifier	 copy Features1
(	TokenNameLPAREN	
features	TokenNameIdentifier	 features
,	TokenNameCOMMA	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
,	TokenNameCOMMA	
from	TokenNameIdentifier	 from
,	TokenNameCOMMA	
to	TokenNameIdentifier	 to
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
features	TokenNameIdentifier	 features
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
getSAXFeatures	TokenNameIdentifier	 get SAX Features
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
copyFeatures1	TokenNameIdentifier	 copy Features1
(	TokenNameLPAREN	
features	TokenNameIdentifier	 features
,	TokenNameCOMMA	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SAX_FEATURE_PREFIX	TokenNameIdentifier	 SAX  FEATURE  PREFIX
,	TokenNameCOMMA	
from	TokenNameIdentifier	 from
,	TokenNameCOMMA	
to	TokenNameIdentifier	 to
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
copyFeatures	TokenNameIdentifier	 copy Features
(	TokenNameLPAREN	
XMLComponentManager	TokenNameIdentifier	 XML Component Manager
from	TokenNameIdentifier	 from
,	TokenNameCOMMA	
XMLParserConfiguration	TokenNameIdentifier	 XML Parser Configuration
to	TokenNameIdentifier	 to
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Enumeration	TokenNameIdentifier	 Enumeration
features	TokenNameIdentifier	 features
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
getXercesFeatures	TokenNameIdentifier	 get Xerces Features
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
copyFeatures1	TokenNameIdentifier	 copy Features1
(	TokenNameLPAREN	
features	TokenNameIdentifier	 features
,	TokenNameCOMMA	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
,	TokenNameCOMMA	
from	TokenNameIdentifier	 from
,	TokenNameCOMMA	
to	TokenNameIdentifier	 to
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
features	TokenNameIdentifier	 features
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
getSAXFeatures	TokenNameIdentifier	 get SAX Features
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
copyFeatures1	TokenNameIdentifier	 copy Features1
(	TokenNameLPAREN	
features	TokenNameIdentifier	 features
,	TokenNameCOMMA	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SAX_FEATURE_PREFIX	TokenNameIdentifier	 SAX  FEATURE  PREFIX
,	TokenNameCOMMA	
from	TokenNameIdentifier	 from
,	TokenNameCOMMA	
to	TokenNameIdentifier	 to
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
copyFeatures1	TokenNameIdentifier	 copy Features1
(	TokenNameLPAREN	
Enumeration	TokenNameIdentifier	 Enumeration
features	TokenNameIdentifier	 features
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
featurePrefix	TokenNameIdentifier	 feature Prefix
,	TokenNameCOMMA	
XMLComponentManager	TokenNameIdentifier	 XML Component Manager
from	TokenNameIdentifier	 from
,	TokenNameCOMMA	
ParserConfigurationSettings	TokenNameIdentifier	 Parser Configuration Settings
to	TokenNameIdentifier	 to
)	TokenNameRPAREN	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
features	TokenNameIdentifier	 features
.	TokenNameDOT	
hasMoreElements	TokenNameIdentifier	 has More Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
featureId	TokenNameIdentifier	 feature Id
=	TokenNameEQUAL	
featurePrefix	TokenNameIdentifier	 feature Prefix
+	TokenNamePLUS	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
features	TokenNameIdentifier	 features
.	TokenNameDOT	
nextElement	TokenNameIdentifier	 next Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
to	TokenNameIdentifier	 to
.	TokenNameDOT	
addRecognizedFeatures	TokenNameIdentifier	 add Recognized Features
(	TokenNameLPAREN	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
featureId	TokenNameIdentifier	 feature Id
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
to	TokenNameIdentifier	 to
.	TokenNameDOT	
setFeature	TokenNameIdentifier	 set Feature
(	TokenNameLPAREN	
featureId	TokenNameIdentifier	 feature Id
,	TokenNameCOMMA	
from	TokenNameIdentifier	 from
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
featureId	TokenNameIdentifier	 feature Id
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// componentManager doesn't support this feature, 	TokenNameCOMMENT_LINE	componentManager doesn't support this feature, 
// so we won't worry about it 	TokenNameCOMMENT_LINE	so we won't worry about it 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
copyFeatures1	TokenNameIdentifier	 copy Features1
(	TokenNameLPAREN	
Enumeration	TokenNameIdentifier	 Enumeration
features	TokenNameIdentifier	 features
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
featurePrefix	TokenNameIdentifier	 feature Prefix
,	TokenNameCOMMA	
XMLComponentManager	TokenNameIdentifier	 XML Component Manager
from	TokenNameIdentifier	 from
,	TokenNameCOMMA	
XMLParserConfiguration	TokenNameIdentifier	 XML Parser Configuration
to	TokenNameIdentifier	 to
)	TokenNameRPAREN	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
features	TokenNameIdentifier	 features
.	TokenNameDOT	
hasMoreElements	TokenNameIdentifier	 has More Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
featureId	TokenNameIdentifier	 feature Id
=	TokenNameEQUAL	
featurePrefix	TokenNameIdentifier	 feature Prefix
+	TokenNamePLUS	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
features	TokenNameIdentifier	 features
.	TokenNameDOT	
nextElement	TokenNameIdentifier	 next Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
from	TokenNameIdentifier	 from
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
featureId	TokenNameIdentifier	 feature Id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
to	TokenNameIdentifier	 to
.	TokenNameDOT	
setFeature	TokenNameIdentifier	 set Feature
(	TokenNameLPAREN	
featureId	TokenNameIdentifier	 feature Id
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// componentManager doesn't support this feature, 	TokenNameCOMMENT_LINE	componentManager doesn't support this feature, 
// so we won't worry about it 	TokenNameCOMMENT_LINE	so we won't worry about it 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// This is a storage class to hold information about the notations. 	TokenNameCOMMENT_LINE	This is a storage class to hold information about the notations. 
// We're not using XMLNotationDecl because we don't want to lose the augmentations. 	TokenNameCOMMENT_LINE	We're not using XMLNotationDecl because we don't want to lose the augmentations. 
protected	TokenNameprotected	
static	TokenNamestatic	
class	TokenNameclass	
Notation	TokenNameIdentifier	 Notation
{	TokenNameLBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
;	TokenNameSEMICOLON	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
systemId	TokenNameIdentifier	 system Id
;	TokenNameSEMICOLON	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
baseURI	TokenNameIdentifier	 base URI
;	TokenNameSEMICOLON	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
publicId	TokenNameIdentifier	 public Id
;	TokenNameSEMICOLON	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
expandedSystemId	TokenNameIdentifier	 expanded System Id
;	TokenNameSEMICOLON	
public	TokenNamepublic	
Augmentations	TokenNameIdentifier	 Augmentations
augmentations	TokenNameIdentifier	 augmentations
;	TokenNameSEMICOLON	
// equals() returns true if two Notations have the same name. 	TokenNameCOMMENT_LINE	equals() returns true if two Notations have the same name. 
// Useful for searching Vectors for notations with the same name 	TokenNameCOMMENT_LINE	Useful for searching Vectors for notations with the same name 
public	TokenNamepublic	
boolean	TokenNameboolean	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
obj	TokenNameIdentifier	 obj
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
obj	TokenNameIdentifier	 obj
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
obj	TokenNameIdentifier	 obj
instanceof	TokenNameinstanceof	
Notation	TokenNameIdentifier	 Notation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Notation	TokenNameIdentifier	 Notation
other	TokenNameIdentifier	 other
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Notation	TokenNameIdentifier	 Notation
)	TokenNameRPAREN	
obj	TokenNameIdentifier	 obj
;	TokenNameSEMICOLON	
return	TokenNamereturn	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// from 4.5.2 	TokenNameCOMMENT_LINE	from 4.5.2 
// Notation items with the same [name], [system identifier], 	TokenNameCOMMENT_LINE	Notation items with the same [name], [system identifier], 
// [public identifier], and [declaration base URI] are considered 	TokenNameCOMMENT_LINE	[public identifier], and [declaration base URI] are considered 
// to be duplicate. An application may also be able to detect that 	TokenNameCOMMENT_LINE	to be duplicate. An application may also be able to detect that 
// notations are duplicate through other means. For instance, the URI 	TokenNameCOMMENT_LINE	notations are duplicate through other means. For instance, the URI 
// resulting from combining the system identifier and the declaration 	TokenNameCOMMENT_LINE	resulting from combining the system identifier and the declaration 
// base URI is the same. 	TokenNameCOMMENT_LINE	base URI is the same. 
public	TokenNamepublic	
boolean	TokenNameboolean	
isDuplicate	TokenNameIdentifier	 is Duplicate
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
obj	TokenNameIdentifier	 obj
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
obj	TokenNameIdentifier	 obj
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
obj	TokenNameIdentifier	 obj
instanceof	TokenNameinstanceof	
Notation	TokenNameIdentifier	 Notation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Notation	TokenNameIdentifier	 Notation
other	TokenNameIdentifier	 other
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Notation	TokenNameIdentifier	 Notation
)	TokenNameRPAREN	
obj	TokenNameIdentifier	 obj
;	TokenNameSEMICOLON	
return	TokenNamereturn	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
isEqual	TokenNameIdentifier	 is Equal
(	TokenNameLPAREN	
publicId	TokenNameIdentifier	 public Id
,	TokenNameCOMMA	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
publicId	TokenNameIdentifier	 public Id
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
isEqual	TokenNameIdentifier	 is Equal
(	TokenNameLPAREN	
expandedSystemId	TokenNameIdentifier	 expanded System Id
,	TokenNameCOMMA	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
expandedSystemId	TokenNameIdentifier	 expanded System Id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
isEqual	TokenNameIdentifier	 is Equal
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
one	TokenNameIdentifier	 one
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
two	TokenNameIdentifier	 two
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
one	TokenNameIdentifier	 one
==	TokenNameEQUAL_EQUAL	
two	TokenNameIdentifier	 two
||	TokenNameOR_OR	
(	TokenNameLPAREN	
one	TokenNameIdentifier	 one
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
one	TokenNameIdentifier	 one
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
two	TokenNameIdentifier	 two
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// This is a storage class to hold information about the unparsed entities. 	TokenNameCOMMENT_LINE	This is a storage class to hold information about the unparsed entities. 
// We're not using XMLEntityDecl because we don't want to lose the augmentations. 	TokenNameCOMMENT_LINE	We're not using XMLEntityDecl because we don't want to lose the augmentations. 
protected	TokenNameprotected	
static	TokenNamestatic	
class	TokenNameclass	
UnparsedEntity	TokenNameIdentifier	 Unparsed Entity
{	TokenNameLBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
;	TokenNameSEMICOLON	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
systemId	TokenNameIdentifier	 system Id
;	TokenNameSEMICOLON	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
baseURI	TokenNameIdentifier	 base URI
;	TokenNameSEMICOLON	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
publicId	TokenNameIdentifier	 public Id
;	TokenNameSEMICOLON	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
expandedSystemId	TokenNameIdentifier	 expanded System Id
;	TokenNameSEMICOLON	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
notation	TokenNameIdentifier	 notation
;	TokenNameSEMICOLON	
public	TokenNamepublic	
Augmentations	TokenNameIdentifier	 Augmentations
augmentations	TokenNameIdentifier	 augmentations
;	TokenNameSEMICOLON	
// equals() returns true if two UnparsedEntities have the same name. 	TokenNameCOMMENT_LINE	equals() returns true if two UnparsedEntities have the same name. 
// Useful for searching Vectors for entities with the same name 	TokenNameCOMMENT_LINE	Useful for searching Vectors for entities with the same name 
public	TokenNamepublic	
boolean	TokenNameboolean	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
obj	TokenNameIdentifier	 obj
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
obj	TokenNameIdentifier	 obj
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
obj	TokenNameIdentifier	 obj
instanceof	TokenNameinstanceof	
UnparsedEntity	TokenNameIdentifier	 Unparsed Entity
)	TokenNameRPAREN	
{	TokenNameLBRACE	
UnparsedEntity	TokenNameIdentifier	 Unparsed Entity
other	TokenNameIdentifier	 other
=	TokenNameEQUAL	
(	TokenNameLPAREN	
UnparsedEntity	TokenNameIdentifier	 Unparsed Entity
)	TokenNameRPAREN	
obj	TokenNameIdentifier	 obj
;	TokenNameSEMICOLON	
return	TokenNamereturn	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// from 4.5.1: 	TokenNameCOMMENT_LINE	from 4.5.1: 
// Unparsed entity items with the same [name], [system identifier], 	TokenNameCOMMENT_LINE	Unparsed entity items with the same [name], [system identifier], 
// [public identifier], [declaration base URI], [notation name], and 	TokenNameCOMMENT_LINE	[public identifier], [declaration base URI], [notation name], and 
// [notation] are considered to be duplicate. An application may also 	TokenNameCOMMENT_LINE	[notation] are considered to be duplicate. An application may also 
// be able to detect that unparsed entities are duplicate through other 	TokenNameCOMMENT_LINE	be able to detect that unparsed entities are duplicate through other 
// means. For instance, the URI resulting from combining the system 	TokenNameCOMMENT_LINE	means. For instance, the URI resulting from combining the system 
// identifier and the declaration base URI is the same. 	TokenNameCOMMENT_LINE	identifier and the declaration base URI is the same. 
public	TokenNamepublic	
boolean	TokenNameboolean	
isDuplicate	TokenNameIdentifier	 is Duplicate
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
obj	TokenNameIdentifier	 obj
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
obj	TokenNameIdentifier	 obj
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
obj	TokenNameIdentifier	 obj
instanceof	TokenNameinstanceof	
UnparsedEntity	TokenNameIdentifier	 Unparsed Entity
)	TokenNameRPAREN	
{	TokenNameLBRACE	
UnparsedEntity	TokenNameIdentifier	 Unparsed Entity
other	TokenNameIdentifier	 other
=	TokenNameEQUAL	
(	TokenNameLPAREN	
UnparsedEntity	TokenNameIdentifier	 Unparsed Entity
)	TokenNameRPAREN	
obj	TokenNameIdentifier	 obj
;	TokenNameSEMICOLON	
return	TokenNamereturn	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
isEqual	TokenNameIdentifier	 is Equal
(	TokenNameLPAREN	
publicId	TokenNameIdentifier	 public Id
,	TokenNameCOMMA	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
publicId	TokenNameIdentifier	 public Id
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
isEqual	TokenNameIdentifier	 is Equal
(	TokenNameLPAREN	
expandedSystemId	TokenNameIdentifier	 expanded System Id
,	TokenNameCOMMA	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
expandedSystemId	TokenNameIdentifier	 expanded System Id
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
isEqual	TokenNameIdentifier	 is Equal
(	TokenNameLPAREN	
notation	TokenNameIdentifier	 notation
,	TokenNameCOMMA	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
notation	TokenNameIdentifier	 notation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
isEqual	TokenNameIdentifier	 is Equal
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
one	TokenNameIdentifier	 one
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
two	TokenNameIdentifier	 two
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
one	TokenNameIdentifier	 one
==	TokenNameEQUAL_EQUAL	
two	TokenNameIdentifier	 two
||	TokenNameOR_OR	
(	TokenNameLPAREN	
one	TokenNameIdentifier	 one
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
one	TokenNameIdentifier	 one
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
two	TokenNameIdentifier	 two
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// The following methods are used for XML Base processing 	TokenNameCOMMENT_LINE	The following methods are used for XML Base processing 
/** * Saves the current base URI to the top of the stack. */	TokenNameCOMMENT_JAVADOC	 Saves the current base URI to the top of the stack. 
protected	TokenNameprotected	
void	TokenNamevoid	
saveBaseURI	TokenNameIdentifier	 save Base URI
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fBaseURIScope	TokenNameIdentifier	 f Base URI Scope
.	TokenNameDOT	
push	TokenNameIdentifier	 push
(	TokenNameLPAREN	
fDepth	TokenNameIdentifier	 f Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fBaseURI	TokenNameIdentifier	 f Base URI
.	TokenNameDOT	
push	TokenNameIdentifier	 push
(	TokenNameLPAREN	
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
.	TokenNameDOT	
getBaseSystemId	TokenNameIdentifier	 get Base System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fLiteralSystemID	TokenNameIdentifier	 f Literal System ID
.	TokenNameDOT	
push	TokenNameIdentifier	 push
(	TokenNameLPAREN	
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
.	TokenNameDOT	
getLiteralSystemId	TokenNameIdentifier	 get Literal System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fExpandedSystemID	TokenNameIdentifier	 f Expanded System ID
.	TokenNameDOT	
push	TokenNameIdentifier	 push
(	TokenNameLPAREN	
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
.	TokenNameDOT	
getExpandedSystemId	TokenNameIdentifier	 get Expanded System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Discards the URIs at the top of the stack, and restores the ones beneath it. */	TokenNameCOMMENT_JAVADOC	 Discards the URIs at the top of the stack, and restores the ones beneath it. 
protected	TokenNameprotected	
void	TokenNamevoid	
restoreBaseURI	TokenNameIdentifier	 restore Base URI
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fBaseURI	TokenNameIdentifier	 f Base URI
.	TokenNameDOT	
pop	TokenNameIdentifier	 pop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fLiteralSystemID	TokenNameIdentifier	 f Literal System ID
.	TokenNameDOT	
pop	TokenNameIdentifier	 pop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fExpandedSystemID	TokenNameIdentifier	 f Expanded System ID
.	TokenNameDOT	
pop	TokenNameIdentifier	 pop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fBaseURIScope	TokenNameIdentifier	 f Base URI Scope
.	TokenNameDOT	
pop	TokenNameIdentifier	 pop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
.	TokenNameDOT	
setBaseSystemId	TokenNameIdentifier	 set Base System Id
(	TokenNameLPAREN	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
fBaseURI	TokenNameIdentifier	 f Base URI
.	TokenNameDOT	
peek	TokenNameIdentifier	 peek
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
.	TokenNameDOT	
setLiteralSystemId	TokenNameIdentifier	 set Literal System Id
(	TokenNameLPAREN	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
fLiteralSystemID	TokenNameIdentifier	 f Literal System ID
.	TokenNameDOT	
peek	TokenNameIdentifier	 peek
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
.	TokenNameDOT	
setExpandedSystemId	TokenNameIdentifier	 set Expanded System Id
(	TokenNameLPAREN	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
fExpandedSystemID	TokenNameIdentifier	 f Expanded System ID
.	TokenNameDOT	
peek	TokenNameIdentifier	 peek
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// The following methods are used for language processing 	TokenNameCOMMENT_LINE	The following methods are used for language processing 
/** * Saves the given language on the top of the stack. * * @param language the language to push onto the stack. */	TokenNameCOMMENT_JAVADOC	 Saves the given language on the top of the stack. * @param language the language to push onto the stack. 
protected	TokenNameprotected	
void	TokenNamevoid	
saveLanguage	TokenNameIdentifier	 save Language
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
language	TokenNameIdentifier	 language
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fLanguageScope	TokenNameIdentifier	 f Language Scope
.	TokenNameDOT	
push	TokenNameIdentifier	 push
(	TokenNameLPAREN	
fDepth	TokenNameIdentifier	 f Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fLanguageStack	TokenNameIdentifier	 f Language Stack
.	TokenNameDOT	
push	TokenNameIdentifier	 push
(	TokenNameLPAREN	
language	TokenNameIdentifier	 language
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Discards the language at the top of the stack, and returns the one beneath it. */	TokenNameCOMMENT_JAVADOC	 Discards the language at the top of the stack, and returns the one beneath it. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
restoreLanguage	TokenNameIdentifier	 restore Language
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fLanguageStack	TokenNameIdentifier	 f Language Stack
.	TokenNameDOT	
pop	TokenNameIdentifier	 pop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fLanguageScope	TokenNameIdentifier	 f Language Scope
.	TokenNameDOT	
pop	TokenNameIdentifier	 pop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
fLanguageStack	TokenNameIdentifier	 f Language Stack
.	TokenNameDOT	
peek	TokenNameIdentifier	 peek
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Gets the base URI that was in use at that depth * @param depth * @return the base URI */	TokenNameCOMMENT_JAVADOC	 Gets the base URI that was in use at that depth @param depth @return the base URI 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getBaseURI	TokenNameIdentifier	 get Base URI
(	TokenNameLPAREN	
int	TokenNameint	
depth	TokenNameIdentifier	 depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
scope	TokenNameIdentifier	 scope
=	TokenNameEQUAL	
scopeOfBaseURI	TokenNameIdentifier	 scope Of Base URI
(	TokenNameLPAREN	
depth	TokenNameIdentifier	 depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
fExpandedSystemID	TokenNameIdentifier	 f Expanded System ID
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
scope	TokenNameIdentifier	 scope
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Gets the language that was in use at that depth. * @param depth * @return the language */	TokenNameCOMMENT_JAVADOC	 Gets the language that was in use at that depth. @param depth @return the language 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getLanguage	TokenNameIdentifier	 get Language
(	TokenNameLPAREN	
int	TokenNameint	
depth	TokenNameIdentifier	 depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
scope	TokenNameIdentifier	 scope
=	TokenNameEQUAL	
scopeOfLanguage	TokenNameIdentifier	 scope Of Language
(	TokenNameLPAREN	
depth	TokenNameIdentifier	 depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
fLanguageStack	TokenNameIdentifier	 f Language Stack
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
scope	TokenNameIdentifier	 scope
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns a relative URI, which when resolved against the base URI at the * specified depth, will create the current base URI. * This is accomplished by merged the literal system IDs. * @param depth the depth at which to start creating the relative URI * @return a relative URI to convert the base URI at the given depth to the current * base URI */	TokenNameCOMMENT_JAVADOC	 Returns a relative URI, which when resolved against the base URI at the specified depth, will create the current base URI. This is accomplished by merged the literal system IDs. @param depth the depth at which to start creating the relative URI @return a relative URI to convert the base URI at the given depth to the current base URI 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getRelativeURI	TokenNameIdentifier	 get Relative URI
(	TokenNameLPAREN	
int	TokenNameint	
depth	TokenNameIdentifier	 depth
)	TokenNameRPAREN	
throws	TokenNamethrows	
MalformedURIException	TokenNameIdentifier	 Malformed URI Exception
{	TokenNameLBRACE	
// The literal system id at the location given by "start" is *in focus* at 	TokenNameCOMMENT_LINE	The literal system id at the location given by "start" is *in focus* at 
// the given depth. So we need to adjust it to the next scope, so that we 	TokenNameCOMMENT_LINE	the given depth. So we need to adjust it to the next scope, so that we 
// only process out of focus literal system ids 	TokenNameCOMMENT_LINE	only process out of focus literal system ids 
int	TokenNameint	
start	TokenNameIdentifier	 start
=	TokenNameEQUAL	
scopeOfBaseURI	TokenNameIdentifier	 scope Of Base URI
(	TokenNameLPAREN	
depth	TokenNameIdentifier	 depth
)	TokenNameRPAREN	
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
start	TokenNameIdentifier	 start
==	TokenNameEQUAL_EQUAL	
fBaseURIScope	TokenNameIdentifier	 f Base URI Scope
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If that is the last system id, then we don't need a relative URI 	TokenNameCOMMENT_LINE	If that is the last system id, then we don't need a relative URI 
return	TokenNamereturn	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
URI	TokenNameIdentifier	 URI
uri	TokenNameIdentifier	 uri
=	TokenNameEQUAL	
new	TokenNamenew	
URI	TokenNameIdentifier	 URI
(	TokenNameLPAREN	
"file"	TokenNameStringLiteral	file
,	TokenNameCOMMA	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
fLiteralSystemID	TokenNameIdentifier	 f Literal System ID
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
start	TokenNameIdentifier	 start
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
start	TokenNameIdentifier	 start
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fBaseURIScope	TokenNameIdentifier	 f Base URI Scope
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
uri	TokenNameIdentifier	 uri
=	TokenNameEQUAL	
new	TokenNamenew	
URI	TokenNameIdentifier	 URI
(	TokenNameLPAREN	
uri	TokenNameIdentifier	 uri
,	TokenNameCOMMA	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
fLiteralSystemID	TokenNameIdentifier	 f Literal System ID
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
uri	TokenNameIdentifier	 uri
.	TokenNameDOT	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// We need to find two consecutive elements in the scope stack, 	TokenNameCOMMENT_LINE	We need to find two consecutive elements in the scope stack, 
// such that the first is lower than 'depth' (or equal), and the 	TokenNameCOMMENT_LINE	such that the first is lower than 'depth' (or equal), and the 
// second is higher. 	TokenNameCOMMENT_LINE	second is higher. 
private	TokenNameprivate	
int	TokenNameint	
scopeOfBaseURI	TokenNameIdentifier	 scope Of Base URI
(	TokenNameLPAREN	
int	TokenNameint	
depth	TokenNameIdentifier	 depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
fBaseURIScope	TokenNameIdentifier	 f Base URI Scope
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fBaseURIScope	TokenNameIdentifier	 f Base URI Scope
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
<=	TokenNameLESS_EQUAL	
depth	TokenNameIdentifier	 depth
)	TokenNameRPAREN	
return	TokenNamereturn	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// we should never get here, because 0 was put on the stack in startDocument() 	TokenNameCOMMENT_LINE	we should never get here, because 0 was put on the stack in startDocument() 
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
scopeOfLanguage	TokenNameIdentifier	 scope Of Language
(	TokenNameLPAREN	
int	TokenNameint	
depth	TokenNameIdentifier	 depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
fLanguageScope	TokenNameIdentifier	 f Language Scope
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fLanguageScope	TokenNameIdentifier	 f Language Scope
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
<=	TokenNameLESS_EQUAL	
depth	TokenNameIdentifier	 depth
)	TokenNameRPAREN	
return	TokenNamereturn	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// we should never get here, because 0 was put on the stack in startDocument() 	TokenNameCOMMENT_LINE	we should never get here, because 0 was put on the stack in startDocument() 
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Search for a xml:base attribute, and if one is found, put the new base URI into * effect. */	TokenNameCOMMENT_JAVADOC	 Search for a xml:base attribute, and if one is found, put the new base URI into effect. 
protected	TokenNameprotected	
void	TokenNamevoid	
processXMLBaseAttributes	TokenNameIdentifier	 process XML Base Attributes
(	TokenNameLPAREN	
XMLAttributes	TokenNameIdentifier	 XML Attributes
attributes	TokenNameIdentifier	 attributes
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
baseURIValue	TokenNameIdentifier	 base URI Value
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
NamespaceContext	TokenNameIdentifier	 Namespace Context
.	TokenNameDOT	
XML_URI	TokenNameIdentifier	 XML  URI
,	TokenNameCOMMA	
"base"	TokenNameStringLiteral	base
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
baseURIValue	TokenNameIdentifier	 base URI Value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
expandedValue	TokenNameIdentifier	 expanded Value
=	TokenNameEQUAL	
XMLEntityManager	TokenNameIdentifier	 XML Entity Manager
.	TokenNameDOT	
expandSystemId	TokenNameIdentifier	 expand System Id
(	TokenNameLPAREN	
baseURIValue	TokenNameIdentifier	 base URI Value
,	TokenNameCOMMA	
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
.	TokenNameDOT	
getExpandedSystemId	TokenNameIdentifier	 get Expanded System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
.	TokenNameDOT	
setLiteralSystemId	TokenNameIdentifier	 set Literal System Id
(	TokenNameLPAREN	
baseURIValue	TokenNameIdentifier	 base URI Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
.	TokenNameDOT	
setBaseSystemId	TokenNameIdentifier	 set Base System Id
(	TokenNameLPAREN	
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
.	TokenNameDOT	
getExpandedSystemId	TokenNameIdentifier	 get Expanded System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fCurrentBaseURI	TokenNameIdentifier	 f Current Base URI
.	TokenNameDOT	
setExpandedSystemId	TokenNameIdentifier	 set Expanded System Id
(	TokenNameLPAREN	
expandedValue	TokenNameIdentifier	 expanded Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// push the new values on the stack 	TokenNameCOMMENT_LINE	push the new values on the stack 
saveBaseURI	TokenNameIdentifier	 save Base URI
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
MalformedURIException	TokenNameIdentifier	 Malformed URI Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// REVISIT: throw error here 	TokenNameCOMMENT_LINE	REVISIT: throw error here 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Search for a xml:lang attribute, and if one is found, put the new * [language] into effect. */	TokenNameCOMMENT_JAVADOC	 Search for a xml:lang attribute, and if one is found, put the new [language] into effect. 
protected	TokenNameprotected	
void	TokenNamevoid	
processXMLLangAttributes	TokenNameIdentifier	 process XML Lang Attributes
(	TokenNameLPAREN	
XMLAttributes	TokenNameIdentifier	 XML Attributes
attributes	TokenNameIdentifier	 attributes
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
language	TokenNameIdentifier	 language
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
NamespaceContext	TokenNameIdentifier	 Namespace Context
.	TokenNameDOT	
XML_URI	TokenNameIdentifier	 XML  URI
,	TokenNameCOMMA	
"lang"	TokenNameStringLiteral	lang
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
language	TokenNameIdentifier	 language
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fCurrentLanguage	TokenNameIdentifier	 f Current Language
=	TokenNameEQUAL	
language	TokenNameIdentifier	 language
;	TokenNameSEMICOLON	
saveLanguage	TokenNameIdentifier	 save Language
(	TokenNameLPAREN	
fCurrentLanguage	TokenNameIdentifier	 f Current Language
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Returns <code>true</code> if the given string * would be valid in an HTTP header. * * @param value string to check * @return <code>true</code> if the given string * would be valid in an HTTP header */	TokenNameCOMMENT_JAVADOC	 Returns <code>true</code> if the given string would be valid in an HTTP header. * @param value string to check @return <code>true</code> if the given string would be valid in an HTTP header 
private	TokenNameprivate	
boolean	TokenNameboolean	
isValidInHTTPHeader	TokenNameIdentifier	 is Valid In HTTP Header
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
char	TokenNamechar	
ch	TokenNameIdentifier	 ch
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
<	TokenNameLESS	
0x20	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
ch	TokenNameIdentifier	 ch
>	TokenNameGREATER	
0x7E	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns a new <code>XMLInputSource</code> from the given parameters. */	TokenNameCOMMENT_JAVADOC	 Returns a new <code>XMLInputSource</code> from the given parameters. 
private	TokenNameprivate	
XMLInputSource	TokenNameIdentifier	 XML Input Source
createInputSource	TokenNameIdentifier	 create Input Source
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
publicId	TokenNameIdentifier	 public Id
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
systemId	TokenNameIdentifier	 system Id
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
baseSystemId	TokenNameIdentifier	 base System Id
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
accept	TokenNameIdentifier	 accept
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
acceptLanguage	TokenNameIdentifier	 accept Language
)	TokenNameRPAREN	
{	TokenNameLBRACE	
HTTPInputSource	TokenNameIdentifier	 HTTP Input Source
httpSource	TokenNameIdentifier	 http Source
=	TokenNameEQUAL	
new	TokenNamenew	
HTTPInputSource	TokenNameIdentifier	 HTTP Input Source
(	TokenNameLPAREN	
publicId	TokenNameIdentifier	 public Id
,	TokenNameCOMMA	
systemId	TokenNameIdentifier	 system Id
,	TokenNameCOMMA	
baseSystemId	TokenNameIdentifier	 base System Id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
accept	TokenNameIdentifier	 accept
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
accept	TokenNameIdentifier	 accept
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
httpSource	TokenNameIdentifier	 http Source
.	TokenNameDOT	
setHTTPRequestProperty	TokenNameIdentifier	 set HTTP Request Property
(	TokenNameLPAREN	
XIncludeHandler	TokenNameIdentifier	 X Include Handler
.	TokenNameDOT	
HTTP_ACCEPT	TokenNameIdentifier	 HTTP  ACCEPT
,	TokenNameCOMMA	
accept	TokenNameIdentifier	 accept
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
acceptLanguage	TokenNameIdentifier	 accept Language
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
acceptLanguage	TokenNameIdentifier	 accept Language
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
httpSource	TokenNameIdentifier	 http Source
.	TokenNameDOT	
setHTTPRequestProperty	TokenNameIdentifier	 set HTTP Request Property
(	TokenNameLPAREN	
XIncludeHandler	TokenNameIdentifier	 X Include Handler
.	TokenNameDOT	
HTTP_ACCEPT_LANGUAGE	TokenNameIdentifier	 HTTP  ACCEPT  LANGUAGE
,	TokenNameCOMMA	
acceptLanguage	TokenNameIdentifier	 accept Language
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
httpSource	TokenNameIdentifier	 http Source
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
isEqual	TokenNameIdentifier	 is Equal
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
one	TokenNameIdentifier	 one
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
two	TokenNameIdentifier	 two
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
one	TokenNameIdentifier	 one
==	TokenNameEQUAL_EQUAL	
two	TokenNameIdentifier	 two
||	TokenNameOR_OR	
(	TokenNameLPAREN	
one	TokenNameIdentifier	 one
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
one	TokenNameIdentifier	 one
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
two	TokenNameIdentifier	 two
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// which ASCII characters need to be escaped 	TokenNameCOMMENT_LINE	which ASCII characters need to be escaped 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
gNeedEscaping	TokenNameIdentifier	 g Need Escaping
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
128	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// the first hex character if a character needs to be escaped 	TokenNameCOMMENT_LINE	the first hex character if a character needs to be escaped 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
char	TokenNamechar	
gAfterEscaping1	TokenNameIdentifier	 g After Escaping1
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
128	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// the second hex character if a character needs to be escaped 	TokenNameCOMMENT_LINE	the second hex character if a character needs to be escaped 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
char	TokenNamechar	
gAfterEscaping2	TokenNameIdentifier	 g After Escaping2
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
128	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
gHexChs	TokenNameIdentifier	 g Hex Chs
=	TokenNameEQUAL	
{	TokenNameLBRACE	
'0'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
'1'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
'2'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
'3'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
'4'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
'5'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
'6'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
'7'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
'8'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
'9'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
'A'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
'B'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
'C'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
'D'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
'E'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
'F'	TokenNameCharacterLiteral	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
// initialize the above 3 arrays 	TokenNameCOMMENT_LINE	initialize the above 3 arrays 
static	TokenNamestatic	
{	TokenNameLBRACE	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
escChs	TokenNameIdentifier	 esc Chs
=	TokenNameEQUAL	
{	TokenNameLBRACE	
' '	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
'<'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
'>'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
'"'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
'{'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
'}'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
'|'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
'\\'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
'^'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
'`'	TokenNameCharacterLiteral	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
int	TokenNameint	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
escChs	TokenNameIdentifier	 esc Chs
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
char	TokenNamechar	
ch	TokenNameIdentifier	 ch
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
escChs	TokenNameIdentifier	 esc Chs
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
gNeedEscaping	TokenNameIdentifier	 g Need Escaping
[	TokenNameLBRACKET	
ch	TokenNameIdentifier	 ch
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
gAfterEscaping1	TokenNameIdentifier	 g After Escaping1
[	TokenNameLBRACKET	
ch	TokenNameIdentifier	 ch
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
gHexChs	TokenNameIdentifier	 g Hex Chs
[	TokenNameLBRACKET	
ch	TokenNameIdentifier	 ch
>>	TokenNameRIGHT_SHIFT	
4	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
gAfterEscaping2	TokenNameIdentifier	 g After Escaping2
[	TokenNameLBRACKET	
ch	TokenNameIdentifier	 ch
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
gHexChs	TokenNameIdentifier	 g Hex Chs
[	TokenNameLBRACKET	
ch	TokenNameIdentifier	 ch
&	TokenNameAND	
0xf	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// Escape an href value according to (4.1.1): 	TokenNameCOMMENT_LINE	Escape an href value according to (4.1.1): 
// 	TokenNameCOMMENT_LINE	 
// To convert the value of the href attribute to an IRI reference, the following characters must be escaped: 	TokenNameCOMMENT_LINE	To convert the value of the href attribute to an IRI reference, the following characters must be escaped: 
// space #x20 	TokenNameCOMMENT_LINE	space #x20 
// the delimiters < #x3C, > #x3E and " #x22 	TokenNameCOMMENT_LINE	the delimiters < #x3C, > #x3E and " #x22 
// the unwise characters { #x7B, } #x7D, | #x7C, \ #x5C, ^ #x5E and ` #x60 	TokenNameCOMMENT_LINE	the unwise characters { #x7B, } #x7D, | #x7C, \ #x5C, ^ #x5E and ` #x60 
// 	TokenNameCOMMENT_LINE	 
// To convert an IRI reference to a URI reference, the following characters must also be escaped: 	TokenNameCOMMENT_LINE	To convert an IRI reference to a URI reference, the following characters must also be escaped: 
// the Unicode plane 0 characters #xA0 - #xD7FF, #xF900-#xFDCF, #xFDF0-#xFFEF 	TokenNameCOMMENT_LINE	the Unicode plane 0 characters #xA0 - #xD7FF, #xF900-#xFDCF, #xFDF0-#xFFEF 
// the Unicode plane 1-14 characters #x10000-#x1FFFD ... #xE0000-#xEFFFD 	TokenNameCOMMENT_LINE	the Unicode plane 1-14 characters #x10000-#x1FFFD ... #xE0000-#xEFFFD 
// 	TokenNameCOMMENT_LINE	 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
escapeHref	TokenNameIdentifier	 escape Href
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
href	TokenNameIdentifier	 href
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
href	TokenNameIdentifier	 href
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
ch	TokenNameIdentifier	 ch
;	TokenNameSEMICOLON	
StringBuffer	TokenNameIdentifier	 String Buffer
buffer	TokenNameIdentifier	 buffer
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
len	TokenNameIdentifier	 len
*	TokenNameMULTIPLY	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// for each character in the href 	TokenNameCOMMENT_LINE	for each character in the href 
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
href	TokenNameIdentifier	 href
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// if it's not an ASCII character (excluding 0x7F), break here, and use UTF-8 encoding 	TokenNameCOMMENT_LINE	if it's not an ASCII character (excluding 0x7F), break here, and use UTF-8 encoding 
if	TokenNameif	
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
>	TokenNameGREATER	
0x7E	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// abort: href does not allow this character 	TokenNameCOMMENT_LINE	abort: href does not allow this character 
if	TokenNameif	
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
<	TokenNameLESS	
0x20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
href	TokenNameIdentifier	 href
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
gNeedEscaping	TokenNameIdentifier	 g Need Escaping
[	TokenNameLBRACKET	
ch	TokenNameIdentifier	 ch
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'%'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
gAfterEscaping1	TokenNameIdentifier	 g After Escaping1
[	TokenNameLBRACKET	
ch	TokenNameIdentifier	 ch
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
gAfterEscaping2	TokenNameIdentifier	 g After Escaping2
[	TokenNameLBRACKET	
ch	TokenNameIdentifier	 ch
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// we saw some non-ascii character 	TokenNameCOMMENT_LINE	we saw some non-ascii character 
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// check if remainder of href contains any illegal characters before proceeding 	TokenNameCOMMENT_LINE	check if remainder of href contains any illegal characters before proceeding 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
len	TokenNameIdentifier	 len
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
href	TokenNameIdentifier	 href
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
>=	TokenNameGREATER_EQUAL	
0x20	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
ch	TokenNameIdentifier	 ch
<=	TokenNameLESS_EQUAL	
0x7E	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
>=	TokenNameGREATER_EQUAL	
0xA0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
ch	TokenNameIdentifier	 ch
<=	TokenNameLESS_EQUAL	
0xD7FF	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
>=	TokenNameGREATER_EQUAL	
0xF900	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
ch	TokenNameIdentifier	 ch
<=	TokenNameLESS_EQUAL	
0xFDCF	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
>=	TokenNameGREATER_EQUAL	
0xFDF0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
ch	TokenNameIdentifier	 ch
<=	TokenNameLESS_EQUAL	
0xFFEF	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
XMLChar	TokenNameIdentifier	 XML Char
.	TokenNameDOT	
isHighSurrogate	TokenNameIdentifier	 is High Surrogate
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
++	TokenNamePLUS_PLUS	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
len	TokenNameIdentifier	 len
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
ch2	TokenNameIdentifier	 ch2
=	TokenNameEQUAL	
href	TokenNameIdentifier	 href
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
XMLChar	TokenNameIdentifier	 XML Char
.	TokenNameDOT	
isLowSurrogate	TokenNameIdentifier	 is Low Surrogate
(	TokenNameLPAREN	
ch2	TokenNameIdentifier	 ch2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ch2	TokenNameIdentifier	 ch2
=	TokenNameEQUAL	
XMLChar	TokenNameIdentifier	 XML Char
.	TokenNameDOT	
supplemental	TokenNameIdentifier	 supplemental
(	TokenNameLPAREN	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
ch	TokenNameIdentifier	 ch
,	TokenNameCOMMA	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
ch2	TokenNameIdentifier	 ch2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ch2	TokenNameIdentifier	 ch2
<	TokenNameLESS	
0xF0000	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
ch2	TokenNameIdentifier	 ch2
&	TokenNameAND	
0xFFFF	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
<=	TokenNameLESS_EQUAL	
0xFFFD	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// abort: href does not allow this character 	TokenNameCOMMENT_LINE	abort: href does not allow this character 
return	TokenNamereturn	
href	TokenNameIdentifier	 href
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// get UTF-8 bytes for the remaining sub-string 	TokenNameCOMMENT_LINE	get UTF-8 bytes for the remaining sub-string 
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bytes	TokenNameIdentifier	 bytes
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
bytes	TokenNameIdentifier	 bytes
=	TokenNameEQUAL	
href	TokenNameIdentifier	 href
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
.	TokenNameDOT	
getBytes	TokenNameIdentifier	 get Bytes
(	TokenNameLPAREN	
"UTF-8"	TokenNameStringLiteral	UTF-8
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
UnsupportedEncodingException	TokenNameIdentifier	 Unsupported Encoding Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// should never happen 	TokenNameCOMMENT_LINE	should never happen 
return	TokenNamereturn	
href	TokenNameIdentifier	 href
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
bytes	TokenNameIdentifier	 bytes
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
// for each byte 	TokenNameCOMMENT_LINE	for each byte 
for	TokenNamefor	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
bytes	TokenNameIdentifier	 bytes
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// for non-ASCII character: make it positive, then escape 	TokenNameCOMMENT_LINE	for non-ASCII character: make it positive, then escape 
if	TokenNameif	
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
+	TokenNamePLUS	
256	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'%'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
gHexChs	TokenNameIdentifier	 g Hex Chs
[	TokenNameLBRACKET	
ch	TokenNameIdentifier	 ch
>>	TokenNameRIGHT_SHIFT	
4	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
gHexChs	TokenNameIdentifier	 g Hex Chs
[	TokenNameLBRACKET	
ch	TokenNameIdentifier	 ch
&	TokenNameAND	
0xf	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
gNeedEscaping	TokenNameIdentifier	 g Need Escaping
[	TokenNameLBRACKET	
b	TokenNameIdentifier	 b
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'%'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
gAfterEscaping1	TokenNameIdentifier	 g After Escaping1
[	TokenNameLBRACKET	
b	TokenNameIdentifier	 b
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
gAfterEscaping2	TokenNameIdentifier	 g After Escaping2
[	TokenNameLBRACKET	
b	TokenNameIdentifier	 b
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// If escaping happened, create a new string; 	TokenNameCOMMENT_LINE	If escaping happened, create a new string; 
// otherwise, return the original one. 	TokenNameCOMMENT_LINE	otherwise, return the original one. 
if	TokenNameif	
(	TokenNameLPAREN	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
len	TokenNameIdentifier	 len
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
href	TokenNameIdentifier	 href
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
