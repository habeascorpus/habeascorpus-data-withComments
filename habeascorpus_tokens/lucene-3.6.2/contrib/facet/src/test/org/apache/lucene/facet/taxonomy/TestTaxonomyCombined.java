package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
facet	TokenNameIdentifier	 facet
.	TokenNameDOT	
taxonomy	TokenNameIdentifier	 taxonomy
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
PrintWriter	TokenNameIdentifier	 Print Writer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
StringWriter	TokenNameIdentifier	 String Writer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Arrays	TokenNameIdentifier	 Arrays
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
Directory	TokenNameIdentifier	 Directory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
LockObtainFailedException	TokenNameIdentifier	 Lock Obtain Failed Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
RAMDirectory	TokenNameIdentifier	 RAM Directory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
junit	TokenNameIdentifier	 junit
.	TokenNameDOT	
Ignore	TokenNameIdentifier	 Ignore
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
junit	TokenNameIdentifier	 junit
.	TokenNameDOT	
Test	TokenNameIdentifier	 Test
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
LuceneTestCase	TokenNameIdentifier	 Lucene Test Case
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
facet	TokenNameIdentifier	 facet
.	TokenNameDOT	
taxonomy	TokenNameIdentifier	 taxonomy
.	TokenNameDOT	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
ChildrenArrays	TokenNameIdentifier	 Children Arrays
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
facet	TokenNameIdentifier	 facet
.	TokenNameDOT	
taxonomy	TokenNameIdentifier	 taxonomy
.	TokenNameDOT	
directory	TokenNameIdentifier	 directory
.	TokenNameDOT	
DirectoryTaxonomyReader	TokenNameIdentifier	 Directory Taxonomy Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
facet	TokenNameIdentifier	 facet
.	TokenNameDOT	
taxonomy	TokenNameIdentifier	 taxonomy
.	TokenNameDOT	
directory	TokenNameIdentifier	 directory
.	TokenNameDOT	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
SlowRAMDirectory	TokenNameIdentifier	 Slow RAM Directory
;	TokenNameSEMICOLON	
/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_JAVADOC	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
public	TokenNamepublic	
class	TokenNameclass	
TestTaxonomyCombined	TokenNameIdentifier	 Test Taxonomy Combined
extends	TokenNameextends	
LuceneTestCase	TokenNameIdentifier	 Lucene Test Case
{	TokenNameLBRACE	
/** The following categories will be added to the taxonomy by fillTaxonomy(), and tested by all tests below: */	TokenNameCOMMENT_JAVADOC	 The following categories will be added to the taxonomy by fillTaxonomy(), and tested by all tests below: 
private	TokenNameprivate	
final	TokenNamefinal	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
categories	TokenNameIdentifier	 categories
=	TokenNameEQUAL	
{	TokenNameLBRACE	
{	TokenNameLBRACE	
"Author"	TokenNameStringLiteral	Author
,	TokenNameCOMMA	
"Tom Clancy"	TokenNameStringLiteral	Tom Clancy
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"Author"	TokenNameStringLiteral	Author
,	TokenNameCOMMA	
"Richard Dawkins"	TokenNameStringLiteral	Richard Dawkins
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"Author"	TokenNameStringLiteral	Author
,	TokenNameCOMMA	
"Richard Adams"	TokenNameStringLiteral	Richard Adams
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"Price"	TokenNameStringLiteral	Price
,	TokenNameCOMMA	
"10"	TokenNameStringLiteral	10
,	TokenNameCOMMA	
"11"	TokenNameStringLiteral	11
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"Price"	TokenNameStringLiteral	Price
,	TokenNameCOMMA	
"10"	TokenNameStringLiteral	10
,	TokenNameCOMMA	
"12"	TokenNameStringLiteral	12
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"Price"	TokenNameStringLiteral	Price
,	TokenNameCOMMA	
"20"	TokenNameStringLiteral	20
,	TokenNameCOMMA	
"27"	TokenNameStringLiteral	27
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"Date"	TokenNameStringLiteral	Date
,	TokenNameCOMMA	
"2006"	TokenNameStringLiteral	2006
,	TokenNameCOMMA	
"05"	TokenNameStringLiteral	05
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"Date"	TokenNameStringLiteral	Date
,	TokenNameCOMMA	
"2005"	TokenNameStringLiteral	2005
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"Date"	TokenNameStringLiteral	Date
,	TokenNameCOMMA	
"2006"	TokenNameStringLiteral	2006
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"Subject"	TokenNameStringLiteral	Subject
,	TokenNameCOMMA	
"Nonfiction"	TokenNameStringLiteral	Nonfiction
,	TokenNameCOMMA	
"Children"	TokenNameStringLiteral	Children
,	TokenNameCOMMA	
"Animals"	TokenNameStringLiteral	Animals
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"Author"	TokenNameStringLiteral	Author
,	TokenNameCOMMA	
"Stephen Jay Gould"	TokenNameStringLiteral	Stephen Jay Gould
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"Author"	TokenNameStringLiteral	Author
,	TokenNameCOMMA	
"?????"	TokenNameStringLiteral	?????
}	TokenNameRBRACE	
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** When adding the above categories with TaxonomyWriter.addCategory(), the following paths are expected to be returned: (note that currently the full path is not returned, and therefore not tested - rather, just the last component, the ordinal, is returned and tested. */	TokenNameCOMMENT_JAVADOC	 When adding the above categories with TaxonomyWriter.addCategory(), the following paths are expected to be returned: (note that currently the full path is not returned, and therefore not tested - rather, just the last component, the ordinal, is returned and tested. 
private	TokenNameprivate	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
expectedPaths	TokenNameIdentifier	 expected Paths
=	TokenNameEQUAL	
{	TokenNameLBRACE	
{	TokenNameLBRACE	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
3	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
5	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
6	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
7	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
5	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
6	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
8	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
5	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
9	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
10	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
11	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
13	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
11	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
14	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
11	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
15	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
16	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
17	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
18	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
19	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
20	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** The taxonomy index is expected to then contain the following generated categories, with increasing ordinals (note how parent categories are be added automatically when subcategories are added). */	TokenNameCOMMENT_JAVADOC	 The taxonomy index is expected to then contain the following generated categories, with increasing ordinals (note how parent categories are be added automatically when subcategories are added). 
private	TokenNameprivate	
final	TokenNamefinal	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
expectedCategories	TokenNameIdentifier	 expected Categories
=	TokenNameEQUAL	
{	TokenNameLBRACE	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
// the root category 	TokenNameCOMMENT_LINE	the root category 
{	TokenNameLBRACE	
"Author"	TokenNameStringLiteral	Author
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"Author"	TokenNameStringLiteral	Author
,	TokenNameCOMMA	
"Tom Clancy"	TokenNameStringLiteral	Tom Clancy
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"Author"	TokenNameStringLiteral	Author
,	TokenNameCOMMA	
"Richard Dawkins"	TokenNameStringLiteral	Richard Dawkins
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"Author"	TokenNameStringLiteral	Author
,	TokenNameCOMMA	
"Richard Adams"	TokenNameStringLiteral	Richard Adams
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"Price"	TokenNameStringLiteral	Price
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"Price"	TokenNameStringLiteral	Price
,	TokenNameCOMMA	
"10"	TokenNameStringLiteral	10
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"Price"	TokenNameStringLiteral	Price
,	TokenNameCOMMA	
"10"	TokenNameStringLiteral	10
,	TokenNameCOMMA	
"11"	TokenNameStringLiteral	11
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"Price"	TokenNameStringLiteral	Price
,	TokenNameCOMMA	
"10"	TokenNameStringLiteral	10
,	TokenNameCOMMA	
"12"	TokenNameStringLiteral	12
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"Price"	TokenNameStringLiteral	Price
,	TokenNameCOMMA	
"20"	TokenNameStringLiteral	20
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"Price"	TokenNameStringLiteral	Price
,	TokenNameCOMMA	
"20"	TokenNameStringLiteral	20
,	TokenNameCOMMA	
"27"	TokenNameStringLiteral	27
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"Date"	TokenNameStringLiteral	Date
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"Date"	TokenNameStringLiteral	Date
,	TokenNameCOMMA	
"2006"	TokenNameStringLiteral	2006
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"Date"	TokenNameStringLiteral	Date
,	TokenNameCOMMA	
"2006"	TokenNameStringLiteral	2006
,	TokenNameCOMMA	
"05"	TokenNameStringLiteral	05
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"Date"	TokenNameStringLiteral	Date
,	TokenNameCOMMA	
"2005"	TokenNameStringLiteral	2005
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"Subject"	TokenNameStringLiteral	Subject
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"Subject"	TokenNameStringLiteral	Subject
,	TokenNameCOMMA	
"Nonfiction"	TokenNameStringLiteral	Nonfiction
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"Subject"	TokenNameStringLiteral	Subject
,	TokenNameCOMMA	
"Nonfiction"	TokenNameStringLiteral	Nonfiction
,	TokenNameCOMMA	
"Children"	TokenNameStringLiteral	Children
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"Subject"	TokenNameStringLiteral	Subject
,	TokenNameCOMMA	
"Nonfiction"	TokenNameStringLiteral	Nonfiction
,	TokenNameCOMMA	
"Children"	TokenNameStringLiteral	Children
,	TokenNameCOMMA	
"Animals"	TokenNameStringLiteral	Animals
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"Author"	TokenNameStringLiteral	Author
,	TokenNameCOMMA	
"Stephen Jay Gould"	TokenNameStringLiteral	Stephen Jay Gould
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"Author"	TokenNameStringLiteral	Author
,	TokenNameCOMMA	
"?????"	TokenNameStringLiteral	?????
}	TokenNameRBRACE	
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** fillTaxonomy adds the categories in the categories[] array, and asserts that the additions return exactly the ordinals (in the past - paths) specified in expectedPaths[]. Note that this assumes that fillTaxonomy() is called on an empty taxonomy index. Calling it after something else was already added to the taxonomy index will surely have this method fail. */	TokenNameCOMMENT_JAVADOC	 fillTaxonomy adds the categories in the categories[] array, and asserts that the additions return exactly the ordinals (in the past - paths) specified in expectedPaths[]. Note that this assumes that fillTaxonomy() is called on an empty taxonomy index. Calling it after something else was already added to the taxonomy index will surely have this method fail. 
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
fillTaxonomy	TokenNameIdentifier	 fill Taxonomy
(	TokenNameLPAREN	
TaxonomyWriter	TokenNameIdentifier	 Taxonomy Writer
tw	TokenNameIdentifier	 tw
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
categories	TokenNameIdentifier	 categories
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
ordinal	TokenNameIdentifier	 ordinal
=	TokenNameEQUAL	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
addCategory	TokenNameIdentifier	 add Category
(	TokenNameLPAREN	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
categories	TokenNameIdentifier	 categories
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
expectedOrdinal	TokenNameIdentifier	 expected Ordinal
=	TokenNameEQUAL	
expectedPaths	TokenNameIdentifier	 expected Paths
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
expectedPaths	TokenNameIdentifier	 expected Paths
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ordinal	TokenNameIdentifier	 ordinal
!=	TokenNameNOT_EQUAL	
expectedOrdinal	TokenNameIdentifier	 expected Ordinal
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
"For category "	TokenNameStringLiteral	For category 
+	TokenNamePLUS	
showcat	TokenNameIdentifier	 showcat
(	TokenNameLPAREN	
categories	TokenNameIdentifier	 categories
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" expected ordinal "	TokenNameStringLiteral	 expected ordinal 
+	TokenNamePLUS	
expectedOrdinal	TokenNameIdentifier	 expected Ordinal
+	TokenNamePLUS	
", but got "	TokenNameStringLiteral	, but got 
+	TokenNamePLUS	
ordinal	TokenNameIdentifier	 ordinal
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
showcat	TokenNameIdentifier	 showcat
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
path	TokenNameIdentifier	 path
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
"<null>"	TokenNameStringLiteral	<null>
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
"<empty>"	TokenNameStringLiteral	<empty>
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
path	TokenNameIdentifier	 path
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
"<"">"	TokenNameStringLiteral	<"">
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
StringBuilder	TokenNameIdentifier	 String Builder
sb	TokenNameIdentifier	 sb
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuilder	TokenNameIdentifier	 String Builder
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'/'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
showcat	TokenNameIdentifier	 showcat
(	TokenNameLPAREN	
CategoryPath	TokenNameIdentifier	 Category Path
path	TokenNameIdentifier	 path
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
"<null>"	TokenNameStringLiteral	<null>
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
"<empty>"	TokenNameStringLiteral	<empty>
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
"<"	TokenNameStringLiteral	<
+	TokenNamePLUS	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
'/'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
+	TokenNamePLUS	
">"	TokenNameStringLiteral	>
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Basic tests for TaxonomyWriter. Basically, we test that IndexWriter.addCategory works, i.e. returns the expected ordinals (this is tested by calling the fillTaxonomy() method above). We do not test here that after writing the index can be read - this will be done in more tests below. */	TokenNameCOMMENT_JAVADOC	 Basic tests for TaxonomyWriter. Basically, we test that IndexWriter.addCategory works, i.e. returns the expected ordinals (this is tested by calling the fillTaxonomy() method above). We do not test here that after writing the index can be read - this will be done in more tests below. 
@	TokenNameAT	
Test	TokenNameIdentifier	 Test
public	TokenNamepublic	
void	TokenNamevoid	
testWriter	TokenNameIdentifier	 test Writer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
Directory	TokenNameIdentifier	 Directory
indexDir	TokenNameIdentifier	 index Dir
=	TokenNameEQUAL	
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyWriter	TokenNameIdentifier	 Taxonomy Writer
tw	TokenNameIdentifier	 tw
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fillTaxonomy	TokenNameIdentifier	 fill Taxonomy
(	TokenNameLPAREN	
tw	TokenNameIdentifier	 tw
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Also check TaxonomyWriter.getSize() - see that the taxonomy's size 	TokenNameCOMMENT_LINE	Also check TaxonomyWriter.getSize() - see that the taxonomy's size 
// is what we expect it to be. 	TokenNameCOMMENT_LINE	is what we expect it to be. 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
expectedCategories	TokenNameIdentifier	 expected Categories
.	TokenNameDOT	
length	TokenNameIdentifier	 length
,	TokenNameCOMMA	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
indexDir	TokenNameIdentifier	 index Dir
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** testWriterTwice is exactly like testWriter, except that after adding all the categories, we add them again, and see that we get the same old ids again - not new categories. */	TokenNameCOMMENT_JAVADOC	 testWriterTwice is exactly like testWriter, except that after adding all the categories, we add them again, and see that we get the same old ids again - not new categories. 
@	TokenNameAT	
Test	TokenNameIdentifier	 Test
public	TokenNamepublic	
void	TokenNamevoid	
testWriterTwice	TokenNameIdentifier	 test Writer Twice
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
Directory	TokenNameIdentifier	 Directory
indexDir	TokenNameIdentifier	 index Dir
=	TokenNameEQUAL	
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyWriter	TokenNameIdentifier	 Taxonomy Writer
tw	TokenNameIdentifier	 tw
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fillTaxonomy	TokenNameIdentifier	 fill Taxonomy
(	TokenNameLPAREN	
tw	TokenNameIdentifier	 tw
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// run fillTaxonomy again - this will try to add the same categories 	TokenNameCOMMENT_LINE	run fillTaxonomy again - this will try to add the same categories 
// again, and check that we see the same ordinal paths again, not 	TokenNameCOMMENT_LINE	again, and check that we see the same ordinal paths again, not 
// different ones. 	TokenNameCOMMENT_LINE	different ones. 
fillTaxonomy	TokenNameIdentifier	 fill Taxonomy
(	TokenNameLPAREN	
tw	TokenNameIdentifier	 tw
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Let's check the number of categories again, to see that no 	TokenNameCOMMENT_LINE	Let's check the number of categories again, to see that no 
// extraneous categories were created: 	TokenNameCOMMENT_LINE	extraneous categories were created: 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
expectedCategories	TokenNameIdentifier	 expected Categories
.	TokenNameDOT	
length	TokenNameIdentifier	 length
,	TokenNameCOMMA	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
indexDir	TokenNameIdentifier	 index Dir
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** testWriterTwice2 is similar to testWriterTwice, except that the index is closed and reopened before attempting to write to it the same categories again. While testWriterTwice can get along with writing and reading correctly just to the cache, testWriterTwice2 checks also the actual disk read part of the writer: */	TokenNameCOMMENT_JAVADOC	 testWriterTwice2 is similar to testWriterTwice, except that the index is closed and reopened before attempting to write to it the same categories again. While testWriterTwice can get along with writing and reading correctly just to the cache, testWriterTwice2 checks also the actual disk read part of the writer: 
@	TokenNameAT	
Test	TokenNameIdentifier	 Test
public	TokenNamepublic	
void	TokenNamevoid	
testWriterTwice2	TokenNameIdentifier	 test Writer Twice2
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
Directory	TokenNameIdentifier	 Directory
indexDir	TokenNameIdentifier	 index Dir
=	TokenNameEQUAL	
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyWriter	TokenNameIdentifier	 Taxonomy Writer
tw	TokenNameIdentifier	 tw
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fillTaxonomy	TokenNameIdentifier	 fill Taxonomy
(	TokenNameLPAREN	
tw	TokenNameIdentifier	 tw
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// run fillTaxonomy again - this will try to add the same categories 	TokenNameCOMMENT_LINE	run fillTaxonomy again - this will try to add the same categories 
// again, and check that we see the same ordinals again, not different 	TokenNameCOMMENT_LINE	again, and check that we see the same ordinals again, not different 
// ones, and that the number of categories hasn't grown by the new 	TokenNameCOMMENT_LINE	ones, and that the number of categories hasn't grown by the new 
// additions 	TokenNameCOMMENT_LINE	additions 
fillTaxonomy	TokenNameIdentifier	 fill Taxonomy
(	TokenNameLPAREN	
tw	TokenNameIdentifier	 tw
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
expectedCategories	TokenNameIdentifier	 expected Categories
.	TokenNameDOT	
length	TokenNameIdentifier	 length
,	TokenNameCOMMA	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
indexDir	TokenNameIdentifier	 index Dir
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * testWriterTwice3 is yet another test which tests creating a taxonomy * in two separate writing sessions. This test used to fail because of * a bug involving commit(), explained below, and now should succeed. * * @throws Exception */	TokenNameCOMMENT_JAVADOC	 testWriterTwice3 is yet another test which tests creating a taxonomy in two separate writing sessions. This test used to fail because of a bug involving commit(), explained below, and now should succeed. * @throws Exception 
@	TokenNameAT	
Test	TokenNameIdentifier	 Test
public	TokenNamepublic	
void	TokenNamevoid	
testWriterTwice3	TokenNameIdentifier	 test Writer Twice3
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
Directory	TokenNameIdentifier	 Directory
indexDir	TokenNameIdentifier	 index Dir
=	TokenNameEQUAL	
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// First, create and fill the taxonomy 	TokenNameCOMMENT_LINE	First, create and fill the taxonomy 
TaxonomyWriter	TokenNameIdentifier	 Taxonomy Writer
tw	TokenNameIdentifier	 tw
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fillTaxonomy	TokenNameIdentifier	 fill Taxonomy
(	TokenNameLPAREN	
tw	TokenNameIdentifier	 tw
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Now, open the same taxonomy and add the same categories again. 	TokenNameCOMMENT_LINE	Now, open the same taxonomy and add the same categories again. 
// After a few categories, the LuceneTaxonomyWriter implementation 	TokenNameCOMMENT_LINE	After a few categories, the LuceneTaxonomyWriter implementation 
// will stop looking for each category on disk, and rather read them 	TokenNameCOMMENT_LINE	will stop looking for each category on disk, and rather read them 
// all into memory and close it's reader. The bug was that it closed 	TokenNameCOMMENT_LINE	all into memory and close it's reader. The bug was that it closed 
// the reader, but forgot that it did (because it didn't set the reader 	TokenNameCOMMENT_LINE	the reader, but forgot that it did (because it didn't set the reader 
// reference to null). 	TokenNameCOMMENT_LINE	reference to null). 
tw	TokenNameIdentifier	 tw
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fillTaxonomy	TokenNameIdentifier	 fill Taxonomy
(	TokenNameLPAREN	
tw	TokenNameIdentifier	 tw
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Add one new category, just to make commit() do something: 	TokenNameCOMMENT_LINE	Add one new category, just to make commit() do something: 
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
addCategory	TokenNameIdentifier	 add Category
(	TokenNameLPAREN	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
"hi"	TokenNameStringLiteral	hi
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Do a commit(). Here was a bug - if tw had a reader open, it should 	TokenNameCOMMENT_LINE	Do a commit(). Here was a bug - if tw had a reader open, it should 
// be reopened after the commit. However, in our case the reader should 	TokenNameCOMMENT_LINE	be reopened after the commit. However, in our case the reader should 
// not be open (as explained above) but because it was not set to null, 	TokenNameCOMMENT_LINE	not be open (as explained above) but because it was not set to null, 
// we forgot that, tried to reopen it, and got an AlreadyClosedException. 	TokenNameCOMMENT_LINE	we forgot that, tried to reopen it, and got an AlreadyClosedException. 
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
commit	TokenNameIdentifier	 commit
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
expectedCategories	TokenNameIdentifier	 expected Categories
.	TokenNameDOT	
length	TokenNameIdentifier	 length
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
indexDir	TokenNameIdentifier	 index Dir
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Another set of tests for the writer, which don't use an array and * try to distill the different cases, and therefore may be more helpful * for debugging a problem than testWriter() which is hard to know why * or where it failed. */	TokenNameCOMMENT_JAVADOC	 Another set of tests for the writer, which don't use an array and try to distill the different cases, and therefore may be more helpful for debugging a problem than testWriter() which is hard to know why or where it failed. 
@	TokenNameAT	
Test	TokenNameIdentifier	 Test
public	TokenNamepublic	
void	TokenNamevoid	
testWriterSimpler	TokenNameIdentifier	 test Writer Simpler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
Directory	TokenNameIdentifier	 Directory
indexDir	TokenNameIdentifier	 index Dir
=	TokenNameEQUAL	
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyWriter	TokenNameIdentifier	 Taxonomy Writer
tw	TokenNameIdentifier	 tw
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// the root only 	TokenNameCOMMENT_LINE	the root only 
// Test that adding a new top-level category works 	TokenNameCOMMENT_LINE	Test that adding a new top-level category works 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
addCategory	TokenNameIdentifier	 add Category
(	TokenNameLPAREN	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
"a"	TokenNameStringLiteral	a
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Test that adding the same category again is noticed, and the 	TokenNameCOMMENT_LINE	Test that adding the same category again is noticed, and the 
// same ordinal (and not a new one) is returned. 	TokenNameCOMMENT_LINE	same ordinal (and not a new one) is returned. 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
addCategory	TokenNameIdentifier	 add Category
(	TokenNameLPAREN	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
"a"	TokenNameStringLiteral	a
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Test that adding another top-level category returns a new ordinal, 	TokenNameCOMMENT_LINE	Test that adding another top-level category returns a new ordinal, 
// not the same one 	TokenNameCOMMENT_LINE	not the same one 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
addCategory	TokenNameIdentifier	 add Category
(	TokenNameLPAREN	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
"b"	TokenNameStringLiteral	b
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Test that adding a category inside one of the above adds just one 	TokenNameCOMMENT_LINE	Test that adding a category inside one of the above adds just one 
// new ordinal: 	TokenNameCOMMENT_LINE	new ordinal: 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
addCategory	TokenNameIdentifier	 add Category
(	TokenNameLPAREN	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
"a"	TokenNameStringLiteral	a
,	TokenNameCOMMA	
"c"	TokenNameStringLiteral	c
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
4	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Test that adding the same second-level category doesn't do anything: 	TokenNameCOMMENT_LINE	Test that adding the same second-level category doesn't do anything: 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
addCategory	TokenNameIdentifier	 add Category
(	TokenNameLPAREN	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
"a"	TokenNameStringLiteral	a
,	TokenNameCOMMA	
"c"	TokenNameStringLiteral	c
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
4	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Test that adding a second-level category with two new components 	TokenNameCOMMENT_LINE	Test that adding a second-level category with two new components 
// indeed adds two categories 	TokenNameCOMMENT_LINE	indeed adds two categories 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
5	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
addCategory	TokenNameIdentifier	 add Category
(	TokenNameLPAREN	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
"d"	TokenNameStringLiteral	d
,	TokenNameCOMMA	
"e"	TokenNameStringLiteral	e
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
6	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Verify that the parents were added above in the order we expected 	TokenNameCOMMENT_LINE	Verify that the parents were added above in the order we expected 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
4	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
addCategory	TokenNameIdentifier	 add Category
(	TokenNameLPAREN	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
"d"	TokenNameStringLiteral	d
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Similar, but inside a category that already exists: 	TokenNameCOMMENT_LINE	Similar, but inside a category that already exists: 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
7	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
addCategory	TokenNameIdentifier	 add Category
(	TokenNameLPAREN	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
"b"	TokenNameStringLiteral	b
,	TokenNameCOMMA	
"d"	TokenNameStringLiteral	d
,	TokenNameCOMMA	
"e"	TokenNameStringLiteral	e
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
8	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// And now inside two levels of categories that already exist: 	TokenNameCOMMENT_LINE	And now inside two levels of categories that already exist: 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
8	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
addCategory	TokenNameIdentifier	 add Category
(	TokenNameLPAREN	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
"b"	TokenNameStringLiteral	b
,	TokenNameCOMMA	
"d"	TokenNameStringLiteral	d
,	TokenNameCOMMA	
"f"	TokenNameStringLiteral	f
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
9	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
indexDir	TokenNameIdentifier	 index Dir
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Test writing an empty index, and seeing that a reader finds in it the root category, and only it. We check all the methods on that root category return the expected results. */	TokenNameCOMMENT_JAVADOC	 Test writing an empty index, and seeing that a reader finds in it the root category, and only it. We check all the methods on that root category return the expected results. 
@	TokenNameAT	
Test	TokenNameIdentifier	 Test
public	TokenNamepublic	
void	TokenNamevoid	
testRootOnly	TokenNameIdentifier	 test Root Only
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
Directory	TokenNameIdentifier	 Directory
indexDir	TokenNameIdentifier	 index Dir
=	TokenNameEQUAL	
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyWriter	TokenNameIdentifier	 Taxonomy Writer
tw	TokenNameIdentifier	 tw
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// right after opening the index, it should already contain the 	TokenNameCOMMENT_LINE	right after opening the index, it should already contain the 
// root, so have size 1: 	TokenNameCOMMENT_LINE	root, so have size 1: 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
tr	TokenNameIdentifier	 tr
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyReader	TokenNameIdentifier	 Directory Taxonomy Reader
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
INVALID_ORDINAL	TokenNameIdentifier	 INVALID  ORDINAL
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getOrdinal	TokenNameIdentifier	 get Ordinal
(	TokenNameLPAREN	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
indexDir	TokenNameIdentifier	 index Dir
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** The following test is exactly the same as testRootOnly, except we * do not close the writer before opening the reader. We want to see * that the root is visible to the reader not only after the writer is * closed, but immediately after it is created. */	TokenNameCOMMENT_JAVADOC	 The following test is exactly the same as testRootOnly, except we do not close the writer before opening the reader. We want to see that the root is visible to the reader not only after the writer is closed, but immediately after it is created. 
@	TokenNameAT	
Test	TokenNameIdentifier	 Test
public	TokenNamepublic	
void	TokenNamevoid	
testRootOnly2	TokenNameIdentifier	 test Root Only2
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
Directory	TokenNameIdentifier	 Directory
indexDir	TokenNameIdentifier	 index Dir
=	TokenNameEQUAL	
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyWriter	TokenNameIdentifier	 Taxonomy Writer
tw	TokenNameIdentifier	 tw
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
commit	TokenNameIdentifier	 commit
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
tr	TokenNameIdentifier	 tr
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyReader	TokenNameIdentifier	 Directory Taxonomy Reader
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
INVALID_ORDINAL	TokenNameIdentifier	 INVALID  ORDINAL
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getOrdinal	TokenNameIdentifier	 get Ordinal
(	TokenNameLPAREN	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
indexDir	TokenNameIdentifier	 index Dir
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Basic tests for TaxonomyReader's category <=> ordinal transformations (getSize(), getCategory() and getOrdinal()). We test that after writing the index, it can be read and all the categories and ordinals are there just as we expected them to be. */	TokenNameCOMMENT_JAVADOC	 Basic tests for TaxonomyReader's category <=> ordinal transformations (getSize(), getCategory() and getOrdinal()). We test that after writing the index, it can be read and all the categories and ordinals are there just as we expected them to be. 
@	TokenNameAT	
Test	TokenNameIdentifier	 Test
public	TokenNamepublic	
void	TokenNamevoid	
testReaderBasic	TokenNameIdentifier	 test Reader Basic
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
Directory	TokenNameIdentifier	 Directory
indexDir	TokenNameIdentifier	 index Dir
=	TokenNameEQUAL	
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyWriter	TokenNameIdentifier	 Taxonomy Writer
tw	TokenNameIdentifier	 tw
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fillTaxonomy	TokenNameIdentifier	 fill Taxonomy
(	TokenNameLPAREN	
tw	TokenNameIdentifier	 tw
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
tr	TokenNameIdentifier	 tr
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyReader	TokenNameIdentifier	 Directory Taxonomy Reader
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// test TaxonomyReader.getSize(): 	TokenNameCOMMENT_LINE	test TaxonomyReader.getSize(): 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
expectedCategories	TokenNameIdentifier	 expected Categories
.	TokenNameDOT	
length	TokenNameIdentifier	 length
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// test round trips of ordinal => category => ordinal 	TokenNameCOMMENT_LINE	test round trips of ordinal => category => ordinal 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getOrdinal	TokenNameIdentifier	 get Ordinal
(	TokenNameLPAREN	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// test TaxonomyReader.getCategory(): 	TokenNameCOMMENT_LINE	test TaxonomyReader.getCategory(): 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CategoryPath	TokenNameIdentifier	 Category Path
expectedCategory	TokenNameIdentifier	 expected Category
=	TokenNameEQUAL	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
expectedCategories	TokenNameIdentifier	 expected Categories
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CategoryPath	TokenNameIdentifier	 Category Path
category	TokenNameIdentifier	 category
=	TokenNameEQUAL	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
expectedCategory	TokenNameIdentifier	 expected Category
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
category	TokenNameIdentifier	 category
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
"For ordinal "	TokenNameStringLiteral	For ordinal 
+	TokenNamePLUS	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
" expected category "	TokenNameStringLiteral	 expected category 
+	TokenNamePLUS	
showcat	TokenNameIdentifier	 showcat
(	TokenNameLPAREN	
expectedCategory	TokenNameIdentifier	 expected Category
)	TokenNameRPAREN	
+	TokenNamePLUS	
", but got "	TokenNameStringLiteral	, but got 
+	TokenNamePLUS	
showcat	TokenNameIdentifier	 showcat
(	TokenNameLPAREN	
category	TokenNameIdentifier	 category
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// (also test invalid ordinals:) 	TokenNameCOMMENT_LINE	(also test invalid ordinals:) 
assertNull	TokenNameIdentifier	 assert Null
(	TokenNameLPAREN	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertNull	TokenNameIdentifier	 assert Null
(	TokenNameLPAREN	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertNull	TokenNameIdentifier	 assert Null
(	TokenNameLPAREN	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
INVALID_ORDINAL	TokenNameIdentifier	 INVALID  ORDINAL
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// test TaxonomyReader.getOrdinal(): 	TokenNameCOMMENT_LINE	test TaxonomyReader.getOrdinal(): 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
expectedCategories	TokenNameIdentifier	 expected Categories
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
expectedOrdinal	TokenNameIdentifier	 expected Ordinal
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
int	TokenNameint	
ordinal	TokenNameIdentifier	 ordinal
=	TokenNameEQUAL	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getOrdinal	TokenNameIdentifier	 get Ordinal
(	TokenNameLPAREN	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
expectedCategories	TokenNameIdentifier	 expected Categories
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
expectedOrdinal	TokenNameIdentifier	 expected Ordinal
!=	TokenNameNOT_EQUAL	
ordinal	TokenNameIdentifier	 ordinal
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
"For category "	TokenNameStringLiteral	For category 
+	TokenNamePLUS	
showcat	TokenNameIdentifier	 showcat
(	TokenNameLPAREN	
expectedCategories	TokenNameIdentifier	 expected Categories
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" expected ordinal "	TokenNameStringLiteral	 expected ordinal 
+	TokenNamePLUS	
expectedOrdinal	TokenNameIdentifier	 expected Ordinal
+	TokenNamePLUS	
", but got "	TokenNameStringLiteral	, but got 
+	TokenNamePLUS	
ordinal	TokenNameIdentifier	 ordinal
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// (also test invalid categories:) 	TokenNameCOMMENT_LINE	(also test invalid categories:) 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
INVALID_ORDINAL	TokenNameIdentifier	 INVALID  ORDINAL
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getOrdinal	TokenNameIdentifier	 get Ordinal
(	TokenNameLPAREN	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
"non-existant"	TokenNameStringLiteral	non-existant
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
INVALID_ORDINAL	TokenNameIdentifier	 INVALID  ORDINAL
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getOrdinal	TokenNameIdentifier	 get Ordinal
(	TokenNameLPAREN	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
"Author"	TokenNameStringLiteral	Author
,	TokenNameCOMMA	
"Jules Verne"	TokenNameStringLiteral	Jules Verne
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
indexDir	TokenNameIdentifier	 index Dir
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Tests for TaxonomyReader's getParent() method. We check it by comparing its results to those we could have gotten by looking at the category string paths (where the parentage is obvious). Note that after testReaderBasic(), we already know we can trust the ordinal <=> category conversions. Note: At the moment, the parent methods in the reader are deprecated, but this does not mean they should not be tested! Until they are removed (*if* they are removed), these tests should remain to see that they still work correctly. */	TokenNameCOMMENT_JAVADOC	 Tests for TaxonomyReader's getParent() method. We check it by comparing its results to those we could have gotten by looking at the category string paths (where the parentage is obvious). Note that after testReaderBasic(), we already know we can trust the ordinal <=> category conversions. Note: At the moment, the parent methods in the reader are deprecated, but this does not mean they should not be tested! Until they are removed (*if* they are removed), these tests should remain to see that they still work correctly. 
@	TokenNameAT	
Test	TokenNameIdentifier	 Test
public	TokenNamepublic	
void	TokenNamevoid	
testReaderParent	TokenNameIdentifier	 test Reader Parent
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
Directory	TokenNameIdentifier	 Directory
indexDir	TokenNameIdentifier	 index Dir
=	TokenNameEQUAL	
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyWriter	TokenNameIdentifier	 Taxonomy Writer
tw	TokenNameIdentifier	 tw
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fillTaxonomy	TokenNameIdentifier	 fill Taxonomy
(	TokenNameLPAREN	
tw	TokenNameIdentifier	 tw
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
tr	TokenNameIdentifier	 tr
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyReader	TokenNameIdentifier	 Directory Taxonomy Reader
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// check that the parent of the root ordinal is the invalid ordinal: 	TokenNameCOMMENT_LINE	check that the parent of the root ordinal is the invalid ordinal: 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
INVALID_ORDINAL	TokenNameIdentifier	 INVALID  ORDINAL
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// check parent of non-root ordinals: 	TokenNameCOMMENT_LINE	check parent of non-root ordinals: 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
ordinal	TokenNameIdentifier	 ordinal
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
ordinal	TokenNameIdentifier	 ordinal
<	TokenNameLESS	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ordinal	TokenNameIdentifier	 ordinal
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CategoryPath	TokenNameIdentifier	 Category Path
me	TokenNameIdentifier	 me
=	TokenNameEQUAL	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
ordinal	TokenNameIdentifier	 ordinal
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
parentOrdinal	TokenNameIdentifier	 parent Ordinal
=	TokenNameEQUAL	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
ordinal	TokenNameIdentifier	 ordinal
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CategoryPath	TokenNameIdentifier	 Category Path
parent	TokenNameIdentifier	 parent
=	TokenNameEQUAL	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
parentOrdinal	TokenNameIdentifier	 parent Ordinal
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
parent	TokenNameIdentifier	 parent
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
"Parent of "	TokenNameStringLiteral	Parent of 
+	TokenNamePLUS	
ordinal	TokenNameIdentifier	 ordinal
+	TokenNamePLUS	
" is "	TokenNameStringLiteral	 is 
+	TokenNamePLUS	
parentOrdinal	TokenNameIdentifier	 parent Ordinal
+	TokenNamePLUS	
", but this is not a valid category."	TokenNameStringLiteral	, but this is not a valid category.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// verify that the parent is indeed my parent, according to the strings 	TokenNameCOMMENT_LINE	verify that the parent is indeed my parent, according to the strings 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
me	TokenNameIdentifier	 me
,	TokenNameCOMMA	
me	TokenNameIdentifier	 me
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
parent	TokenNameIdentifier	 parent
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
"Got parent "	TokenNameStringLiteral	Got parent 
+	TokenNamePLUS	
parentOrdinal	TokenNameIdentifier	 parent Ordinal
+	TokenNamePLUS	
" for ordinal "	TokenNameStringLiteral	 for ordinal 
+	TokenNamePLUS	
ordinal	TokenNameIdentifier	 ordinal
+	TokenNamePLUS	
" but categories are "	TokenNameStringLiteral	 but categories are 
+	TokenNamePLUS	
showcat	TokenNameIdentifier	 showcat
(	TokenNameLPAREN	
parent	TokenNameIdentifier	 parent
)	TokenNameRPAREN	
+	TokenNamePLUS	
" and "	TokenNameStringLiteral	 and 
+	TokenNamePLUS	
showcat	TokenNameIdentifier	 showcat
(	TokenNameLPAREN	
me	TokenNameIdentifier	 me
)	TokenNameRPAREN	
+	TokenNamePLUS	
" respectively."	TokenNameStringLiteral	 respectively.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// check parent of of invalid ordinals: 	TokenNameCOMMENT_LINE	check parent of of invalid ordinals: 
try	TokenNametry	
{	TokenNameLBRACE	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
"getParent for -1 should throw exception"	TokenNameStringLiteral	getParent for -1 should throw exception
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ArrayIndexOutOfBoundsException	TokenNameIdentifier	 Array Index Out Of Bounds Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// ok 	TokenNameCOMMENT_LINE	ok 
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
INVALID_ORDINAL	TokenNameIdentifier	 INVALID  ORDINAL
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
"getParent for INVALID_ORDINAL should throw exception"	TokenNameStringLiteral	getParent for INVALID_ORDINAL should throw exception
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ArrayIndexOutOfBoundsException	TokenNameIdentifier	 Array Index Out Of Bounds Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// ok 	TokenNameCOMMENT_LINE	ok 
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
int	TokenNameint	
parent	TokenNameIdentifier	 parent
=	TokenNameEQUAL	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
"getParent for getSize() should throw exception, but returned "	TokenNameStringLiteral	getParent for getSize() should throw exception, but returned 
+	TokenNamePLUS	
parent	TokenNameIdentifier	 parent
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ArrayIndexOutOfBoundsException	TokenNameIdentifier	 Array Index Out Of Bounds Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// ok 	TokenNameCOMMENT_LINE	ok 
}	TokenNameRBRACE	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
indexDir	TokenNameIdentifier	 index Dir
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Tests for TaxonomyWriter's getParent() method. We check it by comparing * its results to those we could have gotten by looking at the category * string paths using a TaxonomyReader (where the parentage is obvious). * Note that after testReaderBasic(), we already know we can trust the * ordinal <=> category conversions from TaxonomyReader. * * The difference between testWriterParent1 and testWriterParent2 is that * the former closes the taxonomy writer before reopening it, while the * latter does not. * * This test code is virtually identical to that of testReaderParent(). */	TokenNameCOMMENT_JAVADOC	 Tests for TaxonomyWriter's getParent() method. We check it by comparing its results to those we could have gotten by looking at the category string paths using a TaxonomyReader (where the parentage is obvious). Note that after testReaderBasic(), we already know we can trust the ordinal <=> category conversions from TaxonomyReader. * The difference between testWriterParent1 and testWriterParent2 is that the former closes the taxonomy writer before reopening it, while the latter does not. * This test code is virtually identical to that of testReaderParent(). 
@	TokenNameAT	
Test	TokenNameIdentifier	 Test
public	TokenNamepublic	
void	TokenNamevoid	
testWriterParent1	TokenNameIdentifier	 test Writer Parent1
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
Directory	TokenNameIdentifier	 Directory
indexDir	TokenNameIdentifier	 index Dir
=	TokenNameEQUAL	
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyWriter	TokenNameIdentifier	 Taxonomy Writer
tw	TokenNameIdentifier	 tw
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fillTaxonomy	TokenNameIdentifier	 fill Taxonomy
(	TokenNameLPAREN	
tw	TokenNameIdentifier	 tw
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
tr	TokenNameIdentifier	 tr
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyReader	TokenNameIdentifier	 Directory Taxonomy Reader
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
checkWriterParent	TokenNameIdentifier	 check Writer Parent
(	TokenNameLPAREN	
tr	TokenNameIdentifier	 tr
,	TokenNameCOMMA	
tw	TokenNameIdentifier	 tw
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
indexDir	TokenNameIdentifier	 index Dir
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Test	TokenNameIdentifier	 Test
public	TokenNamepublic	
void	TokenNamevoid	
testWriterParent2	TokenNameIdentifier	 test Writer Parent2
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
Directory	TokenNameIdentifier	 Directory
indexDir	TokenNameIdentifier	 index Dir
=	TokenNameEQUAL	
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyWriter	TokenNameIdentifier	 Taxonomy Writer
tw	TokenNameIdentifier	 tw
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fillTaxonomy	TokenNameIdentifier	 fill Taxonomy
(	TokenNameLPAREN	
tw	TokenNameIdentifier	 tw
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
commit	TokenNameIdentifier	 commit
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
tr	TokenNameIdentifier	 tr
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyReader	TokenNameIdentifier	 Directory Taxonomy Reader
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
checkWriterParent	TokenNameIdentifier	 check Writer Parent
(	TokenNameLPAREN	
tr	TokenNameIdentifier	 tr
,	TokenNameCOMMA	
tw	TokenNameIdentifier	 tw
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
indexDir	TokenNameIdentifier	 index Dir
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
checkWriterParent	TokenNameIdentifier	 check Writer Parent
(	TokenNameLPAREN	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
tr	TokenNameIdentifier	 tr
,	TokenNameCOMMA	
TaxonomyWriter	TokenNameIdentifier	 Taxonomy Writer
tw	TokenNameIdentifier	 tw
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
// check that the parent of the root ordinal is the invalid ordinal: 	TokenNameCOMMENT_LINE	check that the parent of the root ordinal is the invalid ordinal: 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
INVALID_ORDINAL	TokenNameIdentifier	 INVALID  ORDINAL
,	TokenNameCOMMA	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// check parent of non-root ordinals: 	TokenNameCOMMENT_LINE	check parent of non-root ordinals: 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
ordinal	TokenNameIdentifier	 ordinal
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
ordinal	TokenNameIdentifier	 ordinal
<	TokenNameLESS	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ordinal	TokenNameIdentifier	 ordinal
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CategoryPath	TokenNameIdentifier	 Category Path
me	TokenNameIdentifier	 me
=	TokenNameEQUAL	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
ordinal	TokenNameIdentifier	 ordinal
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
parentOrdinal	TokenNameIdentifier	 parent Ordinal
=	TokenNameEQUAL	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
ordinal	TokenNameIdentifier	 ordinal
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CategoryPath	TokenNameIdentifier	 Category Path
parent	TokenNameIdentifier	 parent
=	TokenNameEQUAL	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
parentOrdinal	TokenNameIdentifier	 parent Ordinal
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
parent	TokenNameIdentifier	 parent
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
"Parent of "	TokenNameStringLiteral	Parent of 
+	TokenNamePLUS	
ordinal	TokenNameIdentifier	 ordinal
+	TokenNamePLUS	
" is "	TokenNameStringLiteral	 is 
+	TokenNamePLUS	
parentOrdinal	TokenNameIdentifier	 parent Ordinal
+	TokenNamePLUS	
", but this is not a valid category."	TokenNameStringLiteral	, but this is not a valid category.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// verify that the parent is indeed my parent, according to the 	TokenNameCOMMENT_LINE	verify that the parent is indeed my parent, according to the 
// strings 	TokenNameCOMMENT_LINE	strings 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
me	TokenNameIdentifier	 me
,	TokenNameCOMMA	
me	TokenNameIdentifier	 me
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
parent	TokenNameIdentifier	 parent
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
"Got parent "	TokenNameStringLiteral	Got parent 
+	TokenNamePLUS	
parentOrdinal	TokenNameIdentifier	 parent Ordinal
+	TokenNamePLUS	
" for ordinal "	TokenNameStringLiteral	 for ordinal 
+	TokenNamePLUS	
ordinal	TokenNameIdentifier	 ordinal
+	TokenNamePLUS	
" but categories are "	TokenNameStringLiteral	 but categories are 
+	TokenNamePLUS	
showcat	TokenNameIdentifier	 showcat
(	TokenNameLPAREN	
parent	TokenNameIdentifier	 parent
)	TokenNameRPAREN	
+	TokenNamePLUS	
" and "	TokenNameStringLiteral	 and 
+	TokenNamePLUS	
showcat	TokenNameIdentifier	 showcat
(	TokenNameLPAREN	
me	TokenNameIdentifier	 me
)	TokenNameRPAREN	
+	TokenNamePLUS	
" respectively."	TokenNameStringLiteral	 respectively.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// check parent of of invalid ordinals: 	TokenNameCOMMENT_LINE	check parent of of invalid ordinals: 
try	TokenNametry	
{	TokenNameLBRACE	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
"getParent for -1 should throw exception"	TokenNameStringLiteral	getParent for -1 should throw exception
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ArrayIndexOutOfBoundsException	TokenNameIdentifier	 Array Index Out Of Bounds Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// ok 	TokenNameCOMMENT_LINE	ok 
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
INVALID_ORDINAL	TokenNameIdentifier	 INVALID  ORDINAL
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
"getParent for INVALID_ORDINAL should throw exception"	TokenNameStringLiteral	getParent for INVALID_ORDINAL should throw exception
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ArrayIndexOutOfBoundsException	TokenNameIdentifier	 Array Index Out Of Bounds Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// ok 	TokenNameCOMMENT_LINE	ok 
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
int	TokenNameint	
parent	TokenNameIdentifier	 parent
=	TokenNameEQUAL	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
"getParent for getSize() should throw exception, but returned "	TokenNameStringLiteral	getParent for getSize() should throw exception, but returned 
+	TokenNamePLUS	
parent	TokenNameIdentifier	 parent
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ArrayIndexOutOfBoundsException	TokenNameIdentifier	 Array Index Out Of Bounds Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// ok 	TokenNameCOMMENT_LINE	ok 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Tests TaxonomyReader's getParentArray() method. We do not test this method directly, but rather just compare its results to those from other methods (which we have already tested above). */	TokenNameCOMMENT_JAVADOC	 Tests TaxonomyReader's getParentArray() method. We do not test this method directly, but rather just compare its results to those from other methods (which we have already tested above). 
@	TokenNameAT	
Test	TokenNameIdentifier	 Test
public	TokenNamepublic	
void	TokenNamevoid	
testReaderParentArray	TokenNameIdentifier	 test Reader Parent Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
Directory	TokenNameIdentifier	 Directory
indexDir	TokenNameIdentifier	 index Dir
=	TokenNameEQUAL	
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyWriter	TokenNameIdentifier	 Taxonomy Writer
tw	TokenNameIdentifier	 tw
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fillTaxonomy	TokenNameIdentifier	 fill Taxonomy
(	TokenNameLPAREN	
tw	TokenNameIdentifier	 tw
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
tr	TokenNameIdentifier	 tr
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyReader	TokenNameIdentifier	 Directory Taxonomy Reader
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
parents	TokenNameIdentifier	 parents
=	TokenNameEQUAL	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getParentArray	TokenNameIdentifier	 get Parent Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
parents	TokenNameIdentifier	 parents
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
,	TokenNameCOMMA	
parents	TokenNameIdentifier	 parents
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
indexDir	TokenNameIdentifier	 index Dir
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Test TaxonomyReader's child browsing method, getChildrenArrays() * This only tests for correctness of the data on one example - we have * below further tests on data refresh etc. */	TokenNameCOMMENT_JAVADOC	 Test TaxonomyReader's child browsing method, getChildrenArrays() This only tests for correctness of the data on one example - we have below further tests on data refresh etc. 
@	TokenNameAT	
Test	TokenNameIdentifier	 Test
public	TokenNamepublic	
void	TokenNamevoid	
testChildrenArrays	TokenNameIdentifier	 test Children Arrays
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
Directory	TokenNameIdentifier	 Directory
indexDir	TokenNameIdentifier	 index Dir
=	TokenNameEQUAL	
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyWriter	TokenNameIdentifier	 Taxonomy Writer
tw	TokenNameIdentifier	 tw
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fillTaxonomy	TokenNameIdentifier	 fill Taxonomy
(	TokenNameLPAREN	
tw	TokenNameIdentifier	 tw
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
tr	TokenNameIdentifier	 tr
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyReader	TokenNameIdentifier	 Directory Taxonomy Reader
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ChildrenArrays	TokenNameIdentifier	 Children Arrays
ca	TokenNameIdentifier	 ca
=	TokenNameEQUAL	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getChildrenArrays	TokenNameIdentifier	 get Children Arrays
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
youngestChildArray	TokenNameIdentifier	 youngest Child Array
=	TokenNameEQUAL	
ca	TokenNameIdentifier	 ca
.	TokenNameDOT	
getYoungestChildArray	TokenNameIdentifier	 get Youngest Child Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
youngestChildArray	TokenNameIdentifier	 youngest Child Array
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
olderSiblingArray	TokenNameIdentifier	 older Sibling Array
=	TokenNameEQUAL	
ca	TokenNameIdentifier	 ca
.	TokenNameDOT	
getOlderSiblingArray	TokenNameIdentifier	 get Older Sibling Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
olderSiblingArray	TokenNameIdentifier	 older Sibling Array
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
expectedCategories	TokenNameIdentifier	 expected Categories
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// find expected children by looking at all expectedCategories 	TokenNameCOMMENT_LINE	find expected children by looking at all expectedCategories 
// for children 	TokenNameCOMMENT_LINE	for children 
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
expectedChildren	TokenNameIdentifier	 expected Children
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
expectedCategories	TokenNameIdentifier	 expected Categories
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
expectedCategories	TokenNameIdentifier	 expected Categories
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
!=	TokenNameNOT_EQUAL	
expectedCategories	TokenNameIdentifier	 expected Categories
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
// not longer by 1, so can't be a child 	TokenNameCOMMENT_LINE	not longer by 1, so can't be a child 
}	TokenNameRBRACE	
boolean	TokenNameboolean	
ischild	TokenNameIdentifier	 ischild
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
k	TokenNameIdentifier	 k
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
<	TokenNameLESS	
expectedCategories	TokenNameIdentifier	 expected Categories
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
expectedCategories	TokenNameIdentifier	 expected Categories
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
expectedCategories	TokenNameIdentifier	 expected Categories
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ischild	TokenNameIdentifier	 ischild
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ischild	TokenNameIdentifier	 ischild
)	TokenNameRPAREN	
{	TokenNameLBRACE	
expectedChildren	TokenNameIdentifier	 expected Children
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// check that children and expectedChildren are the same, with the 	TokenNameCOMMENT_LINE	check that children and expectedChildren are the same, with the 
// correct reverse (youngest to oldest) order: 	TokenNameCOMMENT_LINE	correct reverse (youngest to oldest) order: 
if	TokenNameif	
(	TokenNameLPAREN	
expectedChildren	TokenNameIdentifier	 expected Children
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
INVALID_ORDINAL	TokenNameIdentifier	 INVALID  ORDINAL
,	TokenNameCOMMA	
youngestChildArray	TokenNameIdentifier	 youngest Child Array
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
youngestChildArray	TokenNameIdentifier	 youngest Child Array
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
expectedChildren	TokenNameIdentifier	 expected Children
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
intValue	TokenNameIdentifier	 int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
expectedChildren	TokenNameIdentifier	 expected Children
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
olderSiblingArray	TokenNameIdentifier	 older Sibling Array
[	TokenNameLBRACKET	
child	TokenNameIdentifier	 child
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
expectedChildren	TokenNameIdentifier	 expected Children
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
.	TokenNameDOT	
intValue	TokenNameIdentifier	 int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// if child is INVALID_ORDINAL we should stop, but 	TokenNameCOMMENT_LINE	if child is INVALID_ORDINAL we should stop, but 
// assertEquals would fail in this case anyway. 	TokenNameCOMMENT_LINE	assertEquals would fail in this case anyway. 
}	TokenNameRBRACE	
// When we're done comparing, olderSiblingArray should now point 	TokenNameCOMMENT_LINE	When we're done comparing, olderSiblingArray should now point 
// to INVALID_ORDINAL, saying there are no more children. If it 	TokenNameCOMMENT_LINE	to INVALID_ORDINAL, saying there are no more children. If it 
// doesn't, we found too many children... 	TokenNameCOMMENT_LINE	doesn't, we found too many children... 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
olderSiblingArray	TokenNameIdentifier	 older Sibling Array
[	TokenNameLBRACKET	
child	TokenNameIdentifier	 child
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
indexDir	TokenNameIdentifier	 index Dir
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Similar to testChildrenArrays, except rather than look at * expected results, we test for several "invariants" that the results * should uphold, e.g., that a child of a category indeed has this category * as its parent. This sort of test can more easily be extended to larger * example taxonomies, because we do not need to build the expected list * of categories like we did in the above test. */	TokenNameCOMMENT_JAVADOC	 Similar to testChildrenArrays, except rather than look at expected results, we test for several "invariants" that the results should uphold, e.g., that a child of a category indeed has this category as its parent. This sort of test can more easily be extended to larger example taxonomies, because we do not need to build the expected list of categories like we did in the above test. 
@	TokenNameAT	
Test	TokenNameIdentifier	 Test
public	TokenNamepublic	
void	TokenNamevoid	
testChildrenArraysInvariants	TokenNameIdentifier	 test Children Arrays Invariants
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
Directory	TokenNameIdentifier	 Directory
indexDir	TokenNameIdentifier	 index Dir
=	TokenNameEQUAL	
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyWriter	TokenNameIdentifier	 Taxonomy Writer
tw	TokenNameIdentifier	 tw
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fillTaxonomy	TokenNameIdentifier	 fill Taxonomy
(	TokenNameLPAREN	
tw	TokenNameIdentifier	 tw
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
tr	TokenNameIdentifier	 tr
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyReader	TokenNameIdentifier	 Directory Taxonomy Reader
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ChildrenArrays	TokenNameIdentifier	 Children Arrays
ca	TokenNameIdentifier	 ca
=	TokenNameEQUAL	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getChildrenArrays	TokenNameIdentifier	 get Children Arrays
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
youngestChildArray	TokenNameIdentifier	 youngest Child Array
=	TokenNameEQUAL	
ca	TokenNameIdentifier	 ca
.	TokenNameDOT	
getYoungestChildArray	TokenNameIdentifier	 get Youngest Child Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
youngestChildArray	TokenNameIdentifier	 youngest Child Array
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
olderSiblingArray	TokenNameIdentifier	 older Sibling Array
=	TokenNameEQUAL	
ca	TokenNameIdentifier	 ca
.	TokenNameDOT	
getOlderSiblingArray	TokenNameIdentifier	 get Older Sibling Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
olderSiblingArray	TokenNameIdentifier	 older Sibling Array
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// test that the "youngest child" of every category is indeed a child: 	TokenNameCOMMENT_LINE	test that the "youngest child" of every category is indeed a child: 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
youngestChild	TokenNameIdentifier	 youngest Child
=	TokenNameEQUAL	
youngestChildArray	TokenNameIdentifier	 youngest Child Array
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
youngestChild	TokenNameIdentifier	 youngest Child
!=	TokenNameNOT_EQUAL	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
INVALID_ORDINAL	TokenNameIdentifier	 INVALID  ORDINAL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
youngestChild	TokenNameIdentifier	 youngest Child
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// test that the "older sibling" of every category is indeed older (lower) 	TokenNameCOMMENT_LINE	test that the "older sibling" of every category is indeed older (lower) 
// (it can also be INVALID_ORDINAL, which is lower than any ordinal) 	TokenNameCOMMENT_LINE	(it can also be INVALID_ORDINAL, which is lower than any ordinal) 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assertTrue	TokenNameIdentifier	 assert True
(	TokenNameLPAREN	
"olderSiblingArray["	TokenNameStringLiteral	olderSiblingArray[
+	TokenNamePLUS	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
"] should be <"	TokenNameStringLiteral	] should be <
+	TokenNamePLUS	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
olderSiblingArray	TokenNameIdentifier	 older Sibling Array
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
<	TokenNameLESS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// test that the "older sibling" of every category is indeed a sibling 	TokenNameCOMMENT_LINE	test that the "older sibling" of every category is indeed a sibling 
// (they share the same parent) 	TokenNameCOMMENT_LINE	(they share the same parent) 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
sibling	TokenNameIdentifier	 sibling
=	TokenNameEQUAL	
olderSiblingArray	TokenNameIdentifier	 older Sibling Array
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sibling	TokenNameIdentifier	 sibling
==	TokenNameEQUAL_EQUAL	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
INVALID_ORDINAL	TokenNameIdentifier	 INVALID  ORDINAL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
sibling	TokenNameIdentifier	 sibling
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// And now for slightly more complex (and less "invariant-like"...) 	TokenNameCOMMENT_LINE	And now for slightly more complex (and less "invariant-like"...) 
// tests: 	TokenNameCOMMENT_LINE	tests: 
// test that the "youngest child" is indeed the youngest (so we don't 	TokenNameCOMMENT_LINE	test that the "youngest child" is indeed the youngest (so we don't 
// miss the first children in the chain) 	TokenNameCOMMENT_LINE	miss the first children in the chain) 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Find the really youngest child: 	TokenNameCOMMENT_LINE	Find the really youngest child: 
int	TokenNameint	
j	TokenNameIdentifier	 j
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
>	TokenNameGREATER	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
// found youngest child 	TokenNameCOMMENT_LINE	found youngest child 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
==	TokenNameEQUAL_EQUAL	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// no child found 	TokenNameCOMMENT_LINE	no child found 
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
INVALID_ORDINAL	TokenNameIdentifier	 INVALID  ORDINAL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
,	TokenNameCOMMA	
youngestChildArray	TokenNameIdentifier	 youngest Child Array
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// test that the "older sibling" is indeed the least oldest one - and 	TokenNameCOMMENT_LINE	test that the "older sibling" is indeed the least oldest one - and 
// not a too old one or -1 (so we didn't miss some children in the 	TokenNameCOMMENT_LINE	not a too old one or -1 (so we didn't miss some children in the 
// middle or the end of the chain). 	TokenNameCOMMENT_LINE	middle or the end of the chain). 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Find the youngest older sibling: 	TokenNameCOMMENT_LINE	Find the youngest older sibling: 
int	TokenNameint	
j	TokenNameIdentifier	 j
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
// found youngest older sibling 	TokenNameCOMMENT_LINE	found youngest older sibling 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// no sibling found 	TokenNameCOMMENT_LINE	no sibling found 
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
INVALID_ORDINAL	TokenNameIdentifier	 INVALID  ORDINAL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
,	TokenNameCOMMA	
olderSiblingArray	TokenNameIdentifier	 older Sibling Array
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
indexDir	TokenNameIdentifier	 index Dir
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Test how getChildrenArrays() deals with the taxonomy's growth: */	TokenNameCOMMENT_JAVADOC	 Test how getChildrenArrays() deals with the taxonomy's growth: 
@	TokenNameAT	
Test	TokenNameIdentifier	 Test
public	TokenNamepublic	
void	TokenNamevoid	
testChildrenArraysGrowth	TokenNameIdentifier	 test Children Arrays Growth
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
Directory	TokenNameIdentifier	 Directory
indexDir	TokenNameIdentifier	 index Dir
=	TokenNameEQUAL	
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyWriter	TokenNameIdentifier	 Taxonomy Writer
tw	TokenNameIdentifier	 tw
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
addCategory	TokenNameIdentifier	 add Category
(	TokenNameLPAREN	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
"hi"	TokenNameStringLiteral	hi
,	TokenNameCOMMA	
"there"	TokenNameStringLiteral	there
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
commit	TokenNameIdentifier	 commit
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
tr	TokenNameIdentifier	 tr
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyReader	TokenNameIdentifier	 Directory Taxonomy Reader
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ChildrenArrays	TokenNameIdentifier	 Children Arrays
ca	TokenNameIdentifier	 ca
=	TokenNameEQUAL	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getChildrenArrays	TokenNameIdentifier	 get Children Arrays
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
ca	TokenNameIdentifier	 ca
.	TokenNameDOT	
getOlderSiblingArray	TokenNameIdentifier	 get Older Sibling Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
ca	TokenNameIdentifier	 ca
.	TokenNameDOT	
getYoungestChildArray	TokenNameIdentifier	 get Youngest Child Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertTrue	TokenNameIdentifier	 assert True
(	TokenNameLPAREN	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
ca	TokenNameIdentifier	 ca
.	TokenNameDOT	
getYoungestChildArray	TokenNameIdentifier	 get Youngest Child Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertTrue	TokenNameIdentifier	 assert True
(	TokenNameLPAREN	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
ca	TokenNameIdentifier	 ca
.	TokenNameDOT	
getOlderSiblingArray	TokenNameIdentifier	 get Older Sibling Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
addCategory	TokenNameIdentifier	 add Category
(	TokenNameLPAREN	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
"hi"	TokenNameStringLiteral	hi
,	TokenNameCOMMA	
"ho"	TokenNameStringLiteral	ho
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
addCategory	TokenNameIdentifier	 add Category
(	TokenNameLPAREN	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
"hello"	TokenNameStringLiteral	hello
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
commit	TokenNameIdentifier	 commit
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Before refresh, nothing changed.. 	TokenNameCOMMENT_LINE	Before refresh, nothing changed.. 
ChildrenArrays	TokenNameIdentifier	 Children Arrays
newca	TokenNameIdentifier	 newca
=	TokenNameEQUAL	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getChildrenArrays	TokenNameIdentifier	 get Children Arrays
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertSame	TokenNameIdentifier	 assert Same
(	TokenNameLPAREN	
newca	TokenNameIdentifier	 newca
,	TokenNameCOMMA	
ca	TokenNameIdentifier	 ca
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// we got exactly the same object 	TokenNameCOMMENT_LINE	we got exactly the same object 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
ca	TokenNameIdentifier	 ca
.	TokenNameDOT	
getOlderSiblingArray	TokenNameIdentifier	 get Older Sibling Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
ca	TokenNameIdentifier	 ca
.	TokenNameDOT	
getYoungestChildArray	TokenNameIdentifier	 get Youngest Child Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// After the refresh, things change: 	TokenNameCOMMENT_LINE	After the refresh, things change: 
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
refresh	TokenNameIdentifier	 refresh
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ca	TokenNameIdentifier	 ca
=	TokenNameEQUAL	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getChildrenArrays	TokenNameIdentifier	 get Children Arrays
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
5	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
5	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
ca	TokenNameIdentifier	 ca
.	TokenNameDOT	
getOlderSiblingArray	TokenNameIdentifier	 get Older Sibling Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
5	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
ca	TokenNameIdentifier	 ca
.	TokenNameDOT	
getYoungestChildArray	TokenNameIdentifier	 get Youngest Child Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertTrue	TokenNameIdentifier	 assert True
(	TokenNameLPAREN	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
4	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
ca	TokenNameIdentifier	 ca
.	TokenNameDOT	
getYoungestChildArray	TokenNameIdentifier	 get Youngest Child Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertTrue	TokenNameIdentifier	 assert True
(	TokenNameLPAREN	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
ca	TokenNameIdentifier	 ca
.	TokenNameDOT	
getOlderSiblingArray	TokenNameIdentifier	 get Older Sibling Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
indexDir	TokenNameIdentifier	 index Dir
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Test that getParentArrays is valid when retrieved during refresh */	TokenNameCOMMENT_JAVADOC	 Test that getParentArrays is valid when retrieved during refresh 
@	TokenNameAT	
Test	TokenNameIdentifier	 Test
@	TokenNameAT	
Ignore	TokenNameIdentifier	 Ignore
public	TokenNamepublic	
void	TokenNamevoid	
testTaxonomyReaderRefreshRaces	TokenNameIdentifier	 test Taxonomy Reader Refresh Races
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
// compute base child arrays - after first chunk, and after the other 	TokenNameCOMMENT_LINE	compute base child arrays - after first chunk, and after the other 
Directory	TokenNameIdentifier	 Directory
indexDirBase	TokenNameIdentifier	 index Dir Base
=	TokenNameEQUAL	
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyWriter	TokenNameIdentifier	 Taxonomy Writer
twBase	TokenNameIdentifier	 tw Base
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
(	TokenNameLPAREN	
indexDirBase	TokenNameIdentifier	 index Dir Base
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
twBase	TokenNameIdentifier	 tw Base
.	TokenNameDOT	
addCategory	TokenNameIdentifier	 add Category
(	TokenNameLPAREN	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
"a"	TokenNameStringLiteral	a
,	TokenNameCOMMA	
"0"	TokenNameStringLiteral	0
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
CategoryPath	TokenNameIdentifier	 Category Path
abPath	TokenNameIdentifier	 ab Path
=	TokenNameEQUAL	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
"a"	TokenNameStringLiteral	a
,	TokenNameCOMMA	
"b"	TokenNameStringLiteral	b
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
twBase	TokenNameIdentifier	 tw Base
.	TokenNameDOT	
addCategory	TokenNameIdentifier	 add Category
(	TokenNameLPAREN	
abPath	TokenNameIdentifier	 ab Path
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
twBase	TokenNameIdentifier	 tw Base
.	TokenNameDOT	
commit	TokenNameIdentifier	 commit
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
trBase	TokenNameIdentifier	 tr Base
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyReader	TokenNameIdentifier	 Directory Taxonomy Reader
(	TokenNameLPAREN	
indexDirBase	TokenNameIdentifier	 index Dir Base
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
ChildrenArrays	TokenNameIdentifier	 Children Arrays
ca1	TokenNameIdentifier	 ca1
=	TokenNameEQUAL	
trBase	TokenNameIdentifier	 tr Base
.	TokenNameDOT	
getChildrenArrays	TokenNameIdentifier	 get Children Arrays
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
abOrd	TokenNameIdentifier	 ab Ord
=	TokenNameEQUAL	
trBase	TokenNameIdentifier	 tr Base
.	TokenNameDOT	
getOrdinal	TokenNameIdentifier	 get Ordinal
(	TokenNameLPAREN	
abPath	TokenNameIdentifier	 ab Path
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
abYoungChildBase1	TokenNameIdentifier	 ab Young Child Base1
=	TokenNameEQUAL	
ca1	TokenNameIdentifier	 ca1
.	TokenNameDOT	
getYoungestChildArray	TokenNameIdentifier	 get Youngest Child Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
abOrd	TokenNameIdentifier	 ab Ord
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//1024 facets 	TokenNameCOMMENT_LINE	1024 facets 
twBase	TokenNameIdentifier	 tw Base
.	TokenNameDOT	
addCategory	TokenNameIdentifier	 add Category
(	TokenNameLPAREN	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
"a"	TokenNameStringLiteral	a
,	TokenNameCOMMA	
"b"	TokenNameStringLiteral	b
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
twBase	TokenNameIdentifier	 tw Base
.	TokenNameDOT	
commit	TokenNameIdentifier	 commit
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
trBase	TokenNameIdentifier	 tr Base
.	TokenNameDOT	
refresh	TokenNameIdentifier	 refresh
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
ChildrenArrays	TokenNameIdentifier	 Children Arrays
ca2	TokenNameIdentifier	 ca2
=	TokenNameEQUAL	
trBase	TokenNameIdentifier	 tr Base
.	TokenNameDOT	
getChildrenArrays	TokenNameIdentifier	 get Children Arrays
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
abYoungChildBase2	TokenNameIdentifier	 ab Young Child Base2
=	TokenNameEQUAL	
ca2	TokenNameIdentifier	 ca2
.	TokenNameDOT	
getYoungestChildArray	TokenNameIdentifier	 get Youngest Child Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
abOrd	TokenNameIdentifier	 ab Ord
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
retry	TokenNameIdentifier	 retry
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
retry	TokenNameIdentifier	 retry
<	TokenNameLESS	
100	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
retry	TokenNameIdentifier	 retry
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assertConsistentYoungestChild	TokenNameIdentifier	 assert Consistent Youngest Child
(	TokenNameLPAREN	
abPath	TokenNameIdentifier	 ab Path
,	TokenNameCOMMA	
abOrd	TokenNameIdentifier	 ab Ord
,	TokenNameCOMMA	
abYoungChildBase1	TokenNameIdentifier	 ab Young Child Base1
,	TokenNameCOMMA	
abYoungChildBase2	TokenNameIdentifier	 ab Young Child Base2
,	TokenNameCOMMA	
retry	TokenNameIdentifier	 retry
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
indexDirBase	TokenNameIdentifier	 index Dir Base
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
assertConsistentYoungestChild	TokenNameIdentifier	 assert Consistent Youngest Child
(	TokenNameLPAREN	
final	TokenNamefinal	
CategoryPath	TokenNameIdentifier	 Category Path
abPath	TokenNameIdentifier	 ab Path
,	TokenNameCOMMA	
final	TokenNamefinal	
int	TokenNameint	
abOrd	TokenNameIdentifier	 ab Ord
,	TokenNameCOMMA	
final	TokenNamefinal	
int	TokenNameint	
abYoungChildBase1	TokenNameIdentifier	 ab Young Child Base1
,	TokenNameCOMMA	
final	TokenNamefinal	
int	TokenNameint	
abYoungChildBase2	TokenNameIdentifier	 ab Young Child Base2
,	TokenNameCOMMA	
final	TokenNamefinal	
int	TokenNameint	
retry	TokenNameIdentifier	 retry
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
SlowRAMDirectory	TokenNameIdentifier	 Slow RAM Directory
indexDir	TokenNameIdentifier	 index Dir
=	TokenNameEQUAL	
new	TokenNamenew	
SlowRAMDirectory	TokenNameIdentifier	 Slow RAM Directory
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// no slowness for intialization 	TokenNameCOMMENT_LINE	no slowness for intialization 
TaxonomyWriter	TokenNameIdentifier	 Taxonomy Writer
tw	TokenNameIdentifier	 tw
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
addCategory	TokenNameIdentifier	 add Category
(	TokenNameLPAREN	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
"a"	TokenNameStringLiteral	a
,	TokenNameCOMMA	
"0"	TokenNameStringLiteral	0
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
addCategory	TokenNameIdentifier	 add Category
(	TokenNameLPAREN	
abPath	TokenNameIdentifier	 ab Path
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
commit	TokenNameIdentifier	 commit
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
tr	TokenNameIdentifier	 tr
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyReader	TokenNameIdentifier	 Directory Taxonomy Reader
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//1024 facets 	TokenNameCOMMENT_LINE	1024 facets 
final	TokenNamefinal	
CategoryPath	TokenNameIdentifier	 Category Path
cp	TokenNameIdentifier	 cp
=	TokenNameEQUAL	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
"a"	TokenNameStringLiteral	a
,	TokenNameCOMMA	
"b"	TokenNameStringLiteral	b
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
addCategory	TokenNameIdentifier	 add Category
(	TokenNameLPAREN	
cp	TokenNameIdentifier	 cp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
"Ordinal of "	TokenNameStringLiteral	Ordinal of 
+	TokenNamePLUS	
cp	TokenNameIdentifier	 cp
+	TokenNamePLUS	
" must be invalid until Taxonomy Reader was refreshed"	TokenNameStringLiteral	 must be invalid until Taxonomy Reader was refreshed
,	TokenNameCOMMA	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
INVALID_ORDINAL	TokenNameIdentifier	 INVALID  ORDINAL
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getOrdinal	TokenNameIdentifier	 get Ordinal
(	TokenNameLPAREN	
cp	TokenNameIdentifier	 cp
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
commit	TokenNameIdentifier	 commit
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
stop	TokenNameIdentifier	 stop
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
false	TokenNamefalse	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Throwable	TokenNameIdentifier	 Throwable
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
error	TokenNameIdentifier	 error
=	TokenNameEQUAL	
new	TokenNamenew	
Throwable	TokenNameIdentifier	 Throwable
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
null	TokenNamenull	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
retrieval	TokenNameIdentifier	 retrieval
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
{	TokenNameLBRACE	
0	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
Thread	TokenNameIdentifier	 Thread
thread	TokenNameIdentifier	 thread
=	TokenNameEQUAL	
new	TokenNamenew	
Thread	TokenNameIdentifier	 Thread
(	TokenNameLPAREN	
"Child Arrays Verifier"	TokenNameStringLiteral	Child Arrays Verifier
)	TokenNameRPAREN	
{	TokenNameLBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
run	TokenNameIdentifier	 run
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
setPriority	TokenNameIdentifier	 set Priority
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
getPriority	TokenNameIdentifier	 get Priority
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
!	TokenNameNOT	
stop	TokenNameIdentifier	 stop
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
lastOrd	TokenNameIdentifier	 last Ord
=	TokenNameEQUAL	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getParentArray	TokenNameIdentifier	 get Parent Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
assertNotNull	TokenNameIdentifier	 assert Not Null
(	TokenNameLPAREN	
"path of last-ord "	TokenNameStringLiteral	path of last-ord 
+	TokenNamePLUS	
lastOrd	TokenNameIdentifier	 last Ord
+	TokenNamePLUS	
" is not found!"	TokenNameStringLiteral	 is not found!
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
lastOrd	TokenNameIdentifier	 last Ord
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertChildrenArrays	TokenNameIdentifier	 assert Children Arrays
(	TokenNameLPAREN	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getChildrenArrays	TokenNameIdentifier	 get Children Arrays
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
retry	TokenNameIdentifier	 retry
,	TokenNameCOMMA	
retrieval	TokenNameIdentifier	 retrieval
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Throwable	TokenNameIdentifier	 Throwable
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
error	TokenNameIdentifier	 error
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
stop	TokenNameIdentifier	 stop
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
assertChildrenArrays	TokenNameIdentifier	 assert Children Arrays
(	TokenNameLPAREN	
ChildrenArrays	TokenNameIdentifier	 Children Arrays
ca	TokenNameIdentifier	 ca
,	TokenNameCOMMA	
int	TokenNameint	
retry	TokenNameIdentifier	 retry
,	TokenNameCOMMA	
int	TokenNameint	
retrieval	TokenNameIdentifier	 retrieval
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
abYoungChild	TokenNameIdentifier	 ab Young Child
=	TokenNameEQUAL	
ca	TokenNameIdentifier	 ca
.	TokenNameDOT	
getYoungestChildArray	TokenNameIdentifier	 get Youngest Child Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
abOrd	TokenNameIdentifier	 ab Ord
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
assertTrue	TokenNameIdentifier	 assert True
(	TokenNameLPAREN	
"Retry "	TokenNameStringLiteral	Retry 
+	TokenNamePLUS	
retry	TokenNameIdentifier	 retry
+	TokenNamePLUS	
": retrieval: "	TokenNameStringLiteral	: retrieval: 
+	TokenNamePLUS	
retrieval	TokenNameIdentifier	 retrieval
+	TokenNamePLUS	
": wrong youngest child for category "	TokenNameStringLiteral	: wrong youngest child for category 
+	TokenNamePLUS	
abPath	TokenNameIdentifier	 ab Path
+	TokenNamePLUS	
" (ord="	TokenNameStringLiteral	 (ord=
+	TokenNamePLUS	
abOrd	TokenNameIdentifier	 ab Ord
+	TokenNamePLUS	
") - must be either "	TokenNameStringLiteral	) - must be either 
+	TokenNamePLUS	
abYoungChildBase1	TokenNameIdentifier	 ab Young Child Base1
+	TokenNamePLUS	
" or "	TokenNameStringLiteral	 or 
+	TokenNamePLUS	
abYoungChildBase2	TokenNameIdentifier	 ab Young Child Base2
+	TokenNamePLUS	
" but was: "	TokenNameStringLiteral	 but was: 
+	TokenNamePLUS	
abYoungChild	TokenNameIdentifier	 ab Young Child
,	TokenNameCOMMA	
abYoungChildBase1	TokenNameIdentifier	 ab Young Child Base1
==	TokenNameEQUAL_EQUAL	
abYoungChild	TokenNameIdentifier	 ab Young Child
||	TokenNameOR_OR	
abYoungChildBase2	TokenNameIdentifier	 ab Young Child Base2
==	TokenNameEQUAL_EQUAL	
ca	TokenNameIdentifier	 ca
.	TokenNameDOT	
getYoungestChildArray	TokenNameIdentifier	 get Youngest Child Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
abOrd	TokenNameIdentifier	 ab Ord
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
thread	TokenNameIdentifier	 thread
.	TokenNameDOT	
start	TokenNameIdentifier	 start
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
indexDir	TokenNameIdentifier	 index Dir
.	TokenNameDOT	
setSleepMillis	TokenNameIdentifier	 set Sleep Millis
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// some delay for refresh 	TokenNameCOMMENT_LINE	some delay for refresh 
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
refresh	TokenNameIdentifier	 refresh
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
stop	TokenNameIdentifier	 stop
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
thread	TokenNameIdentifier	 thread
.	TokenNameDOT	
join	TokenNameIdentifier	 join
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertNull	TokenNameIdentifier	 assert Null
(	TokenNameLPAREN	
"Unexpcted exception at retry "	TokenNameStringLiteral	Unexpcted exception at retry 
+	TokenNamePLUS	
retry	TokenNameIdentifier	 retry
+	TokenNamePLUS	
" retrieval "	TokenNameStringLiteral	 retrieval 
+	TokenNamePLUS	
retrieval	TokenNameIdentifier	 retrieval
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
+	TokenNamePLUS	
": "	TokenNameStringLiteral	: 
+	TokenNamePLUS	
stackTraceStr	TokenNameIdentifier	 stack Trace Str
(	TokenNameLPAREN	
error	TokenNameIdentifier	 error
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
error	TokenNameIdentifier	 error
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Grab the stack trace into a string since the exception was thrown in a thread and we want the assert * outside the thread to show the stack trace in case of failure. */	TokenNameCOMMENT_JAVADOC	 Grab the stack trace into a string since the exception was thrown in a thread and we want the assert outside the thread to show the stack trace in case of failure. 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
stackTraceStr	TokenNameIdentifier	 stack Trace Str
(	TokenNameLPAREN	
final	TokenNamefinal	
Throwable	TokenNameIdentifier	 Throwable
error	TokenNameIdentifier	 error
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
error	TokenNameIdentifier	 error
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
StringWriter	TokenNameIdentifier	 String Writer
sw	TokenNameIdentifier	 sw
=	TokenNameEQUAL	
new	TokenNamenew	
StringWriter	TokenNameIdentifier	 String Writer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
PrintWriter	TokenNameIdentifier	 Print Writer
pw	TokenNameIdentifier	 pw
=	TokenNameEQUAL	
new	TokenNamenew	
PrintWriter	TokenNameIdentifier	 Print Writer
(	TokenNameLPAREN	
sw	TokenNameIdentifier	 sw
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
error	TokenNameIdentifier	 error
.	TokenNameDOT	
printStackTrace	TokenNameIdentifier	 print Stack Trace
(	TokenNameLPAREN	
pw	TokenNameIdentifier	 pw
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pw	TokenNameIdentifier	 pw
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
sw	TokenNameIdentifier	 sw
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Test that if separate reader and writer objects are opened, new categories written into the writer are available to a reader only after a commit(). Note that this test obviously doesn't cover all the different concurrency scenarios, all different methods, and so on. We may want to write more tests of this sort. This test simulates what would happen when there are two separate processes, one doing indexing, and the other searching, and each opens its own object (with obviously no connection between the objects) using the same disk files. Note, though, that this test does not test what happens when the two processes do their actual work at exactly the same time. It also doesn't test multi-threading. */	TokenNameCOMMENT_JAVADOC	 Test that if separate reader and writer objects are opened, new categories written into the writer are available to a reader only after a commit(). Note that this test obviously doesn't cover all the different concurrency scenarios, all different methods, and so on. We may want to write more tests of this sort. This test simulates what would happen when there are two separate processes, one doing indexing, and the other searching, and each opens its own object (with obviously no connection between the objects) using the same disk files. Note, though, that this test does not test what happens when the two processes do their actual work at exactly the same time. It also doesn't test multi-threading. 
@	TokenNameAT	
Test	TokenNameIdentifier	 Test
public	TokenNamepublic	
void	TokenNamevoid	
testSeparateReaderAndWriter	TokenNameIdentifier	 test Separate Reader And Writer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
Directory	TokenNameIdentifier	 Directory
indexDir	TokenNameIdentifier	 index Dir
=	TokenNameEQUAL	
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyWriter	TokenNameIdentifier	 Taxonomy Writer
tw	TokenNameIdentifier	 tw
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
commit	TokenNameIdentifier	 commit
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
tr	TokenNameIdentifier	 tr
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyReader	TokenNameIdentifier	 Directory Taxonomy Reader
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
author	TokenNameIdentifier	 author
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// getParent() and getSize() test: 	TokenNameCOMMENT_LINE	getParent() and getSize() test: 
try	TokenNametry	
{	TokenNameLBRACE	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
author	TokenNameIdentifier	 author
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
"Initially, getParent for "	TokenNameStringLiteral	Initially, getParent for 
+	TokenNamePLUS	
author	TokenNameIdentifier	 author
+	TokenNamePLUS	
" should throw exception"	TokenNameStringLiteral	 should throw exception
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ArrayIndexOutOfBoundsException	TokenNameIdentifier	 Array Index Out Of Bounds Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// ok 	TokenNameCOMMENT_LINE	ok 
}	TokenNameRBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// the empty taxonomy has size 1 (the root) 	TokenNameCOMMENT_LINE	the empty taxonomy has size 1 (the root) 
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
addCategory	TokenNameIdentifier	 add Category
(	TokenNameLPAREN	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
"Author"	TokenNameStringLiteral	Author
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
author	TokenNameIdentifier	 author
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
"Before commit() and refresh(), getParent for "	TokenNameStringLiteral	Before commit() and refresh(), getParent for 
+	TokenNamePLUS	
author	TokenNameIdentifier	 author
+	TokenNamePLUS	
" should still throw exception"	TokenNameStringLiteral	 should still throw exception
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ArrayIndexOutOfBoundsException	TokenNameIdentifier	 Array Index Out Of Bounds Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// ok 	TokenNameCOMMENT_LINE	ok 
}	TokenNameRBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// still root only... 	TokenNameCOMMENT_LINE	still root only... 
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
refresh	TokenNameIdentifier	 refresh
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// this is not enough, because tw.commit() hasn't been done yet 	TokenNameCOMMENT_LINE	this is not enough, because tw.commit() hasn't been done yet 
try	TokenNametry	
{	TokenNameLBRACE	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
author	TokenNameIdentifier	 author
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
"Before commit() and refresh(), getParent for "	TokenNameStringLiteral	Before commit() and refresh(), getParent for 
+	TokenNamePLUS	
author	TokenNameIdentifier	 author
+	TokenNamePLUS	
" should still throw exception"	TokenNameStringLiteral	 should still throw exception
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ArrayIndexOutOfBoundsException	TokenNameIdentifier	 Array Index Out Of Bounds Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// ok 	TokenNameCOMMENT_LINE	ok 
}	TokenNameRBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// still root only... 	TokenNameCOMMENT_LINE	still root only... 
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
commit	TokenNameIdentifier	 commit
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
author	TokenNameIdentifier	 author
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
"Before refresh(), getParent for "	TokenNameStringLiteral	Before refresh(), getParent for 
+	TokenNamePLUS	
author	TokenNameIdentifier	 author
+	TokenNamePLUS	
" should still throw exception"	TokenNameStringLiteral	 should still throw exception
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ArrayIndexOutOfBoundsException	TokenNameIdentifier	 Array Index Out Of Bounds Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// ok 	TokenNameCOMMENT_LINE	ok 
}	TokenNameRBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// still root only... 	TokenNameCOMMENT_LINE	still root only... 
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
refresh	TokenNameIdentifier	 refresh
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
ROOT_ORDINAL	TokenNameIdentifier	 ROOT  ORDINAL
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
author	TokenNameIdentifier	 author
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// ok 	TokenNameCOMMENT_LINE	ok 
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ArrayIndexOutOfBoundsException	TokenNameIdentifier	 Array Index Out Of Bounds Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
"After category addition, commit() and refresh(), getParent for "	TokenNameStringLiteral	After category addition, commit() and refresh(), getParent for 
+	TokenNamePLUS	
author	TokenNameIdentifier	 author
+	TokenNamePLUS	
" should NOT throw exception"	TokenNameStringLiteral	 should NOT throw exception
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// finally, see there are two categories 	TokenNameCOMMENT_LINE	finally, see there are two categories 
// now, add another category, and verify that after commit and refresh 	TokenNameCOMMENT_LINE	now, add another category, and verify that after commit and refresh 
// the parent of this category is correct (this requires the reader 	TokenNameCOMMENT_LINE	the parent of this category is correct (this requires the reader 
// to correctly update its prefetched parent vector), and that the 	TokenNameCOMMENT_LINE	to correctly update its prefetched parent vector), and that the 
// old information also wasn't ruined: 	TokenNameCOMMENT_LINE	old information also wasn't ruined: 
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
addCategory	TokenNameIdentifier	 add Category
(	TokenNameLPAREN	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
"Author"	TokenNameStringLiteral	Author
,	TokenNameCOMMA	
"Richard Dawkins"	TokenNameStringLiteral	Richard Dawkins
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
dawkins	TokenNameIdentifier	 dawkins
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
commit	TokenNameIdentifier	 commit
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
refresh	TokenNameIdentifier	 refresh
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
author	TokenNameIdentifier	 author
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
dawkins	TokenNameIdentifier	 dawkins
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
ROOT_ORDINAL	TokenNameIdentifier	 ROOT  ORDINAL
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
author	TokenNameIdentifier	 author
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
INVALID_ORDINAL	TokenNameIdentifier	 INVALID  ORDINAL
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
ROOT_ORDINAL	TokenNameIdentifier	 ROOT  ORDINAL
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
indexDir	TokenNameIdentifier	 index Dir
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Test	TokenNameIdentifier	 Test
public	TokenNamepublic	
void	TokenNamevoid	
testSeparateReaderAndWriter2	TokenNameIdentifier	 test Separate Reader And Writer2
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
Directory	TokenNameIdentifier	 Directory
indexDir	TokenNameIdentifier	 index Dir
=	TokenNameEQUAL	
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyWriter	TokenNameIdentifier	 Taxonomy Writer
tw	TokenNameIdentifier	 tw
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
commit	TokenNameIdentifier	 commit
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
tr	TokenNameIdentifier	 tr
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyReader	TokenNameIdentifier	 Directory Taxonomy Reader
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Test getOrdinal(): 	TokenNameCOMMENT_LINE	Test getOrdinal(): 
CategoryPath	TokenNameIdentifier	 Category Path
author	TokenNameIdentifier	 author
=	TokenNameEQUAL	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
"Author"	TokenNameStringLiteral	Author
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// the empty taxonomy has size 1 (the root) 	TokenNameCOMMENT_LINE	the empty taxonomy has size 1 (the root) 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
INVALID_ORDINAL	TokenNameIdentifier	 INVALID  ORDINAL
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getOrdinal	TokenNameIdentifier	 get Ordinal
(	TokenNameLPAREN	
author	TokenNameIdentifier	 author
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
addCategory	TokenNameIdentifier	 add Category
(	TokenNameLPAREN	
author	TokenNameIdentifier	 author
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// before commit and refresh, no change: 	TokenNameCOMMENT_LINE	before commit and refresh, no change: 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
INVALID_ORDINAL	TokenNameIdentifier	 INVALID  ORDINAL
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getOrdinal	TokenNameIdentifier	 get Ordinal
(	TokenNameLPAREN	
author	TokenNameIdentifier	 author
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// still root only... 	TokenNameCOMMENT_LINE	still root only... 
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
refresh	TokenNameIdentifier	 refresh
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// this is not enough, because tw.commit() hasn't been done yet 	TokenNameCOMMENT_LINE	this is not enough, because tw.commit() hasn't been done yet 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
INVALID_ORDINAL	TokenNameIdentifier	 INVALID  ORDINAL
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getOrdinal	TokenNameIdentifier	 get Ordinal
(	TokenNameLPAREN	
author	TokenNameIdentifier	 author
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// still root only... 	TokenNameCOMMENT_LINE	still root only... 
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
commit	TokenNameIdentifier	 commit
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// still not enough before refresh: 	TokenNameCOMMENT_LINE	still not enough before refresh: 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
INVALID_ORDINAL	TokenNameIdentifier	 INVALID  ORDINAL
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getOrdinal	TokenNameIdentifier	 get Ordinal
(	TokenNameLPAREN	
author	TokenNameIdentifier	 author
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// still root only... 	TokenNameCOMMENT_LINE	still root only... 
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
refresh	TokenNameIdentifier	 refresh
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// finally 	TokenNameCOMMENT_LINE	finally 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getOrdinal	TokenNameIdentifier	 get Ordinal
(	TokenNameLPAREN	
author	TokenNameIdentifier	 author
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// still root only... 	TokenNameCOMMENT_LINE	still root only... 
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
indexDir	TokenNameIdentifier	 index Dir
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Test what happens if we try to write to a locked taxonomy writer, * and see that we can unlock it and continue. */	TokenNameCOMMENT_JAVADOC	 Test what happens if we try to write to a locked taxonomy writer, and see that we can unlock it and continue. 
@	TokenNameAT	
Test	TokenNameIdentifier	 Test
public	TokenNamepublic	
void	TokenNamevoid	
testWriterLock	TokenNameIdentifier	 test Writer Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
// native fslock impl gets angry if we use it, so use RAMDirectory explicitly. 	TokenNameCOMMENT_LINE	native fslock impl gets angry if we use it, so use RAMDirectory explicitly. 
Directory	TokenNameIdentifier	 Directory
indexDir	TokenNameIdentifier	 index Dir
=	TokenNameEQUAL	
new	TokenNamenew	
RAMDirectory	TokenNameIdentifier	 RAM Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyWriter	TokenNameIdentifier	 Taxonomy Writer
tw	TokenNameIdentifier	 tw
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
addCategory	TokenNameIdentifier	 add Category
(	TokenNameLPAREN	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
"hi"	TokenNameStringLiteral	hi
,	TokenNameCOMMA	
"there"	TokenNameStringLiteral	there
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
commit	TokenNameIdentifier	 commit
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// we deliberately not close the write now, and keep it open and 	TokenNameCOMMENT_LINE	we deliberately not close the write now, and keep it open and 
// locked. 	TokenNameCOMMENT_LINE	locked. 
// Verify that the writer worked: 	TokenNameCOMMENT_LINE	Verify that the writer worked: 
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
tr	TokenNameIdentifier	 tr
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyReader	TokenNameIdentifier	 Directory Taxonomy Reader
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getOrdinal	TokenNameIdentifier	 get Ordinal
(	TokenNameLPAREN	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
"hi"	TokenNameStringLiteral	hi
,	TokenNameCOMMA	
"there"	TokenNameStringLiteral	there
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Try to open a second writer, with the first one locking the directory. 	TokenNameCOMMENT_LINE	Try to open a second writer, with the first one locking the directory. 
// We expect to get a LockObtainFailedException. 	TokenNameCOMMENT_LINE	We expect to get a LockObtainFailedException. 
try	TokenNametry	
{	TokenNameLBRACE	
new	TokenNamenew	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
"should have failed to write in locked directory"	TokenNameStringLiteral	should have failed to write in locked directory
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
LockObtainFailedException	TokenNameIdentifier	 Lock Obtain Failed Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// this is what we expect to happen. 	TokenNameCOMMENT_LINE	this is what we expect to happen. 
}	TokenNameRBRACE	
// Remove the lock, and now the open should succeed, and we can 	TokenNameCOMMENT_LINE	Remove the lock, and now the open should succeed, and we can 
// write to the new writer. 	TokenNameCOMMENT_LINE	write to the new writer. 
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyWriter	TokenNameIdentifier	 Taxonomy Writer
tw2	TokenNameIdentifier	 tw2
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw2	TokenNameIdentifier	 tw2
.	TokenNameDOT	
addCategory	TokenNameIdentifier	 add Category
(	TokenNameLPAREN	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
"hey"	TokenNameStringLiteral	hey
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw2	TokenNameIdentifier	 tw2
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// See that the writer indeed wrote: 	TokenNameCOMMENT_LINE	See that the writer indeed wrote: 
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
refresh	TokenNameIdentifier	 refresh
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
getOrdinal	TokenNameIdentifier	 get Ordinal
(	TokenNameLPAREN	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
"hey"	TokenNameStringLiteral	hey
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
indexDir	TokenNameIdentifier	 index Dir
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * fillTaxonomyCheckPaths adds the categories in the categories[] array, * and asserts that the additions return exactly paths specified in * expectedPaths[]. This is the same add fillTaxonomy() but also checks * the correctness of getParent(), not just addCategory(). * Note that this assumes that fillTaxonomyCheckPaths() is called on an empty * taxonomy index. Calling it after something else was already added to the * taxonomy index will surely have this method fail. */	TokenNameCOMMENT_JAVADOC	 fillTaxonomyCheckPaths adds the categories in the categories[] array, and asserts that the additions return exactly paths specified in expectedPaths[]. This is the same add fillTaxonomy() but also checks the correctness of getParent(), not just addCategory(). Note that this assumes that fillTaxonomyCheckPaths() is called on an empty taxonomy index. Calling it after something else was already added to the taxonomy index will surely have this method fail. 
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
fillTaxonomyCheckPaths	TokenNameIdentifier	 fill Taxonomy Check Paths
(	TokenNameLPAREN	
TaxonomyWriter	TokenNameIdentifier	 Taxonomy Writer
tw	TokenNameIdentifier	 tw
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
categories	TokenNameIdentifier	 categories
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
ordinal	TokenNameIdentifier	 ordinal
=	TokenNameEQUAL	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
addCategory	TokenNameIdentifier	 add Category
(	TokenNameLPAREN	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
categories	TokenNameIdentifier	 categories
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
expectedOrdinal	TokenNameIdentifier	 expected Ordinal
=	TokenNameEQUAL	
expectedPaths	TokenNameIdentifier	 expected Paths
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
expectedPaths	TokenNameIdentifier	 expected Paths
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ordinal	TokenNameIdentifier	 ordinal
!=	TokenNameNOT_EQUAL	
expectedOrdinal	TokenNameIdentifier	 expected Ordinal
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
"For category "	TokenNameStringLiteral	For category 
+	TokenNamePLUS	
showcat	TokenNameIdentifier	 showcat
(	TokenNameLPAREN	
categories	TokenNameIdentifier	 categories
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" expected ordinal "	TokenNameStringLiteral	 expected ordinal 
+	TokenNamePLUS	
expectedOrdinal	TokenNameIdentifier	 expected Ordinal
+	TokenNamePLUS	
", but got "	TokenNameStringLiteral	, but got 
+	TokenNamePLUS	
ordinal	TokenNameIdentifier	 ordinal
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
expectedPaths	TokenNameIdentifier	 expected Paths
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ordinal	TokenNameIdentifier	 ordinal
=	TokenNameEQUAL	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
ordinal	TokenNameIdentifier	 ordinal
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
expectedOrdinal	TokenNameIdentifier	 expected Ordinal
=	TokenNameEQUAL	
expectedPaths	TokenNameIdentifier	 expected Paths
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ordinal	TokenNameIdentifier	 ordinal
!=	TokenNameNOT_EQUAL	
expectedOrdinal	TokenNameIdentifier	 expected Ordinal
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
"For category "	TokenNameStringLiteral	For category 
+	TokenNamePLUS	
showcat	TokenNameIdentifier	 showcat
(	TokenNameLPAREN	
categories	TokenNameIdentifier	 categories
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" expected ancestor level "	TokenNameStringLiteral	 expected ancestor level 
+	TokenNamePLUS	
(	TokenNameLPAREN	
expectedPaths	TokenNameIdentifier	 expected Paths
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
-	TokenNameMINUS	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
+	TokenNamePLUS	
" was "	TokenNameStringLiteral	 was 
+	TokenNamePLUS	
expectedOrdinal	TokenNameIdentifier	 expected Ordinal
+	TokenNamePLUS	
", but got "	TokenNameStringLiteral	, but got 
+	TokenNamePLUS	
ordinal	TokenNameIdentifier	 ordinal
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// After fillTaxonomy returned successfully, checkPaths() checks that 	TokenNameCOMMENT_LINE	After fillTaxonomy returned successfully, checkPaths() checks that 
// the getParent() calls return as expected, from the table 	TokenNameCOMMENT_LINE	the getParent() calls return as expected, from the table 
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
checkPaths	TokenNameIdentifier	 check Paths
(	TokenNameLPAREN	
TaxonomyWriter	TokenNameIdentifier	 Taxonomy Writer
tw	TokenNameIdentifier	 tw
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
categories	TokenNameIdentifier	 categories
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
ordinal	TokenNameIdentifier	 ordinal
=	TokenNameEQUAL	
expectedPaths	TokenNameIdentifier	 expected Paths
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
expectedPaths	TokenNameIdentifier	 expected Paths
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
expectedPaths	TokenNameIdentifier	 expected Paths
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ordinal	TokenNameIdentifier	 ordinal
=	TokenNameEQUAL	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
ordinal	TokenNameIdentifier	 ordinal
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
expectedOrdinal	TokenNameIdentifier	 expected Ordinal
=	TokenNameEQUAL	
expectedPaths	TokenNameIdentifier	 expected Paths
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ordinal	TokenNameIdentifier	 ordinal
!=	TokenNameNOT_EQUAL	
expectedOrdinal	TokenNameIdentifier	 expected Ordinal
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
"For category "	TokenNameStringLiteral	For category 
+	TokenNamePLUS	
showcat	TokenNameIdentifier	 showcat
(	TokenNameLPAREN	
categories	TokenNameIdentifier	 categories
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" expected ancestor level "	TokenNameStringLiteral	 expected ancestor level 
+	TokenNamePLUS	
(	TokenNameLPAREN	
expectedPaths	TokenNameIdentifier	 expected Paths
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
-	TokenNameMINUS	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
+	TokenNamePLUS	
" was "	TokenNameStringLiteral	 was 
+	TokenNamePLUS	
expectedOrdinal	TokenNameIdentifier	 expected Ordinal
+	TokenNamePLUS	
", but got "	TokenNameStringLiteral	, but got 
+	TokenNamePLUS	
ordinal	TokenNameIdentifier	 ordinal
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
ROOT_ORDINAL	TokenNameIdentifier	 ROOT  ORDINAL
,	TokenNameCOMMA	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
expectedPaths	TokenNameIdentifier	 expected Paths
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
INVALID_ORDINAL	TokenNameIdentifier	 INVALID  ORDINAL
,	TokenNameCOMMA	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
ROOT_ORDINAL	TokenNameIdentifier	 ROOT  ORDINAL
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Basic test for TaxonomyWriter.getParent(). This is similar to testWriter * above, except we also check the parents of the added categories, not just * the categories themselves. */	TokenNameCOMMENT_JAVADOC	 Basic test for TaxonomyWriter.getParent(). This is similar to testWriter above, except we also check the parents of the added categories, not just the categories themselves. 
@	TokenNameAT	
Test	TokenNameIdentifier	 Test
public	TokenNamepublic	
void	TokenNamevoid	
testWriterCheckPaths	TokenNameIdentifier	 test Writer Check Paths
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
Directory	TokenNameIdentifier	 Directory
indexDir	TokenNameIdentifier	 index Dir
=	TokenNameEQUAL	
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyWriter	TokenNameIdentifier	 Taxonomy Writer
tw	TokenNameIdentifier	 tw
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fillTaxonomyCheckPaths	TokenNameIdentifier	 fill Taxonomy Check Paths
(	TokenNameLPAREN	
tw	TokenNameIdentifier	 tw
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Also check TaxonomyWriter.getSize() - see that the taxonomy's size 	TokenNameCOMMENT_LINE	Also check TaxonomyWriter.getSize() - see that the taxonomy's size 
// is what we expect it to be. 	TokenNameCOMMENT_LINE	is what we expect it to be. 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
expectedCategories	TokenNameIdentifier	 expected Categories
.	TokenNameDOT	
length	TokenNameIdentifier	 length
,	TokenNameCOMMA	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
indexDir	TokenNameIdentifier	 index Dir
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * testWriterCheckPaths2 is the path-checking variant of testWriterTwice * and testWriterTwice2. After adding all the categories, we add them again, * and see that we get the same old ids and paths. We repeat the path checking * yet again after closing and opening the index for writing again - to see * that the reading of existing data from disk works as well. */	TokenNameCOMMENT_JAVADOC	 testWriterCheckPaths2 is the path-checking variant of testWriterTwice and testWriterTwice2. After adding all the categories, we add them again, and see that we get the same old ids and paths. We repeat the path checking yet again after closing and opening the index for writing again - to see that the reading of existing data from disk works as well. 
@	TokenNameAT	
Test	TokenNameIdentifier	 Test
public	TokenNamepublic	
void	TokenNamevoid	
testWriterCheckPaths2	TokenNameIdentifier	 test Writer Check Paths2
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
Directory	TokenNameIdentifier	 Directory
indexDir	TokenNameIdentifier	 index Dir
=	TokenNameEQUAL	
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TaxonomyWriter	TokenNameIdentifier	 Taxonomy Writer
tw	TokenNameIdentifier	 tw
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fillTaxonomy	TokenNameIdentifier	 fill Taxonomy
(	TokenNameLPAREN	
tw	TokenNameIdentifier	 tw
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
checkPaths	TokenNameIdentifier	 check Paths
(	TokenNameLPAREN	
tw	TokenNameIdentifier	 tw
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fillTaxonomy	TokenNameIdentifier	 fill Taxonomy
(	TokenNameLPAREN	
tw	TokenNameIdentifier	 tw
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
checkPaths	TokenNameIdentifier	 check Paths
(	TokenNameLPAREN	
tw	TokenNameIdentifier	 tw
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
=	TokenNameEQUAL	
new	TokenNamenew	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
(	TokenNameLPAREN	
indexDir	TokenNameIdentifier	 index Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
checkPaths	TokenNameIdentifier	 check Paths
(	TokenNameLPAREN	
tw	TokenNameIdentifier	 tw
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fillTaxonomy	TokenNameIdentifier	 fill Taxonomy
(	TokenNameLPAREN	
tw	TokenNameIdentifier	 tw
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
checkPaths	TokenNameIdentifier	 check Paths
(	TokenNameLPAREN	
tw	TokenNameIdentifier	 tw
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tw	TokenNameIdentifier	 tw
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
indexDir	TokenNameIdentifier	 index Dir
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// TODO (Facet): test multiple readers, one writer. Have the multiple readers 	TokenNameCOMMENT_LINE	TODO (Facet): test multiple readers, one writer. Have the multiple readers 
// using the same object (simulating threads) or different objects 	TokenNameCOMMENT_LINE	using the same object (simulating threads) or different objects 
// (simulating processes). 	TokenNameCOMMENT_LINE	(simulating processes). 
}	TokenNameRBRACE	
