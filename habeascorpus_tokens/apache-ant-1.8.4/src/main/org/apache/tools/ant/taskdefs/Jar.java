/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
taskdefs	TokenNameIdentifier	 taskdefs
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
ByteArrayInputStream	TokenNameIdentifier	 Byte Array Input Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
ByteArrayOutputStream	TokenNameIdentifier	 Byte Array Output Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
File	TokenNameIdentifier	 File
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
FileInputStream	TokenNameIdentifier	 File Input Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
FileOutputStream	TokenNameIdentifier	 File Output Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
InputStream	TokenNameIdentifier	 Input Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
InputStreamReader	TokenNameIdentifier	 Input Stream Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
OutputStreamWriter	TokenNameIdentifier	 Output Stream Writer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
PrintWriter	TokenNameIdentifier	 Print Writer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
Reader	TokenNameIdentifier	 Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
UnsupportedEncodingException	TokenNameIdentifier	 Unsupported Encoding Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Collections	TokenNameIdentifier	 Collections
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Comparator	TokenNameIdentifier	 Comparator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Enumeration	TokenNameIdentifier	 Enumeration
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
HashSet	TokenNameIdentifier	 Hash Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Iterator	TokenNameIdentifier	 Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
List	TokenNameIdentifier	 List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
StringTokenizer	TokenNameIdentifier	 String Tokenizer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
TreeMap	TokenNameIdentifier	 Tree Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Vector	TokenNameIdentifier	 Vector
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
zip	TokenNameIdentifier	 zip
.	TokenNameDOT	
ZipEntry	TokenNameIdentifier	 Zip Entry
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
zip	TokenNameIdentifier	 zip
.	TokenNameDOT	
ZipFile	TokenNameIdentifier	 Zip File
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
BuildException	TokenNameIdentifier	 Build Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
Project	TokenNameIdentifier	 Project
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
taskdefs	TokenNameIdentifier	 taskdefs
.	TokenNameDOT	
Manifest	TokenNameIdentifier	 Manifest
.	TokenNameDOT	
Section	TokenNameIdentifier	 Section
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
ArchiveFileSet	TokenNameIdentifier	 Archive File Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
EnumeratedAttribute	TokenNameIdentifier	 Enumerated Attribute
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
FileSet	TokenNameIdentifier	 File Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
Path	TokenNameIdentifier	 Path
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
Resource	TokenNameIdentifier	 Resource
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
ResourceCollection	TokenNameIdentifier	 Resource Collection
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
ZipFileSet	TokenNameIdentifier	 Zip File Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
spi	TokenNameIdentifier	 spi
.	TokenNameDOT	
Service	TokenNameIdentifier	 Service
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
FileUtils	TokenNameIdentifier	 File Utils
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
zip	TokenNameIdentifier	 zip
.	TokenNameDOT	
JarMarker	TokenNameIdentifier	 Jar Marker
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
zip	TokenNameIdentifier	 zip
.	TokenNameDOT	
ZipExtraField	TokenNameIdentifier	 Zip Extra Field
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
zip	TokenNameIdentifier	 zip
.	TokenNameDOT	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
;	TokenNameSEMICOLON	
/** * Creates a JAR archive. * * @since Ant 1.1 * * @ant.task category="packaging" */	TokenNameCOMMENT_JAVADOC	 Creates a JAR archive. * @since Ant 1.1 * @ant.task category="packaging" 
public	TokenNamepublic	
class	TokenNameclass	
Jar	TokenNameIdentifier	 Jar
extends	TokenNameextends	
Zip	TokenNameIdentifier	 Zip
{	TokenNameLBRACE	
/** The index file name. */	TokenNameCOMMENT_JAVADOC	 The index file name. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
INDEX_NAME	TokenNameIdentifier	 INDEX  NAME
=	TokenNameEQUAL	
"META-INF/INDEX.LIST"	TokenNameStringLiteral	META-INF/INDEX.LIST
;	TokenNameSEMICOLON	
/** The manifest file name. */	TokenNameCOMMENT_JAVADOC	 The manifest file name. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
MANIFEST_NAME	TokenNameIdentifier	 MANIFEST  NAME
=	TokenNameEQUAL	
"META-INF/MANIFEST.MF"	TokenNameStringLiteral	META-INF/MANIFEST.MF
;	TokenNameSEMICOLON	
/** * List of all known SPI Services */	TokenNameCOMMENT_JAVADOC	 List of all known SPI Services 
private	TokenNameprivate	
List	TokenNameIdentifier	 List
serviceList	TokenNameIdentifier	 service List
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** merged manifests added through addConfiguredManifest */	TokenNameCOMMENT_JAVADOC	 merged manifests added through addConfiguredManifest 
private	TokenNameprivate	
Manifest	TokenNameIdentifier	 Manifest
configuredManifest	TokenNameIdentifier	 configured Manifest
;	TokenNameSEMICOLON	
/** shadow of the above if upToDate check alters the value */	TokenNameCOMMENT_JAVADOC	 shadow of the above if upToDate check alters the value 
private	TokenNameprivate	
Manifest	TokenNameIdentifier	 Manifest
savedConfiguredManifest	TokenNameIdentifier	 saved Configured Manifest
;	TokenNameSEMICOLON	
/** merged manifests added through filesets */	TokenNameCOMMENT_JAVADOC	 merged manifests added through filesets 
private	TokenNameprivate	
Manifest	TokenNameIdentifier	 Manifest
filesetManifest	TokenNameIdentifier	 fileset Manifest
;	TokenNameSEMICOLON	
/** * Manifest of original archive, will be set to null if not in * update mode. */	TokenNameCOMMENT_JAVADOC	 Manifest of original archive, will be set to null if not in update mode. 
private	TokenNameprivate	
Manifest	TokenNameIdentifier	 Manifest
originalManifest	TokenNameIdentifier	 original Manifest
;	TokenNameSEMICOLON	
/** * whether to merge fileset manifests; * value is true if filesetmanifest is 'merge' or 'mergewithoutmain' */	TokenNameCOMMENT_JAVADOC	 whether to merge fileset manifests; value is true if filesetmanifest is 'merge' or 'mergewithoutmain' 
private	TokenNameprivate	
FilesetManifestConfig	TokenNameIdentifier	 Fileset Manifest Config
filesetManifestConfig	TokenNameIdentifier	 fileset Manifest Config
;	TokenNameSEMICOLON	
/** * whether to merge the main section of fileset manifests; * value is true if filesetmanifest is 'merge' */	TokenNameCOMMENT_JAVADOC	 whether to merge the main section of fileset manifests; value is true if filesetmanifest is 'merge' 
private	TokenNameprivate	
boolean	TokenNameboolean	
mergeManifestsMain	TokenNameIdentifier	 merge Manifests Main
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
/** the manifest specified by the 'manifest' attribute **/	TokenNameCOMMENT_JAVADOC	 the manifest specified by the 'manifest' attribute *
private	TokenNameprivate	
Manifest	TokenNameIdentifier	 Manifest
manifest	TokenNameIdentifier	 manifest
;	TokenNameSEMICOLON	
/** The encoding to use when reading in a manifest file */	TokenNameCOMMENT_JAVADOC	 The encoding to use when reading in a manifest file 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
manifestEncoding	TokenNameIdentifier	 manifest Encoding
;	TokenNameSEMICOLON	
/** * The file found from the 'manifest' attribute. This can be * either the location of a manifest, or the name of a jar added * through a fileset. If its the name of an added jar, the * manifest is looked for in META-INF/MANIFEST.MF */	TokenNameCOMMENT_JAVADOC	 The file found from the 'manifest' attribute. This can be either the location of a manifest, or the name of a jar added through a fileset. If its the name of an added jar, the manifest is looked for in META-INF/MANIFEST.MF 
private	TokenNameprivate	
File	TokenNameIdentifier	 File
manifestFile	TokenNameIdentifier	 manifest File
;	TokenNameSEMICOLON	
/** jar index is JDK 1.3+ only */	TokenNameCOMMENT_JAVADOC	 jar index is JDK 1.3+ only 
private	TokenNameprivate	
boolean	TokenNameboolean	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** Whether to index META-INF/ and its children */	TokenNameCOMMENT_JAVADOC	 Whether to index META-INF/ and its children 
private	TokenNameprivate	
boolean	TokenNameboolean	
indexMetaInf	TokenNameIdentifier	 index Meta Inf
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** * whether to really create the archive in createEmptyZip, will * get set in getResourcesToAdd. */	TokenNameCOMMENT_JAVADOC	 whether to really create the archive in createEmptyZip, will get set in getResourcesToAdd. 
private	TokenNameprivate	
boolean	TokenNameboolean	
createEmpty	TokenNameIdentifier	 create Empty
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** * Stores all files that are in the root of the archive (i.e. that * have a name that doesn't contain a slash) so they can get * listed in the index. * * Will not be filled unless the user has asked for an index. * * @since Ant 1.6 */	TokenNameCOMMENT_JAVADOC	 Stores all files that are in the root of the archive (i.e. that have a name that doesn't contain a slash) so they can get listed in the index. * Will not be filled unless the user has asked for an index. * @since Ant 1.6 
private	TokenNameprivate	
Vector	TokenNameIdentifier	 Vector
rootEntries	TokenNameIdentifier	 root Entries
;	TokenNameSEMICOLON	
/** * Path containing jars that shall be indexed in addition to this archive. * * @since Ant 1.6.2 */	TokenNameCOMMENT_JAVADOC	 Path containing jars that shall be indexed in addition to this archive. * @since Ant 1.6.2 
private	TokenNameprivate	
Path	TokenNameIdentifier	 Path
indexJars	TokenNameIdentifier	 index Jars
;	TokenNameSEMICOLON	
// CheckStyle:LineLength OFF - Link is too long. 	TokenNameCOMMENT_LINE	CheckStyle:LineLength OFF - Link is too long. 
/** * Strict mode for checking rules of the JAR-Specification. * @see http://java.sun.com/j2se/1.3/docs/guide/versioning/spec/VersioningSpecification.html#PackageVersioning */	TokenNameCOMMENT_JAVADOC	 Strict mode for checking rules of the JAR-Specification. @see http://java.sun.com/j2se/1.3/docs/guide/versioning/spec/VersioningSpecification.html#PackageVersioning 
private	TokenNameprivate	
StrictMode	TokenNameIdentifier	 Strict Mode
strict	TokenNameIdentifier	 strict
=	TokenNameEQUAL	
new	TokenNamenew	
StrictMode	TokenNameIdentifier	 Strict Mode
(	TokenNameLPAREN	
"ignore"	TokenNameStringLiteral	ignore
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// CheckStyle:LineLength ON 	TokenNameCOMMENT_LINE	CheckStyle:LineLength ON 
/** * whether to merge Class-Path attributes. */	TokenNameCOMMENT_JAVADOC	 whether to merge Class-Path attributes. 
private	TokenNameprivate	
boolean	TokenNameboolean	
mergeClassPaths	TokenNameIdentifier	 merge Class Paths
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** * whether to flatten Class-Path attributes into a single one. */	TokenNameCOMMENT_JAVADOC	 whether to flatten Class-Path attributes into a single one. 
private	TokenNameprivate	
boolean	TokenNameboolean	
flattenClassPaths	TokenNameIdentifier	 flatten Class Paths
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** * Extra fields needed to make Solaris recognize the archive as a jar file. * * @since Ant 1.6.3 */	TokenNameCOMMENT_JAVADOC	 Extra fields needed to make Solaris recognize the archive as a jar file. * @since Ant 1.6.3 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
ZipExtraField	TokenNameIdentifier	 Zip Extra Field
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
JAR_MARKER	TokenNameIdentifier	 JAR  MARKER
=	TokenNameEQUAL	
new	TokenNamenew	
ZipExtraField	TokenNameIdentifier	 Zip Extra Field
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
JarMarker	TokenNameIdentifier	 Jar Marker
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** constructor */	TokenNameCOMMENT_JAVADOC	 constructor 
public	TokenNamepublic	
Jar	TokenNameIdentifier	 Jar
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
archiveType	TokenNameIdentifier	 archive Type
=	TokenNameEQUAL	
"jar"	TokenNameStringLiteral	jar
;	TokenNameSEMICOLON	
emptyBehavior	TokenNameIdentifier	 empty Behavior
=	TokenNameEQUAL	
"create"	TokenNameStringLiteral	create
;	TokenNameSEMICOLON	
setEncoding	TokenNameIdentifier	 set Encoding
(	TokenNameLPAREN	
"UTF8"	TokenNameStringLiteral	UTF8
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rootEntries	TokenNameIdentifier	 root Entries
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Not used for jar files. * @param we not used * @ant.attribute ignore="true" */	TokenNameCOMMENT_JAVADOC	 Not used for jar files. @param we not used @ant.attribute ignore="true" 
public	TokenNamepublic	
void	TokenNamevoid	
setWhenempty	TokenNameIdentifier	 set Whenempty
(	TokenNameLPAREN	
WhenEmpty	TokenNameIdentifier	 When Empty
we	TokenNameIdentifier	 we
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"JARs are never empty, they contain at least a manifest file"	TokenNameStringLiteral	JARs are never empty, they contain at least a manifest file
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_WARN	TokenNameIdentifier	 MSG  WARN
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Indicates if a jar file should be created when it would only contain a * manifest file. * Possible values are: <code>fail</code> (throw an exception * and halt the build); <code>skip</code> (do not create * any archive, but issue a warning); <code>create</code> * (make an archive with only a manifest file). * Default is <code>create</code>; * @param we a <code>WhenEmpty</code> enumerated value */	TokenNameCOMMENT_JAVADOC	 Indicates if a jar file should be created when it would only contain a manifest file. Possible values are: <code>fail</code> (throw an exception and halt the build); <code>skip</code> (do not create any archive, but issue a warning); <code>create</code> (make an archive with only a manifest file). Default is <code>create</code>; @param we a <code>WhenEmpty</code> enumerated value 
public	TokenNamepublic	
void	TokenNamevoid	
setWhenmanifestonly	TokenNameIdentifier	 set Whenmanifestonly
(	TokenNameLPAREN	
WhenEmpty	TokenNameIdentifier	 When Empty
we	TokenNameIdentifier	 we
)	TokenNameRPAREN	
{	TokenNameLBRACE	
emptyBehavior	TokenNameIdentifier	 empty Behavior
=	TokenNameEQUAL	
we	TokenNameIdentifier	 we
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Activate the strict mode. When set to <i>true</i> a BuildException * will be thrown if the Jar-Packaging specification was broken. * @param strict New value of the strict mode. * @since Ant 1.7.1 */	TokenNameCOMMENT_JAVADOC	 Activate the strict mode. When set to <i>true</i> a BuildException will be thrown if the Jar-Packaging specification was broken. @param strict New value of the strict mode. @since Ant 1.7.1 
public	TokenNamepublic	
void	TokenNamevoid	
setStrict	TokenNameIdentifier	 set Strict
(	TokenNameLPAREN	
StrictMode	TokenNameIdentifier	 Strict Mode
strict	TokenNameIdentifier	 strict
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
strict	TokenNameIdentifier	 strict
=	TokenNameEQUAL	
strict	TokenNameIdentifier	 strict
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set the destination file. * @param jarFile the destination file * @deprecated since 1.5.x. * Use setDestFile(File) instead. */	TokenNameCOMMENT_JAVADOC	 Set the destination file. @param jarFile the destination file @deprecated since 1.5.x. Use setDestFile(File) instead. 
public	TokenNamepublic	
void	TokenNamevoid	
setJarfile	TokenNameIdentifier	 set Jarfile
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
jarFile	TokenNameIdentifier	 jar File
)	TokenNameRPAREN	
{	TokenNameLBRACE	
setDestFile	TokenNameIdentifier	 set Dest File
(	TokenNameLPAREN	
jarFile	TokenNameIdentifier	 jar File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set whether or not to create an index list for classes. * This may speed up classloading in some cases. * @param flag a <code>boolean</code> value */	TokenNameCOMMENT_JAVADOC	 Set whether or not to create an index list for classes. This may speed up classloading in some cases. @param flag a <code>boolean</code> value 
public	TokenNamepublic	
void	TokenNamevoid	
setIndex	TokenNameIdentifier	 set Index
(	TokenNameLPAREN	
boolean	TokenNameboolean	
flag	TokenNameIdentifier	 flag
)	TokenNameRPAREN	
{	TokenNameLBRACE	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
flag	TokenNameIdentifier	 flag
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set whether or not to add META-INF and its children to the index. * * <p>Doesn't have any effect if index is false.</p> * * <p>Sun's jar implementation used to skip the META-INF directory * and Ant followed that example. The behavior has been changed * with Java 5. In order to avoid problems with Ant generated * jars on Java 1.4 or earlier Ant will not include META-INF * unless explicitly asked to.</p> * * @see <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4408526"> * jar -i omits service providers in index.list</a> * @since Ant 1.8.0 * @param flag a <code>boolean</code> value, defaults to false */	TokenNameCOMMENT_JAVADOC	 Set whether or not to add META-INF and its children to the index. * <p>Doesn't have any effect if index is false.</p> * <p>Sun's jar implementation used to skip the META-INF directory and Ant followed that example. The behavior has been changed with Java 5. In order to avoid problems with Ant generated jars on Java 1.4 or earlier Ant will not include META-INF unless explicitly asked to.</p> * @see <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4408526"> jar -i omits service providers in index.list</a> @since Ant 1.8.0 @param flag a <code>boolean</code> value, defaults to false 
public	TokenNamepublic	
void	TokenNamevoid	
setIndexMetaInf	TokenNameIdentifier	 set Index Meta Inf
(	TokenNameLPAREN	
boolean	TokenNameboolean	
flag	TokenNameIdentifier	 flag
)	TokenNameRPAREN	
{	TokenNameLBRACE	
indexMetaInf	TokenNameIdentifier	 index Meta Inf
=	TokenNameEQUAL	
flag	TokenNameIdentifier	 flag
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The character encoding to use in the manifest file. * * @param manifestEncoding the character encoding */	TokenNameCOMMENT_JAVADOC	 The character encoding to use in the manifest file. * @param manifestEncoding the character encoding 
public	TokenNamepublic	
void	TokenNamevoid	
setManifestEncoding	TokenNameIdentifier	 set Manifest Encoding
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
manifestEncoding	TokenNameIdentifier	 manifest Encoding
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
manifestEncoding	TokenNameIdentifier	 manifest Encoding
=	TokenNameEQUAL	
manifestEncoding	TokenNameIdentifier	 manifest Encoding
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Allows the manifest for the archive file to be provided inline * in the build file rather than in an external file. * * @param newManifest an embedded manifest element * @throws ManifestException on error */	TokenNameCOMMENT_JAVADOC	 Allows the manifest for the archive file to be provided inline in the build file rather than in an external file. * @param newManifest an embedded manifest element @throws ManifestException on error 
public	TokenNamepublic	
void	TokenNamevoid	
addConfiguredManifest	TokenNameIdentifier	 add Configured Manifest
(	TokenNameLPAREN	
Manifest	TokenNameIdentifier	 Manifest
newManifest	TokenNameIdentifier	 new Manifest
)	TokenNameRPAREN	
throws	TokenNamethrows	
ManifestException	TokenNameIdentifier	 Manifest Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
configuredManifest	TokenNameIdentifier	 configured Manifest
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
configuredManifest	TokenNameIdentifier	 configured Manifest
=	TokenNameEQUAL	
newManifest	TokenNameIdentifier	 new Manifest
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
configuredManifest	TokenNameIdentifier	 configured Manifest
.	TokenNameDOT	
merge	TokenNameIdentifier	 merge
(	TokenNameLPAREN	
newManifest	TokenNameIdentifier	 new Manifest
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
mergeClassPaths	TokenNameIdentifier	 merge Class Paths
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
savedConfiguredManifest	TokenNameIdentifier	 saved Configured Manifest
=	TokenNameEQUAL	
configuredManifest	TokenNameIdentifier	 configured Manifest
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The manifest file to use. This can be either the location of a manifest, * or the name of a jar added through a fileset. If its the name of an added * jar, the task expects the manifest to be in the jar at META-INF/MANIFEST.MF. * * @param manifestFile the manifest file to use. */	TokenNameCOMMENT_JAVADOC	 The manifest file to use. This can be either the location of a manifest, or the name of a jar added through a fileset. If its the name of an added jar, the task expects the manifest to be in the jar at META-INF/MANIFEST.MF. * @param manifestFile the manifest file to use. 
public	TokenNamepublic	
void	TokenNamevoid	
setManifest	TokenNameIdentifier	 set Manifest
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
manifestFile	TokenNameIdentifier	 manifest File
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
manifestFile	TokenNameIdentifier	 manifest File
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Manifest file: "	TokenNameStringLiteral	Manifest file: 
+	TokenNamePLUS	
manifestFile	TokenNameIdentifier	 manifest File
+	TokenNamePLUS	
" does not exist."	TokenNameStringLiteral	 does not exist.
,	TokenNameCOMMA	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
this	TokenNamethis	
.	TokenNameDOT	
manifestFile	TokenNameIdentifier	 manifest File
=	TokenNameEQUAL	
manifestFile	TokenNameIdentifier	 manifest File
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
Manifest	TokenNameIdentifier	 Manifest
getManifest	TokenNameIdentifier	 get Manifest
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
manifestFile	TokenNameIdentifier	 manifest File
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Manifest	TokenNameIdentifier	 Manifest
newManifest	TokenNameIdentifier	 new Manifest
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
FileInputStream	TokenNameIdentifier	 File Input Stream
fis	TokenNameIdentifier	 fis
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
InputStreamReader	TokenNameIdentifier	 Input Stream Reader
isr	TokenNameIdentifier	 isr
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
fis	TokenNameIdentifier	 fis
=	TokenNameEQUAL	
new	TokenNamenew	
FileInputStream	TokenNameIdentifier	 File Input Stream
(	TokenNameLPAREN	
manifestFile	TokenNameIdentifier	 manifest File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
manifestEncoding	TokenNameIdentifier	 manifest Encoding
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
isr	TokenNameIdentifier	 isr
=	TokenNameEQUAL	
new	TokenNamenew	
InputStreamReader	TokenNameIdentifier	 Input Stream Reader
(	TokenNameLPAREN	
fis	TokenNameIdentifier	 fis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
isr	TokenNameIdentifier	 isr
=	TokenNameEQUAL	
new	TokenNamenew	
InputStreamReader	TokenNameIdentifier	 Input Stream Reader
(	TokenNameLPAREN	
fis	TokenNameIdentifier	 fis
,	TokenNameCOMMA	
manifestEncoding	TokenNameIdentifier	 manifest Encoding
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
newManifest	TokenNameIdentifier	 new Manifest
=	TokenNameEQUAL	
getManifest	TokenNameIdentifier	 get Manifest
(	TokenNameLPAREN	
isr	TokenNameIdentifier	 isr
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
UnsupportedEncodingException	TokenNameIdentifier	 Unsupported Encoding Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Unsupported encoding while reading manifest: "	TokenNameStringLiteral	Unsupported encoding while reading manifest: 
+	TokenNamePLUS	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Unable to read manifest file: "	TokenNameStringLiteral	Unable to read manifest file: 
+	TokenNamePLUS	
manifestFile	TokenNameIdentifier	 manifest File
+	TokenNamePLUS	
" ("	TokenNameStringLiteral	 (
+	TokenNamePLUS	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
")"	TokenNameStringLiteral	)
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
isr	TokenNameIdentifier	 isr
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
newManifest	TokenNameIdentifier	 new Manifest
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @return null if jarFile doesn't contain a manifest, the * manifest otherwise. * @since Ant 1.5.2 */	TokenNameCOMMENT_JAVADOC	 @return null if jarFile doesn't contain a manifest, the manifest otherwise. @since Ant 1.5.2 
private	TokenNameprivate	
Manifest	TokenNameIdentifier	 Manifest
getManifestFromJar	TokenNameIdentifier	 get Manifest From Jar
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
jarFile	TokenNameIdentifier	 jar File
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
ZipFile	TokenNameIdentifier	 Zip File
zf	TokenNameIdentifier	 zf
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
zf	TokenNameIdentifier	 zf
=	TokenNameEQUAL	
new	TokenNamenew	
ZipFile	TokenNameIdentifier	 Zip File
(	TokenNameLPAREN	
jarFile	TokenNameIdentifier	 jar File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// must not use getEntry as "well behaving" applications 	TokenNameCOMMENT_LINE	must not use getEntry as "well behaving" applications 
// must accept the manifest in any capitalization 	TokenNameCOMMENT_LINE	must accept the manifest in any capitalization 
Enumeration	TokenNameIdentifier	 Enumeration
e	TokenNameIdentifier	 e
=	TokenNameEQUAL	
zf	TokenNameIdentifier	 zf
.	TokenNameDOT	
entries	TokenNameIdentifier	 entries
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
hasMoreElements	TokenNameIdentifier	 has More Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ZipEntry	TokenNameIdentifier	 Zip Entry
ze	TokenNameIdentifier	 ze
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ZipEntry	TokenNameIdentifier	 Zip Entry
)	TokenNameRPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
nextElement	TokenNameIdentifier	 next Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ze	TokenNameIdentifier	 ze
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equalsIgnoreCase	TokenNameIdentifier	 equals Ignore Case
(	TokenNameLPAREN	
MANIFEST_NAME	TokenNameIdentifier	 MANIFEST  NAME
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
InputStreamReader	TokenNameIdentifier	 Input Stream Reader
isr	TokenNameIdentifier	 isr
=	TokenNameEQUAL	
new	TokenNamenew	
InputStreamReader	TokenNameIdentifier	 Input Stream Reader
(	TokenNameLPAREN	
zf	TokenNameIdentifier	 zf
.	TokenNameDOT	
getInputStream	TokenNameIdentifier	 get Input Stream
(	TokenNameLPAREN	
ze	TokenNameIdentifier	 ze
)	TokenNameRPAREN	
,	TokenNameCOMMA	
"UTF-8"	TokenNameStringLiteral	UTF-8
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
getManifest	TokenNameIdentifier	 get Manifest
(	TokenNameLPAREN	
isr	TokenNameIdentifier	 isr
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
zf	TokenNameIdentifier	 zf
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
zf	TokenNameIdentifier	 zf
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// XXX - log an error? throw an exception? 	TokenNameCOMMENT_LINE	XXX - log an error? throw an exception? 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
Manifest	TokenNameIdentifier	 Manifest
getManifest	TokenNameIdentifier	 get Manifest
(	TokenNameLPAREN	
Reader	TokenNameIdentifier	 Reader
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Manifest	TokenNameIdentifier	 Manifest
newManifest	TokenNameIdentifier	 new Manifest
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
newManifest	TokenNameIdentifier	 new Manifest
=	TokenNameEQUAL	
new	TokenNamenew	
Manifest	TokenNameIdentifier	 Manifest
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ManifestException	TokenNameIdentifier	 Manifest Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Manifest is invalid: "	TokenNameStringLiteral	Manifest is invalid: 
+	TokenNamePLUS	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_ERR	TokenNameIdentifier	 MSG  ERR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Invalid Manifest: "	TokenNameStringLiteral	Invalid Manifest: 
+	TokenNamePLUS	
manifestFile	TokenNameIdentifier	 manifest File
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
,	TokenNameCOMMA	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Unable to read manifest file"	TokenNameStringLiteral	Unable to read manifest file
+	TokenNamePLUS	
" ("	TokenNameStringLiteral	 (
+	TokenNamePLUS	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
")"	TokenNameStringLiteral	)
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
newManifest	TokenNameIdentifier	 new Manifest
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
jarHasIndex	TokenNameIdentifier	 jar Has Index
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
jarFile	TokenNameIdentifier	 jar File
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
ZipFile	TokenNameIdentifier	 Zip File
zf	TokenNameIdentifier	 zf
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
zf	TokenNameIdentifier	 zf
=	TokenNameEQUAL	
new	TokenNamenew	
ZipFile	TokenNameIdentifier	 Zip File
(	TokenNameLPAREN	
jarFile	TokenNameIdentifier	 jar File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Enumeration	TokenNameIdentifier	 Enumeration
e	TokenNameIdentifier	 e
=	TokenNameEQUAL	
zf	TokenNameIdentifier	 zf
.	TokenNameDOT	
entries	TokenNameIdentifier	 entries
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
hasMoreElements	TokenNameIdentifier	 has More Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ZipEntry	TokenNameIdentifier	 Zip Entry
ze	TokenNameIdentifier	 ze
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ZipEntry	TokenNameIdentifier	 Zip Entry
)	TokenNameRPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
nextElement	TokenNameIdentifier	 next Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ze	TokenNameIdentifier	 ze
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equalsIgnoreCase	TokenNameIdentifier	 equals Ignore Case
(	TokenNameLPAREN	
INDEX_NAME	TokenNameIdentifier	 INDEX  NAME
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
zf	TokenNameIdentifier	 zf
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
zf	TokenNameIdentifier	 zf
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// XXX - log an error? throw an exception? 	TokenNameCOMMENT_LINE	XXX - log an error? throw an exception? 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Behavior when a Manifest is found in a zipfileset or zipgroupfileset file. * Valid values are "skip", "merge", and "mergewithoutmain". * "merge" will merge all of manifests together, and merge this into any * other specified manifests. * "mergewithoutmain" merges everything but the Main section of the manifests. * Default value is "skip". * * Note: if this attribute's value is not "skip", the created jar will not * be readable by using java.util.jar.JarInputStream * * @param config setting for found manifest behavior. */	TokenNameCOMMENT_JAVADOC	 Behavior when a Manifest is found in a zipfileset or zipgroupfileset file. Valid values are "skip", "merge", and "mergewithoutmain". "merge" will merge all of manifests together, and merge this into any other specified manifests. "mergewithoutmain" merges everything but the Main section of the manifests. Default value is "skip". * Note: if this attribute's value is not "skip", the created jar will not be readable by using java.util.jar.JarInputStream * @param config setting for found manifest behavior. 
public	TokenNamepublic	
void	TokenNamevoid	
setFilesetmanifest	TokenNameIdentifier	 set Filesetmanifest
(	TokenNameLPAREN	
FilesetManifestConfig	TokenNameIdentifier	 Fileset Manifest Config
config	TokenNameIdentifier	 config
)	TokenNameRPAREN	
{	TokenNameLBRACE	
filesetManifestConfig	TokenNameIdentifier	 fileset Manifest Config
=	TokenNameEQUAL	
config	TokenNameIdentifier	 config
;	TokenNameSEMICOLON	
mergeManifestsMain	TokenNameIdentifier	 merge Manifests Main
=	TokenNameEQUAL	
"merge"	TokenNameStringLiteral	merge
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
filesetManifestConfig	TokenNameIdentifier	 fileset Manifest Config
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
filesetManifestConfig	TokenNameIdentifier	 fileset Manifest Config
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"skip"	TokenNameStringLiteral	skip
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
doubleFilePass	TokenNameIdentifier	 double File Pass
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Adds a zipfileset to include in the META-INF directory. * * @param fs zipfileset to add */	TokenNameCOMMENT_JAVADOC	 Adds a zipfileset to include in the META-INF directory. * @param fs zipfileset to add 
public	TokenNamepublic	
void	TokenNamevoid	
addMetainf	TokenNameIdentifier	 add Metainf
(	TokenNameLPAREN	
ZipFileSet	TokenNameIdentifier	 Zip File Set
fs	TokenNameIdentifier	 fs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// We just set the prefix for this fileset, and pass it up. 	TokenNameCOMMENT_LINE	We just set the prefix for this fileset, and pass it up. 
fs	TokenNameIdentifier	 fs
.	TokenNameDOT	
setPrefix	TokenNameIdentifier	 set Prefix
(	TokenNameLPAREN	
"META-INF/"	TokenNameStringLiteral	META-INF/
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
super	TokenNamesuper	
.	TokenNameDOT	
addFileset	TokenNameIdentifier	 add Fileset
(	TokenNameLPAREN	
fs	TokenNameIdentifier	 fs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Add a path to index jars. * @param p a path * @since Ant 1.6.2 */	TokenNameCOMMENT_JAVADOC	 Add a path to index jars. @param p a path @since Ant 1.6.2 
public	TokenNamepublic	
void	TokenNamevoid	
addConfiguredIndexJars	TokenNameIdentifier	 add Configured Index Jars
(	TokenNameLPAREN	
Path	TokenNameIdentifier	 Path
p	TokenNameIdentifier	 p
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
indexJars	TokenNameIdentifier	 index Jars
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
indexJars	TokenNameIdentifier	 index Jars
=	TokenNameEQUAL	
new	TokenNamenew	
Path	TokenNameIdentifier	 Path
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
indexJars	TokenNameIdentifier	 index Jars
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * A nested SPI service element. * @param service the nested element. * @since Ant 1.7 */	TokenNameCOMMENT_JAVADOC	 A nested SPI service element. @param service the nested element. @since Ant 1.7 
public	TokenNamepublic	
void	TokenNamevoid	
addConfiguredService	TokenNameIdentifier	 add Configured Service
(	TokenNameLPAREN	
Service	TokenNameIdentifier	 Service
service	TokenNameIdentifier	 service
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Check if the service is configured correctly 	TokenNameCOMMENT_LINE	Check if the service is configured correctly 
service	TokenNameIdentifier	 service
.	TokenNameDOT	
check	TokenNameIdentifier	 check
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
serviceList	TokenNameIdentifier	 service List
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
service	TokenNameIdentifier	 service
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Write SPI Information to JAR */	TokenNameCOMMENT_JAVADOC	 Write SPI Information to JAR 
private	TokenNameprivate	
void	TokenNamevoid	
writeServices	TokenNameIdentifier	 write Services
(	TokenNameLPAREN	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
zOut	TokenNameIdentifier	 z Out
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
Iterator	TokenNameIdentifier	 Iterator
serviceIterator	TokenNameIdentifier	 service Iterator
;	TokenNameSEMICOLON	
Service	TokenNameIdentifier	 Service
service	TokenNameIdentifier	 service
;	TokenNameSEMICOLON	
serviceIterator	TokenNameIdentifier	 service Iterator
=	TokenNameEQUAL	
serviceList	TokenNameIdentifier	 service List
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
serviceIterator	TokenNameIdentifier	 service Iterator
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
service	TokenNameIdentifier	 service
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Service	TokenNameIdentifier	 Service
)	TokenNameRPAREN	
serviceIterator	TokenNameIdentifier	 service Iterator
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
InputStream	TokenNameIdentifier	 Input Stream
is	TokenNameIdentifier	 is
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
is	TokenNameIdentifier	 is
=	TokenNameEQUAL	
service	TokenNameIdentifier	 service
.	TokenNameDOT	
getAsStream	TokenNameIdentifier	 get As Stream
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//stolen from writeManifest 	TokenNameCOMMENT_LINE	stolen from writeManifest 
super	TokenNamesuper	
.	TokenNameDOT	
zipFile	TokenNameIdentifier	 zip File
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
,	TokenNameCOMMA	
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
"META-INF/services/"	TokenNameStringLiteral	META-INF/services/
+	TokenNamePLUS	
service	TokenNameIdentifier	 service
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
ZipFileSet	TokenNameIdentifier	 Zip File Set
.	TokenNameDOT	
DEFAULT_FILE_MODE	TokenNameIdentifier	 DEFAULT  FILE  MODE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
// technically this is unnecessary since 	TokenNameCOMMENT_LINE	technically this is unnecessary since 
// Service.getAsStream returns a ByteArrayInputStream 	TokenNameCOMMENT_LINE	Service.getAsStream returns a ByteArrayInputStream 
// and not closing it wouldn't do any harm. 	TokenNameCOMMENT_LINE	and not closing it wouldn't do any harm. 
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Whether to merge Class-Path attributes. * * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Whether to merge Class-Path attributes. * @since Ant 1.8.0 
public	TokenNamepublic	
void	TokenNamevoid	
setMergeClassPathAttributes	TokenNameIdentifier	 set Merge Class Path Attributes
(	TokenNameLPAREN	
boolean	TokenNameboolean	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
{	TokenNameLBRACE	
mergeClassPaths	TokenNameIdentifier	 merge Class Paths
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Whether to flatten multi-valued attributes (i.e. Class-Path) * into a single one. * * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Whether to flatten multi-valued attributes (i.e. Class-Path) into a single one. * @since Ant 1.8.0 
public	TokenNamepublic	
void	TokenNamevoid	
setFlattenAttributes	TokenNameIdentifier	 set Flatten Attributes
(	TokenNameLPAREN	
boolean	TokenNameboolean	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
{	TokenNameLBRACE	
flattenClassPaths	TokenNameIdentifier	 flatten Class Paths
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Initialize the zip output stream. * @param zOut the zip output stream * @throws IOException on I/O errors * @throws BuildException on other errors */	TokenNameCOMMENT_JAVADOC	 Initialize the zip output stream. @param zOut the zip output stream @throws IOException on I/O errors @throws BuildException on other errors 
protected	TokenNameprotected	
void	TokenNamevoid	
initZipOutputStream	TokenNameIdentifier	 init Zip Output Stream
(	TokenNameLPAREN	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
zOut	TokenNameIdentifier	 z Out
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
BuildException	TokenNameIdentifier	 Build Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
skipWriting	TokenNameIdentifier	 skip Writing
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Manifest	TokenNameIdentifier	 Manifest
jarManifest	TokenNameIdentifier	 jar Manifest
=	TokenNameEQUAL	
createManifest	TokenNameIdentifier	 create Manifest
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeManifest	TokenNameIdentifier	 write Manifest
(	TokenNameLPAREN	
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
jarManifest	TokenNameIdentifier	 jar Manifest
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeServices	TokenNameIdentifier	 write Services
(	TokenNameLPAREN	
zOut	TokenNameIdentifier	 z Out
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
Manifest	TokenNameIdentifier	 Manifest
createManifest	TokenNameIdentifier	 create Manifest
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
BuildException	TokenNameIdentifier	 Build Exception
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
Manifest	TokenNameIdentifier	 Manifest
finalManifest	TokenNameIdentifier	 final Manifest
=	TokenNameEQUAL	
Manifest	TokenNameIdentifier	 Manifest
.	TokenNameDOT	
getDefaultManifest	TokenNameIdentifier	 get Default Manifest
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
manifest	TokenNameIdentifier	 manifest
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
manifestFile	TokenNameIdentifier	 manifest File
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if we haven't got the manifest yet, attempt to 	TokenNameCOMMENT_LINE	if we haven't got the manifest yet, attempt to 
// get it now and have manifest be the final merge 	TokenNameCOMMENT_LINE	get it now and have manifest be the final merge 
manifest	TokenNameIdentifier	 manifest
=	TokenNameEQUAL	
getManifest	TokenNameIdentifier	 get Manifest
(	TokenNameLPAREN	
manifestFile	TokenNameIdentifier	 manifest File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* * Precedence: manifestFile wins over inline manifest, * over manifests read from the filesets over the original * manifest. * * merge with null argument is a no-op */	TokenNameCOMMENT_BLOCK	 Precedence: manifestFile wins over inline manifest, over manifests read from the filesets over the original manifest. * merge with null argument is a no-op 
if	TokenNameif	
(	TokenNameLPAREN	
isInUpdateMode	TokenNameIdentifier	 is In Update Mode
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
finalManifest	TokenNameIdentifier	 final Manifest
.	TokenNameDOT	
merge	TokenNameIdentifier	 merge
(	TokenNameLPAREN	
originalManifest	TokenNameIdentifier	 original Manifest
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
mergeClassPaths	TokenNameIdentifier	 merge Class Paths
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finalManifest	TokenNameIdentifier	 final Manifest
.	TokenNameDOT	
merge	TokenNameIdentifier	 merge
(	TokenNameLPAREN	
filesetManifest	TokenNameIdentifier	 fileset Manifest
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
mergeClassPaths	TokenNameIdentifier	 merge Class Paths
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
finalManifest	TokenNameIdentifier	 final Manifest
.	TokenNameDOT	
merge	TokenNameIdentifier	 merge
(	TokenNameLPAREN	
configuredManifest	TokenNameIdentifier	 configured Manifest
,	TokenNameCOMMA	
!	TokenNameNOT	
mergeManifestsMain	TokenNameIdentifier	 merge Manifests Main
,	TokenNameCOMMA	
mergeClassPaths	TokenNameIdentifier	 merge Class Paths
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
finalManifest	TokenNameIdentifier	 final Manifest
.	TokenNameDOT	
merge	TokenNameIdentifier	 merge
(	TokenNameLPAREN	
manifest	TokenNameIdentifier	 manifest
,	TokenNameCOMMA	
!	TokenNameNOT	
mergeManifestsMain	TokenNameIdentifier	 merge Manifests Main
,	TokenNameCOMMA	
mergeClassPaths	TokenNameIdentifier	 merge Class Paths
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
finalManifest	TokenNameIdentifier	 final Manifest
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ManifestException	TokenNameIdentifier	 Manifest Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Manifest is invalid: "	TokenNameStringLiteral	Manifest is invalid: 
+	TokenNamePLUS	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_ERR	TokenNameIdentifier	 MSG  ERR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Invalid Manifest"	TokenNameStringLiteral	Invalid Manifest
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
,	TokenNameCOMMA	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
writeManifest	TokenNameIdentifier	 write Manifest
(	TokenNameLPAREN	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
Manifest	TokenNameIdentifier	 Manifest
manifest	TokenNameIdentifier	 manifest
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Enumeration	TokenNameIdentifier	 Enumeration
e	TokenNameIdentifier	 e
=	TokenNameEQUAL	
manifest	TokenNameIdentifier	 manifest
.	TokenNameDOT	
getWarnings	TokenNameIdentifier	 get Warnings
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
hasMoreElements	TokenNameIdentifier	 has More Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Manifest warning: "	TokenNameStringLiteral	Manifest warning: 
+	TokenNamePLUS	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
nextElement	TokenNameIdentifier	 next Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_WARN	TokenNameIdentifier	 MSG  WARN
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
zipDir	TokenNameIdentifier	 zip Dir
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Resource	TokenNameIdentifier	 Resource
)	TokenNameRPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
"META-INF/"	TokenNameStringLiteral	META-INF/
,	TokenNameCOMMA	
ZipFileSet	TokenNameIdentifier	 Zip File Set
.	TokenNameDOT	
DEFAULT_DIR_MODE	TokenNameIdentifier	 DEFAULT  DIR  MODE
,	TokenNameCOMMA	
JAR_MARKER	TokenNameIdentifier	 JAR  MARKER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// time to write the manifest 	TokenNameCOMMENT_LINE	time to write the manifest 
ByteArrayOutputStream	TokenNameIdentifier	 Byte Array Output Stream
baos	TokenNameIdentifier	 baos
=	TokenNameEQUAL	
new	TokenNamenew	
ByteArrayOutputStream	TokenNameIdentifier	 Byte Array Output Stream
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
OutputStreamWriter	TokenNameIdentifier	 Output Stream Writer
osw	TokenNameIdentifier	 osw
=	TokenNameEQUAL	
new	TokenNamenew	
OutputStreamWriter	TokenNameIdentifier	 Output Stream Writer
(	TokenNameLPAREN	
baos	TokenNameIdentifier	 baos
,	TokenNameCOMMA	
Manifest	TokenNameIdentifier	 Manifest
.	TokenNameDOT	
JAR_ENCODING	TokenNameIdentifier	 JAR  ENCODING
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
PrintWriter	TokenNameIdentifier	 Print Writer
writer	TokenNameIdentifier	 writer
=	TokenNameEQUAL	
new	TokenNamenew	
PrintWriter	TokenNameIdentifier	 Print Writer
(	TokenNameLPAREN	
osw	TokenNameIdentifier	 osw
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
manifest	TokenNameIdentifier	 manifest
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
writer	TokenNameIdentifier	 writer
,	TokenNameCOMMA	
flattenClassPaths	TokenNameIdentifier	 flatten Class Paths
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
checkError	TokenNameIdentifier	 check Error
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IOException	TokenNameIdentifier	 IO Exception
(	TokenNameLPAREN	
"Encountered an error writing the manifest"	TokenNameStringLiteral	Encountered an error writing the manifest
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ByteArrayInputStream	TokenNameIdentifier	 Byte Array Input Stream
bais	TokenNameIdentifier	 bais
=	TokenNameEQUAL	
new	TokenNamenew	
ByteArrayInputStream	TokenNameIdentifier	 Byte Array Input Stream
(	TokenNameLPAREN	
baos	TokenNameIdentifier	 baos
.	TokenNameDOT	
toByteArray	TokenNameIdentifier	 to Byte Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
zipFile	TokenNameIdentifier	 zip File
(	TokenNameLPAREN	
bais	TokenNameIdentifier	 bais
,	TokenNameCOMMA	
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
MANIFEST_NAME	TokenNameIdentifier	 MANIFEST  NAME
,	TokenNameCOMMA	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
ZipFileSet	TokenNameIdentifier	 Zip File Set
.	TokenNameDOT	
DEFAULT_FILE_MODE	TokenNameIdentifier	 DEFAULT  FILE  MODE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
// not really required 	TokenNameCOMMENT_LINE	not really required 
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
bais	TokenNameIdentifier	 bais
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
initZipOutputStream	TokenNameIdentifier	 init Zip Output Stream
(	TokenNameLPAREN	
zOut	TokenNameIdentifier	 z Out
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Finalize the zip output stream. * This creates an index list if the index attribute is true. * @param zOut the zip output stream * @throws IOException on I/O errors * @throws BuildException on other errors */	TokenNameCOMMENT_JAVADOC	 Finalize the zip output stream. This creates an index list if the index attribute is true. @param zOut the zip output stream @throws IOException on I/O errors @throws BuildException on other errors 
protected	TokenNameprotected	
void	TokenNamevoid	
finalizeZipOutputStream	TokenNameIdentifier	 finalize Zip Output Stream
(	TokenNameLPAREN	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
zOut	TokenNameIdentifier	 z Out
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
BuildException	TokenNameIdentifier	 Build Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
createIndexList	TokenNameIdentifier	 create Index List
(	TokenNameLPAREN	
zOut	TokenNameIdentifier	 z Out
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Create the index list to speed up classloading. * This is a JDK 1.3+ specific feature and is enabled by default. See * <a href="http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html#JAR%20Index"> * the JAR index specification</a> for more details. * * @param zOut the zip stream representing the jar being built. * @throws IOException thrown if there is an error while creating the * index and adding it to the zip stream. */	TokenNameCOMMENT_JAVADOC	 Create the index list to speed up classloading. This is a JDK 1.3+ specific feature and is enabled by default. See <a href="http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html#JAR%20Index"> the JAR index specification</a> for more details. * @param zOut the zip stream representing the jar being built. @throws IOException thrown if there is an error while creating the index and adding it to the zip stream. 
private	TokenNameprivate	
void	TokenNamevoid	
createIndexList	TokenNameIdentifier	 create Index List
(	TokenNameLPAREN	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
zOut	TokenNameIdentifier	 z Out
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
ByteArrayOutputStream	TokenNameIdentifier	 Byte Array Output Stream
baos	TokenNameIdentifier	 baos
=	TokenNameEQUAL	
new	TokenNamenew	
ByteArrayOutputStream	TokenNameIdentifier	 Byte Array Output Stream
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// encoding must be UTF8 as specified in the specs. 	TokenNameCOMMENT_LINE	encoding must be UTF8 as specified in the specs. 
PrintWriter	TokenNameIdentifier	 Print Writer
writer	TokenNameIdentifier	 writer
=	TokenNameEQUAL	
new	TokenNamenew	
PrintWriter	TokenNameIdentifier	 Print Writer
(	TokenNameLPAREN	
new	TokenNamenew	
OutputStreamWriter	TokenNameIdentifier	 Output Stream Writer
(	TokenNameLPAREN	
baos	TokenNameIdentifier	 baos
,	TokenNameCOMMA	
"UTF8"	TokenNameStringLiteral	UTF8
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// version-info blankline 	TokenNameCOMMENT_LINE	version-info blankline 
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"JarIndex-Version: 1.0"	TokenNameStringLiteral	JarIndex-Version: 1.0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// header newline 	TokenNameCOMMENT_LINE	header newline 
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
zipFile	TokenNameIdentifier	 zip File
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeIndexLikeList	TokenNameIdentifier	 write Index Like List
(	TokenNameLPAREN	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
addedDirs	TokenNameIdentifier	 added Dirs
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
rootEntries	TokenNameIdentifier	 root Entries
,	TokenNameCOMMA	
writer	TokenNameIdentifier	 writer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
indexJars	TokenNameIdentifier	 index Jars
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Manifest	TokenNameIdentifier	 Manifest
mf	TokenNameIdentifier	 mf
=	TokenNameEQUAL	
createManifest	TokenNameIdentifier	 create Manifest
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Manifest	TokenNameIdentifier	 Manifest
.	TokenNameDOT	
Attribute	TokenNameIdentifier	 Attribute
classpath	TokenNameIdentifier	 classpath
=	TokenNameEQUAL	
mf	TokenNameIdentifier	 mf
.	TokenNameDOT	
getMainSection	TokenNameIdentifier	 get Main Section
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
Manifest	TokenNameIdentifier	 Manifest
.	TokenNameDOT	
ATTRIBUTE_CLASSPATH	TokenNameIdentifier	 ATTRIBUTE  CLASSPATH
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
cpEntries	TokenNameIdentifier	 cp Entries
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
classpath	TokenNameIdentifier	 classpath
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
classpath	TokenNameIdentifier	 classpath
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StringTokenizer	TokenNameIdentifier	 String Tokenizer
tok	TokenNameIdentifier	 tok
=	TokenNameEQUAL	
new	TokenNamenew	
StringTokenizer	TokenNameIdentifier	 String Tokenizer
(	TokenNameLPAREN	
classpath	TokenNameIdentifier	 classpath
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
" "	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cpEntries	TokenNameIdentifier	 cp Entries
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
tok	TokenNameIdentifier	 tok
.	TokenNameDOT	
countTokens	TokenNameIdentifier	 count Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
tok	TokenNameIdentifier	 tok
.	TokenNameDOT	
hasMoreTokens	TokenNameIdentifier	 has More Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
cpEntries	TokenNameIdentifier	 cp Entries
[	TokenNameLBRACKET	
c	TokenNameIdentifier	 c
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
tok	TokenNameIdentifier	 tok
.	TokenNameDOT	
nextToken	TokenNameIdentifier	 next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
indexJarEntries	TokenNameIdentifier	 index Jar Entries
=	TokenNameEQUAL	
indexJars	TokenNameIdentifier	 index Jars
.	TokenNameDOT	
list	TokenNameIdentifier	 list
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
indexJarEntries	TokenNameIdentifier	 index Jar Entries
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
findJarName	TokenNameIdentifier	 find Jar Name
(	TokenNameLPAREN	
indexJarEntries	TokenNameIdentifier	 index Jar Entries
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
cpEntries	TokenNameIdentifier	 cp Entries
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ArrayList	TokenNameIdentifier	 Array List
dirs	TokenNameIdentifier	 dirs
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ArrayList	TokenNameIdentifier	 Array List
files	TokenNameIdentifier	 files
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
grabFilesAndDirs	TokenNameIdentifier	 grab Files And Dirs
(	TokenNameLPAREN	
indexJarEntries	TokenNameIdentifier	 index Jar Entries
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
dirs	TokenNameIdentifier	 dirs
,	TokenNameCOMMA	
files	TokenNameIdentifier	 files
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dirs	TokenNameIdentifier	 dirs
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
files	TokenNameIdentifier	 files
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeIndexLikeList	TokenNameIdentifier	 write Index Like List
(	TokenNameLPAREN	
dirs	TokenNameIdentifier	 dirs
,	TokenNameCOMMA	
files	TokenNameIdentifier	 files
,	TokenNameCOMMA	
writer	TokenNameIdentifier	 writer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
checkError	TokenNameIdentifier	 check Error
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IOException	TokenNameIdentifier	 IO Exception
(	TokenNameLPAREN	
"Encountered an error writing jar index"	TokenNameStringLiteral	Encountered an error writing jar index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ByteArrayInputStream	TokenNameIdentifier	 Byte Array Input Stream
bais	TokenNameIdentifier	 bais
=	TokenNameEQUAL	
new	TokenNamenew	
ByteArrayInputStream	TokenNameIdentifier	 Byte Array Input Stream
(	TokenNameLPAREN	
baos	TokenNameIdentifier	 baos
.	TokenNameDOT	
toByteArray	TokenNameIdentifier	 to Byte Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
zipFile	TokenNameIdentifier	 zip File
(	TokenNameLPAREN	
bais	TokenNameIdentifier	 bais
,	TokenNameCOMMA	
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
INDEX_NAME	TokenNameIdentifier	 INDEX  NAME
,	TokenNameCOMMA	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
ZipFileSet	TokenNameIdentifier	 Zip File Set
.	TokenNameDOT	
DEFAULT_FILE_MODE	TokenNameIdentifier	 DEFAULT  FILE  MODE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
// not really required 	TokenNameCOMMENT_LINE	not really required 
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
bais	TokenNameIdentifier	 bais
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Overridden from Zip class to deal with manifests and index lists. * @param is the stream to read data for the entry from. The * caller of the method is responsible for closing the stream. * @param zOut the zip output stream * @param vPath the name this entry shall have in the archive * @param lastModified last modification time for the entry. * @param fromArchive the original archive we are copying this * entry from, will be null if we are not copying from an archive. * @param mode the Unix permissions to set. * @throws IOException on error */	TokenNameCOMMENT_JAVADOC	 Overridden from Zip class to deal with manifests and index lists. @param is the stream to read data for the entry from. The caller of the method is responsible for closing the stream. @param zOut the zip output stream @param vPath the name this entry shall have in the archive @param lastModified last modification time for the entry. @param fromArchive the original archive we are copying this entry from, will be null if we are not copying from an archive. @param mode the Unix permissions to set. @throws IOException on error 
protected	TokenNameprotected	
void	TokenNamevoid	
zipFile	TokenNameIdentifier	 zip File
(	TokenNameLPAREN	
InputStream	TokenNameIdentifier	 Input Stream
is	TokenNameIdentifier	 is
,	TokenNameCOMMA	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
vPath	TokenNameIdentifier	 v Path
,	TokenNameCOMMA	
long	TokenNamelong	
lastModified	TokenNameIdentifier	 last Modified
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
fromArchive	TokenNameIdentifier	 from Archive
,	TokenNameCOMMA	
int	TokenNameint	
mode	TokenNameIdentifier	 mode
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
MANIFEST_NAME	TokenNameIdentifier	 MANIFEST  NAME
.	TokenNameDOT	
equalsIgnoreCase	TokenNameIdentifier	 equals Ignore Case
(	TokenNameLPAREN	
vPath	TokenNameIdentifier	 v Path
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isFirstPass	TokenNameIdentifier	 is First Pass
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
filesetManifest	TokenNameIdentifier	 fileset Manifest
(	TokenNameLPAREN	
fromArchive	TokenNameIdentifier	 from Archive
,	TokenNameCOMMA	
is	TokenNameIdentifier	 is
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
INDEX_NAME	TokenNameIdentifier	 INDEX  NAME
.	TokenNameDOT	
equalsIgnoreCase	TokenNameIdentifier	 equals Ignore Case
(	TokenNameLPAREN	
vPath	TokenNameIdentifier	 v Path
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logWhenWriting	TokenNameIdentifier	 log When Writing
(	TokenNameLPAREN	
"Warning: selected "	TokenNameStringLiteral	Warning: selected 
+	TokenNamePLUS	
archiveType	TokenNameIdentifier	 archive Type
+	TokenNamePLUS	
" files include a "	TokenNameStringLiteral	 files include a 
+	TokenNamePLUS	
INDEX_NAME	TokenNameIdentifier	 INDEX  NAME
+	TokenNamePLUS	
" which will"	TokenNameStringLiteral	 which will
+	TokenNamePLUS	
" be replaced by a newly generated one."	TokenNameStringLiteral	 be replaced by a newly generated one.
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_WARN	TokenNameIdentifier	 MSG  WARN
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
&&	TokenNameAND_AND	
vPath	TokenNameIdentifier	 v Path
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
"/"	TokenNameStringLiteral	/
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
rootEntries	TokenNameIdentifier	 root Entries
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
vPath	TokenNameIdentifier	 v Path
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
zipFile	TokenNameIdentifier	 zip File
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
,	TokenNameCOMMA	
zOut	TokenNameIdentifier	 z Out
,	TokenNameCOMMA	
vPath	TokenNameIdentifier	 v Path
,	TokenNameCOMMA	
lastModified	TokenNameIdentifier	 last Modified
,	TokenNameCOMMA	
fromArchive	TokenNameIdentifier	 from Archive
,	TokenNameCOMMA	
mode	TokenNameIdentifier	 mode
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
filesetManifest	TokenNameIdentifier	 fileset Manifest
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
InputStream	TokenNameIdentifier	 Input Stream
is	TokenNameIdentifier	 is
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
manifestFile	TokenNameIdentifier	 manifest File
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
manifestFile	TokenNameIdentifier	 manifest File
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If this is the same name specified in 'manifest', this 	TokenNameCOMMENT_LINE	If this is the same name specified in 'manifest', this 
// is the manifest to use 	TokenNameCOMMENT_LINE	is the manifest to use 
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Found manifest "	TokenNameStringLiteral	Found manifest 
+	TokenNamePLUS	
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_VERBOSE	TokenNameIdentifier	 MSG  VERBOSE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
InputStreamReader	TokenNameIdentifier	 Input Stream Reader
isr	TokenNameIdentifier	 isr
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
manifestEncoding	TokenNameIdentifier	 manifest Encoding
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
isr	TokenNameIdentifier	 isr
=	TokenNameEQUAL	
new	TokenNamenew	
InputStreamReader	TokenNameIdentifier	 Input Stream Reader
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
isr	TokenNameIdentifier	 isr
=	TokenNameEQUAL	
new	TokenNamenew	
InputStreamReader	TokenNameIdentifier	 Input Stream Reader
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
,	TokenNameCOMMA	
manifestEncoding	TokenNameIdentifier	 manifest Encoding
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
manifest	TokenNameIdentifier	 manifest
=	TokenNameEQUAL	
getManifest	TokenNameIdentifier	 get Manifest
(	TokenNameLPAREN	
isr	TokenNameIdentifier	 isr
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
manifest	TokenNameIdentifier	 manifest
=	TokenNameEQUAL	
getManifest	TokenNameIdentifier	 get Manifest
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
UnsupportedEncodingException	TokenNameIdentifier	 Unsupported Encoding Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Unsupported encoding while reading "	TokenNameStringLiteral	Unsupported encoding while reading 
+	TokenNamePLUS	
"manifest: "	TokenNameStringLiteral	manifest: 
+	TokenNamePLUS	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
filesetManifestConfig	TokenNameIdentifier	 fileset Manifest Config
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
filesetManifestConfig	TokenNameIdentifier	 fileset Manifest Config
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"skip"	TokenNameStringLiteral	skip
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// we add this to our group of fileset manifests 	TokenNameCOMMENT_LINE	we add this to our group of fileset manifests 
logWhenWriting	TokenNameIdentifier	 log When Writing
(	TokenNameLPAREN	
"Found manifest to merge in file "	TokenNameStringLiteral	Found manifest to merge in file 
+	TokenNamePLUS	
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_VERBOSE	TokenNameIdentifier	 MSG  VERBOSE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
Manifest	TokenNameIdentifier	 Manifest
newManifest	TokenNameIdentifier	 new Manifest
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
InputStreamReader	TokenNameIdentifier	 Input Stream Reader
isr	TokenNameIdentifier	 isr
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
manifestEncoding	TokenNameIdentifier	 manifest Encoding
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
isr	TokenNameIdentifier	 isr
=	TokenNameEQUAL	
new	TokenNamenew	
InputStreamReader	TokenNameIdentifier	 Input Stream Reader
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
isr	TokenNameIdentifier	 isr
=	TokenNameEQUAL	
new	TokenNamenew	
InputStreamReader	TokenNameIdentifier	 Input Stream Reader
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
,	TokenNameCOMMA	
manifestEncoding	TokenNameIdentifier	 manifest Encoding
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
newManifest	TokenNameIdentifier	 new Manifest
=	TokenNameEQUAL	
getManifest	TokenNameIdentifier	 get Manifest
(	TokenNameLPAREN	
isr	TokenNameIdentifier	 isr
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
newManifest	TokenNameIdentifier	 new Manifest
=	TokenNameEQUAL	
getManifest	TokenNameIdentifier	 get Manifest
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
filesetManifest	TokenNameIdentifier	 fileset Manifest
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
filesetManifest	TokenNameIdentifier	 fileset Manifest
=	TokenNameEQUAL	
newManifest	TokenNameIdentifier	 new Manifest
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
filesetManifest	TokenNameIdentifier	 fileset Manifest
.	TokenNameDOT	
merge	TokenNameIdentifier	 merge
(	TokenNameLPAREN	
newManifest	TokenNameIdentifier	 new Manifest
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
mergeClassPaths	TokenNameIdentifier	 merge Class Paths
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
UnsupportedEncodingException	TokenNameIdentifier	 Unsupported Encoding Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Unsupported encoding while reading "	TokenNameStringLiteral	Unsupported encoding while reading 
+	TokenNamePLUS	
"manifest: "	TokenNameStringLiteral	manifest: 
+	TokenNamePLUS	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ManifestException	TokenNameIdentifier	 Manifest Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Manifest in file "	TokenNameStringLiteral	Manifest in file 
+	TokenNamePLUS	
file	TokenNameIdentifier	 file
+	TokenNamePLUS	
" is invalid: "	TokenNameStringLiteral	 is invalid: 
+	TokenNamePLUS	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_ERR	TokenNameIdentifier	 MSG  ERR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Invalid Manifest"	TokenNameStringLiteral	Invalid Manifest
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
,	TokenNameCOMMA	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// assuming 'skip' otherwise 	TokenNameCOMMENT_LINE	assuming 'skip' otherwise 
// don't warn if skip has been requested explicitly, warn if user 	TokenNameCOMMENT_LINE	don't warn if skip has been requested explicitly, warn if user 
// didn't set the attribute 	TokenNameCOMMENT_LINE	didn't set the attribute 
// Hide warning also as it makes no sense since 	TokenNameCOMMENT_LINE	Hide warning also as it makes no sense since 
// the filesetmanifest attribute itself has been 	TokenNameCOMMENT_LINE	the filesetmanifest attribute itself has been 
// hidden 	TokenNameCOMMENT_LINE	hidden 
//int logLevel = filesetManifestConfig == null ? 	TokenNameCOMMENT_LINE	int logLevel = filesetManifestConfig == null ? 
// Project.MSG_WARN : Project.MSG_VERBOSE; 	TokenNameCOMMENT_LINE	Project.MSG_WARN : Project.MSG_VERBOSE; 
//log("File " + file 	TokenNameCOMMENT_LINE	log("File " + file 
// + " includes a META-INF/MANIFEST.MF which will be ignored. " 	TokenNameCOMMENT_LINE	+ " includes a META-INF/MANIFEST.MF which will be ignored. " 
// + "To include this file, set filesetManifest to a value other " 	TokenNameCOMMENT_LINE	+ "To include this file, set filesetManifest to a value other " 
// + "than 'skip'.", logLevel); 	TokenNameCOMMENT_LINE	+ "than 'skip'.", logLevel); 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Collect the resources that are newer than the corresponding * entries (or missing) in the original archive. * * <p>If we are going to recreate the archive instead of updating * it, all resources should be considered as new, if a single one * is. Because of this, subclasses overriding this method must * call <code>super.getResourcesToAdd</code> and indicate with the * third arg if they already know that the archive is * out-of-date.</p> * * @param rcs The resource collections to grab resources from * @param zipFile intended archive file (may or may not exist) * @param needsUpdate whether we already know that the archive is * out-of-date. Subclasses overriding this method are supposed to * set this value correctly in their call to * super.getResourcesToAdd. * @return an array of resources to add for each fileset passed in as well * as a flag that indicates whether the archive is uptodate. * * @exception BuildException if it likes */	TokenNameCOMMENT_JAVADOC	 Collect the resources that are newer than the corresponding entries (or missing) in the original archive. * <p>If we are going to recreate the archive instead of updating it, all resources should be considered as new, if a single one is. Because of this, subclasses overriding this method must call <code>super.getResourcesToAdd</code> and indicate with the third arg if they already know that the archive is out-of-date.</p> * @param rcs The resource collections to grab resources from @param zipFile intended archive file (may or may not exist) @param needsUpdate whether we already know that the archive is out-of-date. Subclasses overriding this method are supposed to set this value correctly in their call to super.getResourcesToAdd. @return an array of resources to add for each fileset passed in as well as a flag that indicates whether the archive is uptodate. * @exception BuildException if it likes 
protected	TokenNameprotected	
ArchiveState	TokenNameIdentifier	 Archive State
getResourcesToAdd	TokenNameIdentifier	 get Resources To Add
(	TokenNameLPAREN	
ResourceCollection	TokenNameIdentifier	 Resource Collection
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
rcs	TokenNameIdentifier	 rcs
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
zipFile	TokenNameIdentifier	 zip File
,	TokenNameCOMMA	
boolean	TokenNameboolean	
needsUpdate	TokenNameIdentifier	 needs Update
)	TokenNameRPAREN	
throws	TokenNamethrows	
BuildException	TokenNameIdentifier	 Build Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
skipWriting	TokenNameIdentifier	 skip Writing
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// this pass is only there to construct the merged 	TokenNameCOMMENT_LINE	this pass is only there to construct the merged 
// manifest this means we claim an update was needed and 	TokenNameCOMMENT_LINE	manifest this means we claim an update was needed and 
// only include the manifests, skipping any uptodate 	TokenNameCOMMENT_LINE	only include the manifests, skipping any uptodate 
// checks here defering them for the second run 	TokenNameCOMMENT_LINE	checks here defering them for the second run 
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
manifests	TokenNameIdentifier	 manifests
=	TokenNameEQUAL	
grabManifests	TokenNameIdentifier	 grab Manifests
(	TokenNameLPAREN	
rcs	TokenNameIdentifier	 rcs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
manifests	TokenNameIdentifier	 manifests
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
count	TokenNameIdentifier	 count
+=	TokenNamePLUS_EQUAL	
manifests	TokenNameIdentifier	 manifests
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"found a total of "	TokenNameStringLiteral	found a total of 
+	TokenNamePLUS	
count	TokenNameIdentifier	 count
+	TokenNamePLUS	
" manifests in "	TokenNameStringLiteral	 manifests in 
+	TokenNamePLUS	
manifests	TokenNameIdentifier	 manifests
.	TokenNameDOT	
length	TokenNameIdentifier	 length
+	TokenNamePLUS	
" resource collections"	TokenNameStringLiteral	 resource collections
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_VERBOSE	TokenNameIdentifier	 MSG  VERBOSE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
ArchiveState	TokenNameIdentifier	 Archive State
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
manifests	TokenNameIdentifier	 manifests
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// need to handle manifest as a special check 	TokenNameCOMMENT_LINE	need to handle manifest as a special check 
if	TokenNameif	
(	TokenNameLPAREN	
zipFile	TokenNameIdentifier	 zip File
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if it doesn't exist, it will get created anyway, don't 	TokenNameCOMMENT_LINE	if it doesn't exist, it will get created anyway, don't 
// bother with any up-to-date checks. 	TokenNameCOMMENT_LINE	bother with any up-to-date checks. 
try	TokenNametry	
{	TokenNameLBRACE	
originalManifest	TokenNameIdentifier	 original Manifest
=	TokenNameEQUAL	
getManifestFromJar	TokenNameIdentifier	 get Manifest From Jar
(	TokenNameLPAREN	
zipFile	TokenNameIdentifier	 zip File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
originalManifest	TokenNameIdentifier	 original Manifest
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Updating jar since the current jar has"	TokenNameStringLiteral	Updating jar since the current jar has
+	TokenNamePLUS	
" no manifest"	TokenNameStringLiteral	 no manifest
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_VERBOSE	TokenNameIdentifier	 MSG  VERBOSE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
needsUpdate	TokenNameIdentifier	 needs Update
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
Manifest	TokenNameIdentifier	 Manifest
mf	TokenNameIdentifier	 mf
=	TokenNameEQUAL	
createManifest	TokenNameIdentifier	 create Manifest
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
mf	TokenNameIdentifier	 mf
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
originalManifest	TokenNameIdentifier	 original Manifest
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Updating jar since jar manifest has"	TokenNameStringLiteral	Updating jar since jar manifest has
+	TokenNamePLUS	
" changed"	TokenNameStringLiteral	 changed
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_VERBOSE	TokenNameIdentifier	 MSG  VERBOSE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
needsUpdate	TokenNameIdentifier	 needs Update
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Throwable	TokenNameIdentifier	 Throwable
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"error while reading original manifest in file: "	TokenNameStringLiteral	error while reading original manifest in file: 
+	TokenNamePLUS	
zipFile	TokenNameIdentifier	 zip File
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" due to "	TokenNameStringLiteral	 due to 
+	TokenNamePLUS	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_WARN	TokenNameIdentifier	 MSG  WARN
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
needsUpdate	TokenNameIdentifier	 needs Update
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// no existing archive 	TokenNameCOMMENT_LINE	no existing archive 
needsUpdate	TokenNameIdentifier	 needs Update
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
createEmpty	TokenNameIdentifier	 create Empty
=	TokenNameEQUAL	
needsUpdate	TokenNameIdentifier	 needs Update
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
needsUpdate	TokenNameIdentifier	 needs Update
&&	TokenNameAND_AND	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
needsUpdate	TokenNameIdentifier	 needs Update
=	TokenNameEQUAL	
!	TokenNameNOT	
jarHasIndex	TokenNameIdentifier	 jar Has Index
(	TokenNameLPAREN	
zipFile	TokenNameIdentifier	 zip File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//if we couldn't read it, we might as well recreate it? 	TokenNameCOMMENT_LINE	if we couldn't read it, we might as well recreate it? 
needsUpdate	TokenNameIdentifier	 needs Update
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
super	TokenNamesuper	
.	TokenNameDOT	
getResourcesToAdd	TokenNameIdentifier	 get Resources To Add
(	TokenNameLPAREN	
rcs	TokenNameIdentifier	 rcs
,	TokenNameCOMMA	
zipFile	TokenNameIdentifier	 zip File
,	TokenNameCOMMA	
needsUpdate	TokenNameIdentifier	 needs Update
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Create an empty jar file. * @param zipFile the file to create * @return true for historic reasons * @throws BuildException on error */	TokenNameCOMMENT_JAVADOC	 Create an empty jar file. @param zipFile the file to create @return true for historic reasons @throws BuildException on error 
protected	TokenNameprotected	
boolean	TokenNameboolean	
createEmptyZip	TokenNameIdentifier	 create Empty Zip
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
zipFile	TokenNameIdentifier	 zip File
)	TokenNameRPAREN	
throws	TokenNamethrows	
BuildException	TokenNameIdentifier	 Build Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
createEmpty	TokenNameIdentifier	 create Empty
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
emptyBehavior	TokenNameIdentifier	 empty Behavior
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"skip"	TokenNameStringLiteral	skip
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
skipWriting	TokenNameIdentifier	 skip Writing
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Warning: skipping "	TokenNameStringLiteral	Warning: skipping 
+	TokenNamePLUS	
archiveType	TokenNameIdentifier	 archive Type
+	TokenNamePLUS	
" archive "	TokenNameStringLiteral	 archive 
+	TokenNamePLUS	
zipFile	TokenNameIdentifier	 zip File
+	TokenNamePLUS	
" because no files were included."	TokenNameStringLiteral	 because no files were included.
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_WARN	TokenNameIdentifier	 MSG  WARN
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
emptyBehavior	TokenNameIdentifier	 empty Behavior
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"fail"	TokenNameStringLiteral	fail
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Cannot create "	TokenNameStringLiteral	Cannot create 
+	TokenNamePLUS	
archiveType	TokenNameIdentifier	 archive Type
+	TokenNamePLUS	
" archive "	TokenNameStringLiteral	 archive 
+	TokenNamePLUS	
zipFile	TokenNameIdentifier	 zip File
+	TokenNamePLUS	
": no files were included."	TokenNameStringLiteral	: no files were included.
,	TokenNameCOMMA	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
zOut	TokenNameIdentifier	 z Out
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
skipWriting	TokenNameIdentifier	 skip Writing
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Building MANIFEST-only jar: "	TokenNameStringLiteral	Building MANIFEST-only jar: 
+	TokenNamePLUS	
getDestFile	TokenNameIdentifier	 get Dest File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
zOut	TokenNameIdentifier	 z Out
=	TokenNameEQUAL	
new	TokenNamenew	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
(	TokenNameLPAREN	
new	TokenNamenew	
FileOutputStream	TokenNameIdentifier	 File Output Stream
(	TokenNameLPAREN	
getDestFile	TokenNameIdentifier	 get Dest File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
zOut	TokenNameIdentifier	 z Out
.	TokenNameDOT	
setEncoding	TokenNameIdentifier	 set Encoding
(	TokenNameLPAREN	
getEncoding	TokenNameIdentifier	 get Encoding
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isCompress	TokenNameIdentifier	 is Compress
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
zOut	TokenNameIdentifier	 z Out
.	TokenNameDOT	
setMethod	TokenNameIdentifier	 set Method
(	TokenNameLPAREN	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
.	TokenNameDOT	
DEFLATED	TokenNameIdentifier	 DEFLATED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
zOut	TokenNameIdentifier	 z Out
.	TokenNameDOT	
setMethod	TokenNameIdentifier	 set Method
(	TokenNameLPAREN	
ZipOutputStream	TokenNameIdentifier	 Zip Output Stream
.	TokenNameDOT	
STORED	TokenNameIdentifier	 STORED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
initZipOutputStream	TokenNameIdentifier	 init Zip Output Stream
(	TokenNameLPAREN	
zOut	TokenNameIdentifier	 z Out
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
finalizeZipOutputStream	TokenNameIdentifier	 finalize Zip Output Stream
(	TokenNameLPAREN	
zOut	TokenNameIdentifier	 z Out
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ioe	TokenNameIdentifier	 ioe
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Could not create almost empty JAR archive"	TokenNameStringLiteral	Could not create almost empty JAR archive
+	TokenNamePLUS	
" ("	TokenNameStringLiteral	 (
+	TokenNamePLUS	
ioe	TokenNameIdentifier	 ioe
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
")"	TokenNameStringLiteral	)
,	TokenNameCOMMA	
ioe	TokenNameIdentifier	 ioe
,	TokenNameCOMMA	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
// Close the output stream. 	TokenNameCOMMENT_LINE	Close the output stream. 
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
zOut	TokenNameIdentifier	 z Out
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
createEmpty	TokenNameIdentifier	 create Empty
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Make sure we don't think we already have a MANIFEST next time this task * gets executed. * * @see Zip#cleanUp */	TokenNameCOMMENT_JAVADOC	 Make sure we don't think we already have a MANIFEST next time this task gets executed. * @see Zip#cleanUp 
protected	TokenNameprotected	
void	TokenNamevoid	
cleanUp	TokenNameIdentifier	 clean Up
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
cleanUp	TokenNameIdentifier	 clean Up
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
checkJarSpec	TokenNameIdentifier	 check Jar Spec
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// we want to save this info if we are going to make another pass 	TokenNameCOMMENT_LINE	we want to save this info if we are going to make another pass 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
doubleFilePass	TokenNameIdentifier	 double File Pass
||	TokenNameOR_OR	
!	TokenNameNOT	
skipWriting	TokenNameIdentifier	 skip Writing
)	TokenNameRPAREN	
{	TokenNameLBRACE	
manifest	TokenNameIdentifier	 manifest
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
configuredManifest	TokenNameIdentifier	 configured Manifest
=	TokenNameEQUAL	
savedConfiguredManifest	TokenNameIdentifier	 saved Configured Manifest
;	TokenNameSEMICOLON	
filesetManifest	TokenNameIdentifier	 fileset Manifest
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
originalManifest	TokenNameIdentifier	 original Manifest
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
rootEntries	TokenNameIdentifier	 root Entries
.	TokenNameDOT	
removeAllElements	TokenNameIdentifier	 remove All Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// CheckStyle:LineLength OFF - Link is too long. 	TokenNameCOMMENT_LINE	CheckStyle:LineLength OFF - Link is too long. 
/** * Check against packaging spec * @see http://java.sun.com/j2se/1.3/docs/guide/versioning/spec/VersioningSpecification.html#PackageVersioning */	TokenNameCOMMENT_JAVADOC	 Check against packaging spec @see http://java.sun.com/j2se/1.3/docs/guide/versioning/spec/VersioningSpecification.html#PackageVersioning 
// CheckStyle:LineLength ON 	TokenNameCOMMENT_LINE	CheckStyle:LineLength ON 
private	TokenNameprivate	
void	TokenNamevoid	
checkJarSpec	TokenNameIdentifier	 check Jar Spec
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
br	TokenNameIdentifier	 br
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"line.separator"	TokenNameStringLiteral	line.separator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
StringBuffer	TokenNameIdentifier	 String Buffer
message	TokenNameIdentifier	 message
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Section	TokenNameIdentifier	 Section
mainSection	TokenNameIdentifier	 main Section
=	TokenNameEQUAL	
(	TokenNameLPAREN	
configuredManifest	TokenNameIdentifier	 configured Manifest
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
configuredManifest	TokenNameIdentifier	 configured Manifest
.	TokenNameDOT	
getMainSection	TokenNameIdentifier	 get Main Section
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
mainSection	TokenNameIdentifier	 main Section
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"No Implementation-Title set."	TokenNameStringLiteral	No Implementation-Title set.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
message	TokenNameIdentifier	 message
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"No Implementation-Version set."	TokenNameStringLiteral	No Implementation-Version set.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
message	TokenNameIdentifier	 message
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"No Implementation-Vendor set."	TokenNameStringLiteral	No Implementation-Vendor set.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
mainSection	TokenNameIdentifier	 main Section
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
"Implementation-Title"	TokenNameStringLiteral	Implementation-Title
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"No Implementation-Title set."	TokenNameStringLiteral	No Implementation-Title set.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
mainSection	TokenNameIdentifier	 main Section
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
"Implementation-Version"	TokenNameStringLiteral	Implementation-Version
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"No Implementation-Version set."	TokenNameStringLiteral	No Implementation-Version set.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
mainSection	TokenNameIdentifier	 main Section
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
"Implementation-Vendor"	TokenNameStringLiteral	Implementation-Vendor
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"No Implementation-Vendor set."	TokenNameStringLiteral	No Implementation-Vendor set.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
message	TokenNameIdentifier	 message
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
br	TokenNameIdentifier	 br
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
message	TokenNameIdentifier	 message
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"Location: "	TokenNameStringLiteral	Location: 
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
message	TokenNameIdentifier	 message
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
br	TokenNameIdentifier	 br
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
strict	TokenNameIdentifier	 strict
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equalsIgnoreCase	TokenNameIdentifier	 equals Ignore Case
(	TokenNameLPAREN	
"fail"	TokenNameStringLiteral	fail
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
message	TokenNameIdentifier	 message
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
logWhenWriting	TokenNameIdentifier	 log When Writing
(	TokenNameLPAREN	
message	TokenNameIdentifier	 message
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
strict	TokenNameIdentifier	 strict
.	TokenNameDOT	
getLogLevel	TokenNameIdentifier	 get Log Level
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * reset to default values. * * @see Zip#reset * * @since 1.44, Ant 1.5 */	TokenNameCOMMENT_JAVADOC	 reset to default values. * @see Zip#reset * @since 1.44, Ant 1.5 
public	TokenNamepublic	
void	TokenNamevoid	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
emptyBehavior	TokenNameIdentifier	 empty Behavior
=	TokenNameEQUAL	
"create"	TokenNameStringLiteral	create
;	TokenNameSEMICOLON	
configuredManifest	TokenNameIdentifier	 configured Manifest
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
filesetManifestConfig	TokenNameIdentifier	 fileset Manifest Config
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
mergeManifestsMain	TokenNameIdentifier	 merge Manifests Main
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
manifestFile	TokenNameIdentifier	 manifest File
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The manifest config enumerated type. */	TokenNameCOMMENT_JAVADOC	 The manifest config enumerated type. 
public	TokenNamepublic	
static	TokenNamestatic	
class	TokenNameclass	
FilesetManifestConfig	TokenNameIdentifier	 Fileset Manifest Config
extends	TokenNameextends	
EnumeratedAttribute	TokenNameIdentifier	 Enumerated Attribute
{	TokenNameLBRACE	
/** * Get the list of valid strings. * @return the list of values - "skip", "merge" and "mergewithoutmain" */	TokenNameCOMMENT_JAVADOC	 Get the list of valid strings. @return the list of values - "skip", "merge" and "mergewithoutmain" 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getValues	TokenNameIdentifier	 get Values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"skip"	TokenNameStringLiteral	skip
,	TokenNameCOMMA	
"merge"	TokenNameStringLiteral	merge
,	TokenNameCOMMA	
"mergewithoutmain"	TokenNameStringLiteral	mergewithoutmain
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Writes the directory entries from the first and the filenames * from the second list to the given writer, one entry per line. * * @param dirs a list of directories * @param files a list of files * @param writer the writer to write to * @throws IOException on error * @since Ant 1.6.2 */	TokenNameCOMMENT_JAVADOC	 Writes the directory entries from the first and the filenames from the second list to the given writer, one entry per line. * @param dirs a list of directories @param files a list of files @param writer the writer to write to @throws IOException on error @since Ant 1.6.2 
protected	TokenNameprotected	
final	TokenNamefinal	
void	TokenNamevoid	
writeIndexLikeList	TokenNameIdentifier	 write Index Like List
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
dirs	TokenNameIdentifier	 dirs
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
files	TokenNameIdentifier	 files
,	TokenNameCOMMA	
PrintWriter	TokenNameIdentifier	 Print Writer
writer	TokenNameIdentifier	 writer
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// JarIndex is sorting the directories by ascending order. 	TokenNameCOMMENT_LINE	JarIndex is sorting the directories by ascending order. 
// it has no value but cosmetic since it will be read into a 	TokenNameCOMMENT_LINE	it has no value but cosmetic since it will be read into a 
// hashtable by the classloader, but we'll do so anyway. 	TokenNameCOMMENT_LINE	hashtable by the classloader, but we'll do so anyway. 
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
dirs	TokenNameIdentifier	 dirs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
files	TokenNameIdentifier	 files
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Iterator	TokenNameIdentifier	 Iterator
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
dirs	TokenNameIdentifier	 dirs
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// try to be smart, not to be fooled by a weird directory name 	TokenNameCOMMENT_LINE	try to be smart, not to be fooled by a weird directory name 
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
'\\'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
'/'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
"./"	TokenNameStringLiteral	./
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
"/"	TokenNameStringLiteral	/
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
lastIndexOf	TokenNameIdentifier	 last Index Of
(	TokenNameLPAREN	
'/'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// looks like nothing from META-INF should be added 	TokenNameCOMMENT_LINE	looks like nothing from META-INF should be added 
// and the check is not case insensitive. 	TokenNameCOMMENT_LINE	and the check is not case insensitive. 
// see sun.misc.JarIndex 	TokenNameCOMMENT_LINE	see sun.misc.JarIndex 
// see also 	TokenNameCOMMENT_LINE	see also 
// http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4408526 	TokenNameCOMMENT_LINE	http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4408526 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
indexMetaInf	TokenNameIdentifier	 index Meta Inf
&&	TokenNameAND_AND	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
"META-INF"	TokenNameStringLiteral	META-INF
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// name newline 	TokenNameCOMMENT_LINE	name newline 
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
files	TokenNameIdentifier	 files
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * try to guess the name of the given file. * * <p>If this jar has a classpath attribute in its manifest, we * can assume that it will only require an index of jars listed * there. try to find which classpath entry is most likely the * one the given file name points to.</p> * * <p>In the absence of a classpath attribute, assume the other * files will be placed inside the same directory as this jar and * use their basename.</p> * * <p>if there is a classpath and the given file doesn't match any * of its entries, return null.</p> * * @param fileName the name to look for * @param classpath the classpath to look in (may be null) * @return the matching entry, or null if the file is not found * @since Ant 1.6.2 */	TokenNameCOMMENT_JAVADOC	 try to guess the name of the given file. * <p>If this jar has a classpath attribute in its manifest, we can assume that it will only require an index of jars listed there. try to find which classpath entry is most likely the one the given file name points to.</p> * <p>In the absence of a classpath attribute, assume the other files will be placed inside the same directory as this jar and use their basename.</p> * <p>if there is a classpath and the given file doesn't match any of its entries, return null.</p> * @param fileName the name to look for @param classpath the classpath to look in (may be null) @return the matching entry, or null if the file is not found @since Ant 1.6.2 
protected	TokenNameprotected	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
findJarName	TokenNameIdentifier	 find Jar Name
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
fileName	TokenNameIdentifier	 file Name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
classpath	TokenNameIdentifier	 classpath
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
classpath	TokenNameIdentifier	 classpath
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
fileName	TokenNameIdentifier	 file Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fileName	TokenNameIdentifier	 file Name
=	TokenNameEQUAL	
fileName	TokenNameIdentifier	 file Name
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separatorChar	TokenNameIdentifier	 separator Char
,	TokenNameCOMMA	
'/'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TreeMap	TokenNameIdentifier	 Tree Map
matches	TokenNameIdentifier	 matches
=	TokenNameEQUAL	
new	TokenNamenew	
TreeMap	TokenNameIdentifier	 Tree Map
(	TokenNameLPAREN	
new	TokenNamenew	
Comparator	TokenNameIdentifier	 Comparator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// longest match comes first 	TokenNameCOMMENT_LINE	longest match comes first 
public	TokenNamepublic	
int	TokenNameint	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
o1	TokenNameIdentifier	 o1
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
o2	TokenNameIdentifier	 o2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
o1	TokenNameIdentifier	 o1
instanceof	TokenNameinstanceof	
String	TokenNameIdentifier	 String
&&	TokenNameAND_AND	
o2	TokenNameIdentifier	 o2
instanceof	TokenNameinstanceof	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
o2	TokenNameIdentifier	 o2
)	TokenNameRPAREN	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
o1	TokenNameIdentifier	 o1
)	TokenNameRPAREN	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
classpath	TokenNameIdentifier	 classpath
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fileName	TokenNameIdentifier	 file Name
.	TokenNameDOT	
endsWith	TokenNameIdentifier	 ends With
(	TokenNameLPAREN	
classpath	TokenNameIdentifier	 classpath
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
matches	TokenNameIdentifier	 matches
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
classpath	TokenNameIdentifier	 classpath
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
classpath	TokenNameIdentifier	 classpath
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
slash	TokenNameIdentifier	 slash
=	TokenNameEQUAL	
classpath	TokenNameIdentifier	 classpath
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
"/"	TokenNameStringLiteral	/
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
candidate	TokenNameIdentifier	 candidate
=	TokenNameEQUAL	
classpath	TokenNameIdentifier	 classpath
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
slash	TokenNameIdentifier	 slash
>	TokenNameGREATER	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
candidate	TokenNameIdentifier	 candidate
=	TokenNameEQUAL	
candidate	TokenNameIdentifier	 candidate
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
slash	TokenNameIdentifier	 slash
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fileName	TokenNameIdentifier	 file Name
.	TokenNameDOT	
endsWith	TokenNameIdentifier	 ends With
(	TokenNameLPAREN	
candidate	TokenNameIdentifier	 candidate
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
matches	TokenNameIdentifier	 matches
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
candidate	TokenNameIdentifier	 candidate
,	TokenNameCOMMA	
classpath	TokenNameIdentifier	 classpath
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
slash	TokenNameIdentifier	 slash
=	TokenNameEQUAL	
candidate	TokenNameIdentifier	 candidate
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
"/"	TokenNameStringLiteral	/
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
matches	TokenNameIdentifier	 matches
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
matches	TokenNameIdentifier	 matches
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
matches	TokenNameIdentifier	 matches
.	TokenNameDOT	
firstKey	TokenNameIdentifier	 first Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Grab lists of all root-level files and all directories * contained in the given archive. * @param file the zip file to examine * @param dirs where to place the directories found * @param files where to place the files found * @since Ant 1.7 * @throws IOException on error */	TokenNameCOMMENT_JAVADOC	 Grab lists of all root-level files and all directories contained in the given archive. @param file the zip file to examine @param dirs where to place the directories found @param files where to place the files found @since Ant 1.7 @throws IOException on error 
protected	TokenNameprotected	
static	TokenNamestatic	
void	TokenNamevoid	
grabFilesAndDirs	TokenNameIdentifier	 grab Files And Dirs
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
dirs	TokenNameIdentifier	 dirs
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
files	TokenNameIdentifier	 files
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
zip	TokenNameIdentifier	 zip
.	TokenNameDOT	
ZipFile	TokenNameIdentifier	 Zip File
zf	TokenNameIdentifier	 zf
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
zf	TokenNameIdentifier	 zf
=	TokenNameEQUAL	
new	TokenNamenew	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
zip	TokenNameIdentifier	 zip
.	TokenNameDOT	
ZipFile	TokenNameIdentifier	 Zip File
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
"utf-8"	TokenNameStringLiteral	utf-8
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Enumeration	TokenNameIdentifier	 Enumeration
entries	TokenNameIdentifier	 entries
=	TokenNameEQUAL	
zf	TokenNameIdentifier	 zf
.	TokenNameDOT	
getEntries	TokenNameIdentifier	 get Entries
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
HashSet	TokenNameIdentifier	 Hash Set
dirSet	TokenNameIdentifier	 dir Set
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
entries	TokenNameIdentifier	 entries
.	TokenNameDOT	
hasMoreElements	TokenNameIdentifier	 has More Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
zip	TokenNameIdentifier	 zip
.	TokenNameDOT	
ZipEntry	TokenNameIdentifier	 Zip Entry
ze	TokenNameIdentifier	 ze
=	TokenNameEQUAL	
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
zip	TokenNameIdentifier	 zip
.	TokenNameDOT	
ZipEntry	TokenNameIdentifier	 Zip Entry
)	TokenNameRPAREN	
entries	TokenNameIdentifier	 entries
.	TokenNameDOT	
nextElement	TokenNameIdentifier	 next Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
ze	TokenNameIdentifier	 ze
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ze	TokenNameIdentifier	 ze
.	TokenNameDOT	
isDirectory	TokenNameIdentifier	 is Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dirSet	TokenNameIdentifier	 dir Set
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
"/"	TokenNameStringLiteral	/
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
files	TokenNameIdentifier	 files
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// a file, not in the root 	TokenNameCOMMENT_LINE	a file, not in the root 
// since the jar may be one without directory 	TokenNameCOMMENT_LINE	since the jar may be one without directory 
// entries, add the parent dir of this file as 	TokenNameCOMMENT_LINE	entries, add the parent dir of this file as 
// well. 	TokenNameCOMMENT_LINE	well. 
dirSet	TokenNameIdentifier	 dir Set
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
lastIndexOf	TokenNameIdentifier	 last Index Of
(	TokenNameLPAREN	
"/"	TokenNameStringLiteral	/
)	TokenNameRPAREN	
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
dirs	TokenNameIdentifier	 dirs
.	TokenNameDOT	
addAll	TokenNameIdentifier	 add All
(	TokenNameLPAREN	
dirSet	TokenNameIdentifier	 dir Set
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
zf	TokenNameIdentifier	 zf
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
zf	TokenNameIdentifier	 zf
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
grabManifests	TokenNameIdentifier	 grab Manifests
(	TokenNameLPAREN	
ResourceCollection	TokenNameIdentifier	 Resource Collection
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
rcs	TokenNameIdentifier	 rcs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
manifests	TokenNameIdentifier	 manifests
=	TokenNameEQUAL	
new	TokenNamenew	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
rcs	TokenNameIdentifier	 rcs
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
rcs	TokenNameIdentifier	 rcs
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
resources	TokenNameIdentifier	 resources
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
rcs	TokenNameIdentifier	 rcs
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
instanceof	TokenNameinstanceof	
FileSet	TokenNameIdentifier	 File Set
)	TokenNameRPAREN	
{	TokenNameLBRACE	
resources	TokenNameIdentifier	 resources
=	TokenNameEQUAL	
grabResources	TokenNameIdentifier	 grab Resources
(	TokenNameLPAREN	
new	TokenNamenew	
FileSet	TokenNameIdentifier	 File Set
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
(	TokenNameLPAREN	
FileSet	TokenNameIdentifier	 File Set
)	TokenNameRPAREN	
rcs	TokenNameIdentifier	 rcs
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
resources	TokenNameIdentifier	 resources
=	TokenNameEQUAL	
grabNonFileSetResources	TokenNameIdentifier	 grab Non File Set Resources
(	TokenNameLPAREN	
new	TokenNamenew	
ResourceCollection	TokenNameIdentifier	 Resource Collection
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
rcs	TokenNameIdentifier	 rcs
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
resources	TokenNameIdentifier	 resources
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
resources	TokenNameIdentifier	 resources
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
'\\'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
'/'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
rcs	TokenNameIdentifier	 rcs
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
instanceof	TokenNameinstanceof	
ArchiveFileSet	TokenNameIdentifier	 Archive File Set
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ArchiveFileSet	TokenNameIdentifier	 Archive File Set
afs	TokenNameIdentifier	 afs
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ArchiveFileSet	TokenNameIdentifier	 Archive File Set
)	TokenNameRPAREN	
rcs	TokenNameIdentifier	 rcs
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
""	TokenNameStringLiteral	 
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
afs	TokenNameIdentifier	 afs
.	TokenNameDOT	
getFullpath	TokenNameIdentifier	 get Fullpath
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
afs	TokenNameIdentifier	 afs
.	TokenNameDOT	
getFullpath	TokenNameIdentifier	 get Fullpath
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
""	TokenNameStringLiteral	 
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
afs	TokenNameIdentifier	 afs
.	TokenNameDOT	
getPrefix	TokenNameIdentifier	 get Prefix
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
prefix	TokenNameIdentifier	 prefix
=	TokenNameEQUAL	
afs	TokenNameIdentifier	 afs
.	TokenNameDOT	
getPrefix	TokenNameIdentifier	 get Prefix
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
prefix	TokenNameIdentifier	 prefix
.	TokenNameDOT	
endsWith	TokenNameIdentifier	 ends With
(	TokenNameLPAREN	
"/"	TokenNameStringLiteral	/
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
prefix	TokenNameIdentifier	 prefix
.	TokenNameDOT	
endsWith	TokenNameIdentifier	 ends With
(	TokenNameLPAREN	
"\"	TokenNameStringLiteral	\
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
prefix	TokenNameIdentifier	 prefix
+=	TokenNamePLUS_EQUAL	
"/"	TokenNameStringLiteral	/
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
prefix	TokenNameIdentifier	 prefix
+	TokenNamePLUS	
name	TokenNameIdentifier	 name
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
equalsIgnoreCase	TokenNameIdentifier	 equals Ignore Case
(	TokenNameLPAREN	
MANIFEST_NAME	TokenNameIdentifier	 MANIFEST  NAME
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
manifests	TokenNameIdentifier	 manifests
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
resources	TokenNameIdentifier	 resources
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
manifests	TokenNameIdentifier	 manifests
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
manifests	TokenNameIdentifier	 manifests
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
manifests	TokenNameIdentifier	 manifests
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** The strict enumerated type. */	TokenNameCOMMENT_JAVADOC	 The strict enumerated type. 
public	TokenNamepublic	
static	TokenNamestatic	
class	TokenNameclass	
StrictMode	TokenNameIdentifier	 Strict Mode
extends	TokenNameextends	
EnumeratedAttribute	TokenNameIdentifier	 Enumerated Attribute
{	TokenNameLBRACE	
/** Public no arg constructor. */	TokenNameCOMMENT_JAVADOC	 Public no arg constructor. 
public	TokenNamepublic	
StrictMode	TokenNameIdentifier	 Strict Mode
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
/** * Constructor with an arg. * @param value the enumerated value as a string. */	TokenNameCOMMENT_JAVADOC	 Constructor with an arg. @param value the enumerated value as a string. 
public	TokenNamepublic	
StrictMode	TokenNameIdentifier	 Strict Mode
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
setValue	TokenNameIdentifier	 set Value
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get List of valid strings. * @return the list of values. */	TokenNameCOMMENT_JAVADOC	 Get List of valid strings. @return the list of values. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getValues	TokenNameIdentifier	 get Values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"fail"	TokenNameStringLiteral	fail
,	TokenNameCOMMA	
"warn"	TokenNameStringLiteral	warn
,	TokenNameCOMMA	
"ignore"	TokenNameStringLiteral	ignore
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @return The log level according to the strict mode. */	TokenNameCOMMENT_JAVADOC	 @return The log level according to the strict mode. 
public	TokenNamepublic	
int	TokenNameint	
getLogLevel	TokenNameIdentifier	 get Log Level
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"ignore"	TokenNameStringLiteral	ignore
)	TokenNameRPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_VERBOSE	TokenNameIdentifier	 MSG  VERBOSE
:	TokenNameCOLON	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_WARN	TokenNameIdentifier	 MSG  WARN
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
