/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
locator	TokenNameIdentifier	 locator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
net	TokenNameIdentifier	 net
.	TokenNameDOT	
InetAddress	TokenNameIdentifier	 Inet Address
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
nio	TokenNameIdentifier	 nio
.	TokenNameDOT	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
ConcurrentHashMap	TokenNameIdentifier	 Concurrent Hash Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
ConcurrentMap	TokenNameIdentifier	 Concurrent Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
CopyOnWriteArrayList	TokenNameIdentifier	 Copy On Write Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
locks	TokenNameIdentifier	 locks
.	TokenNameDOT	
ReadWriteLock	TokenNameIdentifier	 Read Write Lock
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
locks	TokenNameIdentifier	 locks
.	TokenNameDOT	
ReentrantReadWriteLock	TokenNameIdentifier	 Reentrant Read Write Lock
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
collect	TokenNameIdentifier	 collect
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
BiMultiValMap	TokenNameIdentifier	 Bi Multi Val Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
Pair	TokenNameIdentifier	 Pair
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
SortedBiMultiValMap	TokenNameIdentifier	 Sorted Bi Multi Val Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
commons	TokenNameIdentifier	 commons
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
StringUtils	TokenNameIdentifier	 String Utils
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
slf4j	TokenNameIdentifier	 slf4j
.	TokenNameDOT	
Logger	TokenNameIdentifier	 Logger
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
slf4j	TokenNameIdentifier	 slf4j
.	TokenNameDOT	
LoggerFactory	TokenNameIdentifier	 Logger Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
dht	TokenNameIdentifier	 dht
.	TokenNameDOT	
Range	TokenNameIdentifier	 Range
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
dht	TokenNameIdentifier	 dht
.	TokenNameDOT	
Token	TokenNameIdentifier	 Token
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
gms	TokenNameIdentifier	 gms
.	TokenNameDOT	
FailureDetector	TokenNameIdentifier	 Failure Detector
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
service	TokenNameIdentifier	 service
.	TokenNameDOT	
StorageService	TokenNameIdentifier	 Storage Service
;	TokenNameSEMICOLON	
public	TokenNamepublic	
class	TokenNameclass	
TokenMetadata	TokenNameIdentifier	 Token Metadata
{	TokenNameLBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Logger	TokenNameIdentifier	 Logger
logger	TokenNameIdentifier	 logger
=	TokenNameEQUAL	
LoggerFactory	TokenNameIdentifier	 Logger Factory
.	TokenNameDOT	
getLogger	TokenNameIdentifier	 get Logger
(	TokenNameLPAREN	
TokenMetadata	TokenNameIdentifier	 Token Metadata
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* Maintains token to endpoint map of every node in the cluster. */	TokenNameCOMMENT_BLOCK	 Maintains token to endpoint map of every node in the cluster. 
private	TokenNameprivate	
final	TokenNamefinal	
BiMultiValMap	TokenNameIdentifier	 Bi Multi Val Map
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
tokenToEndpointMap	TokenNameIdentifier	 token To Endpoint Map
;	TokenNameSEMICOLON	
/* Maintains endpoint to host ID map of every node in the cluster */	TokenNameCOMMENT_BLOCK	 Maintains endpoint to host ID map of every node in the cluster 
private	TokenNameprivate	
final	TokenNamefinal	
BiMap	TokenNameIdentifier	 Bi Map
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
UUID	TokenNameIdentifier	 UUID
>	TokenNameGREATER	
endpointToHostIdMap	TokenNameIdentifier	 endpoint To Host Id Map
;	TokenNameSEMICOLON	
// Prior to CASSANDRA-603, we just had <tt>Map<Range, InetAddress> pendingRanges<tt>, 	TokenNameCOMMENT_LINE	Prior to CASSANDRA-603, we just had <tt>Map<Range, InetAddress> pendingRanges<tt>, 
// which was added to when a node began bootstrap and removed from when it finished. 	TokenNameCOMMENT_LINE	which was added to when a node began bootstrap and removed from when it finished. 
// 	TokenNameCOMMENT_LINE	 
// This is inadequate when multiple changes are allowed simultaneously. For example, 	TokenNameCOMMENT_LINE	This is inadequate when multiple changes are allowed simultaneously. For example, 
// suppose that there is a ring of nodes A, C and E, with replication factor 3. 	TokenNameCOMMENT_LINE	suppose that there is a ring of nodes A, C and E, with replication factor 3. 
// Node D bootstraps between C and E, so its pending ranges will be E-A, A-C and C-D. 	TokenNameCOMMENT_LINE	Node D bootstraps between C and E, so its pending ranges will be E-A, A-C and C-D. 
// Now suppose node B bootstraps between A and C at the same time. Its pending ranges 	TokenNameCOMMENT_LINE	Now suppose node B bootstraps between A and C at the same time. Its pending ranges 
// would be C-E, E-A and A-B. Now both nodes need to be assigned pending range E-A, 	TokenNameCOMMENT_LINE	would be C-E, E-A and A-B. Now both nodes need to be assigned pending range E-A, 
// which we would be unable to represent with the old Map. The same thing happens 	TokenNameCOMMENT_LINE	which we would be unable to represent with the old Map. The same thing happens 
// even more obviously for any nodes that boot simultaneously between same two nodes. 	TokenNameCOMMENT_LINE	even more obviously for any nodes that boot simultaneously between same two nodes. 
// 	TokenNameCOMMENT_LINE	 
// So, we made two changes: 	TokenNameCOMMENT_LINE	So, we made two changes: 
// 	TokenNameCOMMENT_LINE	 
// First, we changed pendingRanges to a <tt>Multimap<Range, InetAddress></tt> (now 	TokenNameCOMMENT_LINE	First, we changed pendingRanges to a <tt>Multimap<Range, InetAddress></tt> (now 
// <tt>Map<String, Multimap<Range, InetAddress>></tt>, because replication strategy 	TokenNameCOMMENT_LINE	<tt>Map<String, Multimap<Range, InetAddress>></tt>, because replication strategy 
// and options are per-KeySpace). 	TokenNameCOMMENT_LINE	and options are per-KeySpace). 
// 	TokenNameCOMMENT_LINE	 
// Second, we added the bootstrapTokens and leavingEndpoints collections, so we can 	TokenNameCOMMENT_LINE	Second, we added the bootstrapTokens and leavingEndpoints collections, so we can 
// rebuild pendingRanges from the complete information of what is going on, when 	TokenNameCOMMENT_LINE	rebuild pendingRanges from the complete information of what is going on, when 
// additional changes are made mid-operation. 	TokenNameCOMMENT_LINE	additional changes are made mid-operation. 
// 	TokenNameCOMMENT_LINE	 
// Finally, note that recording the tokens of joining nodes in bootstrapTokens also 	TokenNameCOMMENT_LINE	Finally, note that recording the tokens of joining nodes in bootstrapTokens also 
// means we can detect and reject the addition of multiple nodes at the same token 	TokenNameCOMMENT_LINE	means we can detect and reject the addition of multiple nodes at the same token 
// before one becomes part of the ring. 	TokenNameCOMMENT_LINE	before one becomes part of the ring. 
private	TokenNameprivate	
final	TokenNamefinal	
BiMultiValMap	TokenNameIdentifier	 Bi Multi Val Map
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
bootstrapTokens	TokenNameIdentifier	 bootstrap Tokens
=	TokenNameEQUAL	
new	TokenNamenew	
BiMultiValMap	TokenNameIdentifier	 Bi Multi Val Map
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// (don't need to record Token here since it's still part of tokenToEndpointMap until it's done leaving) 	TokenNameCOMMENT_LINE	(don't need to record Token here since it's still part of tokenToEndpointMap until it's done leaving) 
private	TokenNameprivate	
final	TokenNamefinal	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
leavingEndpoints	TokenNameIdentifier	 leaving Endpoints
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// this is a cache of the calculation from {tokenToEndpointMap, bootstrapTokens, leavingEndpoints} 	TokenNameCOMMENT_LINE	this is a cache of the calculation from {tokenToEndpointMap, bootstrapTokens, leavingEndpoints} 
private	TokenNameprivate	
final	TokenNamefinal	
ConcurrentMap	TokenNameIdentifier	 Concurrent Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
pendingRanges	TokenNameIdentifier	 pending Ranges
=	TokenNameEQUAL	
new	TokenNamenew	
ConcurrentHashMap	TokenNameIdentifier	 Concurrent Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// nodes which are migrating to the new tokens in the ring 	TokenNameCOMMENT_LINE	nodes which are migrating to the new tokens in the ring 
private	TokenNameprivate	
final	TokenNamefinal	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
movingEndpoints	TokenNameIdentifier	 moving Endpoints
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// tokens which are migrating to new endpoints 	TokenNameCOMMENT_LINE	tokens which are migrating to new endpoints 
private	TokenNameprivate	
final	TokenNamefinal	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
relocatingTokens	TokenNameIdentifier	 relocating Tokens
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* Use this lock for manipulating the token map */	TokenNameCOMMENT_BLOCK	 Use this lock for manipulating the token map 
private	TokenNameprivate	
final	TokenNamefinal	
ReadWriteLock	TokenNameIdentifier	 Read Write Lock
lock	TokenNameIdentifier	 lock
=	TokenNameEQUAL	
new	TokenNamenew	
ReentrantReadWriteLock	TokenNameIdentifier	 Reentrant Read Write Lock
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
volatile	TokenNamevolatile	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
sortedTokens	TokenNameIdentifier	 sorted Tokens
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Topology	TokenNameIdentifier	 Topology
topology	TokenNameIdentifier	 topology
;	TokenNameSEMICOLON	
/* list of subscribers that are notified when the tokenToEndpointMap changed */	TokenNameCOMMENT_BLOCK	 list of subscribers that are notified when the tokenToEndpointMap changed 
private	TokenNameprivate	
final	TokenNamefinal	
CopyOnWriteArrayList	TokenNameIdentifier	 Copy On Write Array List
<	TokenNameLESS	
AbstractReplicationStrategy	TokenNameIdentifier	 Abstract Replication Strategy
>	TokenNameGREATER	
subscribers	TokenNameIdentifier	 subscribers
=	TokenNameEQUAL	
new	TokenNamenew	
CopyOnWriteArrayList	TokenNameIdentifier	 Copy On Write Array List
<	TokenNameLESS	
AbstractReplicationStrategy	TokenNameIdentifier	 Abstract Replication Strategy
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Comparator	TokenNameIdentifier	 Comparator
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
inetaddressCmp	TokenNameIdentifier	 inetaddress Cmp
=	TokenNameEQUAL	
new	TokenNamenew	
Comparator	TokenNameIdentifier	 Comparator
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
int	TokenNameint	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
o1	TokenNameIdentifier	 o1
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
o2	TokenNameIdentifier	 o2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
.	TokenNameDOT	
wrap	TokenNameIdentifier	 wrap
(	TokenNameLPAREN	
o1	TokenNameIdentifier	 o1
.	TokenNameDOT	
getAddress	TokenNameIdentifier	 get Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
compareTo	TokenNameIdentifier	 compare To
(	TokenNameLPAREN	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
.	TokenNameDOT	
wrap	TokenNameIdentifier	 wrap
(	TokenNameLPAREN	
o2	TokenNameIdentifier	 o2
.	TokenNameDOT	
getAddress	TokenNameIdentifier	 get Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
TokenMetadata	TokenNameIdentifier	 Token Metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
(	TokenNameLPAREN	
SortedBiMultiValMap	TokenNameIdentifier	 Sorted Bi Multi Val Map
.	TokenNameDOT	
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
inetaddressCmp	TokenNameIdentifier	 inetaddress Cmp
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
Topology	TokenNameIdentifier	 Topology
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
TokenMetadata	TokenNameIdentifier	 Token Metadata
(	TokenNameLPAREN	
BiMultiValMap	TokenNameIdentifier	 Bi Multi Val Map
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
tokenToEndpointMap	TokenNameIdentifier	 token To Endpoint Map
,	TokenNameCOMMA	
Topology	TokenNameIdentifier	 Topology
topology	TokenNameIdentifier	 topology
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
tokenToEndpointMap	TokenNameIdentifier	 token To Endpoint Map
=	TokenNameEQUAL	
tokenToEndpointMap	TokenNameIdentifier	 token To Endpoint Map
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
topology	TokenNameIdentifier	 topology
=	TokenNameEQUAL	
topology	TokenNameIdentifier	 topology
;	TokenNameSEMICOLON	
endpointToHostIdMap	TokenNameIdentifier	 endpoint To Host Id Map
=	TokenNameEQUAL	
HashBiMap	TokenNameIdentifier	 Hash Bi Map
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sortedTokens	TokenNameIdentifier	 sorted Tokens
=	TokenNameEQUAL	
sortTokens	TokenNameIdentifier	 sort Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
sortTokens	TokenNameIdentifier	 sort Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
(	TokenNameLPAREN	
tokenToEndpointMap	TokenNameIdentifier	 token To Endpoint Map
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** @return the number of nodes bootstrapping into source's primary range */	TokenNameCOMMENT_JAVADOC	 @return the number of nodes bootstrapping into source's primary range 
public	TokenNamepublic	
int	TokenNameint	
pendingRangeChanges	TokenNameIdentifier	 pending Range Changes
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
source	TokenNameIdentifier	 source
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
sourceRanges	TokenNameIdentifier	 source Ranges
=	TokenNameEQUAL	
getPrimaryRangesFor	TokenNameIdentifier	 get Primary Ranges For
(	TokenNameLPAREN	
getTokens	TokenNameIdentifier	 get Tokens
(	TokenNameLPAREN	
source	TokenNameIdentifier	 source
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
:	TokenNameCOLON	
bootstrapTokens	TokenNameIdentifier	 bootstrap Tokens
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
for	TokenNamefor	
(	TokenNameLPAREN	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
:	TokenNameCOLON	
sourceRanges	TokenNameIdentifier	 source Ranges
)	TokenNameRPAREN	
if	TokenNameif	
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
)	TokenNameRPAREN	
n	TokenNameIdentifier	 n
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
n	TokenNameIdentifier	 n
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Update token map with a single token/endpoint pair in normal state. */	TokenNameCOMMENT_JAVADOC	 Update token map with a single token/endpoint pair in normal state. 
public	TokenNamepublic	
void	TokenNamevoid	
updateNormalToken	TokenNameIdentifier	 update Normal Token
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
{	TokenNameLBRACE	
updateNormalTokens	TokenNameIdentifier	 update Normal Tokens
(	TokenNameLPAREN	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
singleton	TokenNameIdentifier	 singleton
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
updateNormalTokens	TokenNameIdentifier	 update Normal Tokens
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
endpointTokens	TokenNameIdentifier	 endpoint Tokens
=	TokenNameEQUAL	
HashMultimap	TokenNameIdentifier	 Hash Multimap
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
:	TokenNameCOLON	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
endpointTokens	TokenNameIdentifier	 endpoint Tokens
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
updateNormalTokens	TokenNameIdentifier	 update Normal Tokens
(	TokenNameLPAREN	
endpointTokens	TokenNameIdentifier	 endpoint Tokens
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Update token map with a set of token/endpoint pairs in normal state. * * Prefer this whenever there are multiple pairs to update, as each update (whether a single or multiple) * is expensive (CASSANDRA-3831). * * @param endpointTokens */	TokenNameCOMMENT_JAVADOC	 Update token map with a set of token/endpoint pairs in normal state. * Prefer this whenever there are multiple pairs to update, as each update (whether a single or multiple) is expensive (CASSANDRA-3831). * @param endpointTokens 
public	TokenNamepublic	
void	TokenNamevoid	
updateNormalTokens	TokenNameIdentifier	 update Normal Tokens
(	TokenNameLPAREN	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
endpointTokens	TokenNameIdentifier	 endpoint Tokens
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
endpointTokens	TokenNameIdentifier	 endpoint Tokens
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
shouldSortTokens	TokenNameIdentifier	 should Sort Tokens
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
:	TokenNameCOLON	
endpointTokens	TokenNameIdentifier	 endpoint Tokens
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
tokens	TokenNameIdentifier	 tokens
=	TokenNameEQUAL	
endpointTokens	TokenNameIdentifier	 endpoint Tokens
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
tokens	TokenNameIdentifier	 tokens
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bootstrapTokens	TokenNameIdentifier	 bootstrap Tokens
.	TokenNameDOT	
removeValue	TokenNameIdentifier	 remove Value
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tokenToEndpointMap	TokenNameIdentifier	 token To Endpoint Map
.	TokenNameDOT	
removeValue	TokenNameIdentifier	 remove Value
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
topology	TokenNameIdentifier	 topology
.	TokenNameDOT	
addEndpoint	TokenNameIdentifier	 add Endpoint
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
leavingEndpoints	TokenNameIdentifier	 leaving Endpoints
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
removeFromMoving	TokenNameIdentifier	 remove From Moving
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// also removing this endpoint from moving 	TokenNameCOMMENT_LINE	also removing this endpoint from moving 
for	TokenNamefor	
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
:	TokenNameCOLON	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
{	TokenNameLBRACE	
InetAddress	TokenNameIdentifier	 Inet Address
prev	TokenNameIdentifier	 prev
=	TokenNameEQUAL	
tokenToEndpointMap	TokenNameIdentifier	 token To Endpoint Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
endpoint	TokenNameIdentifier	 endpoint
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
prev	TokenNameIdentifier	 prev
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
prev	TokenNameIdentifier	 prev
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
"Token "	TokenNameStringLiteral	Token 
+	TokenNamePLUS	
token	TokenNameIdentifier	 token
+	TokenNamePLUS	
" changing ownership from "	TokenNameStringLiteral	 changing ownership from 
+	TokenNamePLUS	
prev	TokenNameIdentifier	 prev
+	TokenNamePLUS	
" to "	TokenNameStringLiteral	 to 
+	TokenNamePLUS	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
shouldSortTokens	TokenNameIdentifier	 should Sort Tokens
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
shouldSortTokens	TokenNameIdentifier	 should Sort Tokens
)	TokenNameRPAREN	
sortedTokens	TokenNameIdentifier	 sorted Tokens
=	TokenNameEQUAL	
sortTokens	TokenNameIdentifier	 sort Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Store an end-point to host ID mapping. Each ID must be unique, and * cannot be changed after the fact. * * @param hostId * @param endpoint */	TokenNameCOMMENT_JAVADOC	 Store an end-point to host ID mapping. Each ID must be unique, and cannot be changed after the fact. * @param hostId @param endpoint 
public	TokenNamepublic	
void	TokenNamevoid	
updateHostId	TokenNameIdentifier	 update Host Id
(	TokenNameLPAREN	
UUID	TokenNameIdentifier	 UUID
hostId	TokenNameIdentifier	 host Id
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
hostId	TokenNameIdentifier	 host Id
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
endpoint	TokenNameIdentifier	 endpoint
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
InetAddress	TokenNameIdentifier	 Inet Address
storedEp	TokenNameIdentifier	 stored Ep
=	TokenNameEQUAL	
endpointToHostIdMap	TokenNameIdentifier	 endpoint To Host Id Map
.	TokenNameDOT	
inverse	TokenNameIdentifier	 inverse
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
hostId	TokenNameIdentifier	 host Id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
storedEp	TokenNameIdentifier	 stored Ep
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
storedEp	TokenNameIdentifier	 stored Ep
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
FailureDetector	TokenNameIdentifier	 Failure Detector
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
isAlive	TokenNameIdentifier	 is Alive
(	TokenNameLPAREN	
storedEp	TokenNameIdentifier	 stored Ep
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Host ID collision between active endpoint %s and %s (id=%s)"	TokenNameStringLiteral	Host ID collision between active endpoint %s and %s (id=%s)
,	TokenNameCOMMA	
storedEp	TokenNameIdentifier	 stored Ep
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
hostId	TokenNameIdentifier	 host Id
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
UUID	TokenNameIdentifier	 UUID
storedId	TokenNameIdentifier	 stored Id
=	TokenNameEQUAL	
endpointToHostIdMap	TokenNameIdentifier	 endpoint To Host Id Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
storedId	TokenNameIdentifier	 stored Id
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
!	TokenNameNOT	
storedId	TokenNameIdentifier	 stored Id
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
hostId	TokenNameIdentifier	 host Id
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
"Changing {}'s host ID from {} to {}"	TokenNameStringLiteral	Changing {}'s host ID from {} to {}
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
storedId	TokenNameIdentifier	 stored Id
,	TokenNameCOMMA	
hostId	TokenNameIdentifier	 host Id
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
endpointToHostIdMap	TokenNameIdentifier	 endpoint To Host Id Map
.	TokenNameDOT	
forcePut	TokenNameIdentifier	 force Put
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
hostId	TokenNameIdentifier	 host Id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Return the unique host ID for an end-point. */	TokenNameCOMMENT_JAVADOC	 Return the unique host ID for an end-point. 
public	TokenNamepublic	
UUID	TokenNameIdentifier	 UUID
getHostId	TokenNameIdentifier	 get Host Id
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
endpointToHostIdMap	TokenNameIdentifier	 endpoint To Host Id Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Return the end-point for a unique host ID */	TokenNameCOMMENT_JAVADOC	 Return the end-point for a unique host ID 
public	TokenNamepublic	
InetAddress	TokenNameIdentifier	 Inet Address
getEndpointForHostId	TokenNameIdentifier	 get Endpoint For Host Id
(	TokenNameLPAREN	
UUID	TokenNameIdentifier	 UUID
hostId	TokenNameIdentifier	 host Id
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
endpointToHostIdMap	TokenNameIdentifier	 endpoint To Host Id Map
.	TokenNameDOT	
inverse	TokenNameIdentifier	 inverse
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
hostId	TokenNameIdentifier	 host Id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** @return a copy of the endpoint-to-id map for read-only operations */	TokenNameCOMMENT_JAVADOC	 @return a copy of the endpoint-to-id map for read-only operations 
public	TokenNamepublic	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
UUID	TokenNameIdentifier	 UUID
>	TokenNameGREATER	
getEndpointToHostIdMapForReading	TokenNameIdentifier	 get Endpoint To Host Id Map For Reading
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
UUID	TokenNameIdentifier	 UUID
>	TokenNameGREATER	
readMap	TokenNameIdentifier	 read Map
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
UUID	TokenNameIdentifier	 UUID
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
readMap	TokenNameIdentifier	 read Map
.	TokenNameDOT	
putAll	TokenNameIdentifier	 put All
(	TokenNameLPAREN	
endpointToHostIdMap	TokenNameIdentifier	 endpoint To Host Id Map
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
readMap	TokenNameIdentifier	 read Map
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
public	TokenNamepublic	
void	TokenNamevoid	
addBootstrapToken	TokenNameIdentifier	 add Bootstrap Token
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addBootstrapTokens	TokenNameIdentifier	 add Bootstrap Tokens
(	TokenNameLPAREN	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
singleton	TokenNameIdentifier	 singleton
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
addBootstrapTokens	TokenNameIdentifier	 add Bootstrap Tokens
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
tokens	TokenNameIdentifier	 tokens
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
endpoint	TokenNameIdentifier	 endpoint
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
InetAddress	TokenNameIdentifier	 Inet Address
oldEndpoint	TokenNameIdentifier	 old Endpoint
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
:	TokenNameCOLON	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
{	TokenNameLBRACE	
oldEndpoint	TokenNameIdentifier	 old Endpoint
=	TokenNameEQUAL	
bootstrapTokens	TokenNameIdentifier	 bootstrap Tokens
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
oldEndpoint	TokenNameIdentifier	 old Endpoint
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
oldEndpoint	TokenNameIdentifier	 old Endpoint
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"Bootstrap Token collision between "	TokenNameStringLiteral	Bootstrap Token collision between 
+	TokenNamePLUS	
oldEndpoint	TokenNameIdentifier	 old Endpoint
+	TokenNamePLUS	
" and "	TokenNameStringLiteral	 and 
+	TokenNamePLUS	
endpoint	TokenNameIdentifier	 endpoint
+	TokenNamePLUS	
" (token "	TokenNameStringLiteral	 (token 
+	TokenNamePLUS	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
oldEndpoint	TokenNameIdentifier	 old Endpoint
=	TokenNameEQUAL	
tokenToEndpointMap	TokenNameIdentifier	 token To Endpoint Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
oldEndpoint	TokenNameIdentifier	 old Endpoint
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
oldEndpoint	TokenNameIdentifier	 old Endpoint
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"Bootstrap Token collision between "	TokenNameStringLiteral	Bootstrap Token collision between 
+	TokenNamePLUS	
oldEndpoint	TokenNameIdentifier	 old Endpoint
+	TokenNamePLUS	
" and "	TokenNameStringLiteral	 and 
+	TokenNamePLUS	
endpoint	TokenNameIdentifier	 endpoint
+	TokenNamePLUS	
" (token "	TokenNameStringLiteral	 (token 
+	TokenNamePLUS	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
bootstrapTokens	TokenNameIdentifier	 bootstrap Tokens
.	TokenNameDOT	
removeValue	TokenNameIdentifier	 remove Value
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
:	TokenNameCOLON	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
bootstrapTokens	TokenNameIdentifier	 bootstrap Tokens
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
removeBootstrapTokens	TokenNameIdentifier	 remove Bootstrap Tokens
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
tokens	TokenNameIdentifier	 tokens
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
:	TokenNameCOLON	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
bootstrapTokens	TokenNameIdentifier	 bootstrap Tokens
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
addLeavingEndpoint	TokenNameIdentifier	 add Leaving Endpoint
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
endpoint	TokenNameIdentifier	 endpoint
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
leavingEndpoints	TokenNameIdentifier	 leaving Endpoints
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Add a new moving endpoint * @param token token which is node moving to * @param endpoint address of the moving node */	TokenNameCOMMENT_JAVADOC	 Add a new moving endpoint @param token token which is node moving to @param endpoint address of the moving node 
public	TokenNamepublic	
void	TokenNamevoid	
addMovingEndpoint	TokenNameIdentifier	 add Moving Endpoint
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
endpoint	TokenNameIdentifier	 endpoint
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
movingEndpoints	TokenNameIdentifier	 moving Endpoints
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
Pair	TokenNameIdentifier	 Pair
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Add new relocating ranges (tokens moving from their respective endpoints, to another). * @param tokens tokens being moved * @param endpoint destination of moves */	TokenNameCOMMENT_JAVADOC	 Add new relocating ranges (tokens moving from their respective endpoints, to another). @param tokens tokens being moved @param endpoint destination of moves 
public	TokenNamepublic	
void	TokenNamevoid	
addRelocatingTokens	TokenNameIdentifier	 add Relocating Tokens
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
endpoint	TokenNameIdentifier	 endpoint
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
tokens	TokenNameIdentifier	 tokens
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
:	TokenNameCOLON	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
{	TokenNameLBRACE	
InetAddress	TokenNameIdentifier	 Inet Address
prev	TokenNameIdentifier	 prev
=	TokenNameEQUAL	
relocatingTokens	TokenNameIdentifier	 relocating Tokens
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
prev	TokenNameIdentifier	 prev
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
prev	TokenNameIdentifier	 prev
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
"Relocation of {} to {} overwrites previous to {}"	TokenNameStringLiteral	Relocation of {} to {} overwrites previous to {}
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
prev	TokenNameIdentifier	 prev
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
removeEndpoint	TokenNameIdentifier	 remove Endpoint
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
endpoint	TokenNameIdentifier	 endpoint
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
bootstrapTokens	TokenNameIdentifier	 bootstrap Tokens
.	TokenNameDOT	
removeValue	TokenNameIdentifier	 remove Value
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tokenToEndpointMap	TokenNameIdentifier	 token To Endpoint Map
.	TokenNameDOT	
removeValue	TokenNameIdentifier	 remove Value
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
topology	TokenNameIdentifier	 topology
.	TokenNameDOT	
removeEndpoint	TokenNameIdentifier	 remove Endpoint
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
leavingEndpoints	TokenNameIdentifier	 leaving Endpoints
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
endpointToHostIdMap	TokenNameIdentifier	 endpoint To Host Id Map
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sortedTokens	TokenNameIdentifier	 sorted Tokens
=	TokenNameEQUAL	
sortTokens	TokenNameIdentifier	 sort Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
invalidateCaches	TokenNameIdentifier	 invalidate Caches
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Remove pair of token/address from moving endpoints * @param endpoint address of the moving node */	TokenNameCOMMENT_JAVADOC	 Remove pair of token/address from moving endpoints @param endpoint address of the moving node 
public	TokenNamepublic	
void	TokenNamevoid	
removeFromMoving	TokenNameIdentifier	 remove From Moving
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
endpoint	TokenNameIdentifier	 endpoint
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
pair	TokenNameIdentifier	 pair
:	TokenNameCOLON	
movingEndpoints	TokenNameIdentifier	 moving Endpoints
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
right	TokenNameIdentifier	 right
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
movingEndpoints	TokenNameIdentifier	 moving Endpoints
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
pair	TokenNameIdentifier	 pair
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
invalidateCaches	TokenNameIdentifier	 invalidate Caches
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Remove pair of token/address from relocating ranges. * @param endpoint */	TokenNameCOMMENT_JAVADOC	 Remove pair of token/address from relocating ranges. @param endpoint 
public	TokenNamepublic	
void	TokenNamevoid	
removeFromRelocating	TokenNameIdentifier	 remove From Relocating
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
endpoint	TokenNameIdentifier	 endpoint
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
token	TokenNameIdentifier	 token
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
InetAddress	TokenNameIdentifier	 Inet Address
previous	TokenNameIdentifier	 previous
=	TokenNameEQUAL	
relocatingTokens	TokenNameIdentifier	 relocating Tokens
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
previous	TokenNameIdentifier	 previous
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Cannot remove {}, not found among the relocating (previously removed?)"	TokenNameStringLiteral	Cannot remove {}, not found among the relocating (previously removed?)
,	TokenNameCOMMA	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
previous	TokenNameIdentifier	 previous
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
"Removal of relocating token {} with mismatched endpoint ({} != {})"	TokenNameStringLiteral	Removal of relocating token {} with mismatched endpoint ({} != {})
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
previous	TokenNameIdentifier	 previous
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
getTokens	TokenNameIdentifier	 get Tokens
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
endpoint	TokenNameIdentifier	 endpoint
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
isMember	TokenNameIdentifier	 is Member
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// don't want to return nulls 	TokenNameCOMMENT_LINE	don't want to return nulls 
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
(	TokenNameLPAREN	
tokenToEndpointMap	TokenNameIdentifier	 token To Endpoint Map
.	TokenNameDOT	
inverse	TokenNameIdentifier	 inverse
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
public	TokenNamepublic	
Token	TokenNameIdentifier	 Token
getToken	TokenNameIdentifier	 get Token
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getTokens	TokenNameIdentifier	 get Tokens
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isMember	TokenNameIdentifier	 is Member
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
endpoint	TokenNameIdentifier	 endpoint
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
return	TokenNamereturn	
tokenToEndpointMap	TokenNameIdentifier	 token To Endpoint Map
.	TokenNameDOT	
inverse	TokenNameIdentifier	 inverse
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
containsKey	TokenNameIdentifier	 contains Key
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isLeaving	TokenNameIdentifier	 is Leaving
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
endpoint	TokenNameIdentifier	 endpoint
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
return	TokenNamereturn	
leavingEndpoints	TokenNameIdentifier	 leaving Endpoints
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isMoving	TokenNameIdentifier	 is Moving
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
endpoint	TokenNameIdentifier	 endpoint
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
pair	TokenNameIdentifier	 pair
:	TokenNameCOLON	
movingEndpoints	TokenNameIdentifier	 moving Endpoints
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
right	TokenNameIdentifier	 right
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isRelocating	TokenNameIdentifier	 is Relocating
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
token	TokenNameIdentifier	 token
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
return	TokenNamereturn	
relocatingTokens	TokenNameIdentifier	 relocating Tokens
.	TokenNameDOT	
containsKey	TokenNameIdentifier	 contains Key
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Create a copy of TokenMetadata with only tokenToEndpointMap. That is, pending ranges, * bootstrap tokens and leaving endpoints are not included in the copy. */	TokenNameCOMMENT_JAVADOC	 Create a copy of TokenMetadata with only tokenToEndpointMap. That is, pending ranges, bootstrap tokens and leaving endpoints are not included in the copy. 
public	TokenNamepublic	
TokenMetadata	TokenNameIdentifier	 Token Metadata
cloneOnlyTokenMap	TokenNameIdentifier	 clone Only Token Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
TokenMetadata	TokenNameIdentifier	 Token Metadata
(	TokenNameLPAREN	
SortedBiMultiValMap	TokenNameIdentifier	 Sorted Bi Multi Val Map
.	TokenNameDOT	
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
tokenToEndpointMap	TokenNameIdentifier	 token To Endpoint Map
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
inetaddressCmp	TokenNameIdentifier	 inetaddress Cmp
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
Topology	TokenNameIdentifier	 Topology
(	TokenNameLPAREN	
topology	TokenNameIdentifier	 topology
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Create a copy of TokenMetadata with tokenToEndpointMap reflecting situation after all * current leave operations have finished. * * @return new token metadata */	TokenNameCOMMENT_JAVADOC	 Create a copy of TokenMetadata with tokenToEndpointMap reflecting situation after all current leave operations have finished. * @return new token metadata 
public	TokenNamepublic	
TokenMetadata	TokenNameIdentifier	 Token Metadata
cloneAfterAllLeft	TokenNameIdentifier	 clone After All Left
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
TokenMetadata	TokenNameIdentifier	 Token Metadata
allLeftMetadata	TokenNameIdentifier	 all Left Metadata
=	TokenNameEQUAL	
cloneOnlyTokenMap	TokenNameIdentifier	 clone Only Token Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
:	TokenNameCOLON	
leavingEndpoints	TokenNameIdentifier	 leaving Endpoints
)	TokenNameRPAREN	
allLeftMetadata	TokenNameIdentifier	 all Left Metadata
.	TokenNameDOT	
removeEndpoint	TokenNameIdentifier	 remove Endpoint
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
allLeftMetadata	TokenNameIdentifier	 all Left Metadata
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Create a copy of TokenMetadata with tokenToEndpointMap reflecting situation after all * current leave, move, and relocate operations have finished. * * @return new token metadata */	TokenNameCOMMENT_JAVADOC	 Create a copy of TokenMetadata with tokenToEndpointMap reflecting situation after all current leave, move, and relocate operations have finished. * @return new token metadata 
public	TokenNamepublic	
TokenMetadata	TokenNameIdentifier	 Token Metadata
cloneAfterAllSettled	TokenNameIdentifier	 clone After All Settled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
TokenMetadata	TokenNameIdentifier	 Token Metadata
metadata	TokenNameIdentifier	 metadata
=	TokenNameEQUAL	
cloneOnlyTokenMap	TokenNameIdentifier	 clone Only Token Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
:	TokenNameCOLON	
leavingEndpoints	TokenNameIdentifier	 leaving Endpoints
)	TokenNameRPAREN	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
removeEndpoint	TokenNameIdentifier	 remove Endpoint
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
pair	TokenNameIdentifier	 pair
:	TokenNameCOLON	
movingEndpoints	TokenNameIdentifier	 moving Endpoints
)	TokenNameRPAREN	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
updateNormalToken	TokenNameIdentifier	 update Normal Token
(	TokenNameLPAREN	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
left	TokenNameIdentifier	 left
,	TokenNameCOMMA	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
right	TokenNameIdentifier	 right
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
relocating	TokenNameIdentifier	 relocating
:	TokenNameCOLON	
relocatingTokens	TokenNameIdentifier	 relocating Tokens
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
updateNormalToken	TokenNameIdentifier	 update Normal Token
(	TokenNameLPAREN	
relocating	TokenNameIdentifier	 relocating
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
relocating	TokenNameIdentifier	 relocating
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
metadata	TokenNameIdentifier	 metadata
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
InetAddress	TokenNameIdentifier	 Inet Address
getEndpoint	TokenNameIdentifier	 get Endpoint
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
return	TokenNamereturn	
tokenToEndpointMap	TokenNameIdentifier	 token To Endpoint Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
getPrimaryRangesFor	TokenNameIdentifier	 get Primary Ranges For
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
ranges	TokenNameIdentifier	 ranges
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
right	TokenNameIdentifier	 right
:	TokenNameCOLON	
tokens	TokenNameIdentifier	 tokens
)	TokenNameRPAREN	
ranges	TokenNameIdentifier	 ranges
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
(	TokenNameLPAREN	
getPredecessor	TokenNameIdentifier	 get Predecessor
(	TokenNameLPAREN	
right	TokenNameIdentifier	 right
)	TokenNameRPAREN	
,	TokenNameCOMMA	
right	TokenNameIdentifier	 right
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
ranges	TokenNameIdentifier	 ranges
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
public	TokenNamepublic	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
getPrimaryRangeFor	TokenNameIdentifier	 get Primary Range For
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
right	TokenNameIdentifier	 right
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getPrimaryRangesFor	TokenNameIdentifier	 get Primary Ranges For
(	TokenNameLPAREN	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
asList	TokenNameIdentifier	 as List
(	TokenNameLPAREN	
right	TokenNameIdentifier	 right
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
sortedTokens	TokenNameIdentifier	 sorted Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
sortedTokens	TokenNameIdentifier	 sorted Tokens
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
getPendingRangesMM	TokenNameIdentifier	 get Pending Ranges MM
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
map	TokenNameIdentifier	 map
=	TokenNameEQUAL	
pendingRanges	TokenNameIdentifier	 pending Ranges
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
map	TokenNameIdentifier	 map
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
map	TokenNameIdentifier	 map
=	TokenNameEQUAL	
HashMultimap	TokenNameIdentifier	 Hash Multimap
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
priorMap	TokenNameIdentifier	 prior Map
=	TokenNameEQUAL	
pendingRanges	TokenNameIdentifier	 pending Ranges
.	TokenNameDOT	
putIfAbsent	TokenNameIdentifier	 put If Absent
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
map	TokenNameIdentifier	 map
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
priorMap	TokenNameIdentifier	 prior Map
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
map	TokenNameIdentifier	 map
=	TokenNameEQUAL	
priorMap	TokenNameIdentifier	 prior Map
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
map	TokenNameIdentifier	 map
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** a mutable map may be returned but caller should not modify it */	TokenNameCOMMENT_JAVADOC	 a mutable map may be returned but caller should not modify it 
public	TokenNamepublic	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
getPendingRanges	TokenNameIdentifier	 get Pending Ranges
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getPendingRangesMM	TokenNameIdentifier	 get Pending Ranges MM
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
.	TokenNameDOT	
asMap	TokenNameIdentifier	 as Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
getPendingRanges	TokenNameIdentifier	 get Pending Ranges
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
ranges	TokenNameIdentifier	 ranges
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
getPendingRangesMM	TokenNameIdentifier	 get Pending Ranges MM
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
.	TokenNameDOT	
entries	TokenNameIdentifier	 entries
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ranges	TokenNameIdentifier	 ranges
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
ranges	TokenNameIdentifier	 ranges
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setPendingRanges	TokenNameIdentifier	 set Pending Ranges
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
rangeMap	TokenNameIdentifier	 range Map
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pendingRanges	TokenNameIdentifier	 pending Ranges
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
rangeMap	TokenNameIdentifier	 range Map
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Token	TokenNameIdentifier	 Token
getPredecessor	TokenNameIdentifier	 get Predecessor
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
tokens	TokenNameIdentifier	 tokens
=	TokenNameEQUAL	
sortedTokens	TokenNameIdentifier	 sorted Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
binarySearch	TokenNameIdentifier	 binary Search
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
index	TokenNameIdentifier	 index
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
token	TokenNameIdentifier	 token
+	TokenNamePLUS	
" not found in "	TokenNameStringLiteral	 not found in 
+	TokenNamePLUS	
StringUtils	TokenNameIdentifier	 String Utils
.	TokenNameDOT	
join	TokenNameIdentifier	 join
(	TokenNameLPAREN	
tokenToEndpointMap	TokenNameIdentifier	 token To Endpoint Map
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
", "	TokenNameStringLiteral	, 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
)	TokenNameRPAREN	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
:	TokenNameCOLON	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Token	TokenNameIdentifier	 Token
getSuccessor	TokenNameIdentifier	 get Successor
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
tokens	TokenNameIdentifier	 tokens
=	TokenNameEQUAL	
sortedTokens	TokenNameIdentifier	 sorted Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
binarySearch	TokenNameIdentifier	 binary Search
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
index	TokenNameIdentifier	 index
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
token	TokenNameIdentifier	 token
+	TokenNamePLUS	
" not found in "	TokenNameStringLiteral	 not found in 
+	TokenNamePLUS	
StringUtils	TokenNameIdentifier	 String Utils
.	TokenNameDOT	
join	TokenNameIdentifier	 join
(	TokenNameLPAREN	
tokenToEndpointMap	TokenNameIdentifier	 token To Endpoint Map
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
", "	TokenNameStringLiteral	, 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
==	TokenNameEQUAL_EQUAL	
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
:	TokenNameCOLON	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** @return a copy of the bootstrapping tokens map */	TokenNameCOMMENT_JAVADOC	 @return a copy of the bootstrapping tokens map 
public	TokenNamepublic	
BiMultiValMap	TokenNameIdentifier	 Bi Multi Val Map
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
getBootstrapTokens	TokenNameIdentifier	 get Bootstrap Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
BiMultiValMap	TokenNameIdentifier	 Bi Multi Val Map
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
(	TokenNameLPAREN	
bootstrapTokens	TokenNameIdentifier	 bootstrap Tokens
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** caller should not modify leavingEndpoints */	TokenNameCOMMENT_JAVADOC	 caller should not modify leavingEndpoints 
public	TokenNamepublic	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
getLeavingEndpoints	TokenNameIdentifier	 get Leaving Endpoints
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
leavingEndpoints	TokenNameIdentifier	 leaving Endpoints
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Endpoints which are migrating to the new tokens * @return set of addresses of moving endpoints */	TokenNameCOMMENT_JAVADOC	 Endpoints which are migrating to the new tokens @return set of addresses of moving endpoints 
public	TokenNamepublic	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
getMovingEndpoints	TokenNameIdentifier	 get Moving Endpoints
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
movingEndpoints	TokenNameIdentifier	 moving Endpoints
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Ranges which are migrating to new endpoints. * @return set of token-address pairs of relocating ranges */	TokenNameCOMMENT_JAVADOC	 Ranges which are migrating to new endpoints. @return set of token-address pairs of relocating ranges 
public	TokenNamepublic	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
getRelocatingRanges	TokenNameIdentifier	 get Relocating Ranges
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
relocatingTokens	TokenNameIdentifier	 relocating Tokens
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
int	TokenNameint	
firstTokenIndex	TokenNameIdentifier	 first Token Index
(	TokenNameLPAREN	
final	TokenNamefinal	
ArrayList	TokenNameIdentifier	 Array List
ring	TokenNameIdentifier	 ring
,	TokenNameCOMMA	
Token	TokenNameIdentifier	 Token
start	TokenNameIdentifier	 start
,	TokenNameCOMMA	
boolean	TokenNameboolean	
insertMin	TokenNameIdentifier	 insert Min
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
ring	TokenNameIdentifier	 ring
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// insert the minimum token (at index == -1) if we were asked to include it and it isn't a member of the ring 	TokenNameCOMMENT_LINE	insert the minimum token (at index == -1) if we were asked to include it and it isn't a member of the ring 
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
binarySearch	TokenNameIdentifier	 binary Search
(	TokenNameLPAREN	
ring	TokenNameIdentifier	 ring
,	TokenNameCOMMA	
start	TokenNameIdentifier	 start
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
ring	TokenNameIdentifier	 ring
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
insertMin	TokenNameIdentifier	 insert Min
?	TokenNameQUESTION	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
Token	TokenNameIdentifier	 Token
firstToken	TokenNameIdentifier	 first Token
(	TokenNameLPAREN	
final	TokenNamefinal	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
ring	TokenNameIdentifier	 ring
,	TokenNameCOMMA	
Token	TokenNameIdentifier	 Token
start	TokenNameIdentifier	 start
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
ring	TokenNameIdentifier	 ring
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
firstTokenIndex	TokenNameIdentifier	 first Token Index
(	TokenNameLPAREN	
ring	TokenNameIdentifier	 ring
,	TokenNameCOMMA	
start	TokenNameIdentifier	 start
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * iterator over the Tokens in the given ring, starting with the token for the node owning start * (which does not have to be a Token in the ring) * @param includeMin True if the minimum token should be returned in the ring even if it has no owner. */	TokenNameCOMMENT_JAVADOC	 iterator over the Tokens in the given ring, starting with the token for the node owning start (which does not have to be a Token in the ring) @param includeMin True if the minimum token should be returned in the ring even if it has no owner. 
public	TokenNamepublic	
static	TokenNamestatic	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
ringIterator	TokenNameIdentifier	 ring Iterator
(	TokenNameLPAREN	
final	TokenNamefinal	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
ring	TokenNameIdentifier	 ring
,	TokenNameCOMMA	
Token	TokenNameIdentifier	 Token
start	TokenNameIdentifier	 start
,	TokenNameCOMMA	
boolean	TokenNameboolean	
includeMin	TokenNameIdentifier	 include Min
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ring	TokenNameIdentifier	 ring
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
includeMin	TokenNameIdentifier	 include Min
?	TokenNameQUESTION	
Iterators	TokenNameIdentifier	 Iterators
.	TokenNameDOT	
singletonIterator	TokenNameIdentifier	 singleton Iterator
(	TokenNameLPAREN	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getMinimumToken	TokenNameIdentifier	 get Minimum Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
Iterators	TokenNameIdentifier	 Iterators
.	TokenNameDOT	
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
emptyIterator	TokenNameIdentifier	 empty Iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
boolean	TokenNameboolean	
insertMin	TokenNameIdentifier	 insert Min
=	TokenNameEQUAL	
includeMin	TokenNameIdentifier	 include Min
&&	TokenNameAND_AND	
!	TokenNameNOT	
ring	TokenNameIdentifier	 ring
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
isMinimum	TokenNameIdentifier	 is Minimum
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
startIndex	TokenNameIdentifier	 start Index
=	TokenNameEQUAL	
firstTokenIndex	TokenNameIdentifier	 first Token Index
(	TokenNameLPAREN	
ring	TokenNameIdentifier	 ring
,	TokenNameCOMMA	
start	TokenNameIdentifier	 start
,	TokenNameCOMMA	
insertMin	TokenNameIdentifier	 insert Min
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
AbstractIterator	TokenNameIdentifier	 Abstract Iterator
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
startIndex	TokenNameIdentifier	 start Index
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
Token	TokenNameIdentifier	 Token
computeNext	TokenNameIdentifier	 compute Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
endOfData	TokenNameIdentifier	 end Of Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
// return minimum for index == -1 	TokenNameCOMMENT_LINE	return minimum for index == -1 
if	TokenNameif	
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getMinimumToken	TokenNameIdentifier	 get Minimum Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// return ring token for other indexes 	TokenNameCOMMENT_LINE	return ring token for other indexes 
return	TokenNamereturn	
ring	TokenNameIdentifier	 ring
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
==	TokenNameEQUAL_EQUAL	
ring	TokenNameIdentifier	 ring
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
insertMin	TokenNameIdentifier	 insert Min
?	TokenNameQUESTION	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
==	TokenNameEQUAL_EQUAL	
startIndex	TokenNameIdentifier	 start Index
)	TokenNameRPAREN	
// end iteration 	TokenNameCOMMENT_LINE	end iteration 
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
-	TokenNameMINUS	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** used by tests */	TokenNameCOMMENT_JAVADOC	 used by tests 
public	TokenNamepublic	
void	TokenNamevoid	
clearUnsafe	TokenNameIdentifier	 clear Unsafe
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bootstrapTokens	TokenNameIdentifier	 bootstrap Tokens
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tokenToEndpointMap	TokenNameIdentifier	 token To Endpoint Map
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
topology	TokenNameIdentifier	 topology
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
leavingEndpoints	TokenNameIdentifier	 leaving Endpoints
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pendingRanges	TokenNameIdentifier	 pending Ranges
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
endpointToHostIdMap	TokenNameIdentifier	 endpoint To Host Id Map
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
invalidateCaches	TokenNameIdentifier	 invalidate Caches
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StringBuilder	TokenNameIdentifier	 String Builder
sb	TokenNameIdentifier	 sb
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuilder	TokenNameIdentifier	 String Builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
eps	TokenNameIdentifier	 eps
=	TokenNameEQUAL	
tokenToEndpointMap	TokenNameIdentifier	 token To Endpoint Map
.	TokenNameDOT	
inverse	TokenNameIdentifier	 inverse
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
eps	TokenNameIdentifier	 eps
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"Normal Tokens:"	TokenNameStringLiteral	Normal Tokens:
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"line.separator"	TokenNameStringLiteral	line.separator
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
ep	TokenNameIdentifier	 ep
:	TokenNameCOLON	
eps	TokenNameIdentifier	 eps
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
":"	TokenNameStringLiteral	:
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
tokenToEndpointMap	TokenNameIdentifier	 token To Endpoint Map
.	TokenNameDOT	
inverse	TokenNameIdentifier	 inverse
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"line.separator"	TokenNameStringLiteral	line.separator
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
bootstrapTokens	TokenNameIdentifier	 bootstrap Tokens
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"Bootstrapping Tokens:"	TokenNameStringLiteral	Bootstrapping Tokens:
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"line.separator"	TokenNameStringLiteral	line.separator
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
bootstrapTokens	TokenNameIdentifier	 bootstrap Tokens
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
":"	TokenNameStringLiteral	:
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"line.separator"	TokenNameStringLiteral	line.separator
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
leavingEndpoints	TokenNameIdentifier	 leaving Endpoints
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"Leaving Endpoints:"	TokenNameStringLiteral	Leaving Endpoints:
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"line.separator"	TokenNameStringLiteral	line.separator
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
ep	TokenNameIdentifier	 ep
:	TokenNameCOLON	
leavingEndpoints	TokenNameIdentifier	 leaving Endpoints
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"line.separator"	TokenNameStringLiteral	line.separator
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
pendingRanges	TokenNameIdentifier	 pending Ranges
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"Pending Ranges:"	TokenNameStringLiteral	Pending Ranges:
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"line.separator"	TokenNameStringLiteral	line.separator
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
printPendingRanges	TokenNameIdentifier	 print Pending Ranges
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
printPendingRanges	TokenNameIdentifier	 print Pending Ranges
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StringBuilder	TokenNameIdentifier	 String Builder
sb	TokenNameIdentifier	 sb
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuilder	TokenNameIdentifier	 String Builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
pendingRanges	TokenNameIdentifier	 pending Ranges
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
rmap	TokenNameIdentifier	 rmap
:	TokenNameCOLON	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
entries	TokenNameIdentifier	 entries
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
rmap	TokenNameIdentifier	 rmap
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
":"	TokenNameStringLiteral	:
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
rmap	TokenNameIdentifier	 rmap
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"line.separator"	TokenNameStringLiteral	line.separator
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
printRelocatingRanges	TokenNameIdentifier	 print Relocating Ranges
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StringBuilder	TokenNameIdentifier	 String Builder
sb	TokenNameIdentifier	 sb
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuilder	TokenNameIdentifier	 String Builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
relocatingTokens	TokenNameIdentifier	 relocating Tokens
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"%s:%s%n"	TokenNameStringLiteral	%s:%s%n
,	TokenNameCOMMA	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
invalidateCaches	TokenNameIdentifier	 invalidate Caches
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
AbstractReplicationStrategy	TokenNameIdentifier	 Abstract Replication Strategy
subscriber	TokenNameIdentifier	 subscriber
:	TokenNameCOLON	
subscribers	TokenNameIdentifier	 subscribers
)	TokenNameRPAREN	
{	TokenNameLBRACE	
subscriber	TokenNameIdentifier	 subscriber
.	TokenNameDOT	
invalidateCachedTokenEndpointValues	TokenNameIdentifier	 invalidate Cached Token Endpoint Values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
register	TokenNameIdentifier	 register
(	TokenNameLPAREN	
AbstractReplicationStrategy	TokenNameIdentifier	 Abstract Replication Strategy
subscriber	TokenNameIdentifier	 subscriber
)	TokenNameRPAREN	
{	TokenNameLBRACE	
subscribers	TokenNameIdentifier	 subscribers
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
subscriber	TokenNameIdentifier	 subscriber
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
unregister	TokenNameIdentifier	 unregister
(	TokenNameLPAREN	
AbstractReplicationStrategy	TokenNameIdentifier	 Abstract Replication Strategy
subscriber	TokenNameIdentifier	 subscriber
)	TokenNameRPAREN	
{	TokenNameLBRACE	
subscribers	TokenNameIdentifier	 subscribers
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
subscriber	TokenNameIdentifier	 subscriber
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
pendingEndpointsFor	TokenNameIdentifier	 pending Endpoints For
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
ranges	TokenNameIdentifier	 ranges
=	TokenNameEQUAL	
getPendingRanges	TokenNameIdentifier	 get Pending Ranges
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ranges	TokenNameIdentifier	 ranges
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
emptyList	TokenNameIdentifier	 empty List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
endpoints	TokenNameIdentifier	 endpoints
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
,	TokenNameCOMMA	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
ranges	TokenNameIdentifier	 ranges
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
)	TokenNameRPAREN	
endpoints	TokenNameIdentifier	 endpoints
.	TokenNameDOT	
addAll	TokenNameIdentifier	 add All
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
endpoints	TokenNameIdentifier	 endpoints
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @deprecated retained for benefit of old tests */	TokenNameCOMMENT_JAVADOC	 @deprecated retained for benefit of old tests 
public	TokenNamepublic	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
getWriteEndpoints	TokenNameIdentifier	 get Write Endpoints
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
naturalEndpoints	TokenNameIdentifier	 natural Endpoints
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
endpoints	TokenNameIdentifier	 endpoints
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Iterables	TokenNameIdentifier	 Iterables
.	TokenNameDOT	
addAll	TokenNameIdentifier	 add All
(	TokenNameLPAREN	
endpoints	TokenNameIdentifier	 endpoints
,	TokenNameCOMMA	
Iterables	TokenNameIdentifier	 Iterables
.	TokenNameDOT	
concat	TokenNameIdentifier	 concat
(	TokenNameLPAREN	
naturalEndpoints	TokenNameIdentifier	 natural Endpoints
,	TokenNameCOMMA	
pendingEndpointsFor	TokenNameIdentifier	 pending Endpoints For
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
endpoints	TokenNameIdentifier	 endpoints
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** @return an endpoint to token multimap representation of tokenToEndpointMap (a copy) */	TokenNameCOMMENT_JAVADOC	 @return an endpoint to token multimap representation of tokenToEndpointMap (a copy) 
public	TokenNamepublic	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
getEndpointToTokenMapForReading	TokenNameIdentifier	 get Endpoint To Token Map For Reading
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
cloned	TokenNameIdentifier	 cloned
=	TokenNameEQUAL	
HashMultimap	TokenNameIdentifier	 Hash Multimap
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
tokenToEndpointMap	TokenNameIdentifier	 token To Endpoint Map
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
cloned	TokenNameIdentifier	 cloned
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
cloned	TokenNameIdentifier	 cloned
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * @return a (stable copy, won't be modified) Token to Endpoint map for all the normal and bootstrapping nodes * in the cluster. */	TokenNameCOMMENT_JAVADOC	 @return a (stable copy, won't be modified) Token to Endpoint map for all the normal and bootstrapping nodes in the cluster. 
public	TokenNamepublic	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
getNormalAndBootstrappingTokenToEndpointMap	TokenNameIdentifier	 get Normal And Bootstrapping Token To Endpoint Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
map	TokenNameIdentifier	 map
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
(	TokenNameLPAREN	
tokenToEndpointMap	TokenNameIdentifier	 token To Endpoint Map
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
bootstrapTokens	TokenNameIdentifier	 bootstrap Tokens
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
map	TokenNameIdentifier	 map
.	TokenNameDOT	
putAll	TokenNameIdentifier	 put All
(	TokenNameLPAREN	
tokenToEndpointMap	TokenNameIdentifier	 token To Endpoint Map
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
map	TokenNameIdentifier	 map
.	TokenNameDOT	
putAll	TokenNameIdentifier	 put All
(	TokenNameLPAREN	
bootstrapTokens	TokenNameIdentifier	 bootstrap Tokens
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
map	TokenNameIdentifier	 map
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * @return the Topology map of nodes to DCs + Racks * * This is only allowed when a copy has been made of TokenMetadata, to avoid concurrent modifications * when Topology methods are subsequently used by the caller. */	TokenNameCOMMENT_JAVADOC	 @return the Topology map of nodes to DCs + Racks * This is only allowed when a copy has been made of TokenMetadata, to avoid concurrent modifications when Topology methods are subsequently used by the caller. 
public	TokenNamepublic	
Topology	TokenNameIdentifier	 Topology
getTopology	TokenNameIdentifier	 get Topology
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
this	TokenNamethis	
!=	TokenNameNOT_EQUAL	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getTokenMetadata	TokenNameIdentifier	 get Token Metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
topology	TokenNameIdentifier	 topology
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Tracks the assignment of racks and endpoints in each datacenter for all the "normal" endpoints * in this TokenMetadata. This allows faster calculation of endpoints in NetworkTopologyStrategy. */	TokenNameCOMMENT_JAVADOC	 Tracks the assignment of racks and endpoints in each datacenter for all the "normal" endpoints in this TokenMetadata. This allows faster calculation of endpoints in NetworkTopologyStrategy. 
public	TokenNamepublic	
static	TokenNamestatic	
class	TokenNameclass	
Topology	TokenNameIdentifier	 Topology
{	TokenNameLBRACE	
/** multi-map of DC to endpoints in that DC */	TokenNameCOMMENT_JAVADOC	 multi-map of DC to endpoints in that DC 
private	TokenNameprivate	
final	TokenNamefinal	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
dcEndpoints	TokenNameIdentifier	 dc Endpoints
;	TokenNameSEMICOLON	
/** map of DC to multi-map of rack to endpoints in that rack */	TokenNameCOMMENT_JAVADOC	 map of DC to multi-map of rack to endpoints in that rack 
private	TokenNameprivate	
final	TokenNamefinal	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
dcRacks	TokenNameIdentifier	 dc Racks
;	TokenNameSEMICOLON	
/** reverse-lookup map for endpoint to current known dc/rack assignment */	TokenNameCOMMENT_JAVADOC	 reverse-lookup map for endpoint to current known dc/rack assignment 
private	TokenNameprivate	
final	TokenNamefinal	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>>	TokenNameRIGHT_SHIFT	
currentLocations	TokenNameIdentifier	 current Locations
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
Topology	TokenNameIdentifier	 Topology
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dcEndpoints	TokenNameIdentifier	 dc Endpoints
=	TokenNameEQUAL	
HashMultimap	TokenNameIdentifier	 Hash Multimap
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dcRacks	TokenNameIdentifier	 dc Racks
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
currentLocations	TokenNameIdentifier	 current Locations
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dcEndpoints	TokenNameIdentifier	 dc Endpoints
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dcRacks	TokenNameIdentifier	 dc Racks
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
currentLocations	TokenNameIdentifier	 current Locations
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * construct deep-copy of other */	TokenNameCOMMENT_JAVADOC	 construct deep-copy of other 
protected	TokenNameprotected	
Topology	TokenNameIdentifier	 Topology
(	TokenNameLPAREN	
Topology	TokenNameIdentifier	 Topology
other	TokenNameIdentifier	 other
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dcEndpoints	TokenNameIdentifier	 dc Endpoints
=	TokenNameEQUAL	
HashMultimap	TokenNameIdentifier	 Hash Multimap
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
dcEndpoints	TokenNameIdentifier	 dc Endpoints
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dcRacks	TokenNameIdentifier	 dc Racks
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
dc	TokenNameIdentifier	 dc
:	TokenNameCOLON	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
dcRacks	TokenNameIdentifier	 dc Racks
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
dcRacks	TokenNameIdentifier	 dc Racks
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
dc	TokenNameIdentifier	 dc
,	TokenNameCOMMA	
HashMultimap	TokenNameIdentifier	 Hash Multimap
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
dcRacks	TokenNameIdentifier	 dc Racks
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
dc	TokenNameIdentifier	 dc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
currentLocations	TokenNameIdentifier	 current Locations
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
currentLocations	TokenNameIdentifier	 current Locations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Stores current DC/rack assignment for ep */	TokenNameCOMMENT_JAVADOC	 Stores current DC/rack assignment for ep 
protected	TokenNameprotected	
void	TokenNamevoid	
addEndpoint	TokenNameIdentifier	 add Endpoint
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
{	TokenNameLBRACE	
IEndpointSnitch	TokenNameIdentifier	 I Endpoint Snitch
snitch	TokenNameIdentifier	 snitch
=	TokenNameEQUAL	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getEndpointSnitch	TokenNameIdentifier	 get Endpoint Snitch
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
dc	TokenNameIdentifier	 dc
=	TokenNameEQUAL	
snitch	TokenNameIdentifier	 snitch
.	TokenNameDOT	
getDatacenter	TokenNameIdentifier	 get Datacenter
(	TokenNameLPAREN	
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
rack	TokenNameIdentifier	 rack
=	TokenNameEQUAL	
snitch	TokenNameIdentifier	 snitch
.	TokenNameDOT	
getRack	TokenNameIdentifier	 get Rack
(	TokenNameLPAREN	
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
current	TokenNameIdentifier	 current
=	TokenNameEQUAL	
currentLocations	TokenNameIdentifier	 current Locations
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
current	TokenNameIdentifier	 current
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
current	TokenNameIdentifier	 current
.	TokenNameDOT	
left	TokenNameIdentifier	 left
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
dc	TokenNameIdentifier	 dc
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
current	TokenNameIdentifier	 current
.	TokenNameDOT	
right	TokenNameIdentifier	 right
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
rack	TokenNameIdentifier	 rack
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
dcRacks	TokenNameIdentifier	 dc Racks
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
current	TokenNameIdentifier	 current
.	TokenNameDOT	
left	TokenNameIdentifier	 left
)	TokenNameRPAREN	
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
current	TokenNameIdentifier	 current
.	TokenNameDOT	
right	TokenNameIdentifier	 right
,	TokenNameCOMMA	
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dcEndpoints	TokenNameIdentifier	 dc Endpoints
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
current	TokenNameIdentifier	 current
.	TokenNameDOT	
left	TokenNameIdentifier	 left
,	TokenNameCOMMA	
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
dcEndpoints	TokenNameIdentifier	 dc Endpoints
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
dc	TokenNameIdentifier	 dc
,	TokenNameCOMMA	
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
dcRacks	TokenNameIdentifier	 dc Racks
.	TokenNameDOT	
containsKey	TokenNameIdentifier	 contains Key
(	TokenNameLPAREN	
dc	TokenNameIdentifier	 dc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
dcRacks	TokenNameIdentifier	 dc Racks
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
dc	TokenNameIdentifier	 dc
,	TokenNameCOMMA	
HashMultimap	TokenNameIdentifier	 Hash Multimap
.	TokenNameDOT	
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dcRacks	TokenNameIdentifier	 dc Racks
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
dc	TokenNameIdentifier	 dc
)	TokenNameRPAREN	
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
rack	TokenNameIdentifier	 rack
,	TokenNameCOMMA	
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
currentLocations	TokenNameIdentifier	 current Locations
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
ep	TokenNameIdentifier	 ep
,	TokenNameCOMMA	
Pair	TokenNameIdentifier	 Pair
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
dc	TokenNameIdentifier	 dc
,	TokenNameCOMMA	
rack	TokenNameIdentifier	 rack
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Removes current DC/rack assignment for ep */	TokenNameCOMMENT_JAVADOC	 Removes current DC/rack assignment for ep 
protected	TokenNameprotected	
void	TokenNamevoid	
removeEndpoint	TokenNameIdentifier	 remove Endpoint
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
currentLocations	TokenNameIdentifier	 current Locations
.	TokenNameDOT	
containsKey	TokenNameIdentifier	 contains Key
(	TokenNameLPAREN	
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
current	TokenNameIdentifier	 current
=	TokenNameEQUAL	
currentLocations	TokenNameIdentifier	 current Locations
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dcEndpoints	TokenNameIdentifier	 dc Endpoints
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
current	TokenNameIdentifier	 current
.	TokenNameDOT	
left	TokenNameIdentifier	 left
,	TokenNameCOMMA	
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dcRacks	TokenNameIdentifier	 dc Racks
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
current	TokenNameIdentifier	 current
.	TokenNameDOT	
left	TokenNameIdentifier	 left
)	TokenNameRPAREN	
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
current	TokenNameIdentifier	 current
.	TokenNameDOT	
right	TokenNameIdentifier	 right
,	TokenNameCOMMA	
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @return multi-map of DC to endpoints in that DC */	TokenNameCOMMENT_JAVADOC	 @return multi-map of DC to endpoints in that DC 
public	TokenNamepublic	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
getDatacenterEndpoints	TokenNameIdentifier	 get Datacenter Endpoints
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
dcEndpoints	TokenNameIdentifier	 dc Endpoints
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @return map of DC to multi-map of rack to endpoints in that rack */	TokenNameCOMMENT_JAVADOC	 @return map of DC to multi-map of rack to endpoints in that rack 
public	TokenNamepublic	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
getDatacenterRacks	TokenNameIdentifier	 get Datacenter Racks
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
dcRacks	TokenNameIdentifier	 dc Racks
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
