/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
/* * $Id: WalkerFactory.java 469314 2006-10-30 23:31:59Z minchau $ */	TokenNameCOMMENT_BLOCK	 $Id: WalkerFactory.java 469314 2006-10-30 23:31:59Z minchau $ 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xpath	TokenNameIdentifier	 xpath
.	TokenNameDOT	
axes	TokenNameIdentifier	 axes
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xalan	TokenNameIdentifier	 xalan
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XSLMessages	TokenNameIdentifier	 XSL Messages
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
Axis	TokenNameIdentifier	 Axis
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
DTMFilter	TokenNameIdentifier	 DTM Filter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
DTMIterator	TokenNameIdentifier	 DTM Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xpath	TokenNameIdentifier	 xpath
.	TokenNameDOT	
Expression	TokenNameIdentifier	 Expression
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xpath	TokenNameIdentifier	 xpath
.	TokenNameDOT	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
Compiler	TokenNameIdentifier	 Compiler
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xpath	TokenNameIdentifier	 xpath
.	TokenNameDOT	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
FunctionTable	TokenNameIdentifier	 Function Table
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xpath	TokenNameIdentifier	 xpath
.	TokenNameDOT	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
OpCodes	TokenNameIdentifier	 Op Codes
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xpath	TokenNameIdentifier	 xpath
.	TokenNameDOT	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
OpMap	TokenNameIdentifier	 Op Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xpath	TokenNameIdentifier	 xpath
.	TokenNameDOT	
objects	TokenNameIdentifier	 objects
.	TokenNameDOT	
XNumber	TokenNameIdentifier	 X Number
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xpath	TokenNameIdentifier	 xpath
.	TokenNameDOT	
patterns	TokenNameIdentifier	 patterns
.	TokenNameDOT	
ContextMatchStepPattern	TokenNameIdentifier	 Context Match Step Pattern
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xpath	TokenNameIdentifier	 xpath
.	TokenNameDOT	
patterns	TokenNameIdentifier	 patterns
.	TokenNameDOT	
FunctionPattern	TokenNameIdentifier	 Function Pattern
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xpath	TokenNameIdentifier	 xpath
.	TokenNameDOT	
patterns	TokenNameIdentifier	 patterns
.	TokenNameDOT	
NodeTest	TokenNameIdentifier	 Node Test
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xpath	TokenNameIdentifier	 xpath
.	TokenNameDOT	
patterns	TokenNameIdentifier	 patterns
.	TokenNameDOT	
StepPattern	TokenNameIdentifier	 Step Pattern
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xpath	TokenNameIdentifier	 xpath
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XPATHErrorResources	TokenNameIdentifier	 XPATH Error Resources
;	TokenNameSEMICOLON	
/** * This class is both a factory for XPath location path expressions, * which are built from the opcode map output, and an analysis engine * for the location path expressions in order to provide optimization hints. */	TokenNameCOMMENT_JAVADOC	 This class is both a factory for XPath location path expressions, which are built from the opcode map output, and an analysis engine for the location path expressions in order to provide optimization hints. 
public	TokenNamepublic	
class	TokenNameclass	
WalkerFactory	TokenNameIdentifier	 Walker Factory
{	TokenNameLBRACE	
/** * This method is for building an array of possible levels * where the target element(s) could be found for a match. * @param lpi The owning location path iterator. * @param compiler non-null reference to compiler object that has processed * the XPath operations into an opcode map. * @param stepOpCodePos The opcode position for the step. * * @return non-null AxesWalker derivative. * * @throws javax.xml.transform.TransformerException * @xsl.usage advanced */	TokenNameCOMMENT_JAVADOC	 This method is for building an array of possible levels where the target element(s) could be found for a match. @param lpi The owning location path iterator. @param compiler non-null reference to compiler object that has processed the XPath operations into an opcode map. @param stepOpCodePos The opcode position for the step. * @return non-null AxesWalker derivative. * @throws javax.xml.transform.TransformerException @xsl.usage advanced 
static	TokenNamestatic	
AxesWalker	TokenNameIdentifier	 Axes Walker
loadOneWalker	TokenNameIdentifier	 load One Walker
(	TokenNameLPAREN	
WalkingIterator	TokenNameIdentifier	 Walking Iterator
lpi	TokenNameIdentifier	 lpi
,	TokenNameCOMMA	
Compiler	TokenNameIdentifier	 Compiler
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
int	TokenNameint	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
)	TokenNameRPAREN	
throws	TokenNamethrows	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
TransformerException	TokenNameIdentifier	 Transformer Exception
{	TokenNameLBRACE	
AxesWalker	TokenNameIdentifier	 Axes Walker
firstWalker	TokenNameIdentifier	 first Walker
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
stepType	TokenNameIdentifier	 step Type
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getOp	TokenNameIdentifier	 get Op
(	TokenNameLPAREN	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
stepType	TokenNameIdentifier	 step Type
!=	TokenNameNOT_EQUAL	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
ENDOP	TokenNameIdentifier	 ENDOP
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// m_axesWalkers = new AxesWalker[1]; 	TokenNameCOMMENT_LINE	m_axesWalkers = new AxesWalker[1]; 
// As we unwind from the recursion, create the iterators. 	TokenNameCOMMENT_LINE	As we unwind from the recursion, create the iterators. 
firstWalker	TokenNameIdentifier	 first Walker
=	TokenNameEQUAL	
createDefaultWalker	TokenNameIdentifier	 create Default Walker
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
stepType	TokenNameIdentifier	 step Type
,	TokenNameCOMMA	
lpi	TokenNameIdentifier	 lpi
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
firstWalker	TokenNameIdentifier	 first Walker
.	TokenNameDOT	
init	TokenNameIdentifier	 init
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
,	TokenNameCOMMA	
stepType	TokenNameIdentifier	 step Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
firstWalker	TokenNameIdentifier	 first Walker
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * This method is for building an array of possible levels * where the target element(s) could be found for a match. * @param lpi The owning location path iterator object. * @param compiler non-null reference to compiler object that has processed * the XPath operations into an opcode map. * @param stepOpCodePos The opcode position for the step. * @param stepIndex The top-level step index withing the iterator. * * @return non-null AxesWalker derivative. * * @throws javax.xml.transform.TransformerException * @xsl.usage advanced */	TokenNameCOMMENT_JAVADOC	 This method is for building an array of possible levels where the target element(s) could be found for a match. @param lpi The owning location path iterator object. @param compiler non-null reference to compiler object that has processed the XPath operations into an opcode map. @param stepOpCodePos The opcode position for the step. @param stepIndex The top-level step index withing the iterator. * @return non-null AxesWalker derivative. * @throws javax.xml.transform.TransformerException @xsl.usage advanced 
static	TokenNamestatic	
AxesWalker	TokenNameIdentifier	 Axes Walker
loadWalkers	TokenNameIdentifier	 load Walkers
(	TokenNameLPAREN	
WalkingIterator	TokenNameIdentifier	 Walking Iterator
lpi	TokenNameIdentifier	 lpi
,	TokenNameCOMMA	
Compiler	TokenNameIdentifier	 Compiler
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
int	TokenNameint	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
,	TokenNameCOMMA	
int	TokenNameint	
stepIndex	TokenNameIdentifier	 step Index
)	TokenNameRPAREN	
throws	TokenNamethrows	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
TransformerException	TokenNameIdentifier	 Transformer Exception
{	TokenNameLBRACE	
int	TokenNameint	
stepType	TokenNameIdentifier	 step Type
;	TokenNameSEMICOLON	
AxesWalker	TokenNameIdentifier	 Axes Walker
firstWalker	TokenNameIdentifier	 first Walker
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
AxesWalker	TokenNameIdentifier	 Axes Walker
walker	TokenNameIdentifier	 walker
,	TokenNameCOMMA	
prevWalker	TokenNameIdentifier	 prev Walker
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
=	TokenNameEQUAL	
analyze	TokenNameIdentifier	 analyze
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
,	TokenNameCOMMA	
stepIndex	TokenNameIdentifier	 step Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
ENDOP	TokenNameIdentifier	 ENDOP
!=	TokenNameNOT_EQUAL	
(	TokenNameLPAREN	
stepType	TokenNameIdentifier	 step Type
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getOp	TokenNameIdentifier	 get Op
(	TokenNameLPAREN	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
walker	TokenNameIdentifier	 walker
=	TokenNameEQUAL	
createDefaultWalker	TokenNameIdentifier	 create Default Walker
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
,	TokenNameCOMMA	
lpi	TokenNameIdentifier	 lpi
,	TokenNameCOMMA	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
walker	TokenNameIdentifier	 walker
.	TokenNameDOT	
init	TokenNameIdentifier	 init
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
,	TokenNameCOMMA	
stepType	TokenNameIdentifier	 step Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
walker	TokenNameIdentifier	 walker
.	TokenNameDOT	
exprSetParent	TokenNameIdentifier	 expr Set Parent
(	TokenNameLPAREN	
lpi	TokenNameIdentifier	 lpi
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// walker.setAnalysis(analysis); 	TokenNameCOMMENT_LINE	walker.setAnalysis(analysis); 
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
firstWalker	TokenNameIdentifier	 first Walker
)	TokenNameRPAREN	
{	TokenNameLBRACE	
firstWalker	TokenNameIdentifier	 first Walker
=	TokenNameEQUAL	
walker	TokenNameIdentifier	 walker
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
prevWalker	TokenNameIdentifier	 prev Walker
.	TokenNameDOT	
setNextWalker	TokenNameIdentifier	 set Next Walker
(	TokenNameLPAREN	
walker	TokenNameIdentifier	 walker
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
walker	TokenNameIdentifier	 walker
.	TokenNameDOT	
setPrevWalker	TokenNameIdentifier	 set Prev Walker
(	TokenNameLPAREN	
prevWalker	TokenNameIdentifier	 prev Walker
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
prevWalker	TokenNameIdentifier	 prev Walker
=	TokenNameEQUAL	
walker	TokenNameIdentifier	 walker
;	TokenNameSEMICOLON	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getNextStepPos	TokenNameIdentifier	 get Next Step Pos
(	TokenNameLPAREN	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
firstWalker	TokenNameIdentifier	 first Walker
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
isSet	TokenNameIdentifier	 is Set
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
int	TokenNameint	
bits	TokenNameIdentifier	 bits
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
!=	TokenNameNOT_EQUAL	
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
&	TokenNameAND	
bits	TokenNameIdentifier	 bits
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
diagnoseIterator	TokenNameIdentifier	 diagnose Iterator
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
Compiler	TokenNameIdentifier	 Compiler
compiler	TokenNameIdentifier	 compiler
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
", "	TokenNameStringLiteral	, 
+	TokenNamePLUS	
name	TokenNameIdentifier	 name
+	TokenNamePLUS	
", "	TokenNameStringLiteral	, 
+	TokenNamePLUS	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toBinaryString	TokenNameIdentifier	 to Binary String
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
+	TokenNamePLUS	
", "	TokenNameStringLiteral	, 
+	TokenNamePLUS	
getAnalysisString	TokenNameIdentifier	 get Analysis String
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Create a new LocPathIterator iterator. The exact type of iterator * returned is based on an analysis of the XPath operations. * * @param compiler non-null reference to compiler object that has processed * the XPath operations into an opcode map. * @param opPos The position of the operation code for this itterator. * * @return non-null reference to a LocPathIterator or derivative. * * @throws javax.xml.transform.TransformerException */	TokenNameCOMMENT_JAVADOC	 Create a new LocPathIterator iterator. The exact type of iterator returned is based on an analysis of the XPath operations. * @param compiler non-null reference to compiler object that has processed the XPath operations into an opcode map. @param opPos The position of the operation code for this itterator. * @return non-null reference to a LocPathIterator or derivative. * @throws javax.xml.transform.TransformerException 
public	TokenNamepublic	
static	TokenNamestatic	
DTMIterator	TokenNameIdentifier	 DTM Iterator
newDTMIterator	TokenNameIdentifier	 new DTM Iterator
(	TokenNameLPAREN	
Compiler	TokenNameIdentifier	 Compiler
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
int	TokenNameint	
opPos	TokenNameIdentifier	 op Pos
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isTopLevel	TokenNameIdentifier	 is Top Level
)	TokenNameRPAREN	
throws	TokenNamethrows	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
TransformerException	TokenNameIdentifier	 Transformer Exception
{	TokenNameLBRACE	
int	TokenNameint	
firstStepPos	TokenNameIdentifier	 first Step Pos
=	TokenNameEQUAL	
OpMap	TokenNameIdentifier	 Op Map
.	TokenNameDOT	
getFirstChildPos	TokenNameIdentifier	 get First Child Pos
(	TokenNameLPAREN	
opPos	TokenNameIdentifier	 op Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
=	TokenNameEQUAL	
analyze	TokenNameIdentifier	 analyze
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
firstStepPos	TokenNameIdentifier	 first Step Pos
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
isOneStep	TokenNameIdentifier	 is One Step
=	TokenNameEQUAL	
isOneStep	TokenNameIdentifier	 is One Step
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DTMIterator	TokenNameIdentifier	 DTM Iterator
iter	TokenNameIdentifier	 iter
;	TokenNameSEMICOLON	
// Is the iteration a one-step attribute pattern (i.e. select="@foo")? 	TokenNameCOMMENT_LINE	Is the iteration a one-step attribute pattern (i.e. select="@foo")? 
if	TokenNameif	
(	TokenNameLPAREN	
isOneStep	TokenNameIdentifier	 is One Step
&&	TokenNameAND_AND	
walksSelfOnly	TokenNameIdentifier	 walks Self Only
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
isWild	TokenNameIdentifier	 is Wild
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
hasPredicate	TokenNameIdentifier	 has Predicate
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG_ITERATOR_CREATION	TokenNameIdentifier	 DEBUG  ITERATOR  CREATION
)	TokenNameRPAREN	
diagnoseIterator	TokenNameIdentifier	 diagnose Iterator
(	TokenNameLPAREN	
"SelfIteratorNoPredicate"	TokenNameStringLiteral	SelfIteratorNoPredicate
,	TokenNameCOMMA	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
compiler	TokenNameIdentifier	 compiler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Then use a simple iteration of the attributes, with node test 	TokenNameCOMMENT_LINE	Then use a simple iteration of the attributes, with node test 
// and predicate testing. 	TokenNameCOMMENT_LINE	and predicate testing. 
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
new	TokenNamenew	
SelfIteratorNoPredicate	TokenNameIdentifier	 Self Iterator No Predicate
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
opPos	TokenNameIdentifier	 op Pos
,	TokenNameCOMMA	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Is the iteration exactly one child step? 	TokenNameCOMMENT_LINE	Is the iteration exactly one child step? 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
walksChildrenOnly	TokenNameIdentifier	 walks Children Only
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
isOneStep	TokenNameIdentifier	 is One Step
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Does the pattern specify *any* child with no predicate? (i.e. select="child::node()". 	TokenNameCOMMENT_LINE	Does the pattern specify *any* child with no predicate? (i.e. select="child::node()". 
if	TokenNameif	
(	TokenNameLPAREN	
isWild	TokenNameIdentifier	 is Wild
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
hasPredicate	TokenNameIdentifier	 has Predicate
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG_ITERATOR_CREATION	TokenNameIdentifier	 DEBUG  ITERATOR  CREATION
)	TokenNameRPAREN	
diagnoseIterator	TokenNameIdentifier	 diagnose Iterator
(	TokenNameLPAREN	
"ChildIterator"	TokenNameStringLiteral	ChildIterator
,	TokenNameCOMMA	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
compiler	TokenNameIdentifier	 compiler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Use simple child iteration without any test. 	TokenNameCOMMENT_LINE	Use simple child iteration without any test. 
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
new	TokenNamenew	
ChildIterator	TokenNameIdentifier	 Child Iterator
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
opPos	TokenNameIdentifier	 op Pos
,	TokenNameCOMMA	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG_ITERATOR_CREATION	TokenNameIdentifier	 DEBUG  ITERATOR  CREATION
)	TokenNameRPAREN	
diagnoseIterator	TokenNameIdentifier	 diagnose Iterator
(	TokenNameLPAREN	
"ChildTestIterator"	TokenNameStringLiteral	ChildTestIterator
,	TokenNameCOMMA	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
compiler	TokenNameIdentifier	 compiler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Else use simple node test iteration with predicate test. 	TokenNameCOMMENT_LINE	Else use simple node test iteration with predicate test. 
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
new	TokenNamenew	
ChildTestIterator	TokenNameIdentifier	 Child Test Iterator
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
opPos	TokenNameIdentifier	 op Pos
,	TokenNameCOMMA	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Is the iteration a one-step attribute pattern (i.e. select="@foo")? 	TokenNameCOMMENT_LINE	Is the iteration a one-step attribute pattern (i.e. select="@foo")? 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
isOneStep	TokenNameIdentifier	 is One Step
&&	TokenNameAND_AND	
walksAttributes	TokenNameIdentifier	 walks Attributes
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG_ITERATOR_CREATION	TokenNameIdentifier	 DEBUG  ITERATOR  CREATION
)	TokenNameRPAREN	
diagnoseIterator	TokenNameIdentifier	 diagnose Iterator
(	TokenNameLPAREN	
"AttributeIterator"	TokenNameStringLiteral	AttributeIterator
,	TokenNameCOMMA	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
compiler	TokenNameIdentifier	 compiler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Then use a simple iteration of the attributes, with node test 	TokenNameCOMMENT_LINE	Then use a simple iteration of the attributes, with node test 
// and predicate testing. 	TokenNameCOMMENT_LINE	and predicate testing. 
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
new	TokenNamenew	
AttributeIterator	TokenNameIdentifier	 Attribute Iterator
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
opPos	TokenNameIdentifier	 op Pos
,	TokenNameCOMMA	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
isOneStep	TokenNameIdentifier	 is One Step
&&	TokenNameAND_AND	
!	TokenNameNOT	
walksFilteredList	TokenNameIdentifier	 walks Filtered List
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
walksNamespaces	TokenNameIdentifier	 walks Namespaces
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
walksInDocOrder	TokenNameIdentifier	 walks In Doc Order
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
||	TokenNameOR_OR	
isSet	TokenNameIdentifier	 is Set
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
BIT_PARENT	TokenNameIdentifier	 BIT  PARENT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
false	TokenNamefalse	
||	TokenNameOR_OR	
DEBUG_ITERATOR_CREATION	TokenNameIdentifier	 DEBUG  ITERATOR  CREATION
)	TokenNameRPAREN	
diagnoseIterator	TokenNameIdentifier	 diagnose Iterator
(	TokenNameLPAREN	
"OneStepIteratorForward"	TokenNameStringLiteral	OneStepIteratorForward
,	TokenNameCOMMA	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
compiler	TokenNameIdentifier	 compiler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Then use a simple iteration of the attributes, with node test 	TokenNameCOMMENT_LINE	Then use a simple iteration of the attributes, with node test 
// and predicate testing. 	TokenNameCOMMENT_LINE	and predicate testing. 
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
new	TokenNamenew	
OneStepIteratorForward	TokenNameIdentifier	 One Step Iterator Forward
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
opPos	TokenNameIdentifier	 op Pos
,	TokenNameCOMMA	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
false	TokenNamefalse	
||	TokenNameOR_OR	
DEBUG_ITERATOR_CREATION	TokenNameIdentifier	 DEBUG  ITERATOR  CREATION
)	TokenNameRPAREN	
diagnoseIterator	TokenNameIdentifier	 diagnose Iterator
(	TokenNameLPAREN	
"OneStepIterator"	TokenNameStringLiteral	OneStepIterator
,	TokenNameCOMMA	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
compiler	TokenNameIdentifier	 compiler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Then use a simple iteration of the attributes, with node test 	TokenNameCOMMENT_LINE	Then use a simple iteration of the attributes, with node test 
// and predicate testing. 	TokenNameCOMMENT_LINE	and predicate testing. 
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
new	TokenNamenew	
OneStepIterator	TokenNameIdentifier	 One Step Iterator
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
opPos	TokenNameIdentifier	 op Pos
,	TokenNameCOMMA	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Analysis of "//center": 	TokenNameCOMMENT_LINE	Analysis of "//center": 
// bits: 1001000000001010000000000000011 	TokenNameCOMMENT_LINE	bits: 1001000000001010000000000000011 
// count: 3 	TokenNameCOMMENT_LINE	count: 3 
// root 	TokenNameCOMMENT_LINE	root 
// child:node() 	TokenNameCOMMENT_LINE	child:node() 
// BIT_DESCENDANT_OR_SELF 	TokenNameCOMMENT_LINE	BIT_DESCENDANT_OR_SELF 
// It's highly possible that we should have a seperate bit set for 	TokenNameCOMMENT_LINE	It's highly possible that we should have a seperate bit set for 
// "//foo" patterns. 	TokenNameCOMMENT_LINE	"//foo" patterns. 
// For at least the time being, we can't optimize patterns like 	TokenNameCOMMENT_LINE	For at least the time being, we can't optimize patterns like 
// "//table[3]", because this has to be analyzed as 	TokenNameCOMMENT_LINE	"//table[3]", because this has to be analyzed as 
// "/descendant-or-self::node()/table[3]" in order for the indexes 	TokenNameCOMMENT_LINE	"/descendant-or-self::node()/table[3]" in order for the indexes 
// to work right. 	TokenNameCOMMENT_LINE	to work right. 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
isOptimizableForDescendantIterator	TokenNameIdentifier	 is Optimizable For Descendant Iterator
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
firstStepPos	TokenNameIdentifier	 first Step Pos
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
// && getStepCount(analysis) <= 3 	TokenNameCOMMENT_LINE	&& getStepCount(analysis) <= 3 
// && walksDescendants(analysis) 	TokenNameCOMMENT_LINE	&& walksDescendants(analysis) 
// && walksSubtreeOnlyFromRootOrContext(analysis) 	TokenNameCOMMENT_LINE	&& walksSubtreeOnlyFromRootOrContext(analysis) 
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG_ITERATOR_CREATION	TokenNameIdentifier	 DEBUG  ITERATOR  CREATION
)	TokenNameRPAREN	
diagnoseIterator	TokenNameIdentifier	 diagnose Iterator
(	TokenNameLPAREN	
"DescendantIterator"	TokenNameStringLiteral	DescendantIterator
,	TokenNameCOMMA	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
compiler	TokenNameIdentifier	 compiler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
new	TokenNamenew	
DescendantIterator	TokenNameIdentifier	 Descendant Iterator
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
opPos	TokenNameIdentifier	 op Pos
,	TokenNameCOMMA	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isNaturalDocOrder	TokenNameIdentifier	 is Natural Doc Order
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
firstStepPos	TokenNameIdentifier	 first Step Pos
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
false	TokenNamefalse	
||	TokenNameOR_OR	
DEBUG_ITERATOR_CREATION	TokenNameIdentifier	 DEBUG  ITERATOR  CREATION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
diagnoseIterator	TokenNameIdentifier	 diagnose Iterator
(	TokenNameLPAREN	
"WalkingIterator"	TokenNameStringLiteral	WalkingIterator
,	TokenNameCOMMA	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
compiler	TokenNameIdentifier	 compiler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
new	TokenNamenew	
WalkingIterator	TokenNameIdentifier	 Walking Iterator
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
opPos	TokenNameIdentifier	 op Pos
,	TokenNameCOMMA	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// if (DEBUG_ITERATOR_CREATION) 	TokenNameCOMMENT_LINE	if (DEBUG_ITERATOR_CREATION) 
// diagnoseIterator("MatchPatternIterator", analysis, compiler); 	TokenNameCOMMENT_LINE	diagnoseIterator("MatchPatternIterator", analysis, compiler); 
// 	TokenNameCOMMENT_LINE	 
// return new MatchPatternIterator(compiler, opPos, analysis); 	TokenNameCOMMENT_LINE	return new MatchPatternIterator(compiler, opPos, analysis); 
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG_ITERATOR_CREATION	TokenNameIdentifier	 DEBUG  ITERATOR  CREATION
)	TokenNameRPAREN	
diagnoseIterator	TokenNameIdentifier	 diagnose Iterator
(	TokenNameLPAREN	
"WalkingIteratorSorted"	TokenNameStringLiteral	WalkingIteratorSorted
,	TokenNameCOMMA	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
compiler	TokenNameIdentifier	 compiler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
new	TokenNamenew	
WalkingIteratorSorted	TokenNameIdentifier	 Walking Iterator Sorted
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
opPos	TokenNameIdentifier	 op Pos
,	TokenNameCOMMA	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
iter	TokenNameIdentifier	 iter
instanceof	TokenNameinstanceof	
LocPathIterator	TokenNameIdentifier	 Loc Path Iterator
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
LocPathIterator	TokenNameIdentifier	 Loc Path Iterator
)	TokenNameRPAREN	
iter	TokenNameIdentifier	 iter
)	TokenNameRPAREN	
.	TokenNameDOT	
setIsTopLevel	TokenNameIdentifier	 set Is Top Level
(	TokenNameLPAREN	
isTopLevel	TokenNameIdentifier	 is Top Level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
iter	TokenNameIdentifier	 iter
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Special purpose function to see if we can optimize the pattern for * a DescendantIterator. * * @param compiler non-null reference to compiler object that has processed * the XPath operations into an opcode map. * @param stepOpCodePos The opcode position for the step. * * @return 32 bits as an integer that give information about the location * path as a whole. * * @throws javax.xml.transform.TransformerException */	TokenNameCOMMENT_JAVADOC	 Special purpose function to see if we can optimize the pattern for a DescendantIterator. * @param compiler non-null reference to compiler object that has processed the XPath operations into an opcode map. @param stepOpCodePos The opcode position for the step. * @return 32 bits as an integer that give information about the location path as a whole. * @throws javax.xml.transform.TransformerException 
public	TokenNamepublic	
static	TokenNamestatic	
int	TokenNameint	
getAxisFromStep	TokenNameIdentifier	 get Axis From Step
(	TokenNameLPAREN	
Compiler	TokenNameIdentifier	 Compiler
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
int	TokenNameint	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
)	TokenNameRPAREN	
throws	TokenNamethrows	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
TransformerException	TokenNameIdentifier	 Transformer Exception
{	TokenNameLBRACE	
int	TokenNameint	
stepType	TokenNameIdentifier	 step Type
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getOp	TokenNameIdentifier	 get Op
(	TokenNameLPAREN	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
stepType	TokenNameIdentifier	 step Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_FOLLOWING	TokenNameIdentifier	 FROM  FOLLOWING
:	TokenNameCOLON	
return	TokenNamereturn	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
FOLLOWING	TokenNameIdentifier	 FOLLOWING
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_FOLLOWING_SIBLINGS	TokenNameIdentifier	 FROM  FOLLOWING  SIBLINGS
:	TokenNameCOLON	
return	TokenNamereturn	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
FOLLOWINGSIBLING	TokenNameIdentifier	 FOLLOWINGSIBLING
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_PRECEDING	TokenNameIdentifier	 FROM  PRECEDING
:	TokenNameCOLON	
return	TokenNamereturn	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
PRECEDING	TokenNameIdentifier	 PRECEDING
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_PRECEDING_SIBLINGS	TokenNameIdentifier	 FROM  PRECEDING  SIBLINGS
:	TokenNameCOLON	
return	TokenNamereturn	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
PRECEDINGSIBLING	TokenNameIdentifier	 PRECEDINGSIBLING
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_PARENT	TokenNameIdentifier	 FROM  PARENT
:	TokenNameCOLON	
return	TokenNamereturn	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
PARENT	TokenNameIdentifier	 PARENT
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_NAMESPACE	TokenNameIdentifier	 FROM  NAMESPACE
:	TokenNameCOLON	
return	TokenNamereturn	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
NAMESPACE	TokenNameIdentifier	 NAMESPACE
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_ANCESTORS	TokenNameIdentifier	 FROM  ANCESTORS
:	TokenNameCOLON	
return	TokenNamereturn	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
ANCESTOR	TokenNameIdentifier	 ANCESTOR
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_ANCESTORS_OR_SELF	TokenNameIdentifier	 FROM  ANCESTORS  OR  SELF
:	TokenNameCOLON	
return	TokenNamereturn	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
ANCESTORORSELF	TokenNameIdentifier	 ANCESTORORSELF
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_ATTRIBUTES	TokenNameIdentifier	 FROM  ATTRIBUTES
:	TokenNameCOLON	
return	TokenNamereturn	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
ATTRIBUTE	TokenNameIdentifier	 ATTRIBUTE
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_ROOT	TokenNameIdentifier	 FROM  ROOT
:	TokenNameCOLON	
return	TokenNamereturn	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
ROOT	TokenNameIdentifier	 ROOT
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_CHILDREN	TokenNameIdentifier	 FROM  CHILDREN
:	TokenNameCOLON	
return	TokenNamereturn	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
CHILD	TokenNameIdentifier	 CHILD
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_DESCENDANTS_OR_SELF	TokenNameIdentifier	 FROM  DESCENDANTS  OR  SELF
:	TokenNameCOLON	
return	TokenNamereturn	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
DESCENDANTORSELF	TokenNameIdentifier	 DESCENDANTORSELF
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_DESCENDANTS	TokenNameIdentifier	 FROM  DESCENDANTS
:	TokenNameCOLON	
return	TokenNamereturn	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
DESCENDANT	TokenNameIdentifier	 DESCENDANT
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_SELF	TokenNameIdentifier	 FROM  SELF
:	TokenNameCOLON	
return	TokenNamereturn	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
SELF	TokenNameIdentifier	 SELF
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_EXTFUNCTION	TokenNameIdentifier	 OP  EXTFUNCTION
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_FUNCTION	TokenNameIdentifier	 OP  FUNCTION
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_GROUP	TokenNameIdentifier	 OP  GROUP
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_VARIABLE	TokenNameIdentifier	 OP  VARIABLE
:	TokenNameCOLON	
return	TokenNamereturn	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
FILTEREDLIST	TokenNameIdentifier	 FILTEREDLIST
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
XSLMessages	TokenNameIdentifier	 XSL Messages
.	TokenNameDOT	
createXPATHMessage	TokenNameIdentifier	 create XPATH Message
(	TokenNameLPAREN	
XPATHErrorResources	TokenNameIdentifier	 XPATH Error Resources
.	TokenNameDOT	
ER_NULL_ERROR_HANDLER	TokenNameIdentifier	 ER  NULL  ERROR  HANDLER
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
stepType	TokenNameIdentifier	 step Type
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//"Programmer's assertion: unknown opcode: " 	TokenNameCOMMENT_LINE	"Programmer's assertion: unknown opcode: " 
//+ stepType); 	TokenNameCOMMENT_LINE	+ stepType); 
}	TokenNameRBRACE	
/** * Get a corresponding BIT_XXX from an axis. * @param axis One of Axis.ANCESTOR, etc. * @return One of BIT_ANCESTOR, etc. */	TokenNameCOMMENT_JAVADOC	 Get a corresponding BIT_XXX from an axis. @param axis One of Axis.ANCESTOR, etc. @return One of BIT_ANCESTOR, etc. 
static	TokenNamestatic	
public	TokenNamepublic	
int	TokenNameint	
getAnalysisBitFromAxes	TokenNameIdentifier	 get Analysis Bit From Axes
(	TokenNameLPAREN	
int	TokenNameint	
axis	TokenNameIdentifier	 axis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
axis	TokenNameIdentifier	 axis
)	TokenNameRPAREN	
// Generate new traverser 	TokenNameCOMMENT_LINE	Generate new traverser 
{	TokenNameLBRACE	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
ANCESTOR	TokenNameIdentifier	 ANCESTOR
:	TokenNameCOLON	
return	TokenNamereturn	
BIT_ANCESTOR	TokenNameIdentifier	 BIT  ANCESTOR
;	TokenNameSEMICOLON	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
ANCESTORORSELF	TokenNameIdentifier	 ANCESTORORSELF
:	TokenNameCOLON	
return	TokenNamereturn	
BIT_ANCESTOR_OR_SELF	TokenNameIdentifier	 BIT  ANCESTOR  OR  SELF
;	TokenNameSEMICOLON	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
ATTRIBUTE	TokenNameIdentifier	 ATTRIBUTE
:	TokenNameCOLON	
return	TokenNamereturn	
BIT_ATTRIBUTE	TokenNameIdentifier	 BIT  ATTRIBUTE
;	TokenNameSEMICOLON	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
CHILD	TokenNameIdentifier	 CHILD
:	TokenNameCOLON	
return	TokenNamereturn	
BIT_CHILD	TokenNameIdentifier	 BIT  CHILD
;	TokenNameSEMICOLON	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
DESCENDANT	TokenNameIdentifier	 DESCENDANT
:	TokenNameCOLON	
return	TokenNamereturn	
BIT_DESCENDANT	TokenNameIdentifier	 BIT  DESCENDANT
;	TokenNameSEMICOLON	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
DESCENDANTORSELF	TokenNameIdentifier	 DESCENDANTORSELF
:	TokenNameCOLON	
return	TokenNamereturn	
BIT_DESCENDANT_OR_SELF	TokenNameIdentifier	 BIT  DESCENDANT  OR  SELF
;	TokenNameSEMICOLON	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
FOLLOWING	TokenNameIdentifier	 FOLLOWING
:	TokenNameCOLON	
return	TokenNamereturn	
BIT_FOLLOWING	TokenNameIdentifier	 BIT  FOLLOWING
;	TokenNameSEMICOLON	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
FOLLOWINGSIBLING	TokenNameIdentifier	 FOLLOWINGSIBLING
:	TokenNameCOLON	
return	TokenNamereturn	
BIT_FOLLOWING_SIBLING	TokenNameIdentifier	 BIT  FOLLOWING  SIBLING
;	TokenNameSEMICOLON	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
NAMESPACE	TokenNameIdentifier	 NAMESPACE
:	TokenNameCOLON	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
NAMESPACEDECLS	TokenNameIdentifier	 NAMESPACEDECLS
:	TokenNameCOLON	
return	TokenNamereturn	
BIT_NAMESPACE	TokenNameIdentifier	 BIT  NAMESPACE
;	TokenNameSEMICOLON	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
PARENT	TokenNameIdentifier	 PARENT
:	TokenNameCOLON	
return	TokenNamereturn	
BIT_PARENT	TokenNameIdentifier	 BIT  PARENT
;	TokenNameSEMICOLON	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
PRECEDING	TokenNameIdentifier	 PRECEDING
:	TokenNameCOLON	
return	TokenNamereturn	
BIT_PRECEDING	TokenNameIdentifier	 BIT  PRECEDING
;	TokenNameSEMICOLON	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
PRECEDINGSIBLING	TokenNameIdentifier	 PRECEDINGSIBLING
:	TokenNameCOLON	
return	TokenNamereturn	
BIT_PRECEDING_SIBLING	TokenNameIdentifier	 BIT  PRECEDING  SIBLING
;	TokenNameSEMICOLON	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
SELF	TokenNameIdentifier	 SELF
:	TokenNameCOLON	
return	TokenNamereturn	
BIT_SELF	TokenNameIdentifier	 BIT  SELF
;	TokenNameSEMICOLON	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
ALLFROMNODE	TokenNameIdentifier	 ALLFROMNODE
:	TokenNameCOLON	
return	TokenNamereturn	
BIT_DESCENDANT_OR_SELF	TokenNameIdentifier	 BIT  DESCENDANT  OR  SELF
;	TokenNameSEMICOLON	
// case Axis.PRECEDINGANDANCESTOR : 	TokenNameCOMMENT_LINE	case Axis.PRECEDINGANDANCESTOR : 
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
DESCENDANTSFROMROOT	TokenNameIdentifier	 DESCENDANTSFROMROOT
:	TokenNameCOLON	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
ALL	TokenNameIdentifier	 ALL
:	TokenNameCOLON	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
DESCENDANTSORSELFFROMROOT	TokenNameIdentifier	 DESCENDANTSORSELFFROMROOT
:	TokenNameCOLON	
return	TokenNamereturn	
BIT_ANY_DESCENDANT_FROM_ROOT	TokenNameIdentifier	 BIT  ANY  DESCENDANT  FROM  ROOT
;	TokenNameSEMICOLON	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
ROOT	TokenNameIdentifier	 ROOT
:	TokenNameCOLON	
return	TokenNamereturn	
BIT_ROOT	TokenNameIdentifier	 BIT  ROOT
;	TokenNameSEMICOLON	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
FILTEREDLIST	TokenNameIdentifier	 FILTEREDLIST
:	TokenNameCOLON	
return	TokenNamereturn	
BIT_FILTER	TokenNameIdentifier	 BIT  FILTER
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
return	TokenNamereturn	
BIT_FILTER	TokenNameIdentifier	 BIT  FILTER
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
static	TokenNamestatic	
boolean	TokenNameboolean	
functionProximateOrContainsProximate	TokenNameIdentifier	 function Proximate Or Contains Proximate
(	TokenNameLPAREN	
Compiler	TokenNameIdentifier	 Compiler
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
int	TokenNameint	
opPos	TokenNameIdentifier	 op Pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
endFunc	TokenNameIdentifier	 end Func
=	TokenNameEQUAL	
opPos	TokenNameIdentifier	 op Pos
+	TokenNamePLUS	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getOp	TokenNameIdentifier	 get Op
(	TokenNameLPAREN	
opPos	TokenNameIdentifier	 op Pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
opPos	TokenNameIdentifier	 op Pos
=	TokenNameEQUAL	
OpMap	TokenNameIdentifier	 Op Map
.	TokenNameDOT	
getFirstChildPos	TokenNameIdentifier	 get First Child Pos
(	TokenNameLPAREN	
opPos	TokenNameIdentifier	 op Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
funcID	TokenNameIdentifier	 func ID
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getOp	TokenNameIdentifier	 get Op
(	TokenNameLPAREN	
opPos	TokenNameIdentifier	 op Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// System.out.println("funcID: "+funcID); 	TokenNameCOMMENT_LINE	System.out.println("funcID: "+funcID); 
// System.out.println("opPos: "+opPos); 	TokenNameCOMMENT_LINE	System.out.println("opPos: "+opPos); 
// System.out.println("endFunc: "+endFunc); 	TokenNameCOMMENT_LINE	System.out.println("endFunc: "+endFunc); 
switch	TokenNameswitch	
(	TokenNameLPAREN	
funcID	TokenNameIdentifier	 func ID
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
FunctionTable	TokenNameIdentifier	 Function Table
.	TokenNameDOT	
FUNC_LAST	TokenNameIdentifier	 FUNC  LAST
:	TokenNameCOLON	
case	TokenNamecase	
FunctionTable	TokenNameIdentifier	 Function Table
.	TokenNameDOT	
FUNC_POSITION	TokenNameIdentifier	 FUNC  POSITION
:	TokenNameCOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
opPos	TokenNameIdentifier	 op Pos
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
opPos	TokenNameIdentifier	 op Pos
;	TokenNameSEMICOLON	
p	TokenNameIdentifier	 p
<	TokenNameLESS	
endFunc	TokenNameIdentifier	 end Func
;	TokenNameSEMICOLON	
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getNextOpPos	TokenNameIdentifier	 get Next Op Pos
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
)	TokenNameRPAREN	
,	TokenNameCOMMA	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
innerExprOpPos	TokenNameIdentifier	 inner Expr Op Pos
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
argOp	TokenNameIdentifier	 arg Op
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getOp	TokenNameIdentifier	 get Op
(	TokenNameLPAREN	
innerExprOpPos	TokenNameIdentifier	 inner Expr Op Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
prox	TokenNameIdentifier	 prox
=	TokenNameEQUAL	
isProximateInnerExpr	TokenNameIdentifier	 is Proximate Inner Expr
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
innerExprOpPos	TokenNameIdentifier	 inner Expr Op Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
prox	TokenNameIdentifier	 prox
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
static	TokenNamestatic	
boolean	TokenNameboolean	
isProximateInnerExpr	TokenNameIdentifier	 is Proximate Inner Expr
(	TokenNameLPAREN	
Compiler	TokenNameIdentifier	 Compiler
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
int	TokenNameint	
opPos	TokenNameIdentifier	 op Pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
op	TokenNameIdentifier	 op
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getOp	TokenNameIdentifier	 get Op
(	TokenNameLPAREN	
opPos	TokenNameIdentifier	 op Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
innerExprOpPos	TokenNameIdentifier	 inner Expr Op Pos
=	TokenNameEQUAL	
opPos	TokenNameIdentifier	 op Pos
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
op	TokenNameIdentifier	 op
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_ARGUMENT	TokenNameIdentifier	 OP  ARGUMENT
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isProximateInnerExpr	TokenNameIdentifier	 is Proximate Inner Expr
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
innerExprOpPos	TokenNameIdentifier	 inner Expr Op Pos
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_VARIABLE	TokenNameIdentifier	 OP  VARIABLE
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_NUMBERLIT	TokenNameIdentifier	 OP  NUMBERLIT
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_LITERAL	TokenNameIdentifier	 OP  LITERAL
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_LOCATIONPATH	TokenNameIdentifier	 OP  LOCATIONPATH
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
// OK 	TokenNameCOMMENT_LINE	OK 
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_FUNCTION	TokenNameIdentifier	 OP  FUNCTION
:	TokenNameCOLON	
boolean	TokenNameboolean	
isProx	TokenNameIdentifier	 is Prox
=	TokenNameEQUAL	
functionProximateOrContainsProximate	TokenNameIdentifier	 function Proximate Or Contains Proximate
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
opPos	TokenNameIdentifier	 op Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isProx	TokenNameIdentifier	 is Prox
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_GT	TokenNameIdentifier	 OP  GT
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_GTE	TokenNameIdentifier	 OP  GTE
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_LT	TokenNameIdentifier	 OP  LT
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_LTE	TokenNameIdentifier	 OP  LTE
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_EQUALS	TokenNameIdentifier	 OP  EQUALS
:	TokenNameCOLON	
int	TokenNameint	
leftPos	TokenNameIdentifier	 left Pos
=	TokenNameEQUAL	
OpMap	TokenNameIdentifier	 Op Map
.	TokenNameDOT	
getFirstChildPos	TokenNameIdentifier	 get First Child Pos
(	TokenNameLPAREN	
op	TokenNameIdentifier	 op
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
rightPos	TokenNameIdentifier	 right Pos
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getNextOpPos	TokenNameIdentifier	 get Next Op Pos
(	TokenNameLPAREN	
leftPos	TokenNameIdentifier	 left Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
isProx	TokenNameIdentifier	 is Prox
=	TokenNameEQUAL	
isProximateInnerExpr	TokenNameIdentifier	 is Proximate Inner Expr
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
leftPos	TokenNameIdentifier	 left Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isProx	TokenNameIdentifier	 is Prox
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
isProx	TokenNameIdentifier	 is Prox
=	TokenNameEQUAL	
isProximateInnerExpr	TokenNameIdentifier	 is Proximate Inner Expr
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
rightPos	TokenNameIdentifier	 right Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isProx	TokenNameIdentifier	 is Prox
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// be conservative... 	TokenNameCOMMENT_LINE	be conservative... 
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Tell if the predicates need to have proximity knowledge. */	TokenNameCOMMENT_JAVADOC	 Tell if the predicates need to have proximity knowledge. 
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
mightBeProximate	TokenNameIdentifier	 might Be Proximate
(	TokenNameLPAREN	
Compiler	TokenNameIdentifier	 Compiler
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
int	TokenNameint	
opPos	TokenNameIdentifier	 op Pos
,	TokenNameCOMMA	
int	TokenNameint	
stepType	TokenNameIdentifier	 step Type
)	TokenNameRPAREN	
throws	TokenNamethrows	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
TransformerException	TokenNameIdentifier	 Transformer Exception
{	TokenNameLBRACE	
boolean	TokenNameboolean	
mightBeProximate	TokenNameIdentifier	 might Be Proximate
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
int	TokenNameint	
argLen	TokenNameIdentifier	 arg Len
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
stepType	TokenNameIdentifier	 step Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_VARIABLE	TokenNameIdentifier	 OP  VARIABLE
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_EXTFUNCTION	TokenNameIdentifier	 OP  EXTFUNCTION
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_FUNCTION	TokenNameIdentifier	 OP  FUNCTION
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_GROUP	TokenNameIdentifier	 OP  GROUP
:	TokenNameCOLON	
argLen	TokenNameIdentifier	 arg Len
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getArgLength	TokenNameIdentifier	 get Arg Length
(	TokenNameLPAREN	
opPos	TokenNameIdentifier	 op Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
argLen	TokenNameIdentifier	 arg Len
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getArgLengthOfStep	TokenNameIdentifier	 get Arg Length Of Step
(	TokenNameLPAREN	
opPos	TokenNameIdentifier	 op Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
predPos	TokenNameIdentifier	 pred Pos
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getFirstPredicateOpPos	TokenNameIdentifier	 get First Predicate Op Pos
(	TokenNameLPAREN	
opPos	TokenNameIdentifier	 op Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_PREDICATE	TokenNameIdentifier	 OP  PREDICATE
==	TokenNameEQUAL_EQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getOp	TokenNameIdentifier	 get Op
(	TokenNameLPAREN	
predPos	TokenNameIdentifier	 pred Pos
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
int	TokenNameint	
innerExprOpPos	TokenNameIdentifier	 inner Expr Op Pos
=	TokenNameEQUAL	
predPos	TokenNameIdentifier	 pred Pos
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
predOp	TokenNameIdentifier	 pred Op
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getOp	TokenNameIdentifier	 get Op
(	TokenNameLPAREN	
innerExprOpPos	TokenNameIdentifier	 inner Expr Op Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
predOp	TokenNameIdentifier	 pred Op
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_VARIABLE	TokenNameIdentifier	 OP  VARIABLE
:	TokenNameCOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// Would need more smarts to tell if this could be a number or not! 	TokenNameCOMMENT_LINE	Would need more smarts to tell if this could be a number or not! 
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_LOCATIONPATH	TokenNameIdentifier	 OP  LOCATIONPATH
:	TokenNameCOLON	
// OK. 	TokenNameCOMMENT_LINE	OK. 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_NUMBER	TokenNameIdentifier	 OP  NUMBER
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_NUMBERLIT	TokenNameIdentifier	 OP  NUMBERLIT
:	TokenNameCOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// that's all she wrote! 	TokenNameCOMMENT_LINE	that's all she wrote! 
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_FUNCTION	TokenNameIdentifier	 OP  FUNCTION
:	TokenNameCOLON	
boolean	TokenNameboolean	
isProx	TokenNameIdentifier	 is Prox
=	TokenNameEQUAL	
functionProximateOrContainsProximate	TokenNameIdentifier	 function Proximate Or Contains Proximate
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
innerExprOpPos	TokenNameIdentifier	 inner Expr Op Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isProx	TokenNameIdentifier	 is Prox
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_GT	TokenNameIdentifier	 OP  GT
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_GTE	TokenNameIdentifier	 OP  GTE
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_LT	TokenNameIdentifier	 OP  LT
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_LTE	TokenNameIdentifier	 OP  LTE
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_EQUALS	TokenNameIdentifier	 OP  EQUALS
:	TokenNameCOLON	
int	TokenNameint	
leftPos	TokenNameIdentifier	 left Pos
=	TokenNameEQUAL	
OpMap	TokenNameIdentifier	 Op Map
.	TokenNameDOT	
getFirstChildPos	TokenNameIdentifier	 get First Child Pos
(	TokenNameLPAREN	
innerExprOpPos	TokenNameIdentifier	 inner Expr Op Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
rightPos	TokenNameIdentifier	 right Pos
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getNextOpPos	TokenNameIdentifier	 get Next Op Pos
(	TokenNameLPAREN	
leftPos	TokenNameIdentifier	 left Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
isProx	TokenNameIdentifier	 is Prox
=	TokenNameEQUAL	
isProximateInnerExpr	TokenNameIdentifier	 is Proximate Inner Expr
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
leftPos	TokenNameIdentifier	 left Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isProx	TokenNameIdentifier	 is Prox
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
isProx	TokenNameIdentifier	 is Prox
=	TokenNameEQUAL	
isProximateInnerExpr	TokenNameIdentifier	 is Proximate Inner Expr
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
rightPos	TokenNameIdentifier	 right Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isProx	TokenNameIdentifier	 is Prox
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// be conservative... 	TokenNameCOMMENT_LINE	be conservative... 
}	TokenNameRBRACE	
predPos	TokenNameIdentifier	 pred Pos
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getNextOpPos	TokenNameIdentifier	 get Next Op Pos
(	TokenNameLPAREN	
predPos	TokenNameIdentifier	 pred Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
mightBeProximate	TokenNameIdentifier	 might Be Proximate
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Special purpose function to see if we can optimize the pattern for * a DescendantIterator. * * @param compiler non-null reference to compiler object that has processed * the XPath operations into an opcode map. * @param stepOpCodePos The opcode position for the step. * @param stepIndex The top-level step index withing the iterator. * * @return 32 bits as an integer that give information about the location * path as a whole. * * @throws javax.xml.transform.TransformerException */	TokenNameCOMMENT_JAVADOC	 Special purpose function to see if we can optimize the pattern for a DescendantIterator. * @param compiler non-null reference to compiler object that has processed the XPath operations into an opcode map. @param stepOpCodePos The opcode position for the step. @param stepIndex The top-level step index withing the iterator. * @return 32 bits as an integer that give information about the location path as a whole. * @throws javax.xml.transform.TransformerException 
private	TokenNameprivate	
static	TokenNamestatic	
boolean	TokenNameboolean	
isOptimizableForDescendantIterator	TokenNameIdentifier	 is Optimizable For Descendant Iterator
(	TokenNameLPAREN	
Compiler	TokenNameIdentifier	 Compiler
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
int	TokenNameint	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
,	TokenNameCOMMA	
int	TokenNameint	
stepIndex	TokenNameIdentifier	 step Index
)	TokenNameRPAREN	
throws	TokenNamethrows	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
TransformerException	TokenNameIdentifier	 Transformer Exception
{	TokenNameLBRACE	
int	TokenNameint	
stepType	TokenNameIdentifier	 step Type
;	TokenNameSEMICOLON	
int	TokenNameint	
stepCount	TokenNameIdentifier	 step Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
foundDorDS	TokenNameIdentifier	 found Dor DS
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
foundSelf	TokenNameIdentifier	 found Self
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
foundDS	TokenNameIdentifier	 found DS
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
int	TokenNameint	
nodeTestType	TokenNameIdentifier	 node Test Type
=	TokenNameEQUAL	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
NODETYPE_NODE	TokenNameIdentifier	 NODETYPE  NODE
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
ENDOP	TokenNameIdentifier	 ENDOP
!=	TokenNameNOT_EQUAL	
(	TokenNameLPAREN	
stepType	TokenNameIdentifier	 step Type
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getOp	TokenNameIdentifier	 get Op
(	TokenNameLPAREN	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// The DescendantIterator can only do one node test. If there's more 	TokenNameCOMMENT_LINE	The DescendantIterator can only do one node test. If there's more 
// than one, use another iterator. 	TokenNameCOMMENT_LINE	than one, use another iterator. 
if	TokenNameif	
(	TokenNameLPAREN	
nodeTestType	TokenNameIdentifier	 node Test Type
!=	TokenNameNOT_EQUAL	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
NODETYPE_NODE	TokenNameIdentifier	 NODETYPE  NODE
&&	TokenNameAND_AND	
nodeTestType	TokenNameIdentifier	 node Test Type
!=	TokenNameNOT_EQUAL	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
NODETYPE_ROOT	TokenNameIdentifier	 NODETYPE  ROOT
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
stepCount	TokenNameIdentifier	 step Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
stepCount	TokenNameIdentifier	 step Count
>	TokenNameGREATER	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
mightBeProximate	TokenNameIdentifier	 might Be Proximate
=	TokenNameEQUAL	
mightBeProximate	TokenNameIdentifier	 might Be Proximate
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
,	TokenNameCOMMA	
stepType	TokenNameIdentifier	 step Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
mightBeProximate	TokenNameIdentifier	 might Be Proximate
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
stepType	TokenNameIdentifier	 step Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_FOLLOWING	TokenNameIdentifier	 FROM  FOLLOWING
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_FOLLOWING_SIBLINGS	TokenNameIdentifier	 FROM  FOLLOWING  SIBLINGS
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_PRECEDING	TokenNameIdentifier	 FROM  PRECEDING
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_PRECEDING_SIBLINGS	TokenNameIdentifier	 FROM  PRECEDING  SIBLINGS
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_PARENT	TokenNameIdentifier	 FROM  PARENT
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_VARIABLE	TokenNameIdentifier	 OP  VARIABLE
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_EXTFUNCTION	TokenNameIdentifier	 OP  EXTFUNCTION
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_FUNCTION	TokenNameIdentifier	 OP  FUNCTION
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_GROUP	TokenNameIdentifier	 OP  GROUP
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_NAMESPACE	TokenNameIdentifier	 FROM  NAMESPACE
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_ANCESTORS	TokenNameIdentifier	 FROM  ANCESTORS
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_ANCESTORS_OR_SELF	TokenNameIdentifier	 FROM  ANCESTORS  OR  SELF
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_ATTRIBUTES	TokenNameIdentifier	 FROM  ATTRIBUTES
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
MATCH_ATTRIBUTE	TokenNameIdentifier	 MATCH  ATTRIBUTE
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
MATCH_ANY_ANCESTOR	TokenNameIdentifier	 MATCH  ANY  ANCESTOR
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
MATCH_IMMEDIATE_ANCESTOR	TokenNameIdentifier	 MATCH  IMMEDIATE  ANCESTOR
:	TokenNameCOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_ROOT	TokenNameIdentifier	 FROM  ROOT
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
!=	TokenNameNOT_EQUAL	
stepCount	TokenNameIdentifier	 step Count
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_CHILDREN	TokenNameIdentifier	 FROM  CHILDREN
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
foundDS	TokenNameIdentifier	 found DS
&&	TokenNameAND_AND	
!	TokenNameNOT	
(	TokenNameLPAREN	
foundDorDS	TokenNameIdentifier	 found Dor DS
&&	TokenNameAND_AND	
foundSelf	TokenNameIdentifier	 found Self
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_DESCENDANTS_OR_SELF	TokenNameIdentifier	 FROM  DESCENDANTS  OR  SELF
:	TokenNameCOLON	
foundDS	TokenNameIdentifier	 found DS
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_DESCENDANTS	TokenNameIdentifier	 FROM  DESCENDANTS
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
==	TokenNameEQUAL_EQUAL	
stepCount	TokenNameIdentifier	 step Count
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
foundDorDS	TokenNameIdentifier	 found Dor DS
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_SELF	TokenNameIdentifier	 FROM  SELF
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
!=	TokenNameNOT_EQUAL	
stepCount	TokenNameIdentifier	 step Count
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
foundSelf	TokenNameIdentifier	 found Self
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
XSLMessages	TokenNameIdentifier	 XSL Messages
.	TokenNameDOT	
createXPATHMessage	TokenNameIdentifier	 create XPATH Message
(	TokenNameLPAREN	
XPATHErrorResources	TokenNameIdentifier	 XPATH Error Resources
.	TokenNameDOT	
ER_NULL_ERROR_HANDLER	TokenNameIdentifier	 ER  NULL  ERROR  HANDLER
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
stepType	TokenNameIdentifier	 step Type
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//"Programmer's assertion: unknown opcode: " 	TokenNameCOMMENT_LINE	"Programmer's assertion: unknown opcode: " 
// + stepType); 	TokenNameCOMMENT_LINE	+ stepType); 
}	TokenNameRBRACE	
nodeTestType	TokenNameIdentifier	 node Test Type
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getStepTestType	TokenNameIdentifier	 get Step Test Type
(	TokenNameLPAREN	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
nextStepOpCodePos	TokenNameIdentifier	 next Step Op Code Pos
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getNextStepPos	TokenNameIdentifier	 get Next Step Pos
(	TokenNameLPAREN	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nextStepOpCodePos	TokenNameIdentifier	 next Step Op Code Pos
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
ENDOP	TokenNameIdentifier	 ENDOP
!=	TokenNameNOT_EQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getOp	TokenNameIdentifier	 get Op
(	TokenNameLPAREN	
nextStepOpCodePos	TokenNameIdentifier	 next Step Op Code Pos
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
countPredicates	TokenNameIdentifier	 count Predicates
(	TokenNameLPAREN	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
=	TokenNameEQUAL	
nextStepOpCodePos	TokenNameIdentifier	 next Step Op Code Pos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Analyze the location path and return 32 bits that give information about * the location path as a whole. See the BIT_XXX constants for meaning about * each of the bits. * * @param compiler non-null reference to compiler object that has processed * the XPath operations into an opcode map. * @param stepOpCodePos The opcode position for the step. * @param stepIndex The top-level step index withing the iterator. * * @return 32 bits as an integer that give information about the location * path as a whole. * * @throws javax.xml.transform.TransformerException */	TokenNameCOMMENT_JAVADOC	 Analyze the location path and return 32 bits that give information about the location path as a whole. See the BIT_XXX constants for meaning about each of the bits. * @param compiler non-null reference to compiler object that has processed the XPath operations into an opcode map. @param stepOpCodePos The opcode position for the step. @param stepIndex The top-level step index withing the iterator. * @return 32 bits as an integer that give information about the location path as a whole. * @throws javax.xml.transform.TransformerException 
private	TokenNameprivate	
static	TokenNamestatic	
int	TokenNameint	
analyze	TokenNameIdentifier	 analyze
(	TokenNameLPAREN	
Compiler	TokenNameIdentifier	 Compiler
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
int	TokenNameint	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
,	TokenNameCOMMA	
int	TokenNameint	
stepIndex	TokenNameIdentifier	 step Index
)	TokenNameRPAREN	
throws	TokenNamethrows	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
TransformerException	TokenNameIdentifier	 Transformer Exception
{	TokenNameLBRACE	
int	TokenNameint	
stepType	TokenNameIdentifier	 step Type
;	TokenNameSEMICOLON	
int	TokenNameint	
stepCount	TokenNameIdentifier	 step Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
analysisResult	TokenNameIdentifier	 analysis Result
=	TokenNameEQUAL	
0x00000000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// 32 bits of analysis 	TokenNameCOMMENT_LINE	32 bits of analysis 
while	TokenNamewhile	
(	TokenNameLPAREN	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
ENDOP	TokenNameIdentifier	 ENDOP
!=	TokenNameNOT_EQUAL	
(	TokenNameLPAREN	
stepType	TokenNameIdentifier	 step Type
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getOp	TokenNameIdentifier	 get Op
(	TokenNameLPAREN	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stepCount	TokenNameIdentifier	 step Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
// String namespace = compiler.getStepNS(stepOpCodePos); 	TokenNameCOMMENT_LINE	String namespace = compiler.getStepNS(stepOpCodePos); 
// boolean isNSWild = (null != namespace) 	TokenNameCOMMENT_LINE	boolean isNSWild = (null != namespace) 
// ? namespace.equals(NodeTest.WILD) : false; 	TokenNameCOMMENT_LINE	? namespace.equals(NodeTest.WILD) : false; 
// String localname = compiler.getStepLocalName(stepOpCodePos); 	TokenNameCOMMENT_LINE	String localname = compiler.getStepLocalName(stepOpCodePos); 
// boolean isWild = (null != localname) ? localname.equals(NodeTest.WILD) : false; 	TokenNameCOMMENT_LINE	boolean isWild = (null != localname) ? localname.equals(NodeTest.WILD) : false; 
boolean	TokenNameboolean	
predAnalysis	TokenNameIdentifier	 pred Analysis
=	TokenNameEQUAL	
analyzePredicate	TokenNameIdentifier	 analyze Predicate
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
,	TokenNameCOMMA	
stepType	TokenNameIdentifier	 step Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
predAnalysis	TokenNameIdentifier	 pred Analysis
)	TokenNameRPAREN	
analysisResult	TokenNameIdentifier	 analysis Result
|=	TokenNameOR_EQUAL	
BIT_PREDICATE	TokenNameIdentifier	 BIT  PREDICATE
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
stepType	TokenNameIdentifier	 step Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_VARIABLE	TokenNameIdentifier	 OP  VARIABLE
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_EXTFUNCTION	TokenNameIdentifier	 OP  EXTFUNCTION
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_FUNCTION	TokenNameIdentifier	 OP  FUNCTION
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_GROUP	TokenNameIdentifier	 OP  GROUP
:	TokenNameCOLON	
analysisResult	TokenNameIdentifier	 analysis Result
|=	TokenNameOR_EQUAL	
BIT_FILTER	TokenNameIdentifier	 BIT  FILTER
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_ROOT	TokenNameIdentifier	 FROM  ROOT
:	TokenNameCOLON	
analysisResult	TokenNameIdentifier	 analysis Result
|=	TokenNameOR_EQUAL	
BIT_ROOT	TokenNameIdentifier	 BIT  ROOT
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_ANCESTORS	TokenNameIdentifier	 FROM  ANCESTORS
:	TokenNameCOLON	
analysisResult	TokenNameIdentifier	 analysis Result
|=	TokenNameOR_EQUAL	
BIT_ANCESTOR	TokenNameIdentifier	 BIT  ANCESTOR
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_ANCESTORS_OR_SELF	TokenNameIdentifier	 FROM  ANCESTORS  OR  SELF
:	TokenNameCOLON	
analysisResult	TokenNameIdentifier	 analysis Result
|=	TokenNameOR_EQUAL	
BIT_ANCESTOR_OR_SELF	TokenNameIdentifier	 BIT  ANCESTOR  OR  SELF
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_ATTRIBUTES	TokenNameIdentifier	 FROM  ATTRIBUTES
:	TokenNameCOLON	
analysisResult	TokenNameIdentifier	 analysis Result
|=	TokenNameOR_EQUAL	
BIT_ATTRIBUTE	TokenNameIdentifier	 BIT  ATTRIBUTE
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_NAMESPACE	TokenNameIdentifier	 FROM  NAMESPACE
:	TokenNameCOLON	
analysisResult	TokenNameIdentifier	 analysis Result
|=	TokenNameOR_EQUAL	
BIT_NAMESPACE	TokenNameIdentifier	 BIT  NAMESPACE
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_CHILDREN	TokenNameIdentifier	 FROM  CHILDREN
:	TokenNameCOLON	
analysisResult	TokenNameIdentifier	 analysis Result
|=	TokenNameOR_EQUAL	
BIT_CHILD	TokenNameIdentifier	 BIT  CHILD
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_DESCENDANTS	TokenNameIdentifier	 FROM  DESCENDANTS
:	TokenNameCOLON	
analysisResult	TokenNameIdentifier	 analysis Result
|=	TokenNameOR_EQUAL	
BIT_DESCENDANT	TokenNameIdentifier	 BIT  DESCENDANT
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_DESCENDANTS_OR_SELF	TokenNameIdentifier	 FROM  DESCENDANTS  OR  SELF
:	TokenNameCOLON	
// Use a special bit to to make sure we get the right analysis of "//foo". 	TokenNameCOMMENT_LINE	Use a special bit to to make sure we get the right analysis of "//foo". 
if	TokenNameif	
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
==	TokenNameEQUAL_EQUAL	
stepCount	TokenNameIdentifier	 step Count
&&	TokenNameAND_AND	
BIT_ROOT	TokenNameIdentifier	 BIT  ROOT
==	TokenNameEQUAL_EQUAL	
analysisResult	TokenNameIdentifier	 analysis Result
)	TokenNameRPAREN	
{	TokenNameLBRACE	
analysisResult	TokenNameIdentifier	 analysis Result
|=	TokenNameOR_EQUAL	
BIT_ANY_DESCENDANT_FROM_ROOT	TokenNameIdentifier	 BIT  ANY  DESCENDANT  FROM  ROOT
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
analysisResult	TokenNameIdentifier	 analysis Result
|=	TokenNameOR_EQUAL	
BIT_DESCENDANT_OR_SELF	TokenNameIdentifier	 BIT  DESCENDANT  OR  SELF
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_FOLLOWING	TokenNameIdentifier	 FROM  FOLLOWING
:	TokenNameCOLON	
analysisResult	TokenNameIdentifier	 analysis Result
|=	TokenNameOR_EQUAL	
BIT_FOLLOWING	TokenNameIdentifier	 BIT  FOLLOWING
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_FOLLOWING_SIBLINGS	TokenNameIdentifier	 FROM  FOLLOWING  SIBLINGS
:	TokenNameCOLON	
analysisResult	TokenNameIdentifier	 analysis Result
|=	TokenNameOR_EQUAL	
BIT_FOLLOWING_SIBLING	TokenNameIdentifier	 BIT  FOLLOWING  SIBLING
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_PRECEDING	TokenNameIdentifier	 FROM  PRECEDING
:	TokenNameCOLON	
analysisResult	TokenNameIdentifier	 analysis Result
|=	TokenNameOR_EQUAL	
BIT_PRECEDING	TokenNameIdentifier	 BIT  PRECEDING
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_PRECEDING_SIBLINGS	TokenNameIdentifier	 FROM  PRECEDING  SIBLINGS
:	TokenNameCOLON	
analysisResult	TokenNameIdentifier	 analysis Result
|=	TokenNameOR_EQUAL	
BIT_PRECEDING_SIBLING	TokenNameIdentifier	 BIT  PRECEDING  SIBLING
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_PARENT	TokenNameIdentifier	 FROM  PARENT
:	TokenNameCOLON	
analysisResult	TokenNameIdentifier	 analysis Result
|=	TokenNameOR_EQUAL	
BIT_PARENT	TokenNameIdentifier	 BIT  PARENT
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_SELF	TokenNameIdentifier	 FROM  SELF
:	TokenNameCOLON	
analysisResult	TokenNameIdentifier	 analysis Result
|=	TokenNameOR_EQUAL	
BIT_SELF	TokenNameIdentifier	 BIT  SELF
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
MATCH_ATTRIBUTE	TokenNameIdentifier	 MATCH  ATTRIBUTE
:	TokenNameCOLON	
analysisResult	TokenNameIdentifier	 analysis Result
|=	TokenNameOR_EQUAL	
(	TokenNameLPAREN	
BIT_MATCH_PATTERN	TokenNameIdentifier	 BIT  MATCH  PATTERN
|	TokenNameOR	
BIT_ATTRIBUTE	TokenNameIdentifier	 BIT  ATTRIBUTE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
MATCH_ANY_ANCESTOR	TokenNameIdentifier	 MATCH  ANY  ANCESTOR
:	TokenNameCOLON	
analysisResult	TokenNameIdentifier	 analysis Result
|=	TokenNameOR_EQUAL	
(	TokenNameLPAREN	
BIT_MATCH_PATTERN	TokenNameIdentifier	 BIT  MATCH  PATTERN
|	TokenNameOR	
BIT_ANCESTOR	TokenNameIdentifier	 BIT  ANCESTOR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
MATCH_IMMEDIATE_ANCESTOR	TokenNameIdentifier	 MATCH  IMMEDIATE  ANCESTOR
:	TokenNameCOLON	
analysisResult	TokenNameIdentifier	 analysis Result
|=	TokenNameOR_EQUAL	
(	TokenNameLPAREN	
BIT_MATCH_PATTERN	TokenNameIdentifier	 BIT  MATCH  PATTERN
|	TokenNameOR	
BIT_PARENT	TokenNameIdentifier	 BIT  PARENT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
XSLMessages	TokenNameIdentifier	 XSL Messages
.	TokenNameDOT	
createXPATHMessage	TokenNameIdentifier	 create XPATH Message
(	TokenNameLPAREN	
XPATHErrorResources	TokenNameIdentifier	 XPATH Error Resources
.	TokenNameDOT	
ER_NULL_ERROR_HANDLER	TokenNameIdentifier	 ER  NULL  ERROR  HANDLER
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
stepType	TokenNameIdentifier	 step Type
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//"Programmer's assertion: unknown opcode: " 	TokenNameCOMMENT_LINE	"Programmer's assertion: unknown opcode: " 
//+ stepType); 	TokenNameCOMMENT_LINE	+ stepType); 
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
NODETYPE_NODE	TokenNameIdentifier	 NODETYPE  NODE
==	TokenNameEQUAL_EQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getOp	TokenNameIdentifier	 get Op
(	TokenNameLPAREN	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
+	TokenNamePLUS	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
// child::node() 	TokenNameCOMMENT_LINE	child::node() 
{	TokenNameLBRACE	
analysisResult	TokenNameIdentifier	 analysis Result
|=	TokenNameOR_EQUAL	
BIT_NODETEST_ANY	TokenNameIdentifier	 BIT  NODETEST  ANY
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getNextStepPos	TokenNameIdentifier	 get Next Step Pos
(	TokenNameLPAREN	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
analysisResult	TokenNameIdentifier	 analysis Result
|=	TokenNameOR_EQUAL	
(	TokenNameLPAREN	
stepCount	TokenNameIdentifier	 step Count
&	TokenNameAND	
BITS_COUNT	TokenNameIdentifier	 BITS  COUNT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
analysisResult	TokenNameIdentifier	 analysis Result
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Tell if the given axis goes downword. Bogus name, if you can think of * a better one, please do tell. This really has to do with inverting * attribute axis. * @param axis One of Axis.XXX. * @return true if the axis is not a child axis and does not go up from * the axis root. */	TokenNameCOMMENT_JAVADOC	 Tell if the given axis goes downword. Bogus name, if you can think of a better one, please do tell. This really has to do with inverting attribute axis. @param axis One of Axis.XXX. @return true if the axis is not a child axis and does not go up from the axis root. 
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
isDownwardAxisOfMany	TokenNameIdentifier	 is Downward Axis Of Many
(	TokenNameLPAREN	
int	TokenNameint	
axis	TokenNameIdentifier	 axis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
DESCENDANTORSELF	TokenNameIdentifier	 DESCENDANTORSELF
==	TokenNameEQUAL_EQUAL	
axis	TokenNameIdentifier	 axis
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
DESCENDANT	TokenNameIdentifier	 DESCENDANT
==	TokenNameEQUAL_EQUAL	
axis	TokenNameIdentifier	 axis
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
FOLLOWING	TokenNameIdentifier	 FOLLOWING
==	TokenNameEQUAL_EQUAL	
axis	TokenNameIdentifier	 axis
)	TokenNameRPAREN	
// || (Axis.FOLLOWINGSIBLING == axis) 	TokenNameCOMMENT_LINE	|| (Axis.FOLLOWINGSIBLING == axis) 
||	TokenNameOR_OR	
(	TokenNameLPAREN	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
PRECEDING	TokenNameIdentifier	 PRECEDING
==	TokenNameEQUAL_EQUAL	
axis	TokenNameIdentifier	 axis
)	TokenNameRPAREN	
// || (Axis.PRECEDINGSIBLING == axis) 	TokenNameCOMMENT_LINE	|| (Axis.PRECEDINGSIBLING == axis) 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Read a <a href="http://www.w3.org/TR/xpath#location-paths">LocationPath</a> * as a generalized match pattern. What this means is that the LocationPath * is read backwards, as a test on a given node, to see if it matches the * criteria of the selection, and ends up at the context node. Essentially, * this is a backwards query from a given node, to find the context node. * <p>So, the selection "foo/daz[2]" is, in non-abreviated expanded syntax, * "self::node()/following-sibling::foo/child::daz[position()=2]". * Taking this as a match pattern for a probable node, it works out to * "self::daz/parent::foo[child::daz[position()=2 and isPrevStepNode()] * precedingSibling::node()[isContextNodeOfLocationPath()]", adding magic * isPrevStepNode and isContextNodeOfLocationPath operations. Predicates in * the location path have to be executed by the following step, * because they have to know the context of their execution. * * @param mpi The MatchPatternIterator to which the steps will be attached. * @param compiler The compiler that holds the syntax tree/op map to * construct from. * @param stepOpCodePos The current op code position within the opmap. * @param stepIndex The top-level step index withing the iterator. * * @return A StepPattern object, which may contain relative StepPatterns. * * @throws javax.xml.transform.TransformerException */	TokenNameCOMMENT_JAVADOC	 Read a <a href="http://www.w3.org/TR/xpath#location-paths">LocationPath</a> as a generalized match pattern. What this means is that the LocationPath is read backwards, as a test on a given node, to see if it matches the criteria of the selection, and ends up at the context node. Essentially, this is a backwards query from a given node, to find the context node. <p>So, the selection "foo/daz[2]" is, in non-abreviated expanded syntax, "self::node()/following-sibling::foo/child::daz[position()=2]". Taking this as a match pattern for a probable node, it works out to "self::daz/parent::foo[child::daz[position()=2 and isPrevStepNode()] precedingSibling::node()[isContextNodeOfLocationPath()]", adding magic isPrevStepNode and isContextNodeOfLocationPath operations. Predicates in the location path have to be executed by the following step, because they have to know the context of their execution. * @param mpi The MatchPatternIterator to which the steps will be attached. @param compiler The compiler that holds the syntax tree/op map to construct from. @param stepOpCodePos The current op code position within the opmap. @param stepIndex The top-level step index withing the iterator. * @return A StepPattern object, which may contain relative StepPatterns. * @throws javax.xml.transform.TransformerException 
static	TokenNamestatic	
StepPattern	TokenNameIdentifier	 Step Pattern
loadSteps	TokenNameIdentifier	 load Steps
(	TokenNameLPAREN	
MatchPatternIterator	TokenNameIdentifier	 Match Pattern Iterator
mpi	TokenNameIdentifier	 mpi
,	TokenNameCOMMA	
Compiler	TokenNameIdentifier	 Compiler
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
int	TokenNameint	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
,	TokenNameCOMMA	
int	TokenNameint	
stepIndex	TokenNameIdentifier	 step Index
)	TokenNameRPAREN	
throws	TokenNamethrows	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
TransformerException	TokenNameIdentifier	 Transformer Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG_PATTERN_CREATION	TokenNameIdentifier	 DEBUG  PATTERN  CREATION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"================"	TokenNameStringLiteral	================
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"loadSteps for: "	TokenNameStringLiteral	loadSteps for: 
+	TokenNamePLUS	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getPatternString	TokenNameIdentifier	 get Pattern String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
stepType	TokenNameIdentifier	 step Type
;	TokenNameSEMICOLON	
StepPattern	TokenNameIdentifier	 Step Pattern
step	TokenNameIdentifier	 step
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
StepPattern	TokenNameIdentifier	 Step Pattern
firstStep	TokenNameIdentifier	 first Step
=	TokenNameEQUAL	
null	TokenNamenull	
,	TokenNameCOMMA	
prevStep	TokenNameIdentifier	 prev Step
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
=	TokenNameEQUAL	
analyze	TokenNameIdentifier	 analyze
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
,	TokenNameCOMMA	
stepIndex	TokenNameIdentifier	 step Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
ENDOP	TokenNameIdentifier	 ENDOP
!=	TokenNameNOT_EQUAL	
(	TokenNameLPAREN	
stepType	TokenNameIdentifier	 step Type
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getOp	TokenNameIdentifier	 get Op
(	TokenNameLPAREN	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
step	TokenNameIdentifier	 step
=	TokenNameEQUAL	
createDefaultStepPattern	TokenNameIdentifier	 create Default Step Pattern
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
,	TokenNameCOMMA	
mpi	TokenNameIdentifier	 mpi
,	TokenNameCOMMA	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
firstStep	TokenNameIdentifier	 first Step
,	TokenNameCOMMA	
prevStep	TokenNameIdentifier	 prev Step
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
firstStep	TokenNameIdentifier	 first Step
)	TokenNameRPAREN	
{	TokenNameLBRACE	
firstStep	TokenNameIdentifier	 first Step
=	TokenNameEQUAL	
step	TokenNameIdentifier	 step
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
//prevStep.setNextWalker(step); 	TokenNameCOMMENT_LINE	prevStep.setNextWalker(step); 
step	TokenNameIdentifier	 step
.	TokenNameDOT	
setRelativePathPattern	TokenNameIdentifier	 set Relative Path Pattern
(	TokenNameLPAREN	
prevStep	TokenNameIdentifier	 prev Step
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
prevStep	TokenNameIdentifier	 prev Step
=	TokenNameEQUAL	
step	TokenNameIdentifier	 step
;	TokenNameSEMICOLON	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getNextStepPos	TokenNameIdentifier	 get Next Step Pos
(	TokenNameLPAREN	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
axis	TokenNameIdentifier	 axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
SELF	TokenNameIdentifier	 SELF
;	TokenNameSEMICOLON	
int	TokenNameint	
paxis	TokenNameIdentifier	 paxis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
SELF	TokenNameIdentifier	 SELF
;	TokenNameSEMICOLON	
StepPattern	TokenNameIdentifier	 Step Pattern
tail	TokenNameIdentifier	 tail
=	TokenNameEQUAL	
step	TokenNameIdentifier	 step
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
StepPattern	TokenNameIdentifier	 Step Pattern
pat	TokenNameIdentifier	 pat
=	TokenNameEQUAL	
step	TokenNameIdentifier	 step
;	TokenNameSEMICOLON	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
pat	TokenNameIdentifier	 pat
;	TokenNameSEMICOLON	
pat	TokenNameIdentifier	 pat
=	TokenNameEQUAL	
pat	TokenNameIdentifier	 pat
.	TokenNameDOT	
getRelativePathPattern	TokenNameIdentifier	 get Relative Path Pattern
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
nextAxis	TokenNameIdentifier	 next Axis
=	TokenNameEQUAL	
pat	TokenNameIdentifier	 pat
.	TokenNameDOT	
getAxis	TokenNameIdentifier	 get Axis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//int nextPaxis = pat.getPredicateAxis(); 	TokenNameCOMMENT_LINE	int nextPaxis = pat.getPredicateAxis(); 
pat	TokenNameIdentifier	 pat
.	TokenNameDOT	
setAxis	TokenNameIdentifier	 set Axis
(	TokenNameLPAREN	
axis	TokenNameIdentifier	 axis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// The predicate axis can't be moved!!! Test Axes103 	TokenNameCOMMENT_LINE	The predicate axis can't be moved!!! Test Axes103 
// pat.setPredicateAxis(paxis); 	TokenNameCOMMENT_LINE	pat.setPredicateAxis(paxis); 
// If we have an attribute or namespace axis that went up, then 	TokenNameCOMMENT_LINE	If we have an attribute or namespace axis that went up, then 
// it won't find the attribute in the inverse, since the select-to-match 	TokenNameCOMMENT_LINE	it won't find the attribute in the inverse, since the select-to-match 
// axes are not invertable (an element is a parent of an attribute, but 	TokenNameCOMMENT_LINE	axes are not invertable (an element is a parent of an attribute, but 
// and attribute is not a child of an element). 	TokenNameCOMMENT_LINE	and attribute is not a child of an element). 
// If we don't do the magic below, then "@*/ancestor-or-self::*" gets 	TokenNameCOMMENT_LINE	If we don't do the magic below, then "@*/ancestor-or-self::*" gets 
// inverted for match to "self::*/descendant-or-self::@*/parent::node()", 	TokenNameCOMMENT_LINE	inverted for match to "self::*/descendant-or-self::@*/parent::node()", 
// which obviously won't work. 	TokenNameCOMMENT_LINE	which obviously won't work. 
// So we will rewrite this as: 	TokenNameCOMMENT_LINE	So we will rewrite this as: 
// "self::*/descendant-or-self::*/attribute::*/parent::node()" 	TokenNameCOMMENT_LINE	"self::*/descendant-or-self::*/attribute::*/parent::node()" 
// Child has to be rewritten a little differently: 	TokenNameCOMMENT_LINE	Child has to be rewritten a little differently: 
// select: "@*/parent::*" 	TokenNameCOMMENT_LINE	select: "@*/parent::*" 
// inverted match: "self::*/child::@*/parent::node()" 	TokenNameCOMMENT_LINE	inverted match: "self::*/child::@*/parent::node()" 
// rewrite: "self::*/attribute::*/parent::node()" 	TokenNameCOMMENT_LINE	rewrite: "self::*/attribute::*/parent::node()" 
// Axes that go down in the select, do not have to have special treatment 	TokenNameCOMMENT_LINE	Axes that go down in the select, do not have to have special treatment 
// in the rewrite. The following inverted match will still not select 	TokenNameCOMMENT_LINE	in the rewrite. The following inverted match will still not select 
// anything. 	TokenNameCOMMENT_LINE	anything. 
// select: "@*/child::*" 	TokenNameCOMMENT_LINE	select: "@*/child::*" 
// inverted match: "self::*/parent::@*/parent::node()" 	TokenNameCOMMENT_LINE	inverted match: "self::*/parent::@*/parent::node()" 
// Lovely business, this. 	TokenNameCOMMENT_LINE	Lovely business, this. 
// -sb 	TokenNameCOMMENT_LINE	-sb 
int	TokenNameint	
whatToShow	TokenNameIdentifier	 what To Show
=	TokenNameEQUAL	
pat	TokenNameIdentifier	 pat
.	TokenNameDOT	
getWhatToShow	TokenNameIdentifier	 get What To Show
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
whatToShow	TokenNameIdentifier	 what To Show
==	TokenNameEQUAL_EQUAL	
DTMFilter	TokenNameIdentifier	 DTM Filter
.	TokenNameDOT	
SHOW_ATTRIBUTE	TokenNameIdentifier	 SHOW  ATTRIBUTE
||	TokenNameOR_OR	
whatToShow	TokenNameIdentifier	 what To Show
==	TokenNameEQUAL_EQUAL	
DTMFilter	TokenNameIdentifier	 DTM Filter
.	TokenNameDOT	
SHOW_NAMESPACE	TokenNameIdentifier	 SHOW  NAMESPACE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
newAxis	TokenNameIdentifier	 new Axis
=	TokenNameEQUAL	
(	TokenNameLPAREN	
whatToShow	TokenNameIdentifier	 what To Show
==	TokenNameEQUAL_EQUAL	
DTMFilter	TokenNameIdentifier	 DTM Filter
.	TokenNameDOT	
SHOW_ATTRIBUTE	TokenNameIdentifier	 SHOW  ATTRIBUTE
)	TokenNameRPAREN	
?	TokenNameQUESTION	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
ATTRIBUTE	TokenNameIdentifier	 ATTRIBUTE
:	TokenNameCOLON	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
NAMESPACE	TokenNameIdentifier	 NAMESPACE
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isDownwardAxisOfMany	TokenNameIdentifier	 is Downward Axis Of Many
(	TokenNameLPAREN	
axis	TokenNameIdentifier	 axis
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StepPattern	TokenNameIdentifier	 Step Pattern
attrPat	TokenNameIdentifier	 attr Pat
=	TokenNameEQUAL	
new	TokenNamenew	
StepPattern	TokenNameIdentifier	 Step Pattern
(	TokenNameLPAREN	
whatToShow	TokenNameIdentifier	 what To Show
,	TokenNameCOMMA	
pat	TokenNameIdentifier	 pat
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
pat	TokenNameIdentifier	 pat
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
//newAxis, pat.getPredicateAxis); 	TokenNameCOMMENT_LINE	newAxis, pat.getPredicateAxis); 
newAxis	TokenNameIdentifier	 new Axis
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// don't care about the predicate axis 	TokenNameCOMMENT_LINE	don't care about the predicate axis 
XNumber	TokenNameIdentifier	 X Number
score	TokenNameIdentifier	 score
=	TokenNameEQUAL	
pat	TokenNameIdentifier	 pat
.	TokenNameDOT	
getStaticScore	TokenNameIdentifier	 get Static Score
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pat	TokenNameIdentifier	 pat
.	TokenNameDOT	
setNamespace	TokenNameIdentifier	 set Namespace
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pat	TokenNameIdentifier	 pat
.	TokenNameDOT	
setLocalName	TokenNameIdentifier	 set Local Name
(	TokenNameLPAREN	
NodeTest	TokenNameIdentifier	 Node Test
.	TokenNameDOT	
WILD	TokenNameIdentifier	 WILD
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
attrPat	TokenNameIdentifier	 attr Pat
.	TokenNameDOT	
setPredicates	TokenNameIdentifier	 set Predicates
(	TokenNameLPAREN	
pat	TokenNameIdentifier	 pat
.	TokenNameDOT	
getPredicates	TokenNameIdentifier	 get Predicates
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pat	TokenNameIdentifier	 pat
.	TokenNameDOT	
setPredicates	TokenNameIdentifier	 set Predicates
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pat	TokenNameIdentifier	 pat
.	TokenNameDOT	
setWhatToShow	TokenNameIdentifier	 set What To Show
(	TokenNameLPAREN	
DTMFilter	TokenNameIdentifier	 DTM Filter
.	TokenNameDOT	
SHOW_ELEMENT	TokenNameIdentifier	 SHOW  ELEMENT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
StepPattern	TokenNameIdentifier	 Step Pattern
rel	TokenNameIdentifier	 rel
=	TokenNameEQUAL	
pat	TokenNameIdentifier	 pat
.	TokenNameDOT	
getRelativePathPattern	TokenNameIdentifier	 get Relative Path Pattern
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pat	TokenNameIdentifier	 pat
.	TokenNameDOT	
setRelativePathPattern	TokenNameIdentifier	 set Relative Path Pattern
(	TokenNameLPAREN	
attrPat	TokenNameIdentifier	 attr Pat
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
attrPat	TokenNameIdentifier	 attr Pat
.	TokenNameDOT	
setRelativePathPattern	TokenNameIdentifier	 set Relative Path Pattern
(	TokenNameLPAREN	
rel	TokenNameIdentifier	 rel
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
attrPat	TokenNameIdentifier	 attr Pat
.	TokenNameDOT	
setStaticScore	TokenNameIdentifier	 set Static Score
(	TokenNameLPAREN	
score	TokenNameIdentifier	 score
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// This is needed to inverse a following pattern, because of the 	TokenNameCOMMENT_LINE	This is needed to inverse a following pattern, because of the 
// wacky Xalan rules for following from an attribute. See axes108. 	TokenNameCOMMENT_LINE	wacky Xalan rules for following from an attribute. See axes108. 
// By these rules, following from an attribute is not strictly 	TokenNameCOMMENT_LINE	By these rules, following from an attribute is not strictly 
// inverseable. 	TokenNameCOMMENT_LINE	inverseable. 
if	TokenNameif	
(	TokenNameLPAREN	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
PRECEDING	TokenNameIdentifier	 PRECEDING
==	TokenNameEQUAL_EQUAL	
pat	TokenNameIdentifier	 pat
.	TokenNameDOT	
getAxis	TokenNameIdentifier	 get Axis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
pat	TokenNameIdentifier	 pat
.	TokenNameDOT	
setAxis	TokenNameIdentifier	 set Axis
(	TokenNameLPAREN	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
PRECEDINGANDANCESTOR	TokenNameIdentifier	 PRECEDINGANDANCESTOR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
DESCENDANT	TokenNameIdentifier	 DESCENDANT
==	TokenNameEQUAL_EQUAL	
pat	TokenNameIdentifier	 pat
.	TokenNameDOT	
getAxis	TokenNameIdentifier	 get Axis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
pat	TokenNameIdentifier	 pat
.	TokenNameDOT	
setAxis	TokenNameIdentifier	 set Axis
(	TokenNameLPAREN	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
DESCENDANTORSELF	TokenNameIdentifier	 DESCENDANTORSELF
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pat	TokenNameIdentifier	 pat
=	TokenNameEQUAL	
attrPat	TokenNameIdentifier	 attr Pat
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
CHILD	TokenNameIdentifier	 CHILD
==	TokenNameEQUAL_EQUAL	
pat	TokenNameIdentifier	 pat
.	TokenNameDOT	
getAxis	TokenNameIdentifier	 get Axis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// In this case just change the axis. 	TokenNameCOMMENT_LINE	In this case just change the axis. 
// pat.setWhatToShow(whatToShow); 	TokenNameCOMMENT_LINE	pat.setWhatToShow(whatToShow); 
pat	TokenNameIdentifier	 pat
.	TokenNameDOT	
setAxis	TokenNameIdentifier	 set Axis
(	TokenNameLPAREN	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
ATTRIBUTE	TokenNameIdentifier	 ATTRIBUTE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
axis	TokenNameIdentifier	 axis
=	TokenNameEQUAL	
nextAxis	TokenNameIdentifier	 next Axis
;	TokenNameSEMICOLON	
//paxis = nextPaxis; 	TokenNameCOMMENT_LINE	paxis = nextPaxis; 
tail	TokenNameIdentifier	 tail
=	TokenNameEQUAL	
pat	TokenNameIdentifier	 pat
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
axis	TokenNameIdentifier	 axis
<	TokenNameLESS	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
ALL	TokenNameIdentifier	 ALL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StepPattern	TokenNameIdentifier	 Step Pattern
selfPattern	TokenNameIdentifier	 self Pattern
=	TokenNameEQUAL	
new	TokenNamenew	
ContextMatchStepPattern	TokenNameIdentifier	 Context Match Step Pattern
(	TokenNameLPAREN	
axis	TokenNameIdentifier	 axis
,	TokenNameCOMMA	
paxis	TokenNameIdentifier	 paxis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// We need to keep the new nodetest from affecting the score... 	TokenNameCOMMENT_LINE	We need to keep the new nodetest from affecting the score... 
XNumber	TokenNameIdentifier	 X Number
score	TokenNameIdentifier	 score
=	TokenNameEQUAL	
tail	TokenNameIdentifier	 tail
.	TokenNameDOT	
getStaticScore	TokenNameIdentifier	 get Static Score
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tail	TokenNameIdentifier	 tail
.	TokenNameDOT	
setRelativePathPattern	TokenNameIdentifier	 set Relative Path Pattern
(	TokenNameLPAREN	
selfPattern	TokenNameIdentifier	 self Pattern
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tail	TokenNameIdentifier	 tail
.	TokenNameDOT	
setStaticScore	TokenNameIdentifier	 set Static Score
(	TokenNameLPAREN	
score	TokenNameIdentifier	 score
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
selfPattern	TokenNameIdentifier	 self Pattern
.	TokenNameDOT	
setStaticScore	TokenNameIdentifier	 set Static Score
(	TokenNameLPAREN	
score	TokenNameIdentifier	 score
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG_PATTERN_CREATION	TokenNameIdentifier	 DEBUG  PATTERN  CREATION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Done loading steps: "	TokenNameStringLiteral	Done loading steps: 
+	TokenNamePLUS	
step	TokenNameIdentifier	 step
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
step	TokenNameIdentifier	 step
;	TokenNameSEMICOLON	
// start from last pattern?? //firstStep; 	TokenNameCOMMENT_LINE	start from last pattern?? //firstStep; 
}	TokenNameRBRACE	
/** * Create a StepPattern that is contained within a LocationPath. * * * @param compiler The compiler that holds the syntax tree/op map to * construct from. * @param stepOpCodePos The current op code position within the opmap. * @param mpi The MatchPatternIterator to which the steps will be attached. * @param analysis 32 bits of analysis, from which the type of AxesWalker * may be influenced. * @param tail The step that is the first step analyzed, but the last * step in the relative match linked list, i.e. the tail. * May be null. * @param head The step that is the current head of the relative * match step linked list. * May be null. * * @return the head of the list. * * @throws javax.xml.transform.TransformerException */	TokenNameCOMMENT_JAVADOC	 Create a StepPattern that is contained within a LocationPath. * @param compiler The compiler that holds the syntax tree/op map to construct from. @param stepOpCodePos The current op code position within the opmap. @param mpi The MatchPatternIterator to which the steps will be attached. @param analysis 32 bits of analysis, from which the type of AxesWalker may be influenced. @param tail The step that is the first step analyzed, but the last step in the relative match linked list, i.e. the tail. May be null. @param head The step that is the current head of the relative match step linked list. May be null. * @return the head of the list. * @throws javax.xml.transform.TransformerException 
private	TokenNameprivate	
static	TokenNamestatic	
StepPattern	TokenNameIdentifier	 Step Pattern
createDefaultStepPattern	TokenNameIdentifier	 create Default Step Pattern
(	TokenNameLPAREN	
Compiler	TokenNameIdentifier	 Compiler
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
int	TokenNameint	
opPos	TokenNameIdentifier	 op Pos
,	TokenNameCOMMA	
MatchPatternIterator	TokenNameIdentifier	 Match Pattern Iterator
mpi	TokenNameIdentifier	 mpi
,	TokenNameCOMMA	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
StepPattern	TokenNameIdentifier	 Step Pattern
tail	TokenNameIdentifier	 tail
,	TokenNameCOMMA	
StepPattern	TokenNameIdentifier	 Step Pattern
head	TokenNameIdentifier	 head
)	TokenNameRPAREN	
throws	TokenNamethrows	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
TransformerException	TokenNameIdentifier	 Transformer Exception
{	TokenNameLBRACE	
int	TokenNameint	
stepType	TokenNameIdentifier	 step Type
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getOp	TokenNameIdentifier	 get Op
(	TokenNameLPAREN	
opPos	TokenNameIdentifier	 op Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
simpleInit	TokenNameIdentifier	 simple Init
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
prevIsOneStepDown	TokenNameIdentifier	 prev Is One Step Down
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
int	TokenNameint	
whatToShow	TokenNameIdentifier	 what To Show
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getWhatToShow	TokenNameIdentifier	 get What To Show
(	TokenNameLPAREN	
opPos	TokenNameIdentifier	 op Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
StepPattern	TokenNameIdentifier	 Step Pattern
ai	TokenNameIdentifier	 ai
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
axis	TokenNameIdentifier	 axis
,	TokenNameCOMMA	
predicateAxis	TokenNameIdentifier	 predicate Axis
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
stepType	TokenNameIdentifier	 step Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_VARIABLE	TokenNameIdentifier	 OP  VARIABLE
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_EXTFUNCTION	TokenNameIdentifier	 OP  EXTFUNCTION
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_FUNCTION	TokenNameIdentifier	 OP  FUNCTION
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_GROUP	TokenNameIdentifier	 OP  GROUP
:	TokenNameCOLON	
prevIsOneStepDown	TokenNameIdentifier	 prev Is One Step Down
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
Expression	TokenNameIdentifier	 Expression
expr	TokenNameIdentifier	 expr
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
stepType	TokenNameIdentifier	 step Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_VARIABLE	TokenNameIdentifier	 OP  VARIABLE
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_EXTFUNCTION	TokenNameIdentifier	 OP  EXTFUNCTION
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_FUNCTION	TokenNameIdentifier	 OP  FUNCTION
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_GROUP	TokenNameIdentifier	 OP  GROUP
:	TokenNameCOLON	
expr	TokenNameIdentifier	 expr
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
compile	TokenNameIdentifier	 compile
(	TokenNameLPAREN	
opPos	TokenNameIdentifier	 op Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
expr	TokenNameIdentifier	 expr
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
compile	TokenNameIdentifier	 compile
(	TokenNameLPAREN	
opPos	TokenNameIdentifier	 op Pos
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
axis	TokenNameIdentifier	 axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
FILTEREDLIST	TokenNameIdentifier	 FILTEREDLIST
;	TokenNameSEMICOLON	
predicateAxis	TokenNameIdentifier	 predicate Axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
FILTEREDLIST	TokenNameIdentifier	 FILTEREDLIST
;	TokenNameSEMICOLON	
ai	TokenNameIdentifier	 ai
=	TokenNameEQUAL	
new	TokenNamenew	
FunctionPattern	TokenNameIdentifier	 Function Pattern
(	TokenNameLPAREN	
expr	TokenNameIdentifier	 expr
,	TokenNameCOMMA	
axis	TokenNameIdentifier	 axis
,	TokenNameCOMMA	
predicateAxis	TokenNameIdentifier	 predicate Axis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
simpleInit	TokenNameIdentifier	 simple Init
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_ROOT	TokenNameIdentifier	 FROM  ROOT
:	TokenNameCOLON	
whatToShow	TokenNameIdentifier	 what To Show
=	TokenNameEQUAL	
DTMFilter	TokenNameIdentifier	 DTM Filter
.	TokenNameDOT	
SHOW_DOCUMENT	TokenNameIdentifier	 SHOW  DOCUMENT
|	TokenNameOR	
DTMFilter	TokenNameIdentifier	 DTM Filter
.	TokenNameDOT	
SHOW_DOCUMENT_FRAGMENT	TokenNameIdentifier	 SHOW  DOCUMENT  FRAGMENT
;	TokenNameSEMICOLON	
axis	TokenNameIdentifier	 axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
ROOT	TokenNameIdentifier	 ROOT
;	TokenNameSEMICOLON	
predicateAxis	TokenNameIdentifier	 predicate Axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
ROOT	TokenNameIdentifier	 ROOT
;	TokenNameSEMICOLON	
ai	TokenNameIdentifier	 ai
=	TokenNameEQUAL	
new	TokenNamenew	
StepPattern	TokenNameIdentifier	 Step Pattern
(	TokenNameLPAREN	
DTMFilter	TokenNameIdentifier	 DTM Filter
.	TokenNameDOT	
SHOW_DOCUMENT	TokenNameIdentifier	 SHOW  DOCUMENT
|	TokenNameOR	
DTMFilter	TokenNameIdentifier	 DTM Filter
.	TokenNameDOT	
SHOW_DOCUMENT_FRAGMENT	TokenNameIdentifier	 SHOW  DOCUMENT  FRAGMENT
,	TokenNameCOMMA	
axis	TokenNameIdentifier	 axis
,	TokenNameCOMMA	
predicateAxis	TokenNameIdentifier	 predicate Axis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_ATTRIBUTES	TokenNameIdentifier	 FROM  ATTRIBUTES
:	TokenNameCOLON	
whatToShow	TokenNameIdentifier	 what To Show
=	TokenNameEQUAL	
DTMFilter	TokenNameIdentifier	 DTM Filter
.	TokenNameDOT	
SHOW_ATTRIBUTE	TokenNameIdentifier	 SHOW  ATTRIBUTE
;	TokenNameSEMICOLON	
axis	TokenNameIdentifier	 axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
PARENT	TokenNameIdentifier	 PARENT
;	TokenNameSEMICOLON	
predicateAxis	TokenNameIdentifier	 predicate Axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
ATTRIBUTE	TokenNameIdentifier	 ATTRIBUTE
;	TokenNameSEMICOLON	
// ai = new StepPattern(whatToShow, Axis.SELF, Axis.SELF); 	TokenNameCOMMENT_LINE	ai = new StepPattern(whatToShow, Axis.SELF, Axis.SELF); 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_NAMESPACE	TokenNameIdentifier	 FROM  NAMESPACE
:	TokenNameCOLON	
whatToShow	TokenNameIdentifier	 what To Show
=	TokenNameEQUAL	
DTMFilter	TokenNameIdentifier	 DTM Filter
.	TokenNameDOT	
SHOW_NAMESPACE	TokenNameIdentifier	 SHOW  NAMESPACE
;	TokenNameSEMICOLON	
axis	TokenNameIdentifier	 axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
PARENT	TokenNameIdentifier	 PARENT
;	TokenNameSEMICOLON	
predicateAxis	TokenNameIdentifier	 predicate Axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
NAMESPACE	TokenNameIdentifier	 NAMESPACE
;	TokenNameSEMICOLON	
// ai = new StepPattern(whatToShow, axis, predicateAxis); 	TokenNameCOMMENT_LINE	ai = new StepPattern(whatToShow, axis, predicateAxis); 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_ANCESTORS	TokenNameIdentifier	 FROM  ANCESTORS
:	TokenNameCOLON	
axis	TokenNameIdentifier	 axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
DESCENDANT	TokenNameIdentifier	 DESCENDANT
;	TokenNameSEMICOLON	
predicateAxis	TokenNameIdentifier	 predicate Axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
ANCESTOR	TokenNameIdentifier	 ANCESTOR
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_CHILDREN	TokenNameIdentifier	 FROM  CHILDREN
:	TokenNameCOLON	
axis	TokenNameIdentifier	 axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
PARENT	TokenNameIdentifier	 PARENT
;	TokenNameSEMICOLON	
predicateAxis	TokenNameIdentifier	 predicate Axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
CHILD	TokenNameIdentifier	 CHILD
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_ANCESTORS_OR_SELF	TokenNameIdentifier	 FROM  ANCESTORS  OR  SELF
:	TokenNameCOLON	
axis	TokenNameIdentifier	 axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
DESCENDANTORSELF	TokenNameIdentifier	 DESCENDANTORSELF
;	TokenNameSEMICOLON	
predicateAxis	TokenNameIdentifier	 predicate Axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
ANCESTORORSELF	TokenNameIdentifier	 ANCESTORORSELF
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_SELF	TokenNameIdentifier	 FROM  SELF
:	TokenNameCOLON	
axis	TokenNameIdentifier	 axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
SELF	TokenNameIdentifier	 SELF
;	TokenNameSEMICOLON	
predicateAxis	TokenNameIdentifier	 predicate Axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
SELF	TokenNameIdentifier	 SELF
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_PARENT	TokenNameIdentifier	 FROM  PARENT
:	TokenNameCOLON	
axis	TokenNameIdentifier	 axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
CHILD	TokenNameIdentifier	 CHILD
;	TokenNameSEMICOLON	
predicateAxis	TokenNameIdentifier	 predicate Axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
PARENT	TokenNameIdentifier	 PARENT
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_PRECEDING_SIBLINGS	TokenNameIdentifier	 FROM  PRECEDING  SIBLINGS
:	TokenNameCOLON	
axis	TokenNameIdentifier	 axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
FOLLOWINGSIBLING	TokenNameIdentifier	 FOLLOWINGSIBLING
;	TokenNameSEMICOLON	
predicateAxis	TokenNameIdentifier	 predicate Axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
PRECEDINGSIBLING	TokenNameIdentifier	 PRECEDINGSIBLING
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_PRECEDING	TokenNameIdentifier	 FROM  PRECEDING
:	TokenNameCOLON	
axis	TokenNameIdentifier	 axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
FOLLOWING	TokenNameIdentifier	 FOLLOWING
;	TokenNameSEMICOLON	
predicateAxis	TokenNameIdentifier	 predicate Axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
PRECEDING	TokenNameIdentifier	 PRECEDING
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_FOLLOWING_SIBLINGS	TokenNameIdentifier	 FROM  FOLLOWING  SIBLINGS
:	TokenNameCOLON	
axis	TokenNameIdentifier	 axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
PRECEDINGSIBLING	TokenNameIdentifier	 PRECEDINGSIBLING
;	TokenNameSEMICOLON	
predicateAxis	TokenNameIdentifier	 predicate Axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
FOLLOWINGSIBLING	TokenNameIdentifier	 FOLLOWINGSIBLING
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_FOLLOWING	TokenNameIdentifier	 FROM  FOLLOWING
:	TokenNameCOLON	
axis	TokenNameIdentifier	 axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
PRECEDING	TokenNameIdentifier	 PRECEDING
;	TokenNameSEMICOLON	
predicateAxis	TokenNameIdentifier	 predicate Axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
FOLLOWING	TokenNameIdentifier	 FOLLOWING
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_DESCENDANTS_OR_SELF	TokenNameIdentifier	 FROM  DESCENDANTS  OR  SELF
:	TokenNameCOLON	
axis	TokenNameIdentifier	 axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
ANCESTORORSELF	TokenNameIdentifier	 ANCESTORORSELF
;	TokenNameSEMICOLON	
predicateAxis	TokenNameIdentifier	 predicate Axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
DESCENDANTORSELF	TokenNameIdentifier	 DESCENDANTORSELF
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_DESCENDANTS	TokenNameIdentifier	 FROM  DESCENDANTS
:	TokenNameCOLON	
axis	TokenNameIdentifier	 axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
ANCESTOR	TokenNameIdentifier	 ANCESTOR
;	TokenNameSEMICOLON	
predicateAxis	TokenNameIdentifier	 predicate Axis
=	TokenNameEQUAL	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
DESCENDANT	TokenNameIdentifier	 DESCENDANT
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
XSLMessages	TokenNameIdentifier	 XSL Messages
.	TokenNameDOT	
createXPATHMessage	TokenNameIdentifier	 create XPATH Message
(	TokenNameLPAREN	
XPATHErrorResources	TokenNameIdentifier	 XPATH Error Resources
.	TokenNameDOT	
ER_NULL_ERROR_HANDLER	TokenNameIdentifier	 ER  NULL  ERROR  HANDLER
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
stepType	TokenNameIdentifier	 step Type
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//"Programmer's assertion: unknown opcode: " 	TokenNameCOMMENT_LINE	"Programmer's assertion: unknown opcode: " 
//+ stepType); 	TokenNameCOMMENT_LINE	+ stepType); 
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
ai	TokenNameIdentifier	 ai
)	TokenNameRPAREN	
{	TokenNameLBRACE	
whatToShow	TokenNameIdentifier	 what To Show
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getWhatToShow	TokenNameIdentifier	 get What To Show
(	TokenNameLPAREN	
opPos	TokenNameIdentifier	 op Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// %REVIEW% 	TokenNameCOMMENT_LINE	%REVIEW% 
ai	TokenNameIdentifier	 ai
=	TokenNameEQUAL	
new	TokenNamenew	
StepPattern	TokenNameIdentifier	 Step Pattern
(	TokenNameLPAREN	
whatToShow	TokenNameIdentifier	 what To Show
,	TokenNameCOMMA	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getStepNS	TokenNameIdentifier	 get Step NS
(	TokenNameLPAREN	
opPos	TokenNameIdentifier	 op Pos
)	TokenNameRPAREN	
,	TokenNameCOMMA	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getStepLocalName	TokenNameIdentifier	 get Step Local Name
(	TokenNameLPAREN	
opPos	TokenNameIdentifier	 op Pos
)	TokenNameRPAREN	
,	TokenNameCOMMA	
axis	TokenNameIdentifier	 axis
,	TokenNameCOMMA	
predicateAxis	TokenNameIdentifier	 predicate Axis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
false	TokenNamefalse	
||	TokenNameOR_OR	
DEBUG_PATTERN_CREATION	TokenNameIdentifier	 DEBUG  PATTERN  CREATION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
"new step: "	TokenNameStringLiteral	new step: 
+	TokenNamePLUS	
ai	TokenNameIdentifier	 ai
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
", axis: "	TokenNameStringLiteral	, axis: 
+	TokenNamePLUS	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
getNames	TokenNameIdentifier	 get Names
(	TokenNameLPAREN	
ai	TokenNameIdentifier	 ai
.	TokenNameDOT	
getAxis	TokenNameIdentifier	 get Axis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
", predAxis: "	TokenNameStringLiteral	, predAxis: 
+	TokenNamePLUS	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
getNames	TokenNameIdentifier	 get Names
(	TokenNameLPAREN	
ai	TokenNameIdentifier	 ai
.	TokenNameDOT	
getAxis	TokenNameIdentifier	 get Axis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
", what: "	TokenNameStringLiteral	, what: 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
" "	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ai	TokenNameIdentifier	 ai
.	TokenNameDOT	
debugWhatToShow	TokenNameIdentifier	 debug What To Show
(	TokenNameLPAREN	
ai	TokenNameIdentifier	 ai
.	TokenNameDOT	
getWhatToShow	TokenNameIdentifier	 get What To Show
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
argLen	TokenNameIdentifier	 arg Len
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getFirstPredicateOpPos	TokenNameIdentifier	 get First Predicate Op Pos
(	TokenNameLPAREN	
opPos	TokenNameIdentifier	 op Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ai	TokenNameIdentifier	 ai
.	TokenNameDOT	
setPredicates	TokenNameIdentifier	 set Predicates
(	TokenNameLPAREN	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getCompiledPredicates	TokenNameIdentifier	 get Compiled Predicates
(	TokenNameLPAREN	
argLen	TokenNameIdentifier	 arg Len
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
ai	TokenNameIdentifier	 ai
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Analyze a step and give information about it's predicates. Right now this * just returns true or false if the step has a predicate. * * @param compiler non-null reference to compiler object that has processed * the XPath operations into an opcode map. * @param opPos The opcode position for the step. * @param stepType The type of step, one of OP_GROUP, etc. * * @return true if step has a predicate. * * @throws javax.xml.transform.TransformerException */	TokenNameCOMMENT_JAVADOC	 Analyze a step and give information about it's predicates. Right now this just returns true or false if the step has a predicate. * @param compiler non-null reference to compiler object that has processed the XPath operations into an opcode map. @param opPos The opcode position for the step. @param stepType The type of step, one of OP_GROUP, etc. * @return true if step has a predicate. * @throws javax.xml.transform.TransformerException 
static	TokenNamestatic	
boolean	TokenNameboolean	
analyzePredicate	TokenNameIdentifier	 analyze Predicate
(	TokenNameLPAREN	
Compiler	TokenNameIdentifier	 Compiler
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
int	TokenNameint	
opPos	TokenNameIdentifier	 op Pos
,	TokenNameCOMMA	
int	TokenNameint	
stepType	TokenNameIdentifier	 step Type
)	TokenNameRPAREN	
throws	TokenNamethrows	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
TransformerException	TokenNameIdentifier	 Transformer Exception
{	TokenNameLBRACE	
int	TokenNameint	
argLen	TokenNameIdentifier	 arg Len
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
stepType	TokenNameIdentifier	 step Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_VARIABLE	TokenNameIdentifier	 OP  VARIABLE
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_EXTFUNCTION	TokenNameIdentifier	 OP  EXTFUNCTION
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_FUNCTION	TokenNameIdentifier	 OP  FUNCTION
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_GROUP	TokenNameIdentifier	 OP  GROUP
:	TokenNameCOLON	
argLen	TokenNameIdentifier	 arg Len
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getArgLength	TokenNameIdentifier	 get Arg Length
(	TokenNameLPAREN	
opPos	TokenNameIdentifier	 op Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
argLen	TokenNameIdentifier	 arg Len
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getArgLengthOfStep	TokenNameIdentifier	 get Arg Length Of Step
(	TokenNameLPAREN	
opPos	TokenNameIdentifier	 op Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getFirstPredicateOpPos	TokenNameIdentifier	 get First Predicate Op Pos
(	TokenNameLPAREN	
opPos	TokenNameIdentifier	 op Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
nPredicates	TokenNameIdentifier	 n Predicates
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
countPredicates	TokenNameIdentifier	 count Predicates
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
nPredicates	TokenNameIdentifier	 n Predicates
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
true	TokenNametrue	
:	TokenNameCOLON	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Create the proper Walker from the axes type. * * @param compiler non-null reference to compiler object that has processed * the XPath operations into an opcode map. * @param opPos The opcode position for the step. * @param lpi The owning location path iterator. * @param analysis 32 bits of analysis, from which the type of AxesWalker * may be influenced. * * @return non-null reference to AxesWalker derivative. * @throws RuntimeException if the input is bad. */	TokenNameCOMMENT_JAVADOC	 Create the proper Walker from the axes type. * @param compiler non-null reference to compiler object that has processed the XPath operations into an opcode map. @param opPos The opcode position for the step. @param lpi The owning location path iterator. @param analysis 32 bits of analysis, from which the type of AxesWalker may be influenced. * @return non-null reference to AxesWalker derivative. @throws RuntimeException if the input is bad. 
private	TokenNameprivate	
static	TokenNamestatic	
AxesWalker	TokenNameIdentifier	 Axes Walker
createDefaultWalker	TokenNameIdentifier	 create Default Walker
(	TokenNameLPAREN	
Compiler	TokenNameIdentifier	 Compiler
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
int	TokenNameint	
opPos	TokenNameIdentifier	 op Pos
,	TokenNameCOMMA	
WalkingIterator	TokenNameIdentifier	 Walking Iterator
lpi	TokenNameIdentifier	 lpi
,	TokenNameCOMMA	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
AxesWalker	TokenNameIdentifier	 Axes Walker
ai	TokenNameIdentifier	 ai
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
stepType	TokenNameIdentifier	 step Type
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getOp	TokenNameIdentifier	 get Op
(	TokenNameLPAREN	
opPos	TokenNameIdentifier	 op Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* System.out.println("0: "+compiler.getOp(opPos)); System.out.println("1: "+compiler.getOp(opPos+1)); System.out.println("2: "+compiler.getOp(opPos+2)); System.out.println("3: "+compiler.getOp(opPos+3)); System.out.println("4: "+compiler.getOp(opPos+4)); System.out.println("5: "+compiler.getOp(opPos+5)); */	TokenNameCOMMENT_BLOCK	 System.out.println("0: "+compiler.getOp(opPos)); System.out.println("1: "+compiler.getOp(opPos+1)); System.out.println("2: "+compiler.getOp(opPos+2)); System.out.println("3: "+compiler.getOp(opPos+3)); System.out.println("4: "+compiler.getOp(opPos+4)); System.out.println("5: "+compiler.getOp(opPos+5)); 
boolean	TokenNameboolean	
simpleInit	TokenNameIdentifier	 simple Init
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
int	TokenNameint	
totalNumberWalkers	TokenNameIdentifier	 total Number Walkers
=	TokenNameEQUAL	
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
&	TokenNameAND	
BITS_COUNT	TokenNameIdentifier	 BITS  COUNT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
prevIsOneStepDown	TokenNameIdentifier	 prev Is One Step Down
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
stepType	TokenNameIdentifier	 step Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_VARIABLE	TokenNameIdentifier	 OP  VARIABLE
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_EXTFUNCTION	TokenNameIdentifier	 OP  EXTFUNCTION
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_FUNCTION	TokenNameIdentifier	 OP  FUNCTION
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_GROUP	TokenNameIdentifier	 OP  GROUP
:	TokenNameCOLON	
prevIsOneStepDown	TokenNameIdentifier	 prev Is One Step Down
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG_WALKER_CREATION	TokenNameIdentifier	 DEBUG  WALKER  CREATION
)	TokenNameRPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"new walker: FilterExprWalker: "	TokenNameStringLiteral	new walker: FilterExprWalker: 
+	TokenNamePLUS	
analysis	TokenNameIdentifier	 analysis
+	TokenNamePLUS	
", "	TokenNameStringLiteral	, 
+	TokenNamePLUS	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ai	TokenNameIdentifier	 ai
=	TokenNameEQUAL	
new	TokenNamenew	
FilterExprWalker	TokenNameIdentifier	 Filter Expr Walker
(	TokenNameLPAREN	
lpi	TokenNameIdentifier	 lpi
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
simpleInit	TokenNameIdentifier	 simple Init
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_ROOT	TokenNameIdentifier	 FROM  ROOT
:	TokenNameCOLON	
ai	TokenNameIdentifier	 ai
=	TokenNameEQUAL	
new	TokenNamenew	
AxesWalker	TokenNameIdentifier	 Axes Walker
(	TokenNameLPAREN	
lpi	TokenNameIdentifier	 lpi
,	TokenNameCOMMA	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
ROOT	TokenNameIdentifier	 ROOT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_ANCESTORS	TokenNameIdentifier	 FROM  ANCESTORS
:	TokenNameCOLON	
prevIsOneStepDown	TokenNameIdentifier	 prev Is One Step Down
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
ai	TokenNameIdentifier	 ai
=	TokenNameEQUAL	
new	TokenNamenew	
ReverseAxesWalker	TokenNameIdentifier	 Reverse Axes Walker
(	TokenNameLPAREN	
lpi	TokenNameIdentifier	 lpi
,	TokenNameCOMMA	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
ANCESTOR	TokenNameIdentifier	 ANCESTOR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_ANCESTORS_OR_SELF	TokenNameIdentifier	 FROM  ANCESTORS  OR  SELF
:	TokenNameCOLON	
prevIsOneStepDown	TokenNameIdentifier	 prev Is One Step Down
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
ai	TokenNameIdentifier	 ai
=	TokenNameEQUAL	
new	TokenNamenew	
ReverseAxesWalker	TokenNameIdentifier	 Reverse Axes Walker
(	TokenNameLPAREN	
lpi	TokenNameIdentifier	 lpi
,	TokenNameCOMMA	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
ANCESTORORSELF	TokenNameIdentifier	 ANCESTORORSELF
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_ATTRIBUTES	TokenNameIdentifier	 FROM  ATTRIBUTES
:	TokenNameCOLON	
ai	TokenNameIdentifier	 ai
=	TokenNameEQUAL	
new	TokenNamenew	
AxesWalker	TokenNameIdentifier	 Axes Walker
(	TokenNameLPAREN	
lpi	TokenNameIdentifier	 lpi
,	TokenNameCOMMA	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
ATTRIBUTE	TokenNameIdentifier	 ATTRIBUTE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_NAMESPACE	TokenNameIdentifier	 FROM  NAMESPACE
:	TokenNameCOLON	
ai	TokenNameIdentifier	 ai
=	TokenNameEQUAL	
new	TokenNamenew	
AxesWalker	TokenNameIdentifier	 Axes Walker
(	TokenNameLPAREN	
lpi	TokenNameIdentifier	 lpi
,	TokenNameCOMMA	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
NAMESPACE	TokenNameIdentifier	 NAMESPACE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_CHILDREN	TokenNameIdentifier	 FROM  CHILDREN
:	TokenNameCOLON	
ai	TokenNameIdentifier	 ai
=	TokenNameEQUAL	
new	TokenNamenew	
AxesWalker	TokenNameIdentifier	 Axes Walker
(	TokenNameLPAREN	
lpi	TokenNameIdentifier	 lpi
,	TokenNameCOMMA	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
CHILD	TokenNameIdentifier	 CHILD
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_DESCENDANTS	TokenNameIdentifier	 FROM  DESCENDANTS
:	TokenNameCOLON	
prevIsOneStepDown	TokenNameIdentifier	 prev Is One Step Down
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
ai	TokenNameIdentifier	 ai
=	TokenNameEQUAL	
new	TokenNamenew	
AxesWalker	TokenNameIdentifier	 Axes Walker
(	TokenNameLPAREN	
lpi	TokenNameIdentifier	 lpi
,	TokenNameCOMMA	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
DESCENDANT	TokenNameIdentifier	 DESCENDANT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_DESCENDANTS_OR_SELF	TokenNameIdentifier	 FROM  DESCENDANTS  OR  SELF
:	TokenNameCOLON	
prevIsOneStepDown	TokenNameIdentifier	 prev Is One Step Down
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
ai	TokenNameIdentifier	 ai
=	TokenNameEQUAL	
new	TokenNamenew	
AxesWalker	TokenNameIdentifier	 Axes Walker
(	TokenNameLPAREN	
lpi	TokenNameIdentifier	 lpi
,	TokenNameCOMMA	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
DESCENDANTORSELF	TokenNameIdentifier	 DESCENDANTORSELF
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_FOLLOWING	TokenNameIdentifier	 FROM  FOLLOWING
:	TokenNameCOLON	
prevIsOneStepDown	TokenNameIdentifier	 prev Is One Step Down
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
ai	TokenNameIdentifier	 ai
=	TokenNameEQUAL	
new	TokenNamenew	
AxesWalker	TokenNameIdentifier	 Axes Walker
(	TokenNameLPAREN	
lpi	TokenNameIdentifier	 lpi
,	TokenNameCOMMA	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
FOLLOWING	TokenNameIdentifier	 FOLLOWING
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_FOLLOWING_SIBLINGS	TokenNameIdentifier	 FROM  FOLLOWING  SIBLINGS
:	TokenNameCOLON	
prevIsOneStepDown	TokenNameIdentifier	 prev Is One Step Down
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
ai	TokenNameIdentifier	 ai
=	TokenNameEQUAL	
new	TokenNamenew	
AxesWalker	TokenNameIdentifier	 Axes Walker
(	TokenNameLPAREN	
lpi	TokenNameIdentifier	 lpi
,	TokenNameCOMMA	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
FOLLOWINGSIBLING	TokenNameIdentifier	 FOLLOWINGSIBLING
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_PRECEDING	TokenNameIdentifier	 FROM  PRECEDING
:	TokenNameCOLON	
prevIsOneStepDown	TokenNameIdentifier	 prev Is One Step Down
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
ai	TokenNameIdentifier	 ai
=	TokenNameEQUAL	
new	TokenNamenew	
ReverseAxesWalker	TokenNameIdentifier	 Reverse Axes Walker
(	TokenNameLPAREN	
lpi	TokenNameIdentifier	 lpi
,	TokenNameCOMMA	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
PRECEDING	TokenNameIdentifier	 PRECEDING
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_PRECEDING_SIBLINGS	TokenNameIdentifier	 FROM  PRECEDING  SIBLINGS
:	TokenNameCOLON	
prevIsOneStepDown	TokenNameIdentifier	 prev Is One Step Down
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
ai	TokenNameIdentifier	 ai
=	TokenNameEQUAL	
new	TokenNamenew	
ReverseAxesWalker	TokenNameIdentifier	 Reverse Axes Walker
(	TokenNameLPAREN	
lpi	TokenNameIdentifier	 lpi
,	TokenNameCOMMA	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
PRECEDINGSIBLING	TokenNameIdentifier	 PRECEDINGSIBLING
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_PARENT	TokenNameIdentifier	 FROM  PARENT
:	TokenNameCOLON	
prevIsOneStepDown	TokenNameIdentifier	 prev Is One Step Down
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
ai	TokenNameIdentifier	 ai
=	TokenNameEQUAL	
new	TokenNamenew	
ReverseAxesWalker	TokenNameIdentifier	 Reverse Axes Walker
(	TokenNameLPAREN	
lpi	TokenNameIdentifier	 lpi
,	TokenNameCOMMA	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
PARENT	TokenNameIdentifier	 PARENT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_SELF	TokenNameIdentifier	 FROM  SELF
:	TokenNameCOLON	
ai	TokenNameIdentifier	 ai
=	TokenNameEQUAL	
new	TokenNamenew	
AxesWalker	TokenNameIdentifier	 Axes Walker
(	TokenNameLPAREN	
lpi	TokenNameIdentifier	 lpi
,	TokenNameCOMMA	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
SELF	TokenNameIdentifier	 SELF
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
XSLMessages	TokenNameIdentifier	 XSL Messages
.	TokenNameDOT	
createXPATHMessage	TokenNameIdentifier	 create XPATH Message
(	TokenNameLPAREN	
XPATHErrorResources	TokenNameIdentifier	 XPATH Error Resources
.	TokenNameDOT	
ER_NULL_ERROR_HANDLER	TokenNameIdentifier	 ER  NULL  ERROR  HANDLER
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
stepType	TokenNameIdentifier	 step Type
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//"Programmer's assertion: unknown opcode: " 	TokenNameCOMMENT_LINE	"Programmer's assertion: unknown opcode: " 
//+ stepType); 	TokenNameCOMMENT_LINE	+ stepType); 
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
simpleInit	TokenNameIdentifier	 simple Init
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ai	TokenNameIdentifier	 ai
.	TokenNameDOT	
initNodeTest	TokenNameIdentifier	 init Node Test
(	TokenNameLPAREN	
DTMFilter	TokenNameIdentifier	 DTM Filter
.	TokenNameDOT	
SHOW_ALL	TokenNameIdentifier	 SHOW  ALL
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
whatToShow	TokenNameIdentifier	 what To Show
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getWhatToShow	TokenNameIdentifier	 get What To Show
(	TokenNameLPAREN	
opPos	TokenNameIdentifier	 op Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* System.out.print("construct: "); NodeTest.debugWhatToShow(whatToShow); System.out.println("or stuff: "+(whatToShow & (DTMFilter.SHOW_ATTRIBUTE | DTMFilter.SHOW_ELEMENT | DTMFilter.SHOW_PROCESSING_INSTRUCTION))); */	TokenNameCOMMENT_BLOCK	 System.out.print("construct: "); NodeTest.debugWhatToShow(whatToShow); System.out.println("or stuff: "+(whatToShow & (DTMFilter.SHOW_ATTRIBUTE | DTMFilter.SHOW_ELEMENT | DTMFilter.SHOW_PROCESSING_INSTRUCTION))); 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
==	TokenNameEQUAL_EQUAL	
(	TokenNameLPAREN	
whatToShow	TokenNameIdentifier	 what To Show
&	TokenNameAND	
(	TokenNameLPAREN	
DTMFilter	TokenNameIdentifier	 DTM Filter
.	TokenNameDOT	
SHOW_ATTRIBUTE	TokenNameIdentifier	 SHOW  ATTRIBUTE
|	TokenNameOR	
DTMFilter	TokenNameIdentifier	 DTM Filter
.	TokenNameDOT	
SHOW_NAMESPACE	TokenNameIdentifier	 SHOW  NAMESPACE
|	TokenNameOR	
DTMFilter	TokenNameIdentifier	 DTM Filter
.	TokenNameDOT	
SHOW_ELEMENT	TokenNameIdentifier	 SHOW  ELEMENT
|	TokenNameOR	
DTMFilter	TokenNameIdentifier	 DTM Filter
.	TokenNameDOT	
SHOW_PROCESSING_INSTRUCTION	TokenNameIdentifier	 SHOW  PROCESSING  INSTRUCTION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
whatToShow	TokenNameIdentifier	 what To Show
==	TokenNameEQUAL_EQUAL	
DTMFilter	TokenNameIdentifier	 DTM Filter
.	TokenNameDOT	
SHOW_ALL	TokenNameIdentifier	 SHOW  ALL
)	TokenNameRPAREN	
)	TokenNameRPAREN	
ai	TokenNameIdentifier	 ai
.	TokenNameDOT	
initNodeTest	TokenNameIdentifier	 init Node Test
(	TokenNameLPAREN	
whatToShow	TokenNameIdentifier	 what To Show
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
{	TokenNameLBRACE	
ai	TokenNameIdentifier	 ai
.	TokenNameDOT	
initNodeTest	TokenNameIdentifier	 init Node Test
(	TokenNameLPAREN	
whatToShow	TokenNameIdentifier	 what To Show
,	TokenNameCOMMA	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getStepNS	TokenNameIdentifier	 get Step NS
(	TokenNameLPAREN	
opPos	TokenNameIdentifier	 op Pos
)	TokenNameRPAREN	
,	TokenNameCOMMA	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getStepLocalName	TokenNameIdentifier	 get Step Local Name
(	TokenNameLPAREN	
opPos	TokenNameIdentifier	 op Pos
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
ai	TokenNameIdentifier	 ai
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
getAnalysisString	TokenNameIdentifier	 get Analysis String
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StringBuffer	TokenNameIdentifier	 String Buffer
buf	TokenNameIdentifier	 buf
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"count: "	TokenNameStringLiteral	count: 
+	TokenNamePLUS	
getStepCount	TokenNameIdentifier	 get Step Count
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
&	TokenNameAND	
BIT_NODETEST_ANY	TokenNameIdentifier	 BIT  NODETEST  ANY
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"NTANY|"	TokenNameStringLiteral	NTANY|
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
&	TokenNameAND	
BIT_PREDICATE	TokenNameIdentifier	 BIT  PREDICATE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"PRED|"	TokenNameStringLiteral	PRED|
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
&	TokenNameAND	
BIT_ANCESTOR	TokenNameIdentifier	 BIT  ANCESTOR
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"ANC|"	TokenNameStringLiteral	ANC|
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
&	TokenNameAND	
BIT_ANCESTOR_OR_SELF	TokenNameIdentifier	 BIT  ANCESTOR  OR  SELF
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"ANCOS|"	TokenNameStringLiteral	ANCOS|
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
&	TokenNameAND	
BIT_ATTRIBUTE	TokenNameIdentifier	 BIT  ATTRIBUTE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"ATTR|"	TokenNameStringLiteral	ATTR|
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
&	TokenNameAND	
BIT_CHILD	TokenNameIdentifier	 BIT  CHILD
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"CH|"	TokenNameStringLiteral	CH|
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
&	TokenNameAND	
BIT_DESCENDANT	TokenNameIdentifier	 BIT  DESCENDANT
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"DESC|"	TokenNameStringLiteral	DESC|
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
&	TokenNameAND	
BIT_DESCENDANT_OR_SELF	TokenNameIdentifier	 BIT  DESCENDANT  OR  SELF
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"DESCOS|"	TokenNameStringLiteral	DESCOS|
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
&	TokenNameAND	
BIT_FOLLOWING	TokenNameIdentifier	 BIT  FOLLOWING
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"FOL|"	TokenNameStringLiteral	FOL|
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
&	TokenNameAND	
BIT_FOLLOWING_SIBLING	TokenNameIdentifier	 BIT  FOLLOWING  SIBLING
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"FOLS|"	TokenNameStringLiteral	FOLS|
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
&	TokenNameAND	
BIT_NAMESPACE	TokenNameIdentifier	 BIT  NAMESPACE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"NS|"	TokenNameStringLiteral	NS|
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
&	TokenNameAND	
BIT_PARENT	TokenNameIdentifier	 BIT  PARENT
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"P|"	TokenNameStringLiteral	P|
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
&	TokenNameAND	
BIT_PRECEDING	TokenNameIdentifier	 BIT  PRECEDING
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"PREC|"	TokenNameStringLiteral	PREC|
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
&	TokenNameAND	
BIT_PRECEDING_SIBLING	TokenNameIdentifier	 BIT  PRECEDING  SIBLING
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"PRECS|"	TokenNameStringLiteral	PRECS|
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
&	TokenNameAND	
BIT_SELF	TokenNameIdentifier	 BIT  SELF
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
".|"	TokenNameStringLiteral	.|
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
&	TokenNameAND	
BIT_FILTER	TokenNameIdentifier	 BIT  FILTER
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"FLT|"	TokenNameStringLiteral	FLT|
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
&	TokenNameAND	
BIT_ROOT	TokenNameIdentifier	 BIT  ROOT
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"R|"	TokenNameStringLiteral	R|
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Set to true for diagnostics about walker creation */	TokenNameCOMMENT_JAVADOC	 Set to true for diagnostics about walker creation 
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
DEBUG_PATTERN_CREATION	TokenNameIdentifier	 DEBUG  PATTERN  CREATION
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** Set to true for diagnostics about walker creation */	TokenNameCOMMENT_JAVADOC	 Set to true for diagnostics about walker creation 
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
DEBUG_WALKER_CREATION	TokenNameIdentifier	 DEBUG  WALKER  CREATION
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** Set to true for diagnostics about iterator creation */	TokenNameCOMMENT_JAVADOC	 Set to true for diagnostics about iterator creation 
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
DEBUG_ITERATOR_CREATION	TokenNameIdentifier	 DEBUG  ITERATOR  CREATION
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
hasPredicate	TokenNameIdentifier	 has Predicate
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
!=	TokenNameNOT_EQUAL	
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
&	TokenNameAND	
BIT_PREDICATE	TokenNameIdentifier	 BIT  PREDICATE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
isWild	TokenNameIdentifier	 is Wild
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
!=	TokenNameNOT_EQUAL	
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
&	TokenNameAND	
BIT_NODETEST_ANY	TokenNameIdentifier	 BIT  NODETEST  ANY
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
walksAncestors	TokenNameIdentifier	 walks Ancestors
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
isSet	TokenNameIdentifier	 is Set
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
BIT_ANCESTOR	TokenNameIdentifier	 BIT  ANCESTOR
|	TokenNameOR	
BIT_ANCESTOR_OR_SELF	TokenNameIdentifier	 BIT  ANCESTOR  OR  SELF
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
walksAttributes	TokenNameIdentifier	 walks Attributes
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
!=	TokenNameNOT_EQUAL	
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
&	TokenNameAND	
BIT_ATTRIBUTE	TokenNameIdentifier	 BIT  ATTRIBUTE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
walksNamespaces	TokenNameIdentifier	 walks Namespaces
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
!=	TokenNameNOT_EQUAL	
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
&	TokenNameAND	
BIT_NAMESPACE	TokenNameIdentifier	 BIT  NAMESPACE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
walksChildren	TokenNameIdentifier	 walks Children
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
!=	TokenNameNOT_EQUAL	
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
&	TokenNameAND	
BIT_CHILD	TokenNameIdentifier	 BIT  CHILD
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
walksDescendants	TokenNameIdentifier	 walks Descendants
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
isSet	TokenNameIdentifier	 is Set
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
BIT_DESCENDANT	TokenNameIdentifier	 BIT  DESCENDANT
|	TokenNameOR	
BIT_DESCENDANT_OR_SELF	TokenNameIdentifier	 BIT  DESCENDANT  OR  SELF
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
walksSubtree	TokenNameIdentifier	 walks Subtree
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
isSet	TokenNameIdentifier	 is Set
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
BIT_DESCENDANT	TokenNameIdentifier	 BIT  DESCENDANT
|	TokenNameOR	
BIT_DESCENDANT_OR_SELF	TokenNameIdentifier	 BIT  DESCENDANT  OR  SELF
|	TokenNameOR	
BIT_CHILD	TokenNameIdentifier	 BIT  CHILD
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
walksSubtreeOnlyMaybeAbsolute	TokenNameIdentifier	 walks Subtree Only Maybe Absolute
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
walksSubtree	TokenNameIdentifier	 walks Subtree
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
walksExtraNodes	TokenNameIdentifier	 walks Extra Nodes
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
walksUp	TokenNameIdentifier	 walks Up
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
walksSideways	TokenNameIdentifier	 walks Sideways
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
walksSubtreeOnly	TokenNameIdentifier	 walks Subtree Only
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
walksSubtreeOnlyMaybeAbsolute	TokenNameIdentifier	 walks Subtree Only Maybe Absolute
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
isAbsolute	TokenNameIdentifier	 is Absolute
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
walksFilteredList	TokenNameIdentifier	 walks Filtered List
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
isSet	TokenNameIdentifier	 is Set
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
BIT_FILTER	TokenNameIdentifier	 BIT  FILTER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
walksSubtreeOnlyFromRootOrContext	TokenNameIdentifier	 walks Subtree Only From Root Or Context
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
walksSubtree	TokenNameIdentifier	 walks Subtree
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
walksExtraNodes	TokenNameIdentifier	 walks Extra Nodes
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
walksUp	TokenNameIdentifier	 walks Up
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
walksSideways	TokenNameIdentifier	 walks Sideways
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
isSet	TokenNameIdentifier	 is Set
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
BIT_FILTER	TokenNameIdentifier	 BIT  FILTER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
walksInDocOrder	TokenNameIdentifier	 walks In Doc Order
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
walksSubtreeOnlyMaybeAbsolute	TokenNameIdentifier	 walks Subtree Only Maybe Absolute
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
||	TokenNameOR_OR	
walksExtraNodesOnly	TokenNameIdentifier	 walks Extra Nodes Only
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
||	TokenNameOR_OR	
walksFollowingOnlyMaybeAbsolute	TokenNameIdentifier	 walks Following Only Maybe Absolute
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
isSet	TokenNameIdentifier	 is Set
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
BIT_FILTER	TokenNameIdentifier	 BIT  FILTER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
walksFollowingOnlyMaybeAbsolute	TokenNameIdentifier	 walks Following Only Maybe Absolute
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
isSet	TokenNameIdentifier	 is Set
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
BIT_SELF	TokenNameIdentifier	 BIT  SELF
|	TokenNameOR	
BIT_FOLLOWING_SIBLING	TokenNameIdentifier	 BIT  FOLLOWING  SIBLING
|	TokenNameOR	
BIT_FOLLOWING	TokenNameIdentifier	 BIT  FOLLOWING
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
walksSubtree	TokenNameIdentifier	 walks Subtree
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
walksUp	TokenNameIdentifier	 walks Up
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
walksSideways	TokenNameIdentifier	 walks Sideways
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
walksUp	TokenNameIdentifier	 walks Up
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
isSet	TokenNameIdentifier	 is Set
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
BIT_PARENT	TokenNameIdentifier	 BIT  PARENT
|	TokenNameOR	
BIT_ANCESTOR	TokenNameIdentifier	 BIT  ANCESTOR
|	TokenNameOR	
BIT_ANCESTOR_OR_SELF	TokenNameIdentifier	 BIT  ANCESTOR  OR  SELF
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
walksSideways	TokenNameIdentifier	 walks Sideways
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
isSet	TokenNameIdentifier	 is Set
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
BIT_FOLLOWING	TokenNameIdentifier	 BIT  FOLLOWING
|	TokenNameOR	
BIT_FOLLOWING_SIBLING	TokenNameIdentifier	 BIT  FOLLOWING  SIBLING
|	TokenNameOR	
BIT_PRECEDING	TokenNameIdentifier	 BIT  PRECEDING
|	TokenNameOR	
BIT_PRECEDING_SIBLING	TokenNameIdentifier	 BIT  PRECEDING  SIBLING
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
walksExtraNodes	TokenNameIdentifier	 walks Extra Nodes
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
isSet	TokenNameIdentifier	 is Set
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
BIT_NAMESPACE	TokenNameIdentifier	 BIT  NAMESPACE
|	TokenNameOR	
BIT_ATTRIBUTE	TokenNameIdentifier	 BIT  ATTRIBUTE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
walksExtraNodesOnly	TokenNameIdentifier	 walks Extra Nodes Only
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
walksExtraNodes	TokenNameIdentifier	 walks Extra Nodes
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
isSet	TokenNameIdentifier	 is Set
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
BIT_SELF	TokenNameIdentifier	 BIT  SELF
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
walksSubtree	TokenNameIdentifier	 walks Subtree
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
walksUp	TokenNameIdentifier	 walks Up
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
walksSideways	TokenNameIdentifier	 walks Sideways
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
isAbsolute	TokenNameIdentifier	 is Absolute
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
isAbsolute	TokenNameIdentifier	 is Absolute
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
isSet	TokenNameIdentifier	 is Set
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
BIT_ROOT	TokenNameIdentifier	 BIT  ROOT
|	TokenNameOR	
BIT_FILTER	TokenNameIdentifier	 BIT  FILTER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
walksChildrenOnly	TokenNameIdentifier	 walks Children Only
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
walksChildren	TokenNameIdentifier	 walks Children
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
isSet	TokenNameIdentifier	 is Set
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
BIT_SELF	TokenNameIdentifier	 BIT  SELF
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
walksExtraNodes	TokenNameIdentifier	 walks Extra Nodes
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
walksDescendants	TokenNameIdentifier	 walks Descendants
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
walksUp	TokenNameIdentifier	 walks Up
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
walksSideways	TokenNameIdentifier	 walks Sideways
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
!	TokenNameNOT	
isAbsolute	TokenNameIdentifier	 is Absolute
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
||	TokenNameOR_OR	
isSet	TokenNameIdentifier	 is Set
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
BIT_ROOT	TokenNameIdentifier	 BIT  ROOT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
walksChildrenAndExtraAndSelfOnly	TokenNameIdentifier	 walks Children And Extra And Self Only
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
walksChildren	TokenNameIdentifier	 walks Children
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
walksDescendants	TokenNameIdentifier	 walks Descendants
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
walksUp	TokenNameIdentifier	 walks Up
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
walksSideways	TokenNameIdentifier	 walks Sideways
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
!	TokenNameNOT	
isAbsolute	TokenNameIdentifier	 is Absolute
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
||	TokenNameOR_OR	
isSet	TokenNameIdentifier	 is Set
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
BIT_ROOT	TokenNameIdentifier	 BIT  ROOT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
walksDescendantsAndExtraAndSelfOnly	TokenNameIdentifier	 walks Descendants And Extra And Self Only
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
!	TokenNameNOT	
walksChildren	TokenNameIdentifier	 walks Children
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
walksDescendants	TokenNameIdentifier	 walks Descendants
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
walksUp	TokenNameIdentifier	 walks Up
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
walksSideways	TokenNameIdentifier	 walks Sideways
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
!	TokenNameNOT	
isAbsolute	TokenNameIdentifier	 is Absolute
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
||	TokenNameOR_OR	
isSet	TokenNameIdentifier	 is Set
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
BIT_ROOT	TokenNameIdentifier	 BIT  ROOT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
walksSelfOnly	TokenNameIdentifier	 walks Self Only
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
isSet	TokenNameIdentifier	 is Set
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
BIT_SELF	TokenNameIdentifier	 BIT  SELF
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
walksSubtree	TokenNameIdentifier	 walks Subtree
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
walksUp	TokenNameIdentifier	 walks Up
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
walksSideways	TokenNameIdentifier	 walks Sideways
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
isAbsolute	TokenNameIdentifier	 is Absolute
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
walksUpOnly	TokenNameIdentifier	 walks Up Only
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
!	TokenNameNOT	
walksSubtree	TokenNameIdentifier	 walks Subtree
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
walksUp	TokenNameIdentifier	 walks Up
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
walksSideways	TokenNameIdentifier	 walks Sideways
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
isAbsolute	TokenNameIdentifier	 is Absolute
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
walksDownOnly	TokenNameIdentifier	 walks Down Only
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
walksSubtree	TokenNameIdentifier	 walks Subtree
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
walksUp	TokenNameIdentifier	 walks Up
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
walksSideways	TokenNameIdentifier	 walks Sideways
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
isAbsolute	TokenNameIdentifier	 is Absolute
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
walksDownExtraOnly	TokenNameIdentifier	 walks Down Extra Only
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
walksSubtree	TokenNameIdentifier	 walks Subtree
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
walksExtraNodes	TokenNameIdentifier	 walks Extra Nodes
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
walksUp	TokenNameIdentifier	 walks Up
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
walksSideways	TokenNameIdentifier	 walks Sideways
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
isAbsolute	TokenNameIdentifier	 is Absolute
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
canSkipSubtrees	TokenNameIdentifier	 can Skip Subtrees
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
isSet	TokenNameIdentifier	 is Set
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
BIT_CHILD	TokenNameIdentifier	 BIT  CHILD
)	TokenNameRPAREN	
|	TokenNameOR	
walksSideways	TokenNameIdentifier	 walks Sideways
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
canCrissCross	TokenNameIdentifier	 can Criss Cross
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// This could be done faster. Coded for clarity. 	TokenNameCOMMENT_LINE	This could be done faster. Coded for clarity. 
if	TokenNameif	
(	TokenNameLPAREN	
walksSelfOnly	TokenNameIdentifier	 walks Self Only
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
walksDownOnly	TokenNameIdentifier	 walks Down Only
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
canSkipSubtrees	TokenNameIdentifier	 can Skip Subtrees
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
walksChildrenAndExtraAndSelfOnly	TokenNameIdentifier	 walks Children And Extra And Self Only
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
walksDescendantsAndExtraAndSelfOnly	TokenNameIdentifier	 walks Descendants And Extra And Self Only
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
walksUpOnly	TokenNameIdentifier	 walks Up Only
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
walksExtraNodesOnly	TokenNameIdentifier	 walks Extra Nodes Only
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
walksSubtree	TokenNameIdentifier	 walks Subtree
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
walksSideways	TokenNameIdentifier	 walks Sideways
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
||	TokenNameOR_OR	
walksUp	TokenNameIdentifier	 walks Up
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
||	TokenNameOR_OR	
canSkipSubtrees	TokenNameIdentifier	 can Skip Subtrees
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Tell if the pattern can be 'walked' with the iteration steps in natural * document order, without duplicates. * * @param analysis The general analysis of the pattern. * * @return true if the walk can be done in natural order. * * @throws javax.xml.transform.TransformerException */	TokenNameCOMMENT_JAVADOC	 Tell if the pattern can be 'walked' with the iteration steps in natural document order, without duplicates. * @param analysis The general analysis of the pattern. * @return true if the walk can be done in natural order. * @throws javax.xml.transform.TransformerException 
static	TokenNamestatic	
public	TokenNamepublic	
boolean	TokenNameboolean	
isNaturalDocOrder	TokenNameIdentifier	 is Natural Doc Order
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
canCrissCross	TokenNameIdentifier	 can Criss Cross
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
||	TokenNameOR_OR	
isSet	TokenNameIdentifier	 is Set
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
BIT_NAMESPACE	TokenNameIdentifier	 BIT  NAMESPACE
)	TokenNameRPAREN	
||	TokenNameOR_OR	
walksFilteredList	TokenNameIdentifier	 walks Filtered List
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
walksInDocOrder	TokenNameIdentifier	 walks In Doc Order
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Tell if the pattern can be 'walked' with the iteration steps in natural * document order, without duplicates. * * @param compiler non-null reference to compiler object that has processed * the XPath operations into an opcode map. * @param stepOpCodePos The opcode position for the step. * @param stepIndex The top-level step index withing the iterator. * @param analysis The general analysis of the pattern. * * @return true if the walk can be done in natural order. * * @throws javax.xml.transform.TransformerException */	TokenNameCOMMENT_JAVADOC	 Tell if the pattern can be 'walked' with the iteration steps in natural document order, without duplicates. * @param compiler non-null reference to compiler object that has processed the XPath operations into an opcode map. @param stepOpCodePos The opcode position for the step. @param stepIndex The top-level step index withing the iterator. @param analysis The general analysis of the pattern. * @return true if the walk can be done in natural order. * @throws javax.xml.transform.TransformerException 
private	TokenNameprivate	
static	TokenNamestatic	
boolean	TokenNameboolean	
isNaturalDocOrder	TokenNameIdentifier	 is Natural Doc Order
(	TokenNameLPAREN	
Compiler	TokenNameIdentifier	 Compiler
compiler	TokenNameIdentifier	 compiler
,	TokenNameCOMMA	
int	TokenNameint	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
,	TokenNameCOMMA	
int	TokenNameint	
stepIndex	TokenNameIdentifier	 step Index
,	TokenNameCOMMA	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
throws	TokenNamethrows	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
TransformerException	TokenNameIdentifier	 Transformer Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
canCrissCross	TokenNameIdentifier	 can Criss Cross
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// Namespaces can present some problems, so just punt if we're looking for 	TokenNameCOMMENT_LINE	Namespaces can present some problems, so just punt if we're looking for 
// these. 	TokenNameCOMMENT_LINE	these. 
if	TokenNameif	
(	TokenNameLPAREN	
isSet	TokenNameIdentifier	 is Set
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
BIT_NAMESPACE	TokenNameIdentifier	 BIT  NAMESPACE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// The following, preceding, following-sibling, and preceding sibling can 	TokenNameCOMMENT_LINE	The following, preceding, following-sibling, and preceding sibling can 
// be found in doc order if we get to this point, but if they occur 	TokenNameCOMMENT_LINE	be found in doc order if we get to this point, but if they occur 
// together, they produce 	TokenNameCOMMENT_LINE	together, they produce 
// duplicates, so it's better for us to eliminate this case so we don't 	TokenNameCOMMENT_LINE	duplicates, so it's better for us to eliminate this case so we don't 
// have to check for duplicates during runtime if we're using a 	TokenNameCOMMENT_LINE	have to check for duplicates during runtime if we're using a 
// WalkingIterator. 	TokenNameCOMMENT_LINE	WalkingIterator. 
if	TokenNameif	
(	TokenNameLPAREN	
isSet	TokenNameIdentifier	 is Set
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
BIT_FOLLOWING	TokenNameIdentifier	 BIT  FOLLOWING
|	TokenNameOR	
BIT_FOLLOWING_SIBLING	TokenNameIdentifier	 BIT  FOLLOWING  SIBLING
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
isSet	TokenNameIdentifier	 is Set
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
,	TokenNameCOMMA	
BIT_PRECEDING	TokenNameIdentifier	 BIT  PRECEDING
|	TokenNameOR	
BIT_PRECEDING_SIBLING	TokenNameIdentifier	 BIT  PRECEDING  SIBLING
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// OK, now we have to check for select="@*/axis::*" patterns, which 	TokenNameCOMMENT_LINE	OK, now we have to check for select="@*/axis::*" patterns, which 
// can also cause duplicates to happen. But select="axis*/@::*" patterns 	TokenNameCOMMENT_LINE	can also cause duplicates to happen. But select="axis*/@::*" patterns 
// are OK, as are select="@foo/axis::*" patterns. 	TokenNameCOMMENT_LINE	are OK, as are select="@foo/axis::*" patterns. 
// Unfortunately, we can't do this just via the analysis bits. 	TokenNameCOMMENT_LINE	Unfortunately, we can't do this just via the analysis bits. 
int	TokenNameint	
stepType	TokenNameIdentifier	 step Type
;	TokenNameSEMICOLON	
int	TokenNameint	
stepCount	TokenNameIdentifier	 step Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
foundWildAttribute	TokenNameIdentifier	 found Wild Attribute
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// Steps that can traverse anything other than down a 	TokenNameCOMMENT_LINE	Steps that can traverse anything other than down a 
// subtree or that can produce duplicates when used in 	TokenNameCOMMENT_LINE	subtree or that can produce duplicates when used in 
// combonation are counted with this variable. 	TokenNameCOMMENT_LINE	combonation are counted with this variable. 
int	TokenNameint	
potentialDuplicateMakingStepCount	TokenNameIdentifier	 potential Duplicate Making Step Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
ENDOP	TokenNameIdentifier	 ENDOP
!=	TokenNameNOT_EQUAL	
(	TokenNameLPAREN	
stepType	TokenNameIdentifier	 step Type
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getOp	TokenNameIdentifier	 get Op
(	TokenNameLPAREN	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stepCount	TokenNameIdentifier	 step Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
stepType	TokenNameIdentifier	 step Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_ATTRIBUTES	TokenNameIdentifier	 FROM  ATTRIBUTES
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
MATCH_ATTRIBUTE	TokenNameIdentifier	 MATCH  ATTRIBUTE
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
foundWildAttribute	TokenNameIdentifier	 found Wild Attribute
)	TokenNameRPAREN	
// Maybe not needed, but be safe. 	TokenNameCOMMENT_LINE	Maybe not needed, but be safe. 
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// This doesn't seem to work as a test for wild card. Hmph. 	TokenNameCOMMENT_LINE	This doesn't seem to work as a test for wild card. Hmph. 
// int nodeTestType = compiler.getStepTestType(stepOpCodePos); 	TokenNameCOMMENT_LINE	int nodeTestType = compiler.getStepTestType(stepOpCodePos); 
String	TokenNameIdentifier	 String
localName	TokenNameIdentifier	 local Name
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getStepLocalName	TokenNameIdentifier	 get Step Local Name
(	TokenNameLPAREN	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// System.err.println("localName: "+localName); 	TokenNameCOMMENT_LINE	System.err.println("localName: "+localName); 
if	TokenNameif	
(	TokenNameLPAREN	
localName	TokenNameIdentifier	 local Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"*"	TokenNameStringLiteral	*
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
foundWildAttribute	TokenNameIdentifier	 found Wild Attribute
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_FOLLOWING	TokenNameIdentifier	 FROM  FOLLOWING
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_FOLLOWING_SIBLINGS	TokenNameIdentifier	 FROM  FOLLOWING  SIBLINGS
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_PRECEDING	TokenNameIdentifier	 FROM  PRECEDING
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_PRECEDING_SIBLINGS	TokenNameIdentifier	 FROM  PRECEDING  SIBLINGS
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_PARENT	TokenNameIdentifier	 FROM  PARENT
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_VARIABLE	TokenNameIdentifier	 OP  VARIABLE
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_EXTFUNCTION	TokenNameIdentifier	 OP  EXTFUNCTION
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_FUNCTION	TokenNameIdentifier	 OP  FUNCTION
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
OP_GROUP	TokenNameIdentifier	 OP  GROUP
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_NAMESPACE	TokenNameIdentifier	 FROM  NAMESPACE
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_ANCESTORS	TokenNameIdentifier	 FROM  ANCESTORS
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_ANCESTORS_OR_SELF	TokenNameIdentifier	 FROM  ANCESTORS  OR  SELF
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
MATCH_ANY_ANCESTOR	TokenNameIdentifier	 MATCH  ANY  ANCESTOR
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
MATCH_IMMEDIATE_ANCESTOR	TokenNameIdentifier	 MATCH  IMMEDIATE  ANCESTOR
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_DESCENDANTS_OR_SELF	TokenNameIdentifier	 FROM  DESCENDANTS  OR  SELF
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_DESCENDANTS	TokenNameIdentifier	 FROM  DESCENDANTS
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
potentialDuplicateMakingStepCount	TokenNameIdentifier	 potential Duplicate Making Step Count
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
potentialDuplicateMakingStepCount	TokenNameIdentifier	 potential Duplicate Making Step Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_ROOT	TokenNameIdentifier	 FROM  ROOT
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_CHILDREN	TokenNameIdentifier	 FROM  CHILDREN
:	TokenNameCOLON	
case	TokenNamecase	
OpCodes	TokenNameIdentifier	 Op Codes
.	TokenNameDOT	
FROM_SELF	TokenNameIdentifier	 FROM  SELF
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
foundWildAttribute	TokenNameIdentifier	 found Wild Attribute
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
XSLMessages	TokenNameIdentifier	 XSL Messages
.	TokenNameDOT	
createXPATHMessage	TokenNameIdentifier	 create XPATH Message
(	TokenNameLPAREN	
XPATHErrorResources	TokenNameIdentifier	 XPATH Error Resources
.	TokenNameDOT	
ER_NULL_ERROR_HANDLER	TokenNameIdentifier	 ER  NULL  ERROR  HANDLER
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
stepType	TokenNameIdentifier	 step Type
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//"Programmer's assertion: unknown opcode: " 	TokenNameCOMMENT_LINE	"Programmer's assertion: unknown opcode: " 
// + stepType); 	TokenNameCOMMENT_LINE	+ stepType); 
}	TokenNameRBRACE	
int	TokenNameint	
nextStepOpCodePos	TokenNameIdentifier	 next Step Op Code Pos
=	TokenNameEQUAL	
compiler	TokenNameIdentifier	 compiler
.	TokenNameDOT	
getNextStepPos	TokenNameIdentifier	 get Next Step Pos
(	TokenNameLPAREN	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nextStepOpCodePos	TokenNameIdentifier	 next Step Op Code Pos
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
stepOpCodePos	TokenNameIdentifier	 step Op Code Pos
=	TokenNameEQUAL	
nextStepOpCodePos	TokenNameIdentifier	 next Step Op Code Pos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
isOneStep	TokenNameIdentifier	 is One Step
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
&	TokenNameAND	
BITS_COUNT	TokenNameIdentifier	 BITS  COUNT
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0x00000001	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
int	TokenNameint	
getStepCount	TokenNameIdentifier	 get Step Count
(	TokenNameLPAREN	
int	TokenNameint	
analysis	TokenNameIdentifier	 analysis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
analysis	TokenNameIdentifier	 analysis
&	TokenNameAND	
BITS_COUNT	TokenNameIdentifier	 BITS  COUNT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * First 8 bits are the number of top-level location steps. Hopefully * there will never be more that 255 location steps!!! */	TokenNameCOMMENT_JAVADOC	 First 8 bits are the number of top-level location steps. Hopefully there will never be more that 255 location steps!!! 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
BITS_COUNT	TokenNameIdentifier	 BITS  COUNT
=	TokenNameEQUAL	
0x000000FF	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** 4 bits are reserved for future use. */	TokenNameCOMMENT_JAVADOC	 4 bits are reserved for future use. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
BITS_RESERVED	TokenNameIdentifier	 BITS  RESERVED
=	TokenNameEQUAL	
0x00000F00	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** Bit is on if the expression contains a top-level predicate. */	TokenNameCOMMENT_JAVADOC	 Bit is on if the expression contains a top-level predicate. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
BIT_PREDICATE	TokenNameIdentifier	 BIT  PREDICATE
=	TokenNameEQUAL	
(	TokenNameLPAREN	
0x00001000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Bit is on if any of the walkers contain an ancestor step. */	TokenNameCOMMENT_JAVADOC	 Bit is on if any of the walkers contain an ancestor step. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
BIT_ANCESTOR	TokenNameIdentifier	 BIT  ANCESTOR
=	TokenNameEQUAL	
(	TokenNameLPAREN	
0x00001000	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Bit is on if any of the walkers contain an ancestor-or-self step. */	TokenNameCOMMENT_JAVADOC	 Bit is on if any of the walkers contain an ancestor-or-self step. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
BIT_ANCESTOR_OR_SELF	TokenNameIdentifier	 BIT  ANCESTOR  OR  SELF
=	TokenNameEQUAL	
(	TokenNameLPAREN	
0x00001000	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Bit is on if any of the walkers contain an attribute step. */	TokenNameCOMMENT_JAVADOC	 Bit is on if any of the walkers contain an attribute step. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
BIT_ATTRIBUTE	TokenNameIdentifier	 BIT  ATTRIBUTE
=	TokenNameEQUAL	
(	TokenNameLPAREN	
0x00001000	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Bit is on if any of the walkers contain a child step. */	TokenNameCOMMENT_JAVADOC	 Bit is on if any of the walkers contain a child step. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
BIT_CHILD	TokenNameIdentifier	 BIT  CHILD
=	TokenNameEQUAL	
(	TokenNameLPAREN	
0x00001000	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Bit is on if any of the walkers contain a descendant step. */	TokenNameCOMMENT_JAVADOC	 Bit is on if any of the walkers contain a descendant step. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
BIT_DESCENDANT	TokenNameIdentifier	 BIT  DESCENDANT
=	TokenNameEQUAL	
(	TokenNameLPAREN	
0x00001000	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
5	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Bit is on if any of the walkers contain a descendant-or-self step. */	TokenNameCOMMENT_JAVADOC	 Bit is on if any of the walkers contain a descendant-or-self step. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
BIT_DESCENDANT_OR_SELF	TokenNameIdentifier	 BIT  DESCENDANT  OR  SELF
=	TokenNameEQUAL	
(	TokenNameLPAREN	
0x00001000	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
6	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Bit is on if any of the walkers contain a following step. */	TokenNameCOMMENT_JAVADOC	 Bit is on if any of the walkers contain a following step. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
BIT_FOLLOWING	TokenNameIdentifier	 BIT  FOLLOWING
=	TokenNameEQUAL	
(	TokenNameLPAREN	
0x00001000	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
7	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Bit is on if any of the walkers contain a following-sibiling step. */	TokenNameCOMMENT_JAVADOC	 Bit is on if any of the walkers contain a following-sibiling step. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
BIT_FOLLOWING_SIBLING	TokenNameIdentifier	 BIT  FOLLOWING  SIBLING
=	TokenNameEQUAL	
(	TokenNameLPAREN	
0x00001000	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Bit is on if any of the walkers contain a namespace step. */	TokenNameCOMMENT_JAVADOC	 Bit is on if any of the walkers contain a namespace step. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
BIT_NAMESPACE	TokenNameIdentifier	 BIT  NAMESPACE
=	TokenNameEQUAL	
(	TokenNameLPAREN	
0x00001000	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
9	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Bit is on if any of the walkers contain a parent step. */	TokenNameCOMMENT_JAVADOC	 Bit is on if any of the walkers contain a parent step. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
BIT_PARENT	TokenNameIdentifier	 BIT  PARENT
=	TokenNameEQUAL	
(	TokenNameLPAREN	
0x00001000	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Bit is on if any of the walkers contain a preceding step. */	TokenNameCOMMENT_JAVADOC	 Bit is on if any of the walkers contain a preceding step. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
BIT_PRECEDING	TokenNameIdentifier	 BIT  PRECEDING
=	TokenNameEQUAL	
(	TokenNameLPAREN	
0x00001000	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
11	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Bit is on if any of the walkers contain a preceding-sibling step. */	TokenNameCOMMENT_JAVADOC	 Bit is on if any of the walkers contain a preceding-sibling step. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
BIT_PRECEDING_SIBLING	TokenNameIdentifier	 BIT  PRECEDING  SIBLING
=	TokenNameEQUAL	
(	TokenNameLPAREN	
0x00001000	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
12	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Bit is on if any of the walkers contain a self step. */	TokenNameCOMMENT_JAVADOC	 Bit is on if any of the walkers contain a self step. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
BIT_SELF	TokenNameIdentifier	 BIT  SELF
=	TokenNameEQUAL	
(	TokenNameLPAREN	
0x00001000	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
13	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Bit is on if any of the walkers contain a filter (i.e. id(), extension * function, etc.) step. */	TokenNameCOMMENT_JAVADOC	 Bit is on if any of the walkers contain a filter (i.e. id(), extension function, etc.) step. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
BIT_FILTER	TokenNameIdentifier	 BIT  FILTER
=	TokenNameEQUAL	
(	TokenNameLPAREN	
0x00001000	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
14	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Bit is on if any of the walkers contain a root step. */	TokenNameCOMMENT_JAVADOC	 Bit is on if any of the walkers contain a root step. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
BIT_ROOT	TokenNameIdentifier	 BIT  ROOT
=	TokenNameEQUAL	
(	TokenNameLPAREN	
0x00001000	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
15	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * If any of these bits are on, the expression may likely traverse outside * the given subtree. */	TokenNameCOMMENT_JAVADOC	 If any of these bits are on, the expression may likely traverse outside the given subtree. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
BITMASK_TRAVERSES_OUTSIDE_SUBTREE	TokenNameIdentifier	 BITMASK  TRAVERSES  OUTSIDE  SUBTREE
=	TokenNameEQUAL	
(	TokenNameLPAREN	
BIT_NAMESPACE	TokenNameIdentifier	 BIT  NAMESPACE
// ?? 	TokenNameCOMMENT_LINE	?? 
|	TokenNameOR	
BIT_PRECEDING_SIBLING	TokenNameIdentifier	 BIT  PRECEDING  SIBLING
|	TokenNameOR	
BIT_PRECEDING	TokenNameIdentifier	 BIT  PRECEDING
|	TokenNameOR	
BIT_FOLLOWING_SIBLING	TokenNameIdentifier	 BIT  FOLLOWING  SIBLING
|	TokenNameOR	
BIT_FOLLOWING	TokenNameIdentifier	 BIT  FOLLOWING
|	TokenNameOR	
BIT_PARENT	TokenNameIdentifier	 BIT  PARENT
// except parent of attrs. 	TokenNameCOMMENT_LINE	except parent of attrs. 
|	TokenNameOR	
BIT_ANCESTOR_OR_SELF	TokenNameIdentifier	 BIT  ANCESTOR  OR  SELF
|	TokenNameOR	
BIT_ANCESTOR	TokenNameIdentifier	 BIT  ANCESTOR
|	TokenNameOR	
BIT_FILTER	TokenNameIdentifier	 BIT  FILTER
|	TokenNameOR	
BIT_ROOT	TokenNameIdentifier	 BIT  ROOT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Bit is on if any of the walkers can go backwards in document * order from the context node. */	TokenNameCOMMENT_JAVADOC	 Bit is on if any of the walkers can go backwards in document order from the context node. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
BIT_BACKWARDS_SELF	TokenNameIdentifier	 BIT  BACKWARDS  SELF
=	TokenNameEQUAL	
(	TokenNameLPAREN	
0x00001000	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Found "//foo" pattern */	TokenNameCOMMENT_JAVADOC	 Found "//foo" pattern 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
BIT_ANY_DESCENDANT_FROM_ROOT	TokenNameIdentifier	 BIT  ANY  DESCENDANT  FROM  ROOT
=	TokenNameEQUAL	
(	TokenNameLPAREN	
0x00001000	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
17	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Bit is on if any of the walkers contain an node() test. This is * really only useful if the count is 1. */	TokenNameCOMMENT_JAVADOC	 Bit is on if any of the walkers contain an node() test. This is really only useful if the count is 1. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
BIT_NODETEST_ANY	TokenNameIdentifier	 BIT  NODETEST  ANY
=	TokenNameEQUAL	
(	TokenNameLPAREN	
0x00001000	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
18	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// can't go higher than 18! 	TokenNameCOMMENT_LINE	can't go higher than 18! 
/** Bit is on if the expression is a match pattern. */	TokenNameCOMMENT_JAVADOC	 Bit is on if the expression is a match pattern. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
BIT_MATCH_PATTERN	TokenNameIdentifier	 BIT  MATCH  PATTERN
=	TokenNameEQUAL	
(	TokenNameLPAREN	
0x00001000	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
19	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
