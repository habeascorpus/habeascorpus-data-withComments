/* Generated By:JavaCC: Do not edit this line. QueryParser.java */	TokenNameCOMMENT_BLOCK	 Generated By:JavaCC: Do not edit this line. QueryParser.java 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
surround	TokenNameIdentifier	 surround
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
List	TokenNameIdentifier	 List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
StringReader	TokenNameIdentifier	 String Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
TokenStream	TokenNameIdentifier	 Token Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
surround	TokenNameIdentifier	 surround
.	TokenNameDOT	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
SrndQuery	TokenNameIdentifier	 Srnd Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
surround	TokenNameIdentifier	 surround
.	TokenNameDOT	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
FieldsQuery	TokenNameIdentifier	 Fields Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
surround	TokenNameIdentifier	 surround
.	TokenNameDOT	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
OrQuery	TokenNameIdentifier	 Or Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
surround	TokenNameIdentifier	 surround
.	TokenNameDOT	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
AndQuery	TokenNameIdentifier	 And Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
surround	TokenNameIdentifier	 surround
.	TokenNameDOT	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
NotQuery	TokenNameIdentifier	 Not Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
surround	TokenNameIdentifier	 surround
.	TokenNameDOT	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
DistanceQuery	TokenNameIdentifier	 Distance Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
surround	TokenNameIdentifier	 surround
.	TokenNameDOT	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
SrndTermQuery	TokenNameIdentifier	 Srnd Term Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
surround	TokenNameIdentifier	 surround
.	TokenNameDOT	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
SrndPrefixQuery	TokenNameIdentifier	 Srnd Prefix Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
surround	TokenNameIdentifier	 surround
.	TokenNameDOT	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
SrndTruncQuery	TokenNameIdentifier	 Srnd Trunc Query
;	TokenNameSEMICOLON	
/** * This class is generated by JavaCC. The only method that clients should need * to call is <a href="#parse">parse()</a>. */	TokenNameCOMMENT_JAVADOC	 This class is generated by JavaCC. The only method that clients should need to call is <a href="#parse">parse()</a>. 
public	TokenNamepublic	
class	TokenNameclass	
QueryParser	TokenNameIdentifier	 Query Parser
implements	TokenNameimplements	
QueryParserConstants	TokenNameIdentifier	 Query Parser Constants
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
minimumPrefixLength	TokenNameIdentifier	 minimum Prefix Length
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
minimumCharsInTrunc	TokenNameIdentifier	 minimum Chars In Trunc
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
truncationErrorMessage	TokenNameIdentifier	 truncation Error Message
=	TokenNameEQUAL	
"Too unrestrictive truncation: "	TokenNameStringLiteral	Too unrestrictive truncation: 
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
boostErrorMessage	TokenNameIdentifier	 boost Error Message
=	TokenNameEQUAL	
"Cannot handle boost value: "	TokenNameStringLiteral	Cannot handle boost value: 
;	TokenNameSEMICOLON	
/* CHECKME: These should be the same as for the tokenizer. How? */	TokenNameCOMMENT_BLOCK	 CHECKME: These should be the same as for the tokenizer. How? 
final	TokenNamefinal	
char	TokenNamechar	
truncator	TokenNameIdentifier	 truncator
=	TokenNameEQUAL	
'*'	TokenNameCharacterLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
char	TokenNamechar	
anyChar	TokenNameIdentifier	 any Char
=	TokenNameEQUAL	
'?'	TokenNameCharacterLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
char	TokenNamechar	
quote	TokenNameIdentifier	 quote
=	TokenNameEQUAL	
'\"'	TokenNameCharacterLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
char	TokenNamechar	
fieldOperator	TokenNameIdentifier	 field Operator
=	TokenNameEQUAL	
':'	TokenNameCharacterLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
char	TokenNamechar	
comma	TokenNameIdentifier	 comma
=	TokenNameEQUAL	
','	TokenNameCharacterLiteral	
;	TokenNameSEMICOLON	
/* prefix list separator */	TokenNameCOMMENT_BLOCK	 prefix list separator 
final	TokenNamefinal	
char	TokenNamechar	
carat	TokenNameIdentifier	 carat
=	TokenNameEQUAL	
'^'	TokenNameCharacterLiteral	
;	TokenNameSEMICOLON	
/* weight operator */	TokenNameCOMMENT_BLOCK	 weight operator 
static	TokenNamestatic	
public	TokenNamepublic	
SrndQuery	TokenNameIdentifier	 Srnd Query
parse	TokenNameIdentifier	 parse
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
QueryParser	TokenNameIdentifier	 Query Parser
parser	TokenNameIdentifier	 parser
=	TokenNameEQUAL	
new	TokenNamenew	
QueryParser	TokenNameIdentifier	 Query Parser
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
parse2	TokenNameIdentifier	 parse2
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
QueryParser	TokenNameIdentifier	 Query Parser
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
(	TokenNameLPAREN	
new	TokenNamenew	
FastCharStream	TokenNameIdentifier	 Fast Char Stream
(	TokenNameLPAREN	
new	TokenNamenew	
StringReader	TokenNameIdentifier	 String Reader
(	TokenNameLPAREN	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
SrndQuery	TokenNameIdentifier	 Srnd Query
parse2	TokenNameIdentifier	 parse2
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
ReInit	TokenNameIdentifier	 Re Init
(	TokenNameLPAREN	
new	TokenNamenew	
FastCharStream	TokenNameIdentifier	 Fast Char Stream
(	TokenNameLPAREN	
new	TokenNamenew	
StringReader	TokenNameIdentifier	 String Reader
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
return	TokenNamereturn	
TopSrndQuery	TokenNameIdentifier	 Top Srnd Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
TokenMgrError	TokenNameIdentifier	 Token Mgr Error
tme	TokenNameIdentifier	 tme
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
tme	TokenNameIdentifier	 tme
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
protected	TokenNameprotected	
SrndQuery	TokenNameIdentifier	 Srnd Query
getFieldsQuery	TokenNameIdentifier	 get Fields Query
(	TokenNameLPAREN	
SrndQuery	TokenNameIdentifier	 Srnd Query
q	TokenNameIdentifier	 q
,	TokenNameCOMMA	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
fieldNames	TokenNameIdentifier	 field Names
)	TokenNameRPAREN	
{	TokenNameLBRACE	
/* FIXME: check acceptable subquery: at least one subquery should not be * a fields query. */	TokenNameCOMMENT_BLOCK	 FIXME: check acceptable subquery: at least one subquery should not be a fields query. 
return	TokenNamereturn	
new	TokenNamenew	
FieldsQuery	TokenNameIdentifier	 Fields Query
(	TokenNameLPAREN	
q	TokenNameIdentifier	 q
,	TokenNameCOMMA	
fieldNames	TokenNameIdentifier	 field Names
,	TokenNameCOMMA	
fieldOperator	TokenNameIdentifier	 field Operator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
SrndQuery	TokenNameIdentifier	 Srnd Query
getOrQuery	TokenNameIdentifier	 get Or Query
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
SrndQuery	TokenNameIdentifier	 Srnd Query
>	TokenNameGREATER	
queries	TokenNameIdentifier	 queries
,	TokenNameCOMMA	
boolean	TokenNameboolean	
infix	TokenNameIdentifier	 infix
,	TokenNameCOMMA	
Token	TokenNameIdentifier	 Token
orToken	TokenNameIdentifier	 or Token
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
OrQuery	TokenNameIdentifier	 Or Query
(	TokenNameLPAREN	
queries	TokenNameIdentifier	 queries
,	TokenNameCOMMA	
infix	TokenNameIdentifier	 infix
,	TokenNameCOMMA	
orToken	TokenNameIdentifier	 or Token
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
SrndQuery	TokenNameIdentifier	 Srnd Query
getAndQuery	TokenNameIdentifier	 get And Query
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
SrndQuery	TokenNameIdentifier	 Srnd Query
>	TokenNameGREATER	
queries	TokenNameIdentifier	 queries
,	TokenNameCOMMA	
boolean	TokenNameboolean	
infix	TokenNameIdentifier	 infix
,	TokenNameCOMMA	
Token	TokenNameIdentifier	 Token
andToken	TokenNameIdentifier	 and Token
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
AndQuery	TokenNameIdentifier	 And Query
(	TokenNameLPAREN	
queries	TokenNameIdentifier	 queries
,	TokenNameCOMMA	
infix	TokenNameIdentifier	 infix
,	TokenNameCOMMA	
andToken	TokenNameIdentifier	 and Token
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
SrndQuery	TokenNameIdentifier	 Srnd Query
getNotQuery	TokenNameIdentifier	 get Not Query
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
SrndQuery	TokenNameIdentifier	 Srnd Query
>	TokenNameGREATER	
queries	TokenNameIdentifier	 queries
,	TokenNameCOMMA	
Token	TokenNameIdentifier	 Token
notToken	TokenNameIdentifier	 not Token
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
NotQuery	TokenNameIdentifier	 Not Query
(	TokenNameLPAREN	
queries	TokenNameIdentifier	 queries
,	TokenNameCOMMA	
notToken	TokenNameIdentifier	 not Token
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
static	TokenNamestatic	
int	TokenNameint	
getOpDistance	TokenNameIdentifier	 get Op Distance
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
distanceOp	TokenNameIdentifier	 distance Op
)	TokenNameRPAREN	
{	TokenNameLBRACE	
/* W, 2W, 3W etc -> 1, 2 3, etc. Same for N, 2N ... */	TokenNameCOMMENT_BLOCK	 W, 2W, 3W etc -> 1, 2 3, etc. Same for N, 2N ... 
return	TokenNamereturn	
distanceOp	TokenNameIdentifier	 distance Op
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
parseInt	TokenNameIdentifier	 parse Int
(	TokenNameLPAREN	
distanceOp	TokenNameIdentifier	 distance Op
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
distanceOp	TokenNameIdentifier	 distance Op
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
static	TokenNamestatic	
void	TokenNamevoid	
checkDistanceSubQueries	TokenNameIdentifier	 check Distance Sub Queries
(	TokenNameLPAREN	
DistanceQuery	TokenNameIdentifier	 Distance Query
distq	TokenNameIdentifier	 distq
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
opName	TokenNameIdentifier	 op Name
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
m	TokenNameIdentifier	 m
=	TokenNameEQUAL	
distq	TokenNameIdentifier	 distq
.	TokenNameDOT	
distanceSubQueryNotAllowed	TokenNameIdentifier	 distance Sub Query Not Allowed
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
m	TokenNameIdentifier	 m
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
"Operator "	TokenNameStringLiteral	Operator 
+	TokenNamePLUS	
opName	TokenNameIdentifier	 op Name
+	TokenNamePLUS	
": "	TokenNameStringLiteral	: 
+	TokenNamePLUS	
m	TokenNameIdentifier	 m
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
protected	TokenNameprotected	
SrndQuery	TokenNameIdentifier	 Srnd Query
getDistanceQuery	TokenNameIdentifier	 get Distance Query
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
SrndQuery	TokenNameIdentifier	 Srnd Query
>	TokenNameGREATER	
queries	TokenNameIdentifier	 queries
,	TokenNameCOMMA	
boolean	TokenNameboolean	
infix	TokenNameIdentifier	 infix
,	TokenNameCOMMA	
Token	TokenNameIdentifier	 Token
dToken	TokenNameIdentifier	 d Token
,	TokenNameCOMMA	
boolean	TokenNameboolean	
ordered	TokenNameIdentifier	 ordered
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
DistanceQuery	TokenNameIdentifier	 Distance Query
dq	TokenNameIdentifier	 dq
=	TokenNameEQUAL	
new	TokenNamenew	
DistanceQuery	TokenNameIdentifier	 Distance Query
(	TokenNameLPAREN	
queries	TokenNameIdentifier	 queries
,	TokenNameCOMMA	
infix	TokenNameIdentifier	 infix
,	TokenNameCOMMA	
getOpDistance	TokenNameIdentifier	 get Op Distance
(	TokenNameLPAREN	
dToken	TokenNameIdentifier	 d Token
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
,	TokenNameCOMMA	
dToken	TokenNameIdentifier	 d Token
.	TokenNameDOT	
image	TokenNameIdentifier	 image
,	TokenNameCOMMA	
ordered	TokenNameIdentifier	 ordered
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
checkDistanceSubQueries	TokenNameIdentifier	 check Distance Sub Queries
(	TokenNameLPAREN	
dq	TokenNameIdentifier	 dq
,	TokenNameCOMMA	
dToken	TokenNameIdentifier	 d Token
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
dq	TokenNameIdentifier	 dq
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
SrndQuery	TokenNameIdentifier	 Srnd Query
getTermQuery	TokenNameIdentifier	 get Term Query
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
term	TokenNameIdentifier	 term
,	TokenNameCOMMA	
boolean	TokenNameboolean	
quoted	TokenNameIdentifier	 quoted
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
SrndTermQuery	TokenNameIdentifier	 Srnd Term Query
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
,	TokenNameCOMMA	
quoted	TokenNameIdentifier	 quoted
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
boolean	TokenNameboolean	
allowedSuffix	TokenNameIdentifier	 allowed Suffix
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
suffixed	TokenNameIdentifier	 suffixed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
suffixed	TokenNameIdentifier	 suffixed
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>=	TokenNameGREATER_EQUAL	
minimumPrefixLength	TokenNameIdentifier	 minimum Prefix Length
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
SrndQuery	TokenNameIdentifier	 Srnd Query
getPrefixQuery	TokenNameIdentifier	 get Prefix Query
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
prefix	TokenNameIdentifier	 prefix
,	TokenNameCOMMA	
boolean	TokenNameboolean	
quoted	TokenNameIdentifier	 quoted
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
SrndPrefixQuery	TokenNameIdentifier	 Srnd Prefix Query
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
,	TokenNameCOMMA	
quoted	TokenNameIdentifier	 quoted
,	TokenNameCOMMA	
truncator	TokenNameIdentifier	 truncator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
boolean	TokenNameboolean	
allowedTruncation	TokenNameIdentifier	 allowed Truncation
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
truncated	TokenNameIdentifier	 truncated
)	TokenNameRPAREN	
{	TokenNameLBRACE	
/* At least 3 normal characters needed. */	TokenNameCOMMENT_BLOCK	 At least 3 normal characters needed. 
int	TokenNameint	
nrNormalChars	TokenNameIdentifier	 nr Normal Chars
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
truncated	TokenNameIdentifier	 truncated
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
char	TokenNamechar	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
truncated	TokenNameIdentifier	 truncated
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
!=	TokenNameNOT_EQUAL	
truncator	TokenNameIdentifier	 truncator
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
!=	TokenNameNOT_EQUAL	
anyChar	TokenNameIdentifier	 any Char
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nrNormalChars	TokenNameIdentifier	 nr Normal Chars
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
nrNormalChars	TokenNameIdentifier	 nr Normal Chars
>=	TokenNameGREATER_EQUAL	
minimumCharsInTrunc	TokenNameIdentifier	 minimum Chars In Trunc
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
SrndQuery	TokenNameIdentifier	 Srnd Query
getTruncQuery	TokenNameIdentifier	 get Trunc Query
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
truncated	TokenNameIdentifier	 truncated
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
SrndTruncQuery	TokenNameIdentifier	 Srnd Trunc Query
(	TokenNameLPAREN	
truncated	TokenNameIdentifier	 truncated
,	TokenNameCOMMA	
truncator	TokenNameIdentifier	 truncator
,	TokenNameCOMMA	
anyChar	TokenNameIdentifier	 any Char
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
public	TokenNamepublic	
SrndQuery	TokenNameIdentifier	 Srnd Query
TopSrndQuery	TokenNameIdentifier	 Top Srnd Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
SrndQuery	TokenNameIdentifier	 Srnd Query
q	TokenNameIdentifier	 q
;	TokenNameSEMICOLON	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
FieldsQuery	TokenNameIdentifier	 Fields Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
q	TokenNameIdentifier	 q
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"Missing return statement in function"	TokenNameStringLiteral	Missing return statement in function
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
public	TokenNamepublic	
SrndQuery	TokenNameIdentifier	 Srnd Query
FieldsQuery	TokenNameIdentifier	 Fields Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
SrndQuery	TokenNameIdentifier	 Srnd Query
q	TokenNameIdentifier	 q
;	TokenNameSEMICOLON	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
fieldNames	TokenNameIdentifier	 field Names
;	TokenNameSEMICOLON	
fieldNames	TokenNameIdentifier	 field Names
=	TokenNameEQUAL	
OptionalFields	TokenNameIdentifier	 Optional Fields
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
OrQuery	TokenNameIdentifier	 Or Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
(	TokenNameLPAREN	
fieldNames	TokenNameIdentifier	 field Names
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
q	TokenNameIdentifier	 q
:	TokenNameCOLON	
getFieldsQuery	TokenNameIdentifier	 get Fields Query
(	TokenNameLPAREN	
q	TokenNameIdentifier	 q
,	TokenNameCOMMA	
fieldNames	TokenNameIdentifier	 field Names
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"Missing return statement in function"	TokenNameStringLiteral	Missing return statement in function
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
public	TokenNamepublic	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
OptionalFields	TokenNameIdentifier	 Optional Fields
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
Token	TokenNameIdentifier	 Token
fieldName	TokenNameIdentifier	 field Name
;	TokenNameSEMICOLON	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
fieldNames	TokenNameIdentifier	 field Names
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
label_1	TokenNameIdentifier	 label 1
:	TokenNameCOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jj_2_1	TokenNameIdentifier	 jj 2 1
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
break	TokenNamebreak	
label_1	TokenNameIdentifier	 label 1
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// to the colon 	TokenNameCOMMENT_LINE	to the colon 
fieldName	TokenNameIdentifier	 field Name
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
TERM	TokenNameIdentifier	 TERM
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
COLON	TokenNameIdentifier	 COLON
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fieldNames	TokenNameIdentifier	 field Names
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fieldNames	TokenNameIdentifier	 field Names
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fieldNames	TokenNameIdentifier	 field Names
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
fieldName	TokenNameIdentifier	 field Name
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
fieldNames	TokenNameIdentifier	 field Names
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"Missing return statement in function"	TokenNameStringLiteral	Missing return statement in function
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
public	TokenNamepublic	
SrndQuery	TokenNameIdentifier	 Srnd Query
OrQuery	TokenNameIdentifier	 Or Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
SrndQuery	TokenNameIdentifier	 Srnd Query
q	TokenNameIdentifier	 q
;	TokenNameSEMICOLON	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SrndQuery	TokenNameIdentifier	 Srnd Query
>	TokenNameGREATER	
queries	TokenNameIdentifier	 queries
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
Token	TokenNameIdentifier	 Token
oprt	TokenNameIdentifier	 oprt
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
AndQuery	TokenNameIdentifier	 And Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
label_2	TokenNameIdentifier	 label 2
:	TokenNameCOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
OR	TokenNameIdentifier	 OR
:	TokenNameCOLON	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
break	TokenNamebreak	
label_2	TokenNameIdentifier	 label 2
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
oprt	TokenNameIdentifier	 oprt
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
OR	TokenNameIdentifier	 OR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* keep only last used operator */	TokenNameCOMMENT_BLOCK	 keep only last used operator 
if	TokenNameif	
(	TokenNameLPAREN	
queries	TokenNameIdentifier	 queries
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
queries	TokenNameIdentifier	 queries
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SrndQuery	TokenNameIdentifier	 Srnd Query
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
queries	TokenNameIdentifier	 queries
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
q	TokenNameIdentifier	 q
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
AndQuery	TokenNameIdentifier	 And Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
queries	TokenNameIdentifier	 queries
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
q	TokenNameIdentifier	 q
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
(	TokenNameLPAREN	
queries	TokenNameIdentifier	 queries
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
q	TokenNameIdentifier	 q
:	TokenNameCOLON	
getOrQuery	TokenNameIdentifier	 get Or Query
(	TokenNameLPAREN	
queries	TokenNameIdentifier	 queries
,	TokenNameCOMMA	
true	TokenNametrue	
/* infix */	TokenNameCOMMENT_BLOCK	 infix 
,	TokenNameCOMMA	
oprt	TokenNameIdentifier	 oprt
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"Missing return statement in function"	TokenNameStringLiteral	Missing return statement in function
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
public	TokenNamepublic	
SrndQuery	TokenNameIdentifier	 Srnd Query
AndQuery	TokenNameIdentifier	 And Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
SrndQuery	TokenNameIdentifier	 Srnd Query
q	TokenNameIdentifier	 q
;	TokenNameSEMICOLON	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SrndQuery	TokenNameIdentifier	 Srnd Query
>	TokenNameGREATER	
queries	TokenNameIdentifier	 queries
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
Token	TokenNameIdentifier	 Token
oprt	TokenNameIdentifier	 oprt
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
NotQuery	TokenNameIdentifier	 Not Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
label_3	TokenNameIdentifier	 label 3
:	TokenNameCOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
AND	TokenNameIdentifier	 AND
:	TokenNameCOLON	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
break	TokenNamebreak	
label_3	TokenNameIdentifier	 label 3
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
oprt	TokenNameIdentifier	 oprt
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
AND	TokenNameIdentifier	 AND
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* keep only last used operator */	TokenNameCOMMENT_BLOCK	 keep only last used operator 
if	TokenNameif	
(	TokenNameLPAREN	
queries	TokenNameIdentifier	 queries
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
queries	TokenNameIdentifier	 queries
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SrndQuery	TokenNameIdentifier	 Srnd Query
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
queries	TokenNameIdentifier	 queries
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
q	TokenNameIdentifier	 q
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
NotQuery	TokenNameIdentifier	 Not Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
queries	TokenNameIdentifier	 queries
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
q	TokenNameIdentifier	 q
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
(	TokenNameLPAREN	
queries	TokenNameIdentifier	 queries
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
q	TokenNameIdentifier	 q
:	TokenNameCOLON	
getAndQuery	TokenNameIdentifier	 get And Query
(	TokenNameLPAREN	
queries	TokenNameIdentifier	 queries
,	TokenNameCOMMA	
true	TokenNametrue	
/* infix */	TokenNameCOMMENT_BLOCK	 infix 
,	TokenNameCOMMA	
oprt	TokenNameIdentifier	 oprt
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"Missing return statement in function"	TokenNameStringLiteral	Missing return statement in function
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
public	TokenNamepublic	
SrndQuery	TokenNameIdentifier	 Srnd Query
NotQuery	TokenNameIdentifier	 Not Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
SrndQuery	TokenNameIdentifier	 Srnd Query
q	TokenNameIdentifier	 q
;	TokenNameSEMICOLON	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SrndQuery	TokenNameIdentifier	 Srnd Query
>	TokenNameGREATER	
queries	TokenNameIdentifier	 queries
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
Token	TokenNameIdentifier	 Token
oprt	TokenNameIdentifier	 oprt
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
NQuery	TokenNameIdentifier	 N Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
label_4	TokenNameIdentifier	 label 4
:	TokenNameCOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
NOT	TokenNameIdentifier	 NOT
:	TokenNameCOLON	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
break	TokenNamebreak	
label_4	TokenNameIdentifier	 label 4
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
oprt	TokenNameIdentifier	 oprt
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
NOT	TokenNameIdentifier	 NOT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* keep only last used operator */	TokenNameCOMMENT_BLOCK	 keep only last used operator 
if	TokenNameif	
(	TokenNameLPAREN	
queries	TokenNameIdentifier	 queries
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
queries	TokenNameIdentifier	 queries
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SrndQuery	TokenNameIdentifier	 Srnd Query
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
queries	TokenNameIdentifier	 queries
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
q	TokenNameIdentifier	 q
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
NQuery	TokenNameIdentifier	 N Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
queries	TokenNameIdentifier	 queries
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
q	TokenNameIdentifier	 q
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
(	TokenNameLPAREN	
queries	TokenNameIdentifier	 queries
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
q	TokenNameIdentifier	 q
:	TokenNameCOLON	
getNotQuery	TokenNameIdentifier	 get Not Query
(	TokenNameLPAREN	
queries	TokenNameIdentifier	 queries
,	TokenNameCOMMA	
oprt	TokenNameIdentifier	 oprt
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"Missing return statement in function"	TokenNameStringLiteral	Missing return statement in function
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
public	TokenNamepublic	
SrndQuery	TokenNameIdentifier	 Srnd Query
NQuery	TokenNameIdentifier	 N Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
SrndQuery	TokenNameIdentifier	 Srnd Query
q	TokenNameIdentifier	 q
;	TokenNameSEMICOLON	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SrndQuery	TokenNameIdentifier	 Srnd Query
>	TokenNameGREATER	
queries	TokenNameIdentifier	 queries
;	TokenNameSEMICOLON	
Token	TokenNameIdentifier	 Token
dt	TokenNameIdentifier	 dt
;	TokenNameSEMICOLON	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
WQuery	TokenNameIdentifier	 W Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
label_5	TokenNameIdentifier	 label 5
:	TokenNameCOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
N	TokenNameIdentifier	 N
:	TokenNameCOLON	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
3	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
break	TokenNamebreak	
label_5	TokenNameIdentifier	 label 5
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
dt	TokenNameIdentifier	 dt
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
N	TokenNameIdentifier	 N
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
queries	TokenNameIdentifier	 queries
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SrndQuery	TokenNameIdentifier	 Srnd Query
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
queries	TokenNameIdentifier	 queries
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
q	TokenNameIdentifier	 q
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* left associative */	TokenNameCOMMENT_BLOCK	 left associative 
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
WQuery	TokenNameIdentifier	 W Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
queries	TokenNameIdentifier	 queries
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
q	TokenNameIdentifier	 q
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
getDistanceQuery	TokenNameIdentifier	 get Distance Query
(	TokenNameLPAREN	
queries	TokenNameIdentifier	 queries
,	TokenNameCOMMA	
true	TokenNametrue	
/* infix */	TokenNameCOMMENT_BLOCK	 infix 
,	TokenNameCOMMA	
dt	TokenNameIdentifier	 dt
,	TokenNameCOMMA	
false	TokenNamefalse	
/* not ordered */	TokenNameCOMMENT_BLOCK	 not ordered 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
q	TokenNameIdentifier	 q
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"Missing return statement in function"	TokenNameStringLiteral	Missing return statement in function
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
public	TokenNamepublic	
SrndQuery	TokenNameIdentifier	 Srnd Query
WQuery	TokenNameIdentifier	 W Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
SrndQuery	TokenNameIdentifier	 Srnd Query
q	TokenNameIdentifier	 q
;	TokenNameSEMICOLON	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SrndQuery	TokenNameIdentifier	 Srnd Query
>	TokenNameGREATER	
queries	TokenNameIdentifier	 queries
;	TokenNameSEMICOLON	
Token	TokenNameIdentifier	 Token
wt	TokenNameIdentifier	 wt
;	TokenNameSEMICOLON	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
PrimaryQuery	TokenNameIdentifier	 Primary Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
label_6	TokenNameIdentifier	 label 6
:	TokenNameCOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
W	TokenNameIdentifier	 W
:	TokenNameCOLON	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
4	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
break	TokenNamebreak	
label_6	TokenNameIdentifier	 label 6
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
wt	TokenNameIdentifier	 wt
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
W	TokenNameIdentifier	 W
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
queries	TokenNameIdentifier	 queries
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SrndQuery	TokenNameIdentifier	 Srnd Query
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
queries	TokenNameIdentifier	 queries
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
q	TokenNameIdentifier	 q
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* left associative */	TokenNameCOMMENT_BLOCK	 left associative 
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
PrimaryQuery	TokenNameIdentifier	 Primary Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
queries	TokenNameIdentifier	 queries
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
q	TokenNameIdentifier	 q
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
getDistanceQuery	TokenNameIdentifier	 get Distance Query
(	TokenNameLPAREN	
queries	TokenNameIdentifier	 queries
,	TokenNameCOMMA	
true	TokenNametrue	
/* infix */	TokenNameCOMMENT_BLOCK	 infix 
,	TokenNameCOMMA	
wt	TokenNameIdentifier	 wt
,	TokenNameCOMMA	
true	TokenNametrue	
/* ordered */	TokenNameCOMMENT_BLOCK	 ordered 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
q	TokenNameIdentifier	 q
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"Missing return statement in function"	TokenNameStringLiteral	Missing return statement in function
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
public	TokenNamepublic	
SrndQuery	TokenNameIdentifier	 Srnd Query
PrimaryQuery	TokenNameIdentifier	 Primary Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
/* bracketed weighted query or weighted term */	TokenNameCOMMENT_BLOCK	 bracketed weighted query or weighted term 
SrndQuery	TokenNameIdentifier	 Srnd Query
q	TokenNameIdentifier	 q
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
LPAREN	TokenNameIdentifier	 LPAREN
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
LPAREN	TokenNameIdentifier	 LPAREN
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
FieldsQuery	TokenNameIdentifier	 Fields Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RPAREN	TokenNameIdentifier	 RPAREN
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OR	TokenNameIdentifier	 OR
:	TokenNameCOLON	
case	TokenNamecase	
AND	TokenNameIdentifier	 AND
:	TokenNameCOLON	
case	TokenNamecase	
W	TokenNameIdentifier	 W
:	TokenNameCOLON	
case	TokenNamecase	
N	TokenNameIdentifier	 N
:	TokenNameCOLON	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
PrefixOperatorQuery	TokenNameIdentifier	 Prefix Operator Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
TRUNCQUOTED	TokenNameIdentifier	 TRUNCQUOTED
:	TokenNameCOLON	
case	TokenNamecase	
QUOTED	TokenNameIdentifier	 QUOTED
:	TokenNameCOLON	
case	TokenNamecase	
SUFFIXTERM	TokenNameIdentifier	 SUFFIXTERM
:	TokenNameCOLON	
case	TokenNamecase	
TRUNCTERM	TokenNameIdentifier	 TRUNCTERM
:	TokenNameCOLON	
case	TokenNamecase	
TERM	TokenNameIdentifier	 TERM
:	TokenNameCOLON	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
SimpleTerm	TokenNameIdentifier	 Simple Term
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
5	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
OptionalWeights	TokenNameIdentifier	 Optional Weights
(	TokenNameLPAREN	
q	TokenNameIdentifier	 q
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
q	TokenNameIdentifier	 q
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"Missing return statement in function"	TokenNameStringLiteral	Missing return statement in function
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
public	TokenNamepublic	
SrndQuery	TokenNameIdentifier	 Srnd Query
PrefixOperatorQuery	TokenNameIdentifier	 Prefix Operator Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
Token	TokenNameIdentifier	 Token
oprt	TokenNameIdentifier	 oprt
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
SrndQuery	TokenNameIdentifier	 Srnd Query
>	TokenNameGREATER	
queries	TokenNameIdentifier	 queries
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
OR	TokenNameIdentifier	 OR
:	TokenNameCOLON	
oprt	TokenNameIdentifier	 oprt
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
OR	TokenNameIdentifier	 OR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* prefix OR */	TokenNameCOMMENT_BLOCK	 prefix OR 
queries	TokenNameIdentifier	 queries
=	TokenNameEQUAL	
FieldsQueryList	TokenNameIdentifier	 Fields Query List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
getOrQuery	TokenNameIdentifier	 get Or Query
(	TokenNameLPAREN	
queries	TokenNameIdentifier	 queries
,	TokenNameCOMMA	
false	TokenNamefalse	
/* not infix */	TokenNameCOMMENT_BLOCK	 not infix 
,	TokenNameCOMMA	
oprt	TokenNameIdentifier	 oprt
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
AND	TokenNameIdentifier	 AND
:	TokenNameCOLON	
oprt	TokenNameIdentifier	 oprt
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
AND	TokenNameIdentifier	 AND
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* prefix AND */	TokenNameCOMMENT_BLOCK	 prefix AND 
queries	TokenNameIdentifier	 queries
=	TokenNameEQUAL	
FieldsQueryList	TokenNameIdentifier	 Fields Query List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
getAndQuery	TokenNameIdentifier	 get And Query
(	TokenNameLPAREN	
queries	TokenNameIdentifier	 queries
,	TokenNameCOMMA	
false	TokenNamefalse	
/* not infix */	TokenNameCOMMENT_BLOCK	 not infix 
,	TokenNameCOMMA	
oprt	TokenNameIdentifier	 oprt
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
N	TokenNameIdentifier	 N
:	TokenNameCOLON	
oprt	TokenNameIdentifier	 oprt
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
N	TokenNameIdentifier	 N
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* prefix N */	TokenNameCOMMENT_BLOCK	 prefix N 
queries	TokenNameIdentifier	 queries
=	TokenNameEQUAL	
FieldsQueryList	TokenNameIdentifier	 Fields Query List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
getDistanceQuery	TokenNameIdentifier	 get Distance Query
(	TokenNameLPAREN	
queries	TokenNameIdentifier	 queries
,	TokenNameCOMMA	
false	TokenNamefalse	
/* not infix */	TokenNameCOMMENT_BLOCK	 not infix 
,	TokenNameCOMMA	
oprt	TokenNameIdentifier	 oprt
,	TokenNameCOMMA	
false	TokenNamefalse	
/* not ordered */	TokenNameCOMMENT_BLOCK	 not ordered 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
W	TokenNameIdentifier	 W
:	TokenNameCOLON	
oprt	TokenNameIdentifier	 oprt
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
W	TokenNameIdentifier	 W
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* prefix W */	TokenNameCOMMENT_BLOCK	 prefix W 
queries	TokenNameIdentifier	 queries
=	TokenNameEQUAL	
FieldsQueryList	TokenNameIdentifier	 Fields Query List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
getDistanceQuery	TokenNameIdentifier	 get Distance Query
(	TokenNameLPAREN	
queries	TokenNameIdentifier	 queries
,	TokenNameCOMMA	
false	TokenNamefalse	
/* not infix */	TokenNameCOMMENT_BLOCK	 not infix 
,	TokenNameCOMMA	
oprt	TokenNameIdentifier	 oprt
,	TokenNameCOMMA	
true	TokenNametrue	
/* ordered */	TokenNameCOMMENT_BLOCK	 ordered 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
6	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"Missing return statement in function"	TokenNameStringLiteral	Missing return statement in function
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
SrndQuery	TokenNameIdentifier	 Srnd Query
>	TokenNameGREATER	
FieldsQueryList	TokenNameIdentifier	 Fields Query List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
SrndQuery	TokenNameIdentifier	 Srnd Query
q	TokenNameIdentifier	 q
;	TokenNameSEMICOLON	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SrndQuery	TokenNameIdentifier	 Srnd Query
>	TokenNameGREATER	
queries	TokenNameIdentifier	 queries
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SrndQuery	TokenNameIdentifier	 Srnd Query
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
LPAREN	TokenNameIdentifier	 LPAREN
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
FieldsQuery	TokenNameIdentifier	 Fields Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
queries	TokenNameIdentifier	 queries
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
q	TokenNameIdentifier	 q
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
label_7	TokenNameIdentifier	 label 7
:	TokenNameCOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
COMMA	TokenNameIdentifier	 COMMA
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
FieldsQuery	TokenNameIdentifier	 Fields Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
queries	TokenNameIdentifier	 queries
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
q	TokenNameIdentifier	 q
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
COMMA	TokenNameIdentifier	 COMMA
:	TokenNameCOLON	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
7	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
break	TokenNamebreak	
label_7	TokenNameIdentifier	 label 7
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RPAREN	TokenNameIdentifier	 RPAREN
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
queries	TokenNameIdentifier	 queries
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"Missing return statement in function"	TokenNameStringLiteral	Missing return statement in function
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
public	TokenNamepublic	
SrndQuery	TokenNameIdentifier	 Srnd Query
SimpleTerm	TokenNameIdentifier	 Simple Term
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
Token	TokenNameIdentifier	 Token
term	TokenNameIdentifier	 term
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
TERM	TokenNameIdentifier	 TERM
:	TokenNameCOLON	
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
TERM	TokenNameIdentifier	 TERM
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
getTermQuery	TokenNameIdentifier	 get Term Query
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
image	TokenNameIdentifier	 image
,	TokenNameCOMMA	
false	TokenNamefalse	
/* not quoted */	TokenNameCOMMENT_BLOCK	 not quoted 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
QUOTED	TokenNameIdentifier	 QUOTED
:	TokenNameCOLON	
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
QUOTED	TokenNameIdentifier	 QUOTED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
getTermQuery	TokenNameIdentifier	 get Term Query
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
true	TokenNametrue	
/* quoted */	TokenNameCOMMENT_BLOCK	 quoted 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
SUFFIXTERM	TokenNameIdentifier	 SUFFIXTERM
:	TokenNameCOLON	
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
SUFFIXTERM	TokenNameIdentifier	 SUFFIXTERM
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* ending in * */	TokenNameCOMMENT_BLOCK	 ending in 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
allowedSuffix	TokenNameIdentifier	 allowed Suffix
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
truncationErrorMessage	TokenNameIdentifier	 truncation Error Message
+	TokenNamePLUS	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
getPrefixQuery	TokenNameIdentifier	 get Prefix Query
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
/* not quoted */	TokenNameCOMMENT_BLOCK	 not quoted 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
TRUNCTERM	TokenNameIdentifier	 TRUNCTERM
:	TokenNameCOLON	
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
TRUNCTERM	TokenNameIdentifier	 TRUNCTERM
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* with at least one * or ? */	TokenNameCOMMENT_BLOCK	 with at least one or ? 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
allowedTruncation	TokenNameIdentifier	 allowed Truncation
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
truncationErrorMessage	TokenNameIdentifier	 truncation Error Message
+	TokenNamePLUS	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
getTruncQuery	TokenNameIdentifier	 get Trunc Query
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
TRUNCQUOTED	TokenNameIdentifier	 TRUNCQUOTED
:	TokenNameCOLON	
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
TRUNCQUOTED	TokenNameIdentifier	 TRUNCQUOTED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* eg. "9b-b,m"* */	TokenNameCOMMENT_BLOCK	 eg. "9b-b,m"* 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
<	TokenNameLESS	
minimumPrefixLength	TokenNameIdentifier	 minimum Prefix Length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
truncationErrorMessage	TokenNameIdentifier	 truncation Error Message
+	TokenNamePLUS	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
getPrefixQuery	TokenNameIdentifier	 get Prefix Query
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
true	TokenNametrue	
/* quoted */	TokenNameCOMMENT_BLOCK	 quoted 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
8	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"Missing return statement in function"	TokenNameStringLiteral	Missing return statement in function
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
public	TokenNamepublic	
void	TokenNamevoid	
OptionalWeights	TokenNameIdentifier	 Optional Weights
(	TokenNameLPAREN	
SrndQuery	TokenNameIdentifier	 Srnd Query
q	TokenNameIdentifier	 q
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
Token	TokenNameIdentifier	 Token
weight	TokenNameIdentifier	 weight
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
label_8	TokenNameIdentifier	 label 8
:	TokenNameCOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
CARAT	TokenNameIdentifier	 CARAT
:	TokenNameCOLON	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
9	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
break	TokenNamebreak	
label_8	TokenNameIdentifier	 label 8
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
CARAT	TokenNameIdentifier	 CARAT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
weight	TokenNameIdentifier	 weight
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
NUMBER	TokenNameIdentifier	 NUMBER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
f	TokenNameIdentifier	 f
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
Float	TokenNameIdentifier	 Float
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
weight	TokenNameIdentifier	 weight
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
.	TokenNameDOT	
floatValue	TokenNameIdentifier	 float Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
floatExc	TokenNameIdentifier	 float Exc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
boostErrorMessage	TokenNameIdentifier	 boost Error Message
+	TokenNamePLUS	
weight	TokenNameIdentifier	 weight
.	TokenNameDOT	
image	TokenNameIdentifier	 image
+	TokenNamePLUS	
" ("	TokenNameStringLiteral	 (
+	TokenNamePLUS	
floatExc	TokenNameIdentifier	 float Exc
+	TokenNamePLUS	
")"	TokenNameStringLiteral	)
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
f	TokenNameIdentifier	 f
<=	TokenNameLESS_EQUAL	
0.0	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
boostErrorMessage	TokenNameIdentifier	 boost Error Message
+	TokenNamePLUS	
weight	TokenNameIdentifier	 weight
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
q	TokenNameIdentifier	 q
.	TokenNameDOT	
setWeight	TokenNameIdentifier	 set Weight
(	TokenNameLPAREN	
f	TokenNameIdentifier	 f
*	TokenNameMULTIPLY	
q	TokenNameIdentifier	 q
.	TokenNameDOT	
getWeight	TokenNameIdentifier	 get Weight
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* left associative, fwiw */	TokenNameCOMMENT_BLOCK	 left associative, fwiw 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
jj_2_1	TokenNameIdentifier	 jj 2 1
(	TokenNameLPAREN	
int	TokenNameint	
xla	TokenNameIdentifier	 xla
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_la	TokenNameIdentifier	 jj la
=	TokenNameEQUAL	
xla	TokenNameIdentifier	 xla
;	TokenNameSEMICOLON	
jj_lastpos	TokenNameIdentifier	 jj lastpos
=	TokenNameEQUAL	
jj_scanpos	TokenNameIdentifier	 jj scanpos
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
return	TokenNamereturn	
!	TokenNameNOT	
jj_3_1	TokenNameIdentifier	 jj 3 1
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
LookaheadSuccess	TokenNameIdentifier	 Lookahead Success
ls	TokenNameIdentifier	 ls
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
jj_save	TokenNameIdentifier	 jj save
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
xla	TokenNameIdentifier	 xla
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
jj_3_1	TokenNameIdentifier	 jj 3 1
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jj_scan_token	TokenNameIdentifier	 jj scan token
(	TokenNameLPAREN	
TERM	TokenNameIdentifier	 TERM
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jj_scan_token	TokenNameIdentifier	 jj scan token
(	TokenNameLPAREN	
COLON	TokenNameIdentifier	 COLON
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Generated Token Manager. */	TokenNameCOMMENT_JAVADOC	 Generated Token Manager. 
public	TokenNamepublic	
QueryParserTokenManager	TokenNameIdentifier	 Query Parser Token Manager
token_source	TokenNameIdentifier	 token source
;	TokenNameSEMICOLON	
/** Current token. */	TokenNameCOMMENT_JAVADOC	 Current token. 
public	TokenNamepublic	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
/** Next token. */	TokenNameCOMMENT_JAVADOC	 Next token. 
public	TokenNamepublic	
Token	TokenNameIdentifier	 Token
jj_nt	TokenNameIdentifier	 jj nt
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
jj_ntk	TokenNameIdentifier	 jj ntk
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Token	TokenNameIdentifier	 Token
jj_scanpos	TokenNameIdentifier	 jj scanpos
,	TokenNameCOMMA	
jj_lastpos	TokenNameIdentifier	 jj lastpos
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
jj_la	TokenNameIdentifier	 jj la
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
final	TokenNamefinal	
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jj_la1	TokenNameIdentifier	 jj la1
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
10	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jj_la1_0	TokenNameIdentifier	 jj la1 0
;	TokenNameSEMICOLON	
static	TokenNamestatic	
{	TokenNameLBRACE	
jj_la1_init_0	TokenNameIdentifier	 jj la1 init 0
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
jj_la1_init_0	TokenNameIdentifier	 jj la1 init 0
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_la1_0	TokenNameIdentifier	 jj la1 0
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
0x100	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x200	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x400	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x1000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x800	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x7c3b00	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x1b00	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x8000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x7c0000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x20000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
private	TokenNameprivate	
JJCalls	TokenNameIdentifier	 JJ Calls
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
=	TokenNameEQUAL	
new	TokenNamenew	
JJCalls	TokenNameIdentifier	 JJ Calls
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
jj_rescan	TokenNameIdentifier	 jj rescan
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
jj_gc	TokenNameIdentifier	 jj gc
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** Constructor with user supplied CharStream. */	TokenNameCOMMENT_JAVADOC	 Constructor with user supplied CharStream. 
public	TokenNamepublic	
QueryParser	TokenNameIdentifier	 Query Parser
(	TokenNameLPAREN	
CharStream	TokenNameIdentifier	 Char Stream
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
{	TokenNameLBRACE	
token_source	TokenNameIdentifier	 token source
=	TokenNameEQUAL	
new	TokenNamenew	
QueryParserTokenManager	TokenNameIdentifier	 Query Parser Token Manager
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
new	TokenNamenew	
Token	TokenNameIdentifier	 Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jj_gen	TokenNameIdentifier	 jj gen
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
JJCalls	TokenNameIdentifier	 JJ Calls
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Reinitialise. */	TokenNameCOMMENT_JAVADOC	 Reinitialise. 
public	TokenNamepublic	
void	TokenNamevoid	
ReInit	TokenNameIdentifier	 Re Init
(	TokenNameLPAREN	
CharStream	TokenNameIdentifier	 Char Stream
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
{	TokenNameLBRACE	
token_source	TokenNameIdentifier	 token source
.	TokenNameDOT	
ReInit	TokenNameIdentifier	 Re Init
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
new	TokenNamenew	
Token	TokenNameIdentifier	 Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jj_gen	TokenNameIdentifier	 jj gen
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
JJCalls	TokenNameIdentifier	 JJ Calls
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Constructor with generated Token Manager. */	TokenNameCOMMENT_JAVADOC	 Constructor with generated Token Manager. 
public	TokenNamepublic	
QueryParser	TokenNameIdentifier	 Query Parser
(	TokenNameLPAREN	
QueryParserTokenManager	TokenNameIdentifier	 Query Parser Token Manager
tm	TokenNameIdentifier	 tm
)	TokenNameRPAREN	
{	TokenNameLBRACE	
token_source	TokenNameIdentifier	 token source
=	TokenNameEQUAL	
tm	TokenNameIdentifier	 tm
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
new	TokenNamenew	
Token	TokenNameIdentifier	 Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jj_gen	TokenNameIdentifier	 jj gen
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
JJCalls	TokenNameIdentifier	 JJ Calls
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Reinitialise. */	TokenNameCOMMENT_JAVADOC	 Reinitialise. 
public	TokenNamepublic	
void	TokenNamevoid	
ReInit	TokenNameIdentifier	 Re Init
(	TokenNameLPAREN	
QueryParserTokenManager	TokenNameIdentifier	 Query Parser Token Manager
tm	TokenNameIdentifier	 tm
)	TokenNameRPAREN	
{	TokenNameLBRACE	
token_source	TokenNameIdentifier	 token source
=	TokenNameEQUAL	
tm	TokenNameIdentifier	 tm
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
new	TokenNamenew	
Token	TokenNameIdentifier	 Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jj_gen	TokenNameIdentifier	 jj gen
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
JJCalls	TokenNameIdentifier	 JJ Calls
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
Token	TokenNameIdentifier	 Token
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
Token	TokenNameIdentifier	 Token
oldToken	TokenNameIdentifier	 old Token
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
oldToken	TokenNameIdentifier	 old Token
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
.	TokenNameDOT	
next	TokenNameIdentifier	 next
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
else	TokenNameelse	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
token_source	TokenNameIdentifier	 token source
.	TokenNameDOT	
getNextToken	TokenNameIdentifier	 get Next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
==	TokenNameEQUAL_EQUAL	
kind	TokenNameIdentifier	 kind
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_gen	TokenNameIdentifier	 jj gen
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
++	TokenNamePLUS_PLUS	
jj_gc	TokenNameIdentifier	 jj gc
>	TokenNameGREATER	
100	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_gc	TokenNameIdentifier	 jj gc
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
JJCalls	TokenNameIdentifier	 JJ Calls
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
gen	TokenNameIdentifier	 gen
<	TokenNameLESS	
jj_gen	TokenNameIdentifier	 jj gen
)	TokenNameRPAREN	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
first	TokenNameIdentifier	 first
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
oldToken	TokenNameIdentifier	 old Token
;	TokenNameSEMICOLON	
jj_kind	TokenNameIdentifier	 jj kind
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
generateParseException	TokenNameIdentifier	 generate Parse Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
static	TokenNamestatic	
private	TokenNameprivate	
final	TokenNamefinal	
class	TokenNameclass	
LookaheadSuccess	TokenNameIdentifier	 Lookahead Success
extends	TokenNameextends	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
Error	TokenNameIdentifier	 Error
{	TokenNameLBRACE	
}	TokenNameRBRACE	
final	TokenNamefinal	
private	TokenNameprivate	
LookaheadSuccess	TokenNameIdentifier	 Lookahead Success
jj_ls	TokenNameIdentifier	 jj ls
=	TokenNameEQUAL	
new	TokenNamenew	
LookaheadSuccess	TokenNameIdentifier	 Lookahead Success
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
jj_scan_token	TokenNameIdentifier	 jj scan token
(	TokenNameLPAREN	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jj_scanpos	TokenNameIdentifier	 jj scanpos
==	TokenNameEQUAL_EQUAL	
jj_lastpos	TokenNameIdentifier	 jj lastpos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_la	TokenNameIdentifier	 jj la
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jj_scanpos	TokenNameIdentifier	 jj scanpos
.	TokenNameDOT	
next	TokenNameIdentifier	 next
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_lastpos	TokenNameIdentifier	 jj lastpos
=	TokenNameEQUAL	
jj_scanpos	TokenNameIdentifier	 jj scanpos
=	TokenNameEQUAL	
jj_scanpos	TokenNameIdentifier	 jj scanpos
.	TokenNameDOT	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
token_source	TokenNameIdentifier	 token source
.	TokenNameDOT	
getNextToken	TokenNameIdentifier	 get Next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
jj_lastpos	TokenNameIdentifier	 jj lastpos
=	TokenNameEQUAL	
jj_scanpos	TokenNameIdentifier	 jj scanpos
=	TokenNameEQUAL	
jj_scanpos	TokenNameIdentifier	 jj scanpos
.	TokenNameDOT	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
jj_scanpos	TokenNameIdentifier	 jj scanpos
=	TokenNameEQUAL	
jj_scanpos	TokenNameIdentifier	 jj scanpos
.	TokenNameDOT	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jj_rescan	TokenNameIdentifier	 jj rescan
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
Token	TokenNameIdentifier	 Token
tok	TokenNameIdentifier	 tok
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
tok	TokenNameIdentifier	 tok
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
tok	TokenNameIdentifier	 tok
!=	TokenNameNOT_EQUAL	
jj_scanpos	TokenNameIdentifier	 jj scanpos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
tok	TokenNameIdentifier	 tok
=	TokenNameEQUAL	
tok	TokenNameIdentifier	 tok
.	TokenNameDOT	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
tok	TokenNameIdentifier	 tok
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
jj_add_error_token	TokenNameIdentifier	 jj add error token
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
,	TokenNameCOMMA	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jj_scanpos	TokenNameIdentifier	 jj scanpos
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
!=	TokenNameNOT_EQUAL	
kind	TokenNameIdentifier	 kind
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jj_la	TokenNameIdentifier	 jj la
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
jj_scanpos	TokenNameIdentifier	 jj scanpos
==	TokenNameEQUAL_EQUAL	
jj_lastpos	TokenNameIdentifier	 jj lastpos
)	TokenNameRPAREN	
throw	TokenNamethrow	
jj_ls	TokenNameIdentifier	 jj ls
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Get the next Token. */	TokenNameCOMMENT_JAVADOC	 Get the next Token. 
final	TokenNamefinal	
public	TokenNamepublic	
Token	TokenNameIdentifier	 Token
getNextToken	TokenNameIdentifier	 get Next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
next	TokenNameIdentifier	 next
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
else	TokenNameelse	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
token_source	TokenNameIdentifier	 token source
.	TokenNameDOT	
getNextToken	TokenNameIdentifier	 get Next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jj_gen	TokenNameIdentifier	 jj gen
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Get the specific Token. */	TokenNameCOMMENT_JAVADOC	 Get the specific Token. 
final	TokenNamefinal	
public	TokenNamepublic	
Token	TokenNameIdentifier	 Token
getToken	TokenNameIdentifier	 get Token
(	TokenNameLPAREN	
int	TokenNameint	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Token	TokenNameIdentifier	 Token
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
index	TokenNameIdentifier	 index
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
next	TokenNameIdentifier	 next
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
else	TokenNameelse	
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
token_source	TokenNameIdentifier	 token source
.	TokenNameDOT	
getNextToken	TokenNameIdentifier	 get Next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
t	TokenNameIdentifier	 t
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_nt	TokenNameIdentifier	 jj nt
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
next	TokenNameIdentifier	 next
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
=	TokenNameEQUAL	
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
token_source	TokenNameIdentifier	 token source
.	TokenNameDOT	
getNextToken	TokenNameIdentifier	 get Next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
=	TokenNameEQUAL	
jj_nt	TokenNameIdentifier	 jj nt
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
>	TokenNameGREATER	
jj_expentries	TokenNameIdentifier	 jj expentries
=	TokenNameEQUAL	
new	TokenNamenew	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jj_expentry	TokenNameIdentifier	 jj expentry
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
jj_kind	TokenNameIdentifier	 jj kind
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jj_lasttokens	TokenNameIdentifier	 jj lasttokens
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
100	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
jj_endpos	TokenNameIdentifier	 jj endpos
;	TokenNameSEMICOLON	
private	TokenNameprivate	
void	TokenNamevoid	
jj_add_error_token	TokenNameIdentifier	 jj add error token
(	TokenNameLPAREN	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
,	TokenNameCOMMA	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
>=	TokenNameGREATER_EQUAL	
100	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
==	TokenNameEQUAL_EQUAL	
jj_endpos	TokenNameIdentifier	 jj endpos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_lasttokens	TokenNameIdentifier	 jj lasttokens
[	TokenNameLBRACKET	
jj_endpos	TokenNameIdentifier	 jj endpos
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
jj_endpos	TokenNameIdentifier	 jj endpos
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_expentry	TokenNameIdentifier	 jj expentry
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
jj_endpos	TokenNameIdentifier	 jj endpos
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
jj_endpos	TokenNameIdentifier	 jj endpos
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_expentry	TokenNameIdentifier	 jj expentry
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_lasttokens	TokenNameIdentifier	 jj lasttokens
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
jj_entries_loop	TokenNameIdentifier	 jj entries loop
:	TokenNameCOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Iterator	TokenNameIdentifier	 Iterator
it	TokenNameIdentifier	 it
=	TokenNameEQUAL	
jj_expentries	TokenNameIdentifier	 jj expentries
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
it	TokenNameIdentifier	 it
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
oldentry	TokenNameIdentifier	 oldentry
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
it	TokenNameIdentifier	 it
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
oldentry	TokenNameIdentifier	 oldentry
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
jj_expentry	TokenNameIdentifier	 jj expentry
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
jj_expentry	TokenNameIdentifier	 jj expentry
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
oldentry	TokenNameIdentifier	 oldentry
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
jj_expentry	TokenNameIdentifier	 jj expentry
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
jj_entries_loop	TokenNameIdentifier	 jj entries loop
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
jj_expentries	TokenNameIdentifier	 jj expentries
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
jj_expentry	TokenNameIdentifier	 jj expentry
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
jj_entries_loop	TokenNameIdentifier	 jj entries loop
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jj_lasttokens	TokenNameIdentifier	 jj lasttokens
[	TokenNameLBRACKET	
(	TokenNameLPAREN	
jj_endpos	TokenNameIdentifier	 jj endpos
=	TokenNameEQUAL	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Generate ParseException. */	TokenNameCOMMENT_JAVADOC	 Generate ParseException. 
public	TokenNamepublic	
ParseException	TokenNameIdentifier	 Parse Exception
generateParseException	TokenNameIdentifier	 generate Parse Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_expentries	TokenNameIdentifier	 jj expentries
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
la1tokens	TokenNameIdentifier	 la1tokens
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
24	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jj_kind	TokenNameIdentifier	 jj kind
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
la1tokens	TokenNameIdentifier	 la1tokens
[	TokenNameLBRACKET	
jj_kind	TokenNameIdentifier	 jj kind
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
jj_kind	TokenNameIdentifier	 jj kind
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
jj_gen	TokenNameIdentifier	 jj gen
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
32	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_la1_0	TokenNameIdentifier	 jj la1 0
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
&	TokenNameAND	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
la1tokens	TokenNameIdentifier	 la1tokens
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
24	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
la1tokens	TokenNameIdentifier	 la1tokens
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_expentry	TokenNameIdentifier	 jj expentry
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
jj_expentry	TokenNameIdentifier	 jj expentry
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
jj_expentries	TokenNameIdentifier	 jj expentries
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
jj_expentry	TokenNameIdentifier	 jj expentry
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
jj_endpos	TokenNameIdentifier	 jj endpos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jj_rescan_token	TokenNameIdentifier	 jj rescan token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_add_error_token	TokenNameIdentifier	 jj add error token
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
exptokseq	TokenNameIdentifier	 exptokseq
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
jj_expentries	TokenNameIdentifier	 jj expentries
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
jj_expentries	TokenNameIdentifier	 jj expentries
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
exptokseq	TokenNameIdentifier	 exptokseq
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_expentries	TokenNameIdentifier	 jj expentries
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
exptokseq	TokenNameIdentifier	 exptokseq
,	TokenNameCOMMA	
tokenImage	TokenNameIdentifier	 token Image
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Enable tracing. */	TokenNameCOMMENT_JAVADOC	 Enable tracing. 
final	TokenNamefinal	
public	TokenNamepublic	
void	TokenNamevoid	
enable_tracing	TokenNameIdentifier	 enable tracing
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
/** Disable tracing. */	TokenNameCOMMENT_JAVADOC	 Disable tracing. 
final	TokenNamefinal	
public	TokenNamepublic	
void	TokenNamevoid	
disable_tracing	TokenNameIdentifier	 disable tracing
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
jj_rescan_token	TokenNameIdentifier	 jj rescan token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_rescan	TokenNameIdentifier	 jj rescan
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
JJCalls	TokenNameIdentifier	 JJ Calls
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
gen	TokenNameIdentifier	 gen
>	TokenNameGREATER	
jj_gen	TokenNameIdentifier	 jj gen
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_la	TokenNameIdentifier	 jj la
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
arg	TokenNameIdentifier	 arg
;	TokenNameSEMICOLON	
jj_lastpos	TokenNameIdentifier	 jj lastpos
=	TokenNameEQUAL	
jj_scanpos	TokenNameIdentifier	 jj scanpos
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
first	TokenNameIdentifier	 first
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
jj_3_1	TokenNameIdentifier	 jj 3 1
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
LookaheadSuccess	TokenNameIdentifier	 Lookahead Success
ls	TokenNameIdentifier	 ls
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
jj_rescan	TokenNameIdentifier	 jj rescan
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
jj_save	TokenNameIdentifier	 jj save
(	TokenNameLPAREN	
int	TokenNameint	
index	TokenNameIdentifier	 index
,	TokenNameCOMMA	
int	TokenNameint	
xla	TokenNameIdentifier	 xla
)	TokenNameRPAREN	
{	TokenNameLBRACE	
JJCalls	TokenNameIdentifier	 JJ Calls
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
gen	TokenNameIdentifier	 gen
>	TokenNameGREATER	
jj_gen	TokenNameIdentifier	 jj gen
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
next	TokenNameIdentifier	 next
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
new	TokenNamenew	
JJCalls	TokenNameIdentifier	 JJ Calls
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
gen	TokenNameIdentifier	 gen
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
+	TokenNamePLUS	
xla	TokenNameIdentifier	 xla
-	TokenNameMINUS	
jj_la	TokenNameIdentifier	 jj la
;	TokenNameSEMICOLON	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
first	TokenNameIdentifier	 first
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
arg	TokenNameIdentifier	 arg
=	TokenNameEQUAL	
xla	TokenNameIdentifier	 xla
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
static	TokenNamestatic	
final	TokenNamefinal	
class	TokenNameclass	
JJCalls	TokenNameIdentifier	 JJ Calls
{	TokenNameLBRACE	
int	TokenNameint	
gen	TokenNameIdentifier	 gen
;	TokenNameSEMICOLON	
Token	TokenNameIdentifier	 Token
first	TokenNameIdentifier	 first
;	TokenNameSEMICOLON	
int	TokenNameint	
arg	TokenNameIdentifier	 arg
;	TokenNameSEMICOLON	
JJCalls	TokenNameIdentifier	 JJ Calls
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
