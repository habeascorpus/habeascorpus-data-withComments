/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xinclude	TokenNameIdentifier	 xinclude
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
BufferedInputStream	TokenNameIdentifier	 Buffered Input Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
InputStream	TokenNameIdentifier	 Input Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
InputStreamReader	TokenNameIdentifier	 Input Stream Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
Reader	TokenNameIdentifier	 Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
net	TokenNameIdentifier	 net
.	TokenNameDOT	
HttpURLConnection	TokenNameIdentifier	 Http URL Connection
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
net	TokenNameIdentifier	 net
.	TokenNameDOT	
URL	TokenNameIdentifier	 URL
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
net	TokenNameIdentifier	 net
.	TokenNameDOT	
URLConnection	TokenNameIdentifier	 URL Connection
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Iterator	TokenNameIdentifier	 Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Locale	TokenNameIdentifier	 Locale
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Map	TokenNameIdentifier	 Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
XMLEntityManager	TokenNameIdentifier	 XML Entity Manager
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
ASCIIReader	TokenNameIdentifier	 ASCII Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
Latin1Reader	TokenNameIdentifier	 Latin1 Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
UTF16Reader	TokenNameIdentifier	 UT F16 Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
UTF8Reader	TokenNameIdentifier	 UT F8 Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
msg	TokenNameIdentifier	 msg
.	TokenNameDOT	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
EncodingMap	TokenNameIdentifier	 Encoding Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
HTTPInputSource	TokenNameIdentifier	 HTTP Input Source
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
MessageFormatter	TokenNameIdentifier	 Message Formatter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
XMLChar	TokenNameIdentifier	 XML Char
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XMLString	TokenNameIdentifier	 XML String
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLInputSource	TokenNameIdentifier	 XML Input Source
;	TokenNameSEMICOLON	
/** * This class is used for reading resources requested in &lt;include&gt; elements, * when the parse attribute of the &lt;include&gt; element is "text". Using this * class will open the location, detect the encoding, and discard the byte order * mark, if applicable. * * REVISIT: * Much of the code in this class is taken from XMLEntityManager. It would be nice * if this code could be shared in some way. However, since XMLEntityManager is used * for reading files as XML, and this needs to read files as text, there would need * to be some refactoring done. * * @author Michael Glavassevich, IBM * @author Peter McCracken, IBM * @author Ankit Pasricha, IBM * @author Arun Yadav, Sun Microsystems Inc. * * @version $Id: XIncludeTextReader.java 724088 2008-12-07 06:07:55Z mrglavas $ * * @see XIncludeHandler */	TokenNameCOMMENT_JAVADOC	 This class is used for reading resources requested in &lt;include&gt; elements, when the parse attribute of the &lt;include&gt; element is "text". Using this class will open the location, detect the encoding, and discard the byte order mark, if applicable. * REVISIT: Much of the code in this class is taken from XMLEntityManager. It would be nice if this code could be shared in some way. However, since XMLEntityManager is used for reading files as XML, and this needs to read files as text, there would need to be some refactoring done. * @author Michael Glavassevich, IBM @author Peter McCracken, IBM @author Ankit Pasricha, IBM @author Arun Yadav, Sun Microsystems Inc. * @version $Id: XIncludeTextReader.java 724088 2008-12-07 06:07:55Z mrglavas $ * @see XIncludeHandler 
public	TokenNamepublic	
class	TokenNameclass	
XIncludeTextReader	TokenNameIdentifier	 X Include Text Reader
{	TokenNameLBRACE	
private	TokenNameprivate	
Reader	TokenNameIdentifier	 Reader
fReader	TokenNameIdentifier	 f Reader
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
XIncludeHandler	TokenNameIdentifier	 X Include Handler
fHandler	TokenNameIdentifier	 f Handler
;	TokenNameSEMICOLON	
private	TokenNameprivate	
XMLInputSource	TokenNameIdentifier	 XML Input Source
fSource	TokenNameIdentifier	 f Source
;	TokenNameSEMICOLON	
private	TokenNameprivate	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
fErrorReporter	TokenNameIdentifier	 f Error Reporter
;	TokenNameSEMICOLON	
private	TokenNameprivate	
XMLString	TokenNameIdentifier	 XML String
fTempString	TokenNameIdentifier	 f Temp String
=	TokenNameEQUAL	
new	TokenNamenew	
XMLString	TokenNameIdentifier	 XML String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Construct the XIncludeReader using the XMLInputSource and XIncludeHandler. * * @param source The XMLInputSource to use. * @param handler The XIncludeHandler to use. * @param bufferSize The size of this text reader's buffer. */	TokenNameCOMMENT_JAVADOC	 Construct the XIncludeReader using the XMLInputSource and XIncludeHandler. * @param source The XMLInputSource to use. @param handler The XIncludeHandler to use. @param bufferSize The size of this text reader's buffer. 
public	TokenNamepublic	
XIncludeTextReader	TokenNameIdentifier	 X Include Text Reader
(	TokenNameLPAREN	
XMLInputSource	TokenNameIdentifier	 XML Input Source
source	TokenNameIdentifier	 source
,	TokenNameCOMMA	
XIncludeHandler	TokenNameIdentifier	 X Include Handler
handler	TokenNameIdentifier	 handler
,	TokenNameCOMMA	
int	TokenNameint	
bufferSize	TokenNameIdentifier	 buffer Size
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
fHandler	TokenNameIdentifier	 f Handler
=	TokenNameEQUAL	
handler	TokenNameIdentifier	 handler
;	TokenNameSEMICOLON	
fSource	TokenNameIdentifier	 f Source
=	TokenNameEQUAL	
source	TokenNameIdentifier	 source
;	TokenNameSEMICOLON	
fTempString	TokenNameIdentifier	 f Temp String
=	TokenNameEQUAL	
new	TokenNamenew	
XMLString	TokenNameIdentifier	 XML String
(	TokenNameLPAREN	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
bufferSize	TokenNameIdentifier	 buffer Size
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets the XMLErrorReporter used for reporting errors while * reading the text include. * * @param errorReporter the XMLErrorReporter to be used for * reporting errors. */	TokenNameCOMMENT_JAVADOC	 Sets the XMLErrorReporter used for reporting errors while reading the text include. * @param errorReporter the XMLErrorReporter to be used for reporting errors. 
public	TokenNamepublic	
void	TokenNamevoid	
setErrorReporter	TokenNameIdentifier	 set Error Reporter
(	TokenNameLPAREN	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
errorReporter	TokenNameIdentifier	 error Reporter
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
=	TokenNameEQUAL	
errorReporter	TokenNameIdentifier	 error Reporter
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return the Reader for given XMLInputSource. * * @param source The XMLInputSource to use. */	TokenNameCOMMENT_JAVADOC	 Return the Reader for given XMLInputSource. * @param source The XMLInputSource to use. 
protected	TokenNameprotected	
Reader	TokenNameIdentifier	 Reader
getReader	TokenNameIdentifier	 get Reader
(	TokenNameLPAREN	
XMLInputSource	TokenNameIdentifier	 XML Input Source
source	TokenNameIdentifier	 source
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
source	TokenNameIdentifier	 source
.	TokenNameDOT	
getCharacterStream	TokenNameIdentifier	 get Character Stream
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
source	TokenNameIdentifier	 source
.	TokenNameDOT	
getCharacterStream	TokenNameIdentifier	 get Character Stream
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
InputStream	TokenNameIdentifier	 Input Stream
stream	TokenNameIdentifier	 stream
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
=	TokenNameEQUAL	
source	TokenNameIdentifier	 source
.	TokenNameDOT	
getEncoding	TokenNameIdentifier	 get Encoding
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
encoding	TokenNameIdentifier	 encoding
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
encoding	TokenNameIdentifier	 encoding
=	TokenNameEQUAL	
"UTF-8"	TokenNameStringLiteral	UTF-8
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
source	TokenNameIdentifier	 source
.	TokenNameDOT	
getByteStream	TokenNameIdentifier	 get Byte Stream
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
=	TokenNameEQUAL	
source	TokenNameIdentifier	 source
.	TokenNameDOT	
getByteStream	TokenNameIdentifier	 get Byte Stream
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Wrap the InputStream so that it is possible to rewind it. 	TokenNameCOMMENT_LINE	Wrap the InputStream so that it is possible to rewind it. 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
instanceof	TokenNameinstanceof	
BufferedInputStream	TokenNameIdentifier	 Buffered Input Stream
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
=	TokenNameEQUAL	
new	TokenNamenew	
BufferedInputStream	TokenNameIdentifier	 Buffered Input Stream
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
,	TokenNameCOMMA	
fTempString	TokenNameIdentifier	 f Temp String
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
expandedSystemId	TokenNameIdentifier	 expanded System Id
=	TokenNameEQUAL	
XMLEntityManager	TokenNameIdentifier	 XML Entity Manager
.	TokenNameDOT	
expandSystemId	TokenNameIdentifier	 expand System Id
(	TokenNameLPAREN	
source	TokenNameIdentifier	 source
.	TokenNameDOT	
getSystemId	TokenNameIdentifier	 get System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
source	TokenNameIdentifier	 source
.	TokenNameDOT	
getBaseSystemId	TokenNameIdentifier	 get Base System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
URL	TokenNameIdentifier	 URL
url	TokenNameIdentifier	 url
=	TokenNameEQUAL	
new	TokenNamenew	
URL	TokenNameIdentifier	 URL
(	TokenNameLPAREN	
expandedSystemId	TokenNameIdentifier	 expanded System Id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
URLConnection	TokenNameIdentifier	 URL Connection
urlCon	TokenNameIdentifier	 url Con
=	TokenNameEQUAL	
url	TokenNameIdentifier	 url
.	TokenNameDOT	
openConnection	TokenNameIdentifier	 open Connection
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// If this is an HTTP connection attach any request properties to the request. 	TokenNameCOMMENT_LINE	If this is an HTTP connection attach any request properties to the request. 
if	TokenNameif	
(	TokenNameLPAREN	
urlCon	TokenNameIdentifier	 url Con
instanceof	TokenNameinstanceof	
HttpURLConnection	TokenNameIdentifier	 Http URL Connection
&&	TokenNameAND_AND	
source	TokenNameIdentifier	 source
instanceof	TokenNameinstanceof	
HTTPInputSource	TokenNameIdentifier	 HTTP Input Source
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
HttpURLConnection	TokenNameIdentifier	 Http URL Connection
urlConnection	TokenNameIdentifier	 url Connection
=	TokenNameEQUAL	
(	TokenNameLPAREN	
HttpURLConnection	TokenNameIdentifier	 Http URL Connection
)	TokenNameRPAREN	
urlCon	TokenNameIdentifier	 url Con
;	TokenNameSEMICOLON	
final	TokenNamefinal	
HTTPInputSource	TokenNameIdentifier	 HTTP Input Source
httpInputSource	TokenNameIdentifier	 http Input Source
=	TokenNameEQUAL	
(	TokenNameLPAREN	
HTTPInputSource	TokenNameIdentifier	 HTTP Input Source
)	TokenNameRPAREN	
source	TokenNameIdentifier	 source
;	TokenNameSEMICOLON	
// set request properties 	TokenNameCOMMENT_LINE	set request properties 
Iterator	TokenNameIdentifier	 Iterator
propIter	TokenNameIdentifier	 prop Iter
=	TokenNameEQUAL	
httpInputSource	TokenNameIdentifier	 http Input Source
.	TokenNameDOT	
getHTTPRequestProperties	TokenNameIdentifier	 get HTTP Request Properties
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
propIter	TokenNameIdentifier	 prop Iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
entry	TokenNameIdentifier	 entry
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
)	TokenNameRPAREN	
propIter	TokenNameIdentifier	 prop Iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
urlConnection	TokenNameIdentifier	 url Connection
.	TokenNameDOT	
setRequestProperty	TokenNameIdentifier	 set Request Property
(	TokenNameLPAREN	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// set preference for redirection 	TokenNameCOMMENT_LINE	set preference for redirection 
boolean	TokenNameboolean	
followRedirects	TokenNameIdentifier	 follow Redirects
=	TokenNameEQUAL	
httpInputSource	TokenNameIdentifier	 http Input Source
.	TokenNameDOT	
getFollowHTTPRedirects	TokenNameIdentifier	 get Follow HTTP Redirects
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
followRedirects	TokenNameIdentifier	 follow Redirects
)	TokenNameRPAREN	
{	TokenNameLBRACE	
urlConnection	TokenNameIdentifier	 url Connection
.	TokenNameDOT	
setInstanceFollowRedirects	TokenNameIdentifier	 set Instance Follow Redirects
(	TokenNameLPAREN	
followRedirects	TokenNameIdentifier	 follow Redirects
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Wrap the InputStream so that it is possible to rewind it. 	TokenNameCOMMENT_LINE	Wrap the InputStream so that it is possible to rewind it. 
stream	TokenNameIdentifier	 stream
=	TokenNameEQUAL	
new	TokenNamenew	
BufferedInputStream	TokenNameIdentifier	 Buffered Input Stream
(	TokenNameLPAREN	
urlCon	TokenNameIdentifier	 url Con
.	TokenNameDOT	
getInputStream	TokenNameIdentifier	 get Input Stream
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// content type will be string like "text/xml; charset=UTF-8" or "text/xml" 	TokenNameCOMMENT_LINE	content type will be string like "text/xml; charset=UTF-8" or "text/xml" 
String	TokenNameIdentifier	 String
rawContentType	TokenNameIdentifier	 raw Content Type
=	TokenNameEQUAL	
urlCon	TokenNameIdentifier	 url Con
.	TokenNameDOT	
getContentType	TokenNameIdentifier	 get Content Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// text/xml and application/xml offer only one optional parameter 	TokenNameCOMMENT_LINE	text/xml and application/xml offer only one optional parameter 
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
(	TokenNameLPAREN	
rawContentType	TokenNameIdentifier	 raw Content Type
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
rawContentType	TokenNameIdentifier	 raw Content Type
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
';'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
:	TokenNameCOLON	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
contentType	TokenNameIdentifier	 content Type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
charset	TokenNameIdentifier	 charset
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// this should be something like "text/xml" 	TokenNameCOMMENT_LINE	this should be something like "text/xml" 
contentType	TokenNameIdentifier	 content Type
=	TokenNameEQUAL	
rawContentType	TokenNameIdentifier	 raw Content Type
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
.	TokenNameDOT	
trim	TokenNameIdentifier	 trim
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// this should be something like "charset=UTF-8", but we want to 	TokenNameCOMMENT_LINE	this should be something like "charset=UTF-8", but we want to 
// strip it down to just "UTF-8" 	TokenNameCOMMENT_LINE	strip it down to just "UTF-8" 
charset	TokenNameIdentifier	 charset
=	TokenNameEQUAL	
rawContentType	TokenNameIdentifier	 raw Content Type
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
trim	TokenNameIdentifier	 trim
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
charset	TokenNameIdentifier	 charset
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
"charset="	TokenNameStringLiteral	charset=
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 8 is the length of "charset=" 	TokenNameCOMMENT_LINE	8 is the length of "charset=" 
charset	TokenNameIdentifier	 charset
=	TokenNameEQUAL	
charset	TokenNameIdentifier	 charset
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
trim	TokenNameIdentifier	 trim
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// strip quotes, if present 	TokenNameCOMMENT_LINE	strip quotes, if present 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
charset	TokenNameIdentifier	 charset
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
'"'	TokenNameCharacterLiteral	
&&	TokenNameAND_AND	
charset	TokenNameIdentifier	 charset
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
charset	TokenNameIdentifier	 charset
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
'"'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
charset	TokenNameIdentifier	 charset
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
'\''	TokenNameCharacterLiteral	
&&	TokenNameAND_AND	
charset	TokenNameIdentifier	 charset
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
charset	TokenNameIdentifier	 charset
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
'\''	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
charset	TokenNameIdentifier	 charset
=	TokenNameEQUAL	
charset	TokenNameIdentifier	 charset
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
charset	TokenNameIdentifier	 charset
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
charset	TokenNameIdentifier	 charset
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
contentType	TokenNameIdentifier	 content Type
=	TokenNameEQUAL	
rawContentType	TokenNameIdentifier	 raw Content Type
.	TokenNameDOT	
trim	TokenNameIdentifier	 trim
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
detectedEncoding	TokenNameIdentifier	 detected Encoding
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** The encoding of such a resource is determined by: 1 external encoding information, if available, otherwise -- the most common type of external information is the "charset" parameter of a MIME package 2 if the media type of the resource is text/xml, application/xml, or matches the conventions text/*+xml or application/*+xml as described in XML Media Types [IETF RFC 3023], the encoding is recognized as specified in XML 1.0, otherwise 3 the value of the encoding attribute if one exists, otherwise 4 UTF-8. **/	TokenNameCOMMENT_JAVADOC	 The encoding of such a resource is determined by: 1 external encoding information, if available, otherwise -- the most common type of external information is the "charset" parameter of a MIME package 2 if the media type of the resource is text/xml, application/xml, or matches the conventions text/*+xml or application/*+xml as described in XML Media Types [IETF RFC 3023], the encoding is recognized as specified in XML 1.0, otherwise 3 the value of the encoding attribute if one exists, otherwise 4 UTF-8. *
if	TokenNameif	
(	TokenNameLPAREN	
contentType	TokenNameIdentifier	 content Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"text/xml"	TokenNameStringLiteral	text/xml
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
charset	TokenNameIdentifier	 charset
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
detectedEncoding	TokenNameIdentifier	 detected Encoding
=	TokenNameEQUAL	
charset	TokenNameIdentifier	 charset
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// see RFC2376 or 3023, section 3.1 	TokenNameCOMMENT_LINE	see RFC2376 or 3023, section 3.1 
detectedEncoding	TokenNameIdentifier	 detected Encoding
=	TokenNameEQUAL	
"US-ASCII"	TokenNameStringLiteral	US-ASCII
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
contentType	TokenNameIdentifier	 content Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"application/xml"	TokenNameStringLiteral	application/xml
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
charset	TokenNameIdentifier	 charset
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
detectedEncoding	TokenNameIdentifier	 detected Encoding
=	TokenNameEQUAL	
charset	TokenNameIdentifier	 charset
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// see RFC2376 or 3023, section 3.2 	TokenNameCOMMENT_LINE	see RFC2376 or 3023, section 3.2 
detectedEncoding	TokenNameIdentifier	 detected Encoding
=	TokenNameEQUAL	
getEncodingName	TokenNameIdentifier	 get Encoding Name
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
contentType	TokenNameIdentifier	 content Type
.	TokenNameDOT	
endsWith	TokenNameIdentifier	 ends With
(	TokenNameLPAREN	
"+xml"	TokenNameStringLiteral	+xml
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
detectedEncoding	TokenNameIdentifier	 detected Encoding
=	TokenNameEQUAL	
getEncodingName	TokenNameIdentifier	 get Encoding Name
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
detectedEncoding	TokenNameIdentifier	 detected Encoding
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
encoding	TokenNameIdentifier	 encoding
=	TokenNameEQUAL	
detectedEncoding	TokenNameIdentifier	 detected Encoding
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// else 3 or 4. 	TokenNameCOMMENT_LINE	else 3 or 4. 
}	TokenNameRBRACE	
encoding	TokenNameIdentifier	 encoding
=	TokenNameEQUAL	
encoding	TokenNameIdentifier	 encoding
.	TokenNameDOT	
toUpperCase	TokenNameIdentifier	 to Upper Case
(	TokenNameLPAREN	
Locale	TokenNameIdentifier	 Locale
.	TokenNameDOT	
ENGLISH	TokenNameIdentifier	 ENGLISH
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// eat the Byte Order Mark 	TokenNameCOMMENT_LINE	eat the Byte Order Mark 
encoding	TokenNameIdentifier	 encoding
=	TokenNameEQUAL	
consumeBOM	TokenNameIdentifier	 consume BOM
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
,	TokenNameCOMMA	
encoding	TokenNameIdentifier	 encoding
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// If the document is UTF-8, UTF-16, US-ASCII or ISO-8859-1 use 	TokenNameCOMMENT_LINE	If the document is UTF-8, UTF-16, US-ASCII or ISO-8859-1 use 
// the Xerces readers for these encodings. For US-ASCII and ISO-8859-1 	TokenNameCOMMENT_LINE	the Xerces readers for these encodings. For US-ASCII and ISO-8859-1 
// consult the encoding map since these encodings have many aliases. 	TokenNameCOMMENT_LINE	consult the encoding map since these encodings have many aliases. 
if	TokenNameif	
(	TokenNameLPAREN	
encoding	TokenNameIdentifier	 encoding
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"UTF-8"	TokenNameStringLiteral	UTF-8
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
createUTF8Reader	TokenNameIdentifier	 create UT F8 Reader
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
encoding	TokenNameIdentifier	 encoding
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"UTF-16BE"	TokenNameStringLiteral	UTF-16BE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
createUTF16Reader	TokenNameIdentifier	 create UT F16 Reader
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
encoding	TokenNameIdentifier	 encoding
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"UTF-16LE"	TokenNameStringLiteral	UTF-16LE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
createUTF16Reader	TokenNameIdentifier	 create UT F16 Reader
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Try to use a Java reader. 	TokenNameCOMMENT_LINE	Try to use a Java reader. 
String	TokenNameIdentifier	 String
javaEncoding	TokenNameIdentifier	 java Encoding
=	TokenNameEQUAL	
EncodingMap	TokenNameIdentifier	 Encoding Map
.	TokenNameDOT	
getIANA2JavaMapping	TokenNameIdentifier	 get IAN A2 Java Mapping
(	TokenNameLPAREN	
encoding	TokenNameIdentifier	 encoding
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// If the specified encoding wasn't a recognized IANA encoding throw an IOException. 	TokenNameCOMMENT_LINE	If the specified encoding wasn't a recognized IANA encoding throw an IOException. 
// The XIncludeHandler will report this as a ResourceError and then will 	TokenNameCOMMENT_LINE	The XIncludeHandler will report this as a ResourceError and then will 
// attempt to include a fallback if there is one. 	TokenNameCOMMENT_LINE	attempt to include a fallback if there is one. 
if	TokenNameif	
(	TokenNameLPAREN	
javaEncoding	TokenNameIdentifier	 java Encoding
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
MessageFormatter	TokenNameIdentifier	 Message Formatter
aFormatter	TokenNameIdentifier	 a Formatter
=	TokenNameEQUAL	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
getMessageFormatter	TokenNameIdentifier	 get Message Formatter
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Locale	TokenNameIdentifier	 Locale
aLocale	TokenNameIdentifier	 a Locale
=	TokenNameEQUAL	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
getLocale	TokenNameIdentifier	 get Locale
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
IOException	TokenNameIdentifier	 IO Exception
(	TokenNameLPAREN	
aFormatter	TokenNameIdentifier	 a Formatter
.	TokenNameDOT	
formatMessage	TokenNameIdentifier	 format Message
(	TokenNameLPAREN	
aLocale	TokenNameIdentifier	 a Locale
,	TokenNameCOMMA	
"EncodingDeclInvalid"	TokenNameStringLiteral	EncodingDeclInvalid
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
encoding	TokenNameIdentifier	 encoding
}	TokenNameRBRACE	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
javaEncoding	TokenNameIdentifier	 java Encoding
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"ASCII"	TokenNameStringLiteral	ASCII
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
createASCIIReader	TokenNameIdentifier	 create ASCII Reader
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
javaEncoding	TokenNameIdentifier	 java Encoding
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"ISO8859_1"	TokenNameStringLiteral	ISO8859_1
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
createLatin1Reader	TokenNameIdentifier	 create Latin1 Reader
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
new	TokenNamenew	
InputStreamReader	TokenNameIdentifier	 Input Stream Reader
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
,	TokenNameCOMMA	
javaEncoding	TokenNameIdentifier	 java Encoding
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Create a new UTF-8 reader from the InputStream. **/	TokenNameCOMMENT_JAVADOC	 Create a new UTF-8 reader from the InputStream. *
private	TokenNameprivate	
Reader	TokenNameIdentifier	 Reader
createUTF8Reader	TokenNameIdentifier	 create UT F8 Reader
(	TokenNameLPAREN	
InputStream	TokenNameIdentifier	 Input Stream
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
UTF8Reader	TokenNameIdentifier	 UT F8 Reader
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
,	TokenNameCOMMA	
fTempString	TokenNameIdentifier	 f Temp String
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
.	TokenNameDOT	
length	TokenNameIdentifier	 length
,	TokenNameCOMMA	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
getMessageFormatter	TokenNameIdentifier	 get Message Formatter
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
getLocale	TokenNameIdentifier	 get Locale
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Create a new UTF-16 reader from the InputStream. **/	TokenNameCOMMENT_JAVADOC	 Create a new UTF-16 reader from the InputStream. *
private	TokenNameprivate	
Reader	TokenNameIdentifier	 Reader
createUTF16Reader	TokenNameIdentifier	 create UT F16 Reader
(	TokenNameLPAREN	
InputStream	TokenNameIdentifier	 Input Stream
stream	TokenNameIdentifier	 stream
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isBigEndian	TokenNameIdentifier	 is Big Endian
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
UTF16Reader	TokenNameIdentifier	 UT F16 Reader
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
,	TokenNameCOMMA	
(	TokenNameLPAREN	
fTempString	TokenNameIdentifier	 f Temp String
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
.	TokenNameDOT	
length	TokenNameIdentifier	 length
<<	TokenNameLEFT_SHIFT	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
isBigEndian	TokenNameIdentifier	 is Big Endian
,	TokenNameCOMMA	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
getMessageFormatter	TokenNameIdentifier	 get Message Formatter
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
getLocale	TokenNameIdentifier	 get Locale
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Create a new ASCII reader from the InputStream. **/	TokenNameCOMMENT_JAVADOC	 Create a new ASCII reader from the InputStream. *
private	TokenNameprivate	
Reader	TokenNameIdentifier	 Reader
createASCIIReader	TokenNameIdentifier	 create ASCII Reader
(	TokenNameLPAREN	
InputStream	TokenNameIdentifier	 Input Stream
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
ASCIIReader	TokenNameIdentifier	 ASCII Reader
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
,	TokenNameCOMMA	
fTempString	TokenNameIdentifier	 f Temp String
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
.	TokenNameDOT	
length	TokenNameIdentifier	 length
,	TokenNameCOMMA	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
getMessageFormatter	TokenNameIdentifier	 get Message Formatter
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
getLocale	TokenNameIdentifier	 get Locale
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Create a new ISO-8859-1 reader from the InputStream. **/	TokenNameCOMMENT_JAVADOC	 Create a new ISO-8859-1 reader from the InputStream. *
private	TokenNameprivate	
Reader	TokenNameIdentifier	 Reader
createLatin1Reader	TokenNameIdentifier	 create Latin1 Reader
(	TokenNameLPAREN	
InputStream	TokenNameIdentifier	 Input Stream
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
Latin1Reader	TokenNameIdentifier	 Latin1 Reader
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
,	TokenNameCOMMA	
fTempString	TokenNameIdentifier	 f Temp String
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * XMLEntityManager cares about endian-ness, since it creates its own optimized * readers. Since we're just using generic Java readers for now, we're not caring * about endian-ness. If this changes, even more code needs to be copied from * XMLEntity manager. -- PJM */	TokenNameCOMMENT_JAVADOC	 XMLEntityManager cares about endian-ness, since it creates its own optimized readers. Since we're just using generic Java readers for now, we're not caring about endian-ness. If this changes, even more code needs to be copied from XMLEntity manager. -- PJM 
protected	TokenNameprotected	
String	TokenNameIdentifier	 String
getEncodingName	TokenNameIdentifier	 get Encoding Name
(	TokenNameLPAREN	
InputStream	TokenNameIdentifier	 Input Stream
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
final	TokenNamefinal	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
b4	TokenNameIdentifier	 b4
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
4	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// this has the potential to throw an exception 	TokenNameCOMMENT_LINE	this has the potential to throw an exception 
// it will be fixed when we ensure the stream is rewindable (see note above) 	TokenNameCOMMENT_LINE	it will be fixed when we ensure the stream is rewindable (see note above) 
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
mark	TokenNameIdentifier	 mark
(	TokenNameLPAREN	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
read	TokenNameIdentifier	 read
(	TokenNameLPAREN	
b4	TokenNameIdentifier	 b4
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
==	TokenNameEQUAL_EQUAL	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
encoding	TokenNameIdentifier	 encoding
=	TokenNameEQUAL	
getEncodingName	TokenNameIdentifier	 get Encoding Name
(	TokenNameLPAREN	
b4	TokenNameIdentifier	 b4
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
encoding	TokenNameIdentifier	 encoding
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Removes the byte order mark from the stream, if * it exists and returns the encoding name. * * @param stream * @param encoding * @throws IOException */	TokenNameCOMMENT_JAVADOC	 Removes the byte order mark from the stream, if it exists and returns the encoding name. * @param stream @param encoding @throws IOException 
protected	TokenNameprotected	
String	TokenNameIdentifier	 String
consumeBOM	TokenNameIdentifier	 consume BOM
(	TokenNameLPAREN	
InputStream	TokenNameIdentifier	 Input Stream
stream	TokenNameIdentifier	 stream
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
3	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
mark	TokenNameIdentifier	 mark
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
encoding	TokenNameIdentifier	 encoding
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"UTF-8"	TokenNameStringLiteral	UTF-8
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
read	TokenNameIdentifier	 read
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
==	TokenNameEQUAL_EQUAL	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
b0	TokenNameIdentifier	 b0
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xFF	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
b1	TokenNameIdentifier	 b1
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xFF	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
b2	TokenNameIdentifier	 b2
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xFF	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
b0	TokenNameIdentifier	 b0
!=	TokenNameNOT_EQUAL	
0xEF	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
b1	TokenNameIdentifier	 b1
!=	TokenNameNOT_EQUAL	
0xBB	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
b2	TokenNameIdentifier	 b2
!=	TokenNameNOT_EQUAL	
0xBF	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// First three bytes are not BOM, so reset. 	TokenNameCOMMENT_LINE	First three bytes are not BOM, so reset. 
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
encoding	TokenNameIdentifier	 encoding
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
"UTF-16"	TokenNameStringLiteral	UTF-16
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
read	TokenNameIdentifier	 read
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
==	TokenNameEQUAL_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
b0	TokenNameIdentifier	 b0
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xFF	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
b1	TokenNameIdentifier	 b1
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xFF	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
b0	TokenNameIdentifier	 b0
==	TokenNameEQUAL_EQUAL	
0xFE	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
b1	TokenNameIdentifier	 b1
==	TokenNameEQUAL_EQUAL	
0xFF	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
"UTF-16BE"	TokenNameStringLiteral	UTF-16BE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
b0	TokenNameIdentifier	 b0
==	TokenNameEQUAL_EQUAL	
0xFF	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
b1	TokenNameIdentifier	 b1
==	TokenNameEQUAL_EQUAL	
0xFE	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
"UTF-16LE"	TokenNameStringLiteral	UTF-16LE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// First two bytes are not BOM, so reset. 	TokenNameCOMMENT_LINE	First two bytes are not BOM, so reset. 
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// We could do UTF-32, but since the getEncodingName() doesn't support that 	TokenNameCOMMENT_LINE	We could do UTF-32, but since the getEncodingName() doesn't support that 
// we won't support it here. 	TokenNameCOMMENT_LINE	we won't support it here. 
// To implement UTF-32, look for: 00 00 FE FF for big-endian 	TokenNameCOMMENT_LINE	To implement UTF-32, look for: 00 00 FE FF for big-endian 
// or FF FE 00 00 for little-endian 	TokenNameCOMMENT_LINE	or FF FE 00 00 for little-endian 
return	TokenNamereturn	
encoding	TokenNameIdentifier	 encoding
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * REVISIT: This code is taken from org.apache.xerces.impl.XMLEntityManager. * Is there any way we can share the code, without having it implemented twice? * I think we should make it public and static in XMLEntityManager. --PJM * * Returns the IANA encoding name that is auto-detected from * the bytes specified, with the endian-ness of that encoding where appropriate. * * @param b4 The first four bytes of the input. * @return the encoding name, or null if no encoding could be detected */	TokenNameCOMMENT_JAVADOC	 REVISIT: This code is taken from org.apache.xerces.impl.XMLEntityManager. Is there any way we can share the code, without having it implemented twice? I think we should make it public and static in XMLEntityManager. --PJM * Returns the IANA encoding name that is auto-detected from the bytes specified, with the endian-ness of that encoding where appropriate. * @param b4 The first four bytes of the input. @return the encoding name, or null if no encoding could be detected 
protected	TokenNameprotected	
String	TokenNameIdentifier	 String
getEncodingName	TokenNameIdentifier	 get Encoding Name
(	TokenNameLPAREN	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
b4	TokenNameIdentifier	 b4
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// UTF-16, with BOM 	TokenNameCOMMENT_LINE	UTF-16, with BOM 
int	TokenNameint	
b0	TokenNameIdentifier	 b0
=	TokenNameEQUAL	
b4	TokenNameIdentifier	 b4
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xFF	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
b1	TokenNameIdentifier	 b1
=	TokenNameEQUAL	
b4	TokenNameIdentifier	 b4
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xFF	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
b0	TokenNameIdentifier	 b0
==	TokenNameEQUAL_EQUAL	
0xFE	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
b1	TokenNameIdentifier	 b1
==	TokenNameEQUAL_EQUAL	
0xFF	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// UTF-16, big-endian 	TokenNameCOMMENT_LINE	UTF-16, big-endian 
return	TokenNamereturn	
"UTF-16BE"	TokenNameStringLiteral	UTF-16BE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
b0	TokenNameIdentifier	 b0
==	TokenNameEQUAL_EQUAL	
0xFF	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
b1	TokenNameIdentifier	 b1
==	TokenNameEQUAL_EQUAL	
0xFE	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// UTF-16, little-endian 	TokenNameCOMMENT_LINE	UTF-16, little-endian 
return	TokenNamereturn	
"UTF-16LE"	TokenNameStringLiteral	UTF-16LE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// UTF-8 with a BOM 	TokenNameCOMMENT_LINE	UTF-8 with a BOM 
int	TokenNameint	
b2	TokenNameIdentifier	 b2
=	TokenNameEQUAL	
b4	TokenNameIdentifier	 b4
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xFF	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
b0	TokenNameIdentifier	 b0
==	TokenNameEQUAL_EQUAL	
0xEF	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
b1	TokenNameIdentifier	 b1
==	TokenNameEQUAL_EQUAL	
0xBB	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
b2	TokenNameIdentifier	 b2
==	TokenNameEQUAL_EQUAL	
0xBF	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
"UTF-8"	TokenNameStringLiteral	UTF-8
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// other encodings 	TokenNameCOMMENT_LINE	other encodings 
int	TokenNameint	
b3	TokenNameIdentifier	 b3
=	TokenNameEQUAL	
b4	TokenNameIdentifier	 b4
[	TokenNameLBRACKET	
3	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xFF	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
b0	TokenNameIdentifier	 b0
==	TokenNameEQUAL_EQUAL	
0x00	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
b1	TokenNameIdentifier	 b1
==	TokenNameEQUAL_EQUAL	
0x00	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
b2	TokenNameIdentifier	 b2
==	TokenNameEQUAL_EQUAL	
0x00	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
b3	TokenNameIdentifier	 b3
==	TokenNameEQUAL_EQUAL	
0x3C	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// UCS-4, big endian (1234) 	TokenNameCOMMENT_LINE	UCS-4, big endian (1234) 
return	TokenNamereturn	
"ISO-10646-UCS-4"	TokenNameStringLiteral	ISO-10646-UCS-4
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
b0	TokenNameIdentifier	 b0
==	TokenNameEQUAL_EQUAL	
0x3C	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
b1	TokenNameIdentifier	 b1
==	TokenNameEQUAL_EQUAL	
0x00	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
b2	TokenNameIdentifier	 b2
==	TokenNameEQUAL_EQUAL	
0x00	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
b3	TokenNameIdentifier	 b3
==	TokenNameEQUAL_EQUAL	
0x00	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// UCS-4, little endian (4321) 	TokenNameCOMMENT_LINE	UCS-4, little endian (4321) 
return	TokenNamereturn	
"ISO-10646-UCS-4"	TokenNameStringLiteral	ISO-10646-UCS-4
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
b0	TokenNameIdentifier	 b0
==	TokenNameEQUAL_EQUAL	
0x00	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
b1	TokenNameIdentifier	 b1
==	TokenNameEQUAL_EQUAL	
0x00	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
b2	TokenNameIdentifier	 b2
==	TokenNameEQUAL_EQUAL	
0x3C	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
b3	TokenNameIdentifier	 b3
==	TokenNameEQUAL_EQUAL	
0x00	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// UCS-4, unusual octet order (2143) 	TokenNameCOMMENT_LINE	UCS-4, unusual octet order (2143) 
return	TokenNamereturn	
"ISO-10646-UCS-4"	TokenNameStringLiteral	ISO-10646-UCS-4
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
b0	TokenNameIdentifier	 b0
==	TokenNameEQUAL_EQUAL	
0x00	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
b1	TokenNameIdentifier	 b1
==	TokenNameEQUAL_EQUAL	
0x3C	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
b2	TokenNameIdentifier	 b2
==	TokenNameEQUAL_EQUAL	
0x00	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
b3	TokenNameIdentifier	 b3
==	TokenNameEQUAL_EQUAL	
0x00	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// UCS-4, unusual octect order (3412) 	TokenNameCOMMENT_LINE	UCS-4, unusual octect order (3412) 
return	TokenNamereturn	
"ISO-10646-UCS-4"	TokenNameStringLiteral	ISO-10646-UCS-4
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
b0	TokenNameIdentifier	 b0
==	TokenNameEQUAL_EQUAL	
0x00	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
b1	TokenNameIdentifier	 b1
==	TokenNameEQUAL_EQUAL	
0x3C	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
b2	TokenNameIdentifier	 b2
==	TokenNameEQUAL_EQUAL	
0x00	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
b3	TokenNameIdentifier	 b3
==	TokenNameEQUAL_EQUAL	
0x3F	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// UTF-16, big-endian, no BOM 	TokenNameCOMMENT_LINE	UTF-16, big-endian, no BOM 
// (or could turn out to be UCS-2... 	TokenNameCOMMENT_LINE	(or could turn out to be UCS-2... 
return	TokenNamereturn	
"UTF-16BE"	TokenNameStringLiteral	UTF-16BE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
b0	TokenNameIdentifier	 b0
==	TokenNameEQUAL_EQUAL	
0x3C	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
b1	TokenNameIdentifier	 b1
==	TokenNameEQUAL_EQUAL	
0x00	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
b2	TokenNameIdentifier	 b2
==	TokenNameEQUAL_EQUAL	
0x3F	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
b3	TokenNameIdentifier	 b3
==	TokenNameEQUAL_EQUAL	
0x00	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// UTF-16, little-endian, no BOM 	TokenNameCOMMENT_LINE	UTF-16, little-endian, no BOM 
// (or could turn out to be UCS-2... 	TokenNameCOMMENT_LINE	(or could turn out to be UCS-2... 
return	TokenNamereturn	
"UTF-16LE"	TokenNameStringLiteral	UTF-16LE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
b0	TokenNameIdentifier	 b0
==	TokenNameEQUAL_EQUAL	
0x4C	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
b1	TokenNameIdentifier	 b1
==	TokenNameEQUAL_EQUAL	
0x6F	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
b2	TokenNameIdentifier	 b2
==	TokenNameEQUAL_EQUAL	
0xA7	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
b3	TokenNameIdentifier	 b3
==	TokenNameEQUAL_EQUAL	
0x94	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// EBCDIC 	TokenNameCOMMENT_LINE	EBCDIC 
// a la xerces1, return CP037 instead of EBCDIC here 	TokenNameCOMMENT_LINE	a la xerces1, return CP037 instead of EBCDIC here 
return	TokenNamereturn	
"CP037"	TokenNameStringLiteral	CP037
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// this signals us to use the value from the encoding attribute 	TokenNameCOMMENT_LINE	this signals us to use the value from the encoding attribute 
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getEncodingName(byte[]):Object[] 	TokenNameCOMMENT_LINE	getEncodingName(byte[]):Object[] 
/** * Read the input stream as text, and pass the text on to the XIncludeHandler * using calls to characters(). This will read all of the text it can from the * resource. * * @throws IOException */	TokenNameCOMMENT_JAVADOC	 Read the input stream as text, and pass the text on to the XIncludeHandler using calls to characters(). This will read all of the text it can from the resource. * @throws IOException 
public	TokenNamepublic	
void	TokenNamevoid	
parse	TokenNameIdentifier	 parse
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
fReader	TokenNameIdentifier	 f Reader
=	TokenNameEQUAL	
getReader	TokenNameIdentifier	 get Reader
(	TokenNameLPAREN	
fSource	TokenNameIdentifier	 f Source
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fSource	TokenNameIdentifier	 f Source
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
readSize	TokenNameIdentifier	 read Size
=	TokenNameEQUAL	
fReader	TokenNameIdentifier	 f Reader
.	TokenNameDOT	
read	TokenNameIdentifier	 read
(	TokenNameLPAREN	
fTempString	TokenNameIdentifier	 f Temp String
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fTempString	TokenNameIdentifier	 f Temp String
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fHandler	TokenNameIdentifier	 f Handler
.	TokenNameDOT	
fHasIncludeReportedContent	TokenNameIdentifier	 f Has Include Reported Content
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
readSize	TokenNameIdentifier	 read Size
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
readSize	TokenNameIdentifier	 read Size
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
char	TokenNamechar	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
fTempString	TokenNameIdentifier	 f Temp String
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isValid	TokenNameIdentifier	 is Valid
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
XMLChar	TokenNameIdentifier	 XML Char
.	TokenNameDOT	
isHighSurrogate	TokenNameIdentifier	 is High Surrogate
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
ch2	TokenNameIdentifier	 ch2
;	TokenNameSEMICOLON	
// retrieve next character 	TokenNameCOMMENT_LINE	retrieve next character 
if	TokenNameif	
(	TokenNameLPAREN	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
readSize	TokenNameIdentifier	 read Size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ch2	TokenNameIdentifier	 ch2
=	TokenNameEQUAL	
fTempString	TokenNameIdentifier	 f Temp String
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// handle rare boundary case 	TokenNameCOMMENT_LINE	handle rare boundary case 
else	TokenNameelse	
{	TokenNameLBRACE	
ch2	TokenNameIdentifier	 ch2
=	TokenNameEQUAL	
fReader	TokenNameIdentifier	 f Reader
.	TokenNameDOT	
read	TokenNameIdentifier	 read
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ch2	TokenNameIdentifier	 ch2
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fTempString	TokenNameIdentifier	 f Temp String
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
[	TokenNameLBRACKET	
readSize	TokenNameIdentifier	 read Size
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
ch2	TokenNameIdentifier	 ch2
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
XMLChar	TokenNameIdentifier	 XML Char
.	TokenNameDOT	
isLowSurrogate	TokenNameIdentifier	 is Low Surrogate
(	TokenNameLPAREN	
ch2	TokenNameIdentifier	 ch2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// convert surrogates to a supplemental character 	TokenNameCOMMENT_LINE	convert surrogates to a supplemental character 
int	TokenNameint	
sup	TokenNameIdentifier	 sup
=	TokenNameEQUAL	
XMLChar	TokenNameIdentifier	 XML Char
.	TokenNameDOT	
supplemental	TokenNameIdentifier	 supplemental
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
,	TokenNameCOMMA	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
ch2	TokenNameIdentifier	 ch2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isValid	TokenNameIdentifier	 is Valid
(	TokenNameLPAREN	
sup	TokenNameIdentifier	 sup
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
"InvalidCharInContent"	TokenNameStringLiteral	InvalidCharInContent
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
sup	TokenNameIdentifier	 sup
,	TokenNameCOMMA	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_FATAL_ERROR	TokenNameIdentifier	 SEVERITY  FATAL  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
"InvalidCharInContent"	TokenNameStringLiteral	InvalidCharInContent
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
ch2	TokenNameIdentifier	 ch2
,	TokenNameCOMMA	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_FATAL_ERROR	TokenNameIdentifier	 SEVERITY  FATAL  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLMessageFormatter	TokenNameIdentifier	 XML Message Formatter
.	TokenNameDOT	
XML_DOMAIN	TokenNameIdentifier	 XML  DOMAIN
,	TokenNameCOMMA	
"InvalidCharInContent"	TokenNameStringLiteral	InvalidCharInContent
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
,	TokenNameCOMMA	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_FATAL_ERROR	TokenNameIdentifier	 SEVERITY  FATAL  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fHandler	TokenNameIdentifier	 f Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
readSize	TokenNameIdentifier	 read Size
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fTempString	TokenNameIdentifier	 f Temp String
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fTempString	TokenNameIdentifier	 f Temp String
.	TokenNameDOT	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
readSize	TokenNameIdentifier	 read Size
;	TokenNameSEMICOLON	
fHandler	TokenNameIdentifier	 f Handler
.	TokenNameDOT	
characters	TokenNameIdentifier	 characters
(	TokenNameLPAREN	
fTempString	TokenNameIdentifier	 f Temp String
,	TokenNameCOMMA	
fHandler	TokenNameIdentifier	 f Handler
.	TokenNameDOT	
modifyAugmentations	TokenNameIdentifier	 modify Augmentations
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
readSize	TokenNameIdentifier	 read Size
=	TokenNameEQUAL	
fReader	TokenNameIdentifier	 f Reader
.	TokenNameDOT	
read	TokenNameIdentifier	 read
(	TokenNameLPAREN	
fTempString	TokenNameIdentifier	 f Temp String
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fTempString	TokenNameIdentifier	 f Temp String
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Sets the input source on this text reader. * * @param source The XMLInputSource to use. */	TokenNameCOMMENT_JAVADOC	 Sets the input source on this text reader. * @param source The XMLInputSource to use. 
public	TokenNamepublic	
void	TokenNamevoid	
setInputSource	TokenNameIdentifier	 set Input Source
(	TokenNameLPAREN	
XMLInputSource	TokenNameIdentifier	 XML Input Source
source	TokenNameIdentifier	 source
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSource	TokenNameIdentifier	 f Source
=	TokenNameEQUAL	
source	TokenNameIdentifier	 source
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Closes the stream. Call this after parse(), or when there is no longer any need * for this object. * * @throws IOException */	TokenNameCOMMENT_JAVADOC	 Closes the stream. Call this after parse(), or when there is no longer any need for this object. * @throws IOException 
public	TokenNamepublic	
void	TokenNamevoid	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fReader	TokenNameIdentifier	 f Reader
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fReader	TokenNameIdentifier	 f Reader
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fReader	TokenNameIdentifier	 f Reader
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Returns true if the specified character is a valid XML character * as per the rules of XML 1.0. * * @param ch The character to check. */	TokenNameCOMMENT_JAVADOC	 Returns true if the specified character is a valid XML character as per the rules of XML 1.0. * @param ch The character to check. 
protected	TokenNameprotected	
boolean	TokenNameboolean	
isValid	TokenNameIdentifier	 is Valid
(	TokenNameLPAREN	
int	TokenNameint	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
XMLChar	TokenNameIdentifier	 XML Char
.	TokenNameDOT	
isValid	TokenNameIdentifier	 is Valid
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets the buffer size property for the reader which decides the chunk sizes that are parsed * by the reader at a time and passed to the handler * * @param bufferSize The size of the buffer desired */	TokenNameCOMMENT_JAVADOC	 Sets the buffer size property for the reader which decides the chunk sizes that are parsed by the reader at a time and passed to the handler * @param bufferSize The size of the buffer desired 
protected	TokenNameprotected	
void	TokenNamevoid	
setBufferSize	TokenNameIdentifier	 set Buffer Size
(	TokenNameLPAREN	
int	TokenNameint	
bufferSize	TokenNameIdentifier	 buffer Size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fTempString	TokenNameIdentifier	 f Temp String
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
.	TokenNameDOT	
length	TokenNameIdentifier	 length
!=	TokenNameNOT_EQUAL	
++	TokenNamePLUS_PLUS	
bufferSize	TokenNameIdentifier	 buffer Size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fTempString	TokenNameIdentifier	 f Temp String
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
bufferSize	TokenNameIdentifier	 buffer Size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
