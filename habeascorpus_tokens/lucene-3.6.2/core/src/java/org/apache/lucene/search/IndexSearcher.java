package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
;	TokenNameSEMICOLON	
/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_JAVADOC	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Iterator	TokenNameIdentifier	 Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
List	TokenNameIdentifier	 List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
NoSuchElementException	TokenNameIdentifier	 No Such Element Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
Callable	TokenNameIdentifier	 Callable
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
CompletionService	TokenNameIdentifier	 Completion Service
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
ExecutionException	TokenNameIdentifier	 Execution Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
Executor	TokenNameIdentifier	 Executor
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
ExecutorCompletionService	TokenNameIdentifier	 Executor Completion Service
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
ExecutorService	TokenNameIdentifier	 Executor Service
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
locks	TokenNameIdentifier	 locks
.	TokenNameDOT	
Lock	TokenNameIdentifier	 Lock
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
locks	TokenNameIdentifier	 locks
.	TokenNameDOT	
ReentrantLock	TokenNameIdentifier	 Reentrant Lock
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
document	TokenNameIdentifier	 document
.	TokenNameDOT	
Document	TokenNameIdentifier	 Document
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
document	TokenNameIdentifier	 document
.	TokenNameDOT	
FieldSelector	TokenNameIdentifier	 Field Selector
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
CorruptIndexException	TokenNameIdentifier	 Corrupt Index Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
IndexReader	TokenNameIdentifier	 Index Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
Term	TokenNameIdentifier	 Term
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
Directory	TokenNameIdentifier	 Directory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
NIOFSDirectory	TokenNameIdentifier	 NIOFS Directory
;	TokenNameSEMICOLON	
// javadocs 	TokenNameCOMMENT_LINE	javadocs 
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ReaderUtil	TokenNameIdentifier	 Reader Util
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ThreadInterruptedException	TokenNameIdentifier	 Thread Interrupted Exception
;	TokenNameSEMICOLON	
/** Implements search over a single IndexReader. * * <p>Applications usually need only call the inherited * {@link #search(Query,int)} * or {@link #search(Query,Filter,int)} methods. For * performance reasons, if your index is unchanging, you * should share a single IndexSearcher instance across * multiple searches instead of creating a new one * per-search. If your index has changed and you wish to * see the changes reflected in searching, you should * use {@link IndexReader#openIfChanged} to obtain a new reader and * then create a new IndexSearcher from that. Also, for * low-latency turnaround it's best to use a near-real-time * reader ({@link IndexReader#open(IndexWriter,boolean)}). * Once you have a new {@link IndexReader}, it's relatively * cheap to create a new IndexSearcher from it. * * <a name="thread-safety"></a><p><b>NOTE</b>: <code>{@link * IndexSearcher}</code> instances are completely * thread safe, meaning multiple threads can call any of its * methods, concurrently. If your application requires * external synchronization, you should <b>not</b> * synchronize on the <code>IndexSearcher</code> instance; * use your own (non-Lucene) objects instead.</p> */	TokenNameCOMMENT_JAVADOC	 Implements search over a single IndexReader. * <p>Applications usually need only call the inherited {@link #search(Query,int)} or {@link #search(Query,Filter,int)} methods. For performance reasons, if your index is unchanging, you should share a single IndexSearcher instance across multiple searches instead of creating a new one per-search. If your index has changed and you wish to see the changes reflected in searching, you should use {@link IndexReader#openIfChanged} to obtain a new reader and then create a new IndexSearcher from that. Also, for low-latency turnaround it's best to use a near-real-time reader ({@link IndexReader#open(IndexWriter,boolean)}). Once you have a new {@link IndexReader}, it's relatively cheap to create a new IndexSearcher from it. * <a name="thread-safety"></a><p><b>NOTE</b>: <code>{@link IndexSearcher}</code> instances are completely thread safe, meaning multiple threads can call any of its methods, concurrently. If your application requires external synchronization, you should <b>not</b> synchronize on the <code>IndexSearcher</code> instance; use your own (non-Lucene) objects instead.</p> 
public	TokenNamepublic	
class	TokenNameclass	
IndexSearcher	TokenNameIdentifier	 Index Searcher
extends	TokenNameextends	
Searcher	TokenNameIdentifier	 Searcher
{	TokenNameLBRACE	
IndexReader	TokenNameIdentifier	 Index Reader
reader	TokenNameIdentifier	 reader
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
closeReader	TokenNameIdentifier	 close Reader
;	TokenNameSEMICOLON	
// NOTE: these members might change in incompatible ways 	TokenNameCOMMENT_LINE	NOTE: these members might change in incompatible ways 
// in the next release 	TokenNameCOMMENT_LINE	in the next release 
protected	TokenNameprotected	
final	TokenNamefinal	
IndexReader	TokenNameIdentifier	 Index Reader
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
subReaders	TokenNameIdentifier	 sub Readers
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
docStarts	TokenNameIdentifier	 doc Starts
;	TokenNameSEMICOLON	
// These are only used for multi-threaded search 	TokenNameCOMMENT_LINE	These are only used for multi-threaded search 
private	TokenNameprivate	
final	TokenNamefinal	
ExecutorService	TokenNameIdentifier	 Executor Service
executor	TokenNameIdentifier	 executor
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
final	TokenNamefinal	
IndexSearcher	TokenNameIdentifier	 Index Searcher
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
subSearchers	TokenNameIdentifier	 sub Searchers
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
docBase	TokenNameIdentifier	 doc Base
;	TokenNameSEMICOLON	
/** Creates a searcher searching the index in the named * directory, with readOnly=true * @param path directory where IndexReader will be opened * @throws CorruptIndexException if the index is corrupt * @throws IOException if there is a low-level IO error * @deprecated use {@link IndexSearcher#IndexSearcher(IndexReader)} instead. */	TokenNameCOMMENT_JAVADOC	 Creates a searcher searching the index in the named directory, with readOnly=true @param path directory where IndexReader will be opened @throws CorruptIndexException if the index is corrupt @throws IOException if there is a low-level IO error @deprecated use {@link IndexSearcher#IndexSearcher(IndexReader)} instead. 
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
public	TokenNamepublic	
IndexSearcher	TokenNameIdentifier	 Index Searcher
(	TokenNameLPAREN	
Directory	TokenNameIdentifier	 Directory
path	TokenNameIdentifier	 path
)	TokenNameRPAREN	
throws	TokenNamethrows	
CorruptIndexException	TokenNameIdentifier	 Corrupt Index Exception
,	TokenNameCOMMA	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
this	TokenNamethis	
(	TokenNameLPAREN	
IndexReader	TokenNameIdentifier	 Index Reader
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Creates a searcher searching the index in the named * directory. You should pass readOnly=true, since it * gives much better concurrent performance, unless you * intend to do write operations (delete documents or * change norms) with the underlying IndexReader. * @param path directory where IndexReader will be opened * @param readOnly if true, the underlying IndexReader * will be opened readOnly * @throws CorruptIndexException if the index is corrupt * @throws IOException if there is a low-level IO error * @deprecated Use {@link IndexSearcher#IndexSearcher(IndexReader)} instead. */	TokenNameCOMMENT_JAVADOC	 Creates a searcher searching the index in the named directory. You should pass readOnly=true, since it gives much better concurrent performance, unless you intend to do write operations (delete documents or change norms) with the underlying IndexReader. @param path directory where IndexReader will be opened @param readOnly if true, the underlying IndexReader will be opened readOnly @throws CorruptIndexException if the index is corrupt @throws IOException if there is a low-level IO error @deprecated Use {@link IndexSearcher#IndexSearcher(IndexReader)} instead. 
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
public	TokenNamepublic	
IndexSearcher	TokenNameIdentifier	 Index Searcher
(	TokenNameLPAREN	
Directory	TokenNameIdentifier	 Directory
path	TokenNameIdentifier	 path
,	TokenNameCOMMA	
boolean	TokenNameboolean	
readOnly	TokenNameIdentifier	 read Only
)	TokenNameRPAREN	
throws	TokenNamethrows	
CorruptIndexException	TokenNameIdentifier	 Corrupt Index Exception
,	TokenNameCOMMA	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
this	TokenNamethis	
(	TokenNameLPAREN	
IndexReader	TokenNameIdentifier	 Index Reader
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
,	TokenNameCOMMA	
readOnly	TokenNameIdentifier	 read Only
)	TokenNameRPAREN	
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Creates a searcher searching the provided index. */	TokenNameCOMMENT_JAVADOC	 Creates a searcher searching the provided index. 
public	TokenNamepublic	
IndexSearcher	TokenNameIdentifier	 Index Searcher
(	TokenNameLPAREN	
IndexReader	TokenNameIdentifier	 Index Reader
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Runs searches for each segment separately, using the * provided ExecutorService. IndexSearcher will not * shutdown/awaitTermination this ExecutorService on * close; you must do so, eventually, on your own. NOTE: * if you are using {@link NIOFSDirectory}, do not use * the shutdownNow method of ExecutorService as this uses * Thread.interrupt under-the-hood which can silently * close file descriptors (see <a * href="https://issues.apache.org/jira/browse/LUCENE-2239">LUCENE-2239</a>). * * @lucene.experimental */	TokenNameCOMMENT_JAVADOC	 Runs searches for each segment separately, using the provided ExecutorService. IndexSearcher will not shutdown/awaitTermination this ExecutorService on close; you must do so, eventually, on your own. NOTE: if you are using {@link NIOFSDirectory}, do not use the shutdownNow method of ExecutorService as this uses Thread.interrupt under-the-hood which can silently close file descriptors (see <a href="https://issues.apache.org/jira/browse/LUCENE-2239">LUCENE-2239</a>). * @lucene.experimental 
public	TokenNamepublic	
IndexSearcher	TokenNameIdentifier	 Index Searcher
(	TokenNameLPAREN	
IndexReader	TokenNameIdentifier	 Index Reader
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
ExecutorService	TokenNameIdentifier	 Executor Service
executor	TokenNameIdentifier	 executor
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
executor	TokenNameIdentifier	 executor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Expert: directly specify the reader, subReaders and * their docID starts. * * @lucene.experimental */	TokenNameCOMMENT_JAVADOC	 Expert: directly specify the reader, subReaders and their docID starts. * @lucene.experimental 
public	TokenNamepublic	
IndexSearcher	TokenNameIdentifier	 Index Searcher
(	TokenNameLPAREN	
IndexReader	TokenNameIdentifier	 Index Reader
reader	TokenNameIdentifier	 reader
,	TokenNameCOMMA	
IndexReader	TokenNameIdentifier	 Index Reader
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
subReaders	TokenNameIdentifier	 sub Readers
,	TokenNameCOMMA	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
docStarts	TokenNameIdentifier	 doc Starts
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
,	TokenNameCOMMA	
subReaders	TokenNameIdentifier	 sub Readers
,	TokenNameCOMMA	
docStarts	TokenNameIdentifier	 doc Starts
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Used only when we are an atomic sub-searcher in a parent 	TokenNameCOMMENT_LINE	Used only when we are an atomic sub-searcher in a parent 
// IndexSearcher that has an ExecutorService, to record 	TokenNameCOMMENT_LINE	IndexSearcher that has an ExecutorService, to record 
// our docBase in the parent IndexSearcher: 	TokenNameCOMMENT_LINE	our docBase in the parent IndexSearcher: 
private	TokenNameprivate	
IndexSearcher	TokenNameIdentifier	 Index Searcher
(	TokenNameLPAREN	
IndexReader	TokenNameIdentifier	 Index Reader
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
int	TokenNameint	
docBase	TokenNameIdentifier	 doc Base
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reader	TokenNameIdentifier	 reader
=	TokenNameEQUAL	
r	TokenNameIdentifier	 r
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
executor	TokenNameIdentifier	 executor
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
closeReader	TokenNameIdentifier	 close Reader
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
docBase	TokenNameIdentifier	 doc Base
=	TokenNameEQUAL	
docBase	TokenNameIdentifier	 doc Base
;	TokenNameSEMICOLON	
subReaders	TokenNameIdentifier	 sub Readers
=	TokenNameEQUAL	
new	TokenNamenew	
IndexReader	TokenNameIdentifier	 Index Reader
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
docStarts	TokenNameIdentifier	 doc Starts
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
0	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
subSearchers	TokenNameIdentifier	 sub Searchers
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Expert: directly specify the reader, subReaders and * their docID starts, and an ExecutorService. In this * case, each segment will be separately searched using the * ExecutorService. IndexSearcher will not * shutdown/awaitTermination this ExecutorService on * close; you must do so, eventually, on your own. NOTE: * if you are using {@link NIOFSDirectory}, do not use * the shutdownNow method of ExecutorService as this uses * Thread.interrupt under-the-hood which can silently * close file descriptors (see <a * href="https://issues.apache.org/jira/browse/LUCENE-2239">LUCENE-2239</a>). * * @lucene.experimental */	TokenNameCOMMENT_JAVADOC	 Expert: directly specify the reader, subReaders and their docID starts, and an ExecutorService. In this case, each segment will be separately searched using the ExecutorService. IndexSearcher will not shutdown/awaitTermination this ExecutorService on close; you must do so, eventually, on your own. NOTE: if you are using {@link NIOFSDirectory}, do not use the shutdownNow method of ExecutorService as this uses Thread.interrupt under-the-hood which can silently close file descriptors (see <a href="https://issues.apache.org/jira/browse/LUCENE-2239">LUCENE-2239</a>). * @lucene.experimental 
public	TokenNamepublic	
IndexSearcher	TokenNameIdentifier	 Index Searcher
(	TokenNameLPAREN	
IndexReader	TokenNameIdentifier	 Index Reader
reader	TokenNameIdentifier	 reader
,	TokenNameCOMMA	
IndexReader	TokenNameIdentifier	 Index Reader
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
subReaders	TokenNameIdentifier	 sub Readers
,	TokenNameCOMMA	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
docStarts	TokenNameIdentifier	 doc Starts
,	TokenNameCOMMA	
ExecutorService	TokenNameIdentifier	 Executor Service
executor	TokenNameIdentifier	 executor
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
reader	TokenNameIdentifier	 reader
=	TokenNameEQUAL	
reader	TokenNameIdentifier	 reader
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
subReaders	TokenNameIdentifier	 sub Readers
=	TokenNameEQUAL	
subReaders	TokenNameIdentifier	 sub Readers
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
docStarts	TokenNameIdentifier	 doc Starts
=	TokenNameEQUAL	
docStarts	TokenNameIdentifier	 doc Starts
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
executor	TokenNameIdentifier	 executor
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
subSearchers	TokenNameIdentifier	 sub Searchers
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
subSearchers	TokenNameIdentifier	 sub Searchers
=	TokenNameEQUAL	
new	TokenNamenew	
IndexSearcher	TokenNameIdentifier	 Index Searcher
[	TokenNameLBRACKET	
subReaders	TokenNameIdentifier	 sub Readers
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
subReaders	TokenNameIdentifier	 sub Readers
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
subSearchers	TokenNameIdentifier	 sub Searchers
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
IndexSearcher	TokenNameIdentifier	 Index Searcher
(	TokenNameLPAREN	
subReaders	TokenNameIdentifier	 sub Readers
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
docStarts	TokenNameIdentifier	 doc Starts
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
closeReader	TokenNameIdentifier	 close Reader
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
executor	TokenNameIdentifier	 executor
=	TokenNameEQUAL	
executor	TokenNameIdentifier	 executor
;	TokenNameSEMICOLON	
docBase	TokenNameIdentifier	 doc Base
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
IndexSearcher	TokenNameIdentifier	 Index Searcher
(	TokenNameLPAREN	
IndexReader	TokenNameIdentifier	 Index Reader
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
boolean	TokenNameboolean	
closeReader	TokenNameIdentifier	 close Reader
,	TokenNameCOMMA	
ExecutorService	TokenNameIdentifier	 Executor Service
executor	TokenNameIdentifier	 executor
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reader	TokenNameIdentifier	 reader
=	TokenNameEQUAL	
r	TokenNameIdentifier	 r
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
executor	TokenNameIdentifier	 executor
=	TokenNameEQUAL	
executor	TokenNameIdentifier	 executor
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
closeReader	TokenNameIdentifier	 close Reader
=	TokenNameEQUAL	
closeReader	TokenNameIdentifier	 close Reader
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
IndexReader	TokenNameIdentifier	 Index Reader
>	TokenNameGREATER	
subReadersList	TokenNameIdentifier	 sub Readers List
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
IndexReader	TokenNameIdentifier	 Index Reader
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
gatherSubReaders	TokenNameIdentifier	 gather Sub Readers
(	TokenNameLPAREN	
subReadersList	TokenNameIdentifier	 sub Readers List
,	TokenNameCOMMA	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
subReaders	TokenNameIdentifier	 sub Readers
=	TokenNameEQUAL	
subReadersList	TokenNameIdentifier	 sub Readers List
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
new	TokenNamenew	
IndexReader	TokenNameIdentifier	 Index Reader
[	TokenNameLBRACKET	
subReadersList	TokenNameIdentifier	 sub Readers List
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
docStarts	TokenNameIdentifier	 doc Starts
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
subReaders	TokenNameIdentifier	 sub Readers
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
maxDoc	TokenNameIdentifier	 max Doc
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
subReaders	TokenNameIdentifier	 sub Readers
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
docStarts	TokenNameIdentifier	 doc Starts
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
maxDoc	TokenNameIdentifier	 max Doc
;	TokenNameSEMICOLON	
maxDoc	TokenNameIdentifier	 max Doc
+=	TokenNamePLUS_EQUAL	
subReaders	TokenNameIdentifier	 sub Readers
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
maxDoc	TokenNameIdentifier	 max Doc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
executor	TokenNameIdentifier	 executor
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
subSearchers	TokenNameIdentifier	 sub Searchers
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
subSearchers	TokenNameIdentifier	 sub Searchers
=	TokenNameEQUAL	
new	TokenNamenew	
IndexSearcher	TokenNameIdentifier	 Index Searcher
[	TokenNameLBRACKET	
subReaders	TokenNameIdentifier	 sub Readers
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
subReaders	TokenNameIdentifier	 sub Readers
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
subSearchers	TokenNameIdentifier	 sub Searchers
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
IndexSearcher	TokenNameIdentifier	 Index Searcher
(	TokenNameLPAREN	
subReaders	TokenNameIdentifier	 sub Readers
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
docStarts	TokenNameIdentifier	 doc Starts
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
docBase	TokenNameIdentifier	 doc Base
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
gatherSubReaders	TokenNameIdentifier	 gather Sub Readers
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
IndexReader	TokenNameIdentifier	 Index Reader
>	TokenNameGREATER	
allSubReaders	TokenNameIdentifier	 all Sub Readers
,	TokenNameCOMMA	
IndexReader	TokenNameIdentifier	 Index Reader
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ReaderUtil	TokenNameIdentifier	 Reader Util
.	TokenNameDOT	
gatherSubReaders	TokenNameIdentifier	 gather Sub Readers
(	TokenNameLPAREN	
allSubReaders	TokenNameIdentifier	 all Sub Readers
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Return the {@link IndexReader} this searches. */	TokenNameCOMMENT_JAVADOC	 Return the {@link IndexReader} this searches. 
public	TokenNamepublic	
IndexReader	TokenNameIdentifier	 Index Reader
getIndexReader	TokenNameIdentifier	 get Index Reader
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
reader	TokenNameIdentifier	 reader
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Returns the atomic subReaders used by this searcher. */	TokenNameCOMMENT_JAVADOC	 Returns the atomic subReaders used by this searcher. 
public	TokenNamepublic	
IndexReader	TokenNameIdentifier	 Index Reader
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getSubReaders	TokenNameIdentifier	 get Sub Readers
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
subReaders	TokenNameIdentifier	 sub Readers
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Expert: Returns one greater than the largest possible document number. * * @see org.apache.lucene.index.IndexReader#maxDoc() */	TokenNameCOMMENT_JAVADOC	 Expert: Returns one greater than the largest possible document number. * @see org.apache.lucene.index.IndexReader#maxDoc() 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
int	TokenNameint	
maxDoc	TokenNameIdentifier	 max Doc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
maxDoc	TokenNameIdentifier	 max Doc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Returns total docFreq for this term. */	TokenNameCOMMENT_JAVADOC	 Returns total docFreq for this term. 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
int	TokenNameint	
docFreq	TokenNameIdentifier	 doc Freq
(	TokenNameLPAREN	
final	TokenNamefinal	
Term	TokenNameIdentifier	 Term
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
executor	TokenNameIdentifier	 executor
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
docFreq	TokenNameIdentifier	 doc Freq
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
final	TokenNamefinal	
ExecutionHelper	TokenNameIdentifier	 Execution Helper
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
runner	TokenNameIdentifier	 runner
=	TokenNameEQUAL	
new	TokenNamenew	
ExecutionHelper	TokenNameIdentifier	 Execution Helper
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
(	TokenNameLPAREN	
executor	TokenNameIdentifier	 executor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
subReaders	TokenNameIdentifier	 sub Readers
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
IndexSearcher	TokenNameIdentifier	 Index Searcher
searchable	TokenNameIdentifier	 searchable
=	TokenNameEQUAL	
subSearchers	TokenNameIdentifier	 sub Searchers
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
runner	TokenNameIdentifier	 runner
.	TokenNameDOT	
submit	TokenNameIdentifier	 submit
(	TokenNameLPAREN	
new	TokenNamenew	
Callable	TokenNameIdentifier	 Callable
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
Integer	TokenNameIdentifier	 Integer
call	TokenNameIdentifier	 call
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
searchable	TokenNameIdentifier	 searchable
.	TokenNameDOT	
docFreq	TokenNameIdentifier	 doc Freq
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
docFreq	TokenNameIdentifier	 doc Freq
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Integer	TokenNameIdentifier	 Integer
num	TokenNameIdentifier	 num
:	TokenNameCOLON	
runner	TokenNameIdentifier	 runner
)	TokenNameRPAREN	
{	TokenNameLBRACE	
docFreq	TokenNameIdentifier	 doc Freq
+=	TokenNamePLUS_EQUAL	
num	TokenNameIdentifier	 num
.	TokenNameDOT	
intValue	TokenNameIdentifier	 int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
docFreq	TokenNameIdentifier	 doc Freq
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* Sugar for .getIndexReader().document(docID) */	TokenNameCOMMENT_BLOCK	 Sugar for .getIndexReader().document(docID) 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
Document	TokenNameIdentifier	 Document
doc	TokenNameIdentifier	 doc
(	TokenNameLPAREN	
int	TokenNameint	
docID	TokenNameIdentifier	 doc ID
)	TokenNameRPAREN	
throws	TokenNamethrows	
CorruptIndexException	TokenNameIdentifier	 Corrupt Index Exception
,	TokenNameCOMMA	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
document	TokenNameIdentifier	 document
(	TokenNameLPAREN	
docID	TokenNameIdentifier	 doc ID
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* Sugar for .getIndexReader().document(docID, fieldSelector) */	TokenNameCOMMENT_BLOCK	 Sugar for .getIndexReader().document(docID, fieldSelector) 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
Document	TokenNameIdentifier	 Document
doc	TokenNameIdentifier	 doc
(	TokenNameLPAREN	
int	TokenNameint	
docID	TokenNameIdentifier	 doc ID
,	TokenNameCOMMA	
FieldSelector	TokenNameIdentifier	 Field Selector
fieldSelector	TokenNameIdentifier	 field Selector
)	TokenNameRPAREN	
throws	TokenNamethrows	
CorruptIndexException	TokenNameIdentifier	 Corrupt Index Exception
,	TokenNameCOMMA	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
document	TokenNameIdentifier	 document
(	TokenNameLPAREN	
docID	TokenNameIdentifier	 doc ID
,	TokenNameCOMMA	
fieldSelector	TokenNameIdentifier	 field Selector
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Expert: Set the Similarity implementation used by this Searcher. * * @see Similarity#setDefault(Similarity) */	TokenNameCOMMENT_JAVADOC	 Expert: Set the Similarity implementation used by this Searcher. * @see Similarity#setDefault(Similarity) 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
setSimilarity	TokenNameIdentifier	 set Similarity
(	TokenNameLPAREN	
Similarity	TokenNameIdentifier	 Similarity
similarity	TokenNameIdentifier	 similarity
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
setSimilarity	TokenNameIdentifier	 set Similarity
(	TokenNameLPAREN	
similarity	TokenNameIdentifier	 similarity
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
Similarity	TokenNameIdentifier	 Similarity
getSimilarity	TokenNameIdentifier	 get Similarity
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
super	TokenNamesuper	
.	TokenNameDOT	
getSimilarity	TokenNameIdentifier	 get Similarity
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Note that the underlying IndexReader is not closed, if * IndexSearcher was constructed with IndexSearcher(IndexReader r). * If the IndexReader was supplied implicitly by specifying a directory, then * the IndexReader is closed. */	TokenNameCOMMENT_JAVADOC	 Note that the underlying IndexReader is not closed, if IndexSearcher was constructed with IndexSearcher(IndexReader r). If the IndexReader was supplied implicitly by specifying a directory, then the IndexReader is closed. 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
closeReader	TokenNameIdentifier	 close Reader
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Finds the top <code>n</code> * hits for <code>query</code> where all results are after a previous * result (<code>after</code>). * <p> * By passing the bottom result from a previous page as <code>after</code>, * this method can be used for efficient 'deep-paging' across potentially * large result sets. * * @throws BooleanQuery.TooManyClauses */	TokenNameCOMMENT_JAVADOC	 Finds the top <code>n</code> hits for <code>query</code> where all results are after a previous result (<code>after</code>). <p> By passing the bottom result from a previous page as <code>after</code>, this method can be used for efficient 'deep-paging' across potentially large result sets. * @throws BooleanQuery.TooManyClauses 
public	TokenNamepublic	
TopDocs	TokenNameIdentifier	 Top Docs
searchAfter	TokenNameIdentifier	 search After
(	TokenNameLPAREN	
ScoreDoc	TokenNameIdentifier	 Score Doc
after	TokenNameIdentifier	 after
,	TokenNameCOMMA	
Query	TokenNameIdentifier	 Query
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
int	TokenNameint	
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
searchAfter	TokenNameIdentifier	 search After
(	TokenNameLPAREN	
after	TokenNameIdentifier	 after
,	TokenNameCOMMA	
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Finds the top <code>n</code> * hits for <code>query</code>, applying <code>filter</code> if non-null, * where all results are after a previous result (<code>after</code>). * <p> * By passing the bottom result from a previous page as <code>after</code>, * this method can be used for efficient 'deep-paging' across potentially * large result sets. * * @throws BooleanQuery.TooManyClauses */	TokenNameCOMMENT_JAVADOC	 Finds the top <code>n</code> hits for <code>query</code>, applying <code>filter</code> if non-null, where all results are after a previous result (<code>after</code>). <p> By passing the bottom result from a previous page as <code>after</code>, this method can be used for efficient 'deep-paging' across potentially large result sets. * @throws BooleanQuery.TooManyClauses 
public	TokenNamepublic	
TopDocs	TokenNameIdentifier	 Top Docs
searchAfter	TokenNameIdentifier	 search After
(	TokenNameLPAREN	
ScoreDoc	TokenNameIdentifier	 Score Doc
after	TokenNameIdentifier	 after
,	TokenNameCOMMA	
Query	TokenNameIdentifier	 Query
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
Filter	TokenNameIdentifier	 Filter
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
int	TokenNameint	
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
createNormalizedWeight	TokenNameIdentifier	 create Normalized Weight
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
after	TokenNameIdentifier	 after
,	TokenNameCOMMA	
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Finds the top <code>n</code> * hits for <code>query</code>. * * @throws BooleanQuery.TooManyClauses */	TokenNameCOMMENT_JAVADOC	 Finds the top <code>n</code> hits for <code>query</code>. * @throws BooleanQuery.TooManyClauses 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
TopDocs	TokenNameIdentifier	 Top Docs
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
int	TokenNameint	
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Finds the top <code>n</code> * hits for <code>query</code>, applying <code>filter</code> if non-null. * * @throws BooleanQuery.TooManyClauses */	TokenNameCOMMENT_JAVADOC	 Finds the top <code>n</code> hits for <code>query</code>, applying <code>filter</code> if non-null. * @throws BooleanQuery.TooManyClauses 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
TopDocs	TokenNameIdentifier	 Top Docs
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
Filter	TokenNameIdentifier	 Filter
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
int	TokenNameint	
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
createNormalizedWeight	TokenNameIdentifier	 create Normalized Weight
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Lower-level search API. * * <p>{@link Collector#collect(int)} is called for every matching * document. * <br>Collector-based access to remote indexes is discouraged. * * <p>Applications should only use this if they need <i>all</i> of the * matching documents. The high-level search API ({@link * Searcher#search(Query, Filter, int)}) is usually more efficient, as it skips * non-high-scoring hits. * * @param query to match documents * @param filter if non-null, used to permit documents to be collected. * @param results to receive hits * @throws BooleanQuery.TooManyClauses */	TokenNameCOMMENT_JAVADOC	 Lower-level search API. * <p>{@link Collector#collect(int)} is called for every matching document. <br>Collector-based access to remote indexes is discouraged. * <p>Applications should only use this if they need <i>all</i> of the matching documents. The high-level search API ({@link Searcher#search(Query, Filter, int)}) is usually more efficient, as it skips non-high-scoring hits. * @param query to match documents @param filter if non-null, used to permit documents to be collected. @param results to receive hits @throws BooleanQuery.TooManyClauses 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
Filter	TokenNameIdentifier	 Filter
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
Collector	TokenNameIdentifier	 Collector
results	TokenNameIdentifier	 results
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
createNormalizedWeight	TokenNameIdentifier	 create Normalized Weight
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
results	TokenNameIdentifier	 results
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Lower-level search API. * * <p>{@link Collector#collect(int)} is called for every matching document. * * <p>Applications should only use this if they need <i>all</i> of the * matching documents. The high-level search API ({@link * Searcher#search(Query, int)}) is usually more efficient, as it skips * non-high-scoring hits. * <p>Note: The <code>score</code> passed to this method is a raw score. * In other words, the score will not necessarily be a float whose value is * between 0 and 1. * @throws BooleanQuery.TooManyClauses */	TokenNameCOMMENT_JAVADOC	 Lower-level search API. * <p>{@link Collector#collect(int)} is called for every matching document. * <p>Applications should only use this if they need <i>all</i> of the matching documents. The high-level search API ({@link Searcher#search(Query, int)}) is usually more efficient, as it skips non-high-scoring hits. <p>Note: The <code>score</code> passed to this method is a raw score. In other words, the score will not necessarily be a float whose value is between 0 and 1. @throws BooleanQuery.TooManyClauses 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
Collector	TokenNameIdentifier	 Collector
results	TokenNameIdentifier	 results
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
createNormalizedWeight	TokenNameIdentifier	 create Normalized Weight
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
results	TokenNameIdentifier	 results
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Search implementation with arbitrary sorting. Finds * the top <code>n</code> hits for <code>query</code>, applying * <code>filter</code> if non-null, and sorting the hits by the criteria in * <code>sort</code>. * * <p>NOTE: this does not compute scores by default; use * {@link IndexSearcher#setDefaultFieldSortScoring} to * enable scoring. * * @throws BooleanQuery.TooManyClauses */	TokenNameCOMMENT_JAVADOC	 Search implementation with arbitrary sorting. Finds the top <code>n</code> hits for <code>query</code>, applying <code>filter</code> if non-null, and sorting the hits by the criteria in <code>sort</code>. * <p>NOTE: this does not compute scores by default; use {@link IndexSearcher#setDefaultFieldSortScoring} to enable scoring. * @throws BooleanQuery.TooManyClauses 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
TopFieldDocs	TokenNameIdentifier	 Top Field Docs
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
Filter	TokenNameIdentifier	 Filter
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
int	TokenNameint	
n	TokenNameIdentifier	 n
,	TokenNameCOMMA	
Sort	TokenNameIdentifier	 Sort
sort	TokenNameIdentifier	 sort
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
createNormalizedWeight	TokenNameIdentifier	 create Normalized Weight
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
n	TokenNameIdentifier	 n
,	TokenNameCOMMA	
sort	TokenNameIdentifier	 sort
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Search implementation with arbitrary sorting and no filter. * @param query The query to search for * @param n Return only the top n results * @param sort The {@link org.apache.lucene.search.Sort} object * @return The top docs, sorted according to the supplied {@link org.apache.lucene.search.Sort} instance * @throws IOException */	TokenNameCOMMENT_JAVADOC	 Search implementation with arbitrary sorting and no filter. @param query The query to search for @param n Return only the top n results @param sort The {@link org.apache.lucene.search.Sort} object @return The top docs, sorted according to the supplied {@link org.apache.lucene.search.Sort} instance @throws IOException 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
TopFieldDocs	TokenNameIdentifier	 Top Field Docs
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
int	TokenNameint	
n	TokenNameIdentifier	 n
,	TokenNameCOMMA	
Sort	TokenNameIdentifier	 Sort
sort	TokenNameIdentifier	 sort
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
createNormalizedWeight	TokenNameIdentifier	 create Normalized Weight
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
n	TokenNameIdentifier	 n
,	TokenNameCOMMA	
sort	TokenNameIdentifier	 sort
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Expert: Low-level search implementation. Finds the top <code>n</code> * hits for <code>query</code>, applying <code>filter</code> if non-null. * * <p>Applications should usually call {@link Searcher#search(Query,int)} or * {@link Searcher#search(Query,Filter,int)} instead. * @throws BooleanQuery.TooManyClauses */	TokenNameCOMMENT_JAVADOC	 Expert: Low-level search implementation. Finds the top <code>n</code> hits for <code>query</code>, applying <code>filter</code> if non-null. * <p>Applications should usually call {@link Searcher#search(Query,int)} or {@link Searcher#search(Query,Filter,int)} instead. @throws BooleanQuery.TooManyClauses 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
TopDocs	TokenNameIdentifier	 Top Docs
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
Weight	TokenNameIdentifier	 Weight
weight	TokenNameIdentifier	 weight
,	TokenNameCOMMA	
Filter	TokenNameIdentifier	 Filter
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
int	TokenNameint	
nDocs	TokenNameIdentifier	 n Docs
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
weight	TokenNameIdentifier	 weight
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
nDocs	TokenNameIdentifier	 n Docs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Expert: Low-level search implementation. Finds the top <code>n</code> * hits for <code>query</code>, applying <code>filter</code> if non-null, * returning results after <code>after</code>. * * @throws BooleanQuery.TooManyClauses */	TokenNameCOMMENT_JAVADOC	 Expert: Low-level search implementation. Finds the top <code>n</code> hits for <code>query</code>, applying <code>filter</code> if non-null, returning results after <code>after</code>. * @throws BooleanQuery.TooManyClauses 
protected	TokenNameprotected	
TopDocs	TokenNameIdentifier	 Top Docs
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
Weight	TokenNameIdentifier	 Weight
weight	TokenNameIdentifier	 weight
,	TokenNameCOMMA	
Filter	TokenNameIdentifier	 Filter
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
ScoreDoc	TokenNameIdentifier	 Score Doc
after	TokenNameIdentifier	 after
,	TokenNameCOMMA	
int	TokenNameint	
nDocs	TokenNameIdentifier	 n Docs
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
executor	TokenNameIdentifier	 executor
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// single thread 	TokenNameCOMMENT_LINE	single thread 
int	TokenNameint	
limit	TokenNameIdentifier	 limit
=	TokenNameEQUAL	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
maxDoc	TokenNameIdentifier	 max Doc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
limit	TokenNameIdentifier	 limit
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
limit	TokenNameIdentifier	 limit
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
nDocs	TokenNameIdentifier	 n Docs
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
min	TokenNameIdentifier	 min
(	TokenNameLPAREN	
nDocs	TokenNameIdentifier	 n Docs
,	TokenNameCOMMA	
limit	TokenNameIdentifier	 limit
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TopScoreDocCollector	TokenNameIdentifier	 Top Score Doc Collector
collector	TokenNameIdentifier	 collector
=	TokenNameEQUAL	
TopScoreDocCollector	TokenNameIdentifier	 Top Score Doc Collector
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
nDocs	TokenNameIdentifier	 n Docs
,	TokenNameCOMMA	
after	TokenNameIdentifier	 after
,	TokenNameCOMMA	
!	TokenNameNOT	
weight	TokenNameIdentifier	 weight
.	TokenNameDOT	
scoresDocsOutOfOrder	TokenNameIdentifier	 scores Docs Out Of Order
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
weight	TokenNameIdentifier	 weight
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
collector	TokenNameIdentifier	 collector
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
collector	TokenNameIdentifier	 collector
.	TokenNameDOT	
topDocs	TokenNameIdentifier	 top Docs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
final	TokenNamefinal	
HitQueue	TokenNameIdentifier	 Hit Queue
hq	TokenNameIdentifier	 hq
=	TokenNameEQUAL	
new	TokenNamenew	
HitQueue	TokenNameIdentifier	 Hit Queue
(	TokenNameLPAREN	
nDocs	TokenNameIdentifier	 n Docs
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Lock	TokenNameIdentifier	 Lock
lock	TokenNameIdentifier	 lock
=	TokenNameEQUAL	
new	TokenNamenew	
ReentrantLock	TokenNameIdentifier	 Reentrant Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
ExecutionHelper	TokenNameIdentifier	 Execution Helper
<	TokenNameLESS	
TopDocs	TokenNameIdentifier	 Top Docs
>	TokenNameGREATER	
runner	TokenNameIdentifier	 runner
=	TokenNameEQUAL	
new	TokenNamenew	
ExecutionHelper	TokenNameIdentifier	 Execution Helper
<	TokenNameLESS	
TopDocs	TokenNameIdentifier	 Top Docs
>	TokenNameGREATER	
(	TokenNameLPAREN	
executor	TokenNameIdentifier	 executor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
subReaders	TokenNameIdentifier	 sub Readers
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// search each sub 	TokenNameCOMMENT_LINE	search each sub 
runner	TokenNameIdentifier	 runner
.	TokenNameDOT	
submit	TokenNameIdentifier	 submit
(	TokenNameLPAREN	
new	TokenNamenew	
MultiSearcherCallableNoSort	TokenNameIdentifier	 Multi Searcher Callable No Sort
(	TokenNameLPAREN	
lock	TokenNameIdentifier	 lock
,	TokenNameCOMMA	
subSearchers	TokenNameIdentifier	 sub Searchers
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
weight	TokenNameIdentifier	 weight
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
after	TokenNameIdentifier	 after
,	TokenNameCOMMA	
nDocs	TokenNameIdentifier	 n Docs
,	TokenNameCOMMA	
hq	TokenNameIdentifier	 hq
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
totalHits	TokenNameIdentifier	 total Hits
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
maxScore	TokenNameIdentifier	 max Score
=	TokenNameEQUAL	
Float	TokenNameIdentifier	 Float
.	TokenNameDOT	
NEGATIVE_INFINITY	TokenNameIdentifier	 NEGATIVE  INFINITY
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
final	TokenNamefinal	
TopDocs	TokenNameIdentifier	 Top Docs
topDocs	TokenNameIdentifier	 top Docs
:	TokenNameCOLON	
runner	TokenNameIdentifier	 runner
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
topDocs	TokenNameIdentifier	 top Docs
.	TokenNameDOT	
totalHits	TokenNameIdentifier	 total Hits
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
totalHits	TokenNameIdentifier	 total Hits
+=	TokenNamePLUS_EQUAL	
topDocs	TokenNameIdentifier	 top Docs
.	TokenNameDOT	
totalHits	TokenNameIdentifier	 total Hits
;	TokenNameSEMICOLON	
maxScore	TokenNameIdentifier	 max Score
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
max	TokenNameIdentifier	 max
(	TokenNameLPAREN	
maxScore	TokenNameIdentifier	 max Score
,	TokenNameCOMMA	
topDocs	TokenNameIdentifier	 top Docs
.	TokenNameDOT	
getMaxScore	TokenNameIdentifier	 get Max Score
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
final	TokenNamefinal	
ScoreDoc	TokenNameIdentifier	 Score Doc
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
scoreDocs	TokenNameIdentifier	 score Docs
=	TokenNameEQUAL	
new	TokenNamenew	
ScoreDoc	TokenNameIdentifier	 Score Doc
[	TokenNameLBRACKET	
hq	TokenNameIdentifier	 hq
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
hq	TokenNameIdentifier	 hq
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
// put docs in array 	TokenNameCOMMENT_LINE	put docs in array 
scoreDocs	TokenNameIdentifier	 score Docs
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
hq	TokenNameIdentifier	 hq
.	TokenNameDOT	
pop	TokenNameIdentifier	 pop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
TopDocs	TokenNameIdentifier	 Top Docs
(	TokenNameLPAREN	
totalHits	TokenNameIdentifier	 total Hits
,	TokenNameCOMMA	
scoreDocs	TokenNameIdentifier	 score Docs
,	TokenNameCOMMA	
maxScore	TokenNameIdentifier	 max Score
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Expert: Low-level search implementation with arbitrary sorting. Finds * the top <code>n</code> hits for <code>query</code>, applying * <code>filter</code> if non-null, and sorting the hits by the criteria in * <code>sort</code>. * * <p>Applications should usually call {@link * Searcher#search(Query,Filter,int,Sort)} instead. * * @throws BooleanQuery.TooManyClauses */	TokenNameCOMMENT_JAVADOC	 Expert: Low-level search implementation with arbitrary sorting. Finds the top <code>n</code> hits for <code>query</code>, applying <code>filter</code> if non-null, and sorting the hits by the criteria in <code>sort</code>. * <p>Applications should usually call {@link Searcher#search(Query,Filter,int,Sort)} instead. * @throws BooleanQuery.TooManyClauses 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
TopFieldDocs	TokenNameIdentifier	 Top Field Docs
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
Weight	TokenNameIdentifier	 Weight
weight	TokenNameIdentifier	 weight
,	TokenNameCOMMA	
Filter	TokenNameIdentifier	 Filter
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
final	TokenNamefinal	
int	TokenNameint	
nDocs	TokenNameIdentifier	 n Docs
,	TokenNameCOMMA	
Sort	TokenNameIdentifier	 Sort
sort	TokenNameIdentifier	 sort
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
weight	TokenNameIdentifier	 weight
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
nDocs	TokenNameIdentifier	 n Docs
,	TokenNameCOMMA	
sort	TokenNameIdentifier	 sort
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Just like {@link #search(Weight, Filter, int, Sort)}, but you choose * whether or not the fields in the returned {@link FieldDoc} instances should * be set by specifying fillFields. * * <p>NOTE: this does not compute scores by default. If you * need scores, create a {@link TopFieldCollector} * instance by calling {@link TopFieldCollector#create} and * then pass that to {@link #search(Weight, Filter, * Collector)}.</p> */	TokenNameCOMMENT_JAVADOC	 Just like {@link #search(Weight, Filter, int, Sort)}, but you choose whether or not the fields in the returned {@link FieldDoc} instances should be set by specifying fillFields. * <p>NOTE: this does not compute scores by default. If you need scores, create a {@link TopFieldCollector} instance by calling {@link TopFieldCollector#create} and then pass that to {@link #search(Weight, Filter, Collector)}.</p> 
protected	TokenNameprotected	
TopFieldDocs	TokenNameIdentifier	 Top Field Docs
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
Weight	TokenNameIdentifier	 Weight
weight	TokenNameIdentifier	 weight
,	TokenNameCOMMA	
Filter	TokenNameIdentifier	 Filter
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
int	TokenNameint	
nDocs	TokenNameIdentifier	 n Docs
,	TokenNameCOMMA	
Sort	TokenNameIdentifier	 Sort
sort	TokenNameIdentifier	 sort
,	TokenNameCOMMA	
boolean	TokenNameboolean	
fillFields	TokenNameIdentifier	 fill Fields
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
sort	TokenNameIdentifier	 sort
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
NullPointerException	TokenNameIdentifier	 Null Pointer Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
executor	TokenNameIdentifier	 executor
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// single thread 	TokenNameCOMMENT_LINE	single thread 
int	TokenNameint	
limit	TokenNameIdentifier	 limit
=	TokenNameEQUAL	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
maxDoc	TokenNameIdentifier	 max Doc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
limit	TokenNameIdentifier	 limit
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
limit	TokenNameIdentifier	 limit
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
nDocs	TokenNameIdentifier	 n Docs
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
min	TokenNameIdentifier	 min
(	TokenNameLPAREN	
nDocs	TokenNameIdentifier	 n Docs
,	TokenNameCOMMA	
limit	TokenNameIdentifier	 limit
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TopFieldCollector	TokenNameIdentifier	 Top Field Collector
collector	TokenNameIdentifier	 collector
=	TokenNameEQUAL	
TopFieldCollector	TokenNameIdentifier	 Top Field Collector
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
sort	TokenNameIdentifier	 sort
,	TokenNameCOMMA	
nDocs	TokenNameIdentifier	 n Docs
,	TokenNameCOMMA	
fillFields	TokenNameIdentifier	 fill Fields
,	TokenNameCOMMA	
fieldSortDoTrackScores	TokenNameIdentifier	 field Sort Do Track Scores
,	TokenNameCOMMA	
fieldSortDoMaxScore	TokenNameIdentifier	 field Sort Do Max Score
,	TokenNameCOMMA	
!	TokenNameNOT	
weight	TokenNameIdentifier	 weight
.	TokenNameDOT	
scoresDocsOutOfOrder	TokenNameIdentifier	 scores Docs Out Of Order
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
weight	TokenNameIdentifier	 weight
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
collector	TokenNameIdentifier	 collector
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
TopFieldDocs	TokenNameIdentifier	 Top Field Docs
)	TokenNameRPAREN	
collector	TokenNameIdentifier	 collector
.	TokenNameDOT	
topDocs	TokenNameIdentifier	 top Docs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
final	TokenNamefinal	
TopFieldCollector	TokenNameIdentifier	 Top Field Collector
topCollector	TokenNameIdentifier	 top Collector
=	TokenNameEQUAL	
TopFieldCollector	TokenNameIdentifier	 Top Field Collector
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
sort	TokenNameIdentifier	 sort
,	TokenNameCOMMA	
nDocs	TokenNameIdentifier	 n Docs
,	TokenNameCOMMA	
fillFields	TokenNameIdentifier	 fill Fields
,	TokenNameCOMMA	
fieldSortDoTrackScores	TokenNameIdentifier	 field Sort Do Track Scores
,	TokenNameCOMMA	
fieldSortDoMaxScore	TokenNameIdentifier	 field Sort Do Max Score
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Lock	TokenNameIdentifier	 Lock
lock	TokenNameIdentifier	 lock
=	TokenNameEQUAL	
new	TokenNamenew	
ReentrantLock	TokenNameIdentifier	 Reentrant Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
ExecutionHelper	TokenNameIdentifier	 Execution Helper
<	TokenNameLESS	
TopFieldDocs	TokenNameIdentifier	 Top Field Docs
>	TokenNameGREATER	
runner	TokenNameIdentifier	 runner
=	TokenNameEQUAL	
new	TokenNamenew	
ExecutionHelper	TokenNameIdentifier	 Execution Helper
<	TokenNameLESS	
TopFieldDocs	TokenNameIdentifier	 Top Field Docs
>	TokenNameGREATER	
(	TokenNameLPAREN	
executor	TokenNameIdentifier	 executor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
subReaders	TokenNameIdentifier	 sub Readers
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// search each sub 	TokenNameCOMMENT_LINE	search each sub 
runner	TokenNameIdentifier	 runner
.	TokenNameDOT	
submit	TokenNameIdentifier	 submit
(	TokenNameLPAREN	
new	TokenNamenew	
MultiSearcherCallableWithSort	TokenNameIdentifier	 Multi Searcher Callable With Sort
(	TokenNameLPAREN	
lock	TokenNameIdentifier	 lock
,	TokenNameCOMMA	
subSearchers	TokenNameIdentifier	 sub Searchers
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
weight	TokenNameIdentifier	 weight
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
nDocs	TokenNameIdentifier	 n Docs
,	TokenNameCOMMA	
topCollector	TokenNameIdentifier	 top Collector
,	TokenNameCOMMA	
sort	TokenNameIdentifier	 sort
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
totalHits	TokenNameIdentifier	 total Hits
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
maxScore	TokenNameIdentifier	 max Score
=	TokenNameEQUAL	
Float	TokenNameIdentifier	 Float
.	TokenNameDOT	
NEGATIVE_INFINITY	TokenNameIdentifier	 NEGATIVE  INFINITY
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
final	TokenNamefinal	
TopFieldDocs	TokenNameIdentifier	 Top Field Docs
topFieldDocs	TokenNameIdentifier	 top Field Docs
:	TokenNameCOLON	
runner	TokenNameIdentifier	 runner
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
topFieldDocs	TokenNameIdentifier	 top Field Docs
.	TokenNameDOT	
totalHits	TokenNameIdentifier	 total Hits
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
totalHits	TokenNameIdentifier	 total Hits
+=	TokenNamePLUS_EQUAL	
topFieldDocs	TokenNameIdentifier	 top Field Docs
.	TokenNameDOT	
totalHits	TokenNameIdentifier	 total Hits
;	TokenNameSEMICOLON	
maxScore	TokenNameIdentifier	 max Score
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
max	TokenNameIdentifier	 max
(	TokenNameLPAREN	
maxScore	TokenNameIdentifier	 max Score
,	TokenNameCOMMA	
topFieldDocs	TokenNameIdentifier	 top Field Docs
.	TokenNameDOT	
getMaxScore	TokenNameIdentifier	 get Max Score
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
final	TokenNamefinal	
TopFieldDocs	TokenNameIdentifier	 Top Field Docs
topDocs	TokenNameIdentifier	 top Docs
=	TokenNameEQUAL	
(	TokenNameLPAREN	
TopFieldDocs	TokenNameIdentifier	 Top Field Docs
)	TokenNameRPAREN	
topCollector	TokenNameIdentifier	 top Collector
.	TokenNameDOT	
topDocs	TokenNameIdentifier	 top Docs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
TopFieldDocs	TokenNameIdentifier	 Top Field Docs
(	TokenNameLPAREN	
totalHits	TokenNameIdentifier	 total Hits
,	TokenNameCOMMA	
topDocs	TokenNameIdentifier	 top Docs
.	TokenNameDOT	
scoreDocs	TokenNameIdentifier	 score Docs
,	TokenNameCOMMA	
topDocs	TokenNameIdentifier	 top Docs
.	TokenNameDOT	
fields	TokenNameIdentifier	 fields
,	TokenNameCOMMA	
topDocs	TokenNameIdentifier	 top Docs
.	TokenNameDOT	
getMaxScore	TokenNameIdentifier	 get Max Score
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Lower-level search API. * * <p> * {@link Collector#collect(int)} is called for every document. <br> * Collector-based access to remote indexes is discouraged. * * <p> * Applications should only use this if they need <i>all</i> of the matching * documents. The high-level search API ({@link Searcher#search(Query,int)}) is * usually more efficient, as it skips non-high-scoring hits. * * @param weight * to match documents * @param filter * if non-null, used to permit documents to be collected. * @param collector * to receive hits * @throws BooleanQuery.TooManyClauses */	TokenNameCOMMENT_JAVADOC	 Lower-level search API. * <p> {@link Collector#collect(int)} is called for every document. <br> Collector-based access to remote indexes is discouraged. * <p> Applications should only use this if they need <i>all</i> of the matching documents. The high-level search API ({@link Searcher#search(Query,int)}) is usually more efficient, as it skips non-high-scoring hits. * @param weight to match documents @param filter if non-null, used to permit documents to be collected. @param collector to receive hits @throws BooleanQuery.TooManyClauses 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
Weight	TokenNameIdentifier	 Weight
weight	TokenNameIdentifier	 weight
,	TokenNameCOMMA	
Filter	TokenNameIdentifier	 Filter
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
Collector	TokenNameIdentifier	 Collector
collector	TokenNameIdentifier	 collector
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// TODO: should we make this 	TokenNameCOMMENT_LINE	TODO: should we make this 
// threaded...? the Collector could be sync'd? 	TokenNameCOMMENT_LINE	threaded...? the Collector could be sync'd? 
// always use single thread: 	TokenNameCOMMENT_LINE	always use single thread: 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
subReaders	TokenNameIdentifier	 sub Readers
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// search each subreader 	TokenNameCOMMENT_LINE	search each subreader 
collector	TokenNameIdentifier	 collector
.	TokenNameDOT	
setNextReader	TokenNameIdentifier	 set Next Reader
(	TokenNameLPAREN	
subReaders	TokenNameIdentifier	 sub Readers
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
docBase	TokenNameIdentifier	 doc Base
+	TokenNamePLUS	
docStarts	TokenNameIdentifier	 doc Starts
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Scorer	TokenNameIdentifier	 Scorer
scorer	TokenNameIdentifier	 scorer
=	TokenNameEQUAL	
(	TokenNameLPAREN	
filter	TokenNameIdentifier	 filter
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
weight	TokenNameIdentifier	 weight
.	TokenNameDOT	
scorer	TokenNameIdentifier	 scorer
(	TokenNameLPAREN	
subReaders	TokenNameIdentifier	 sub Readers
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
!	TokenNameNOT	
collector	TokenNameIdentifier	 collector
.	TokenNameDOT	
acceptsDocsOutOfOrder	TokenNameIdentifier	 accepts Docs Out Of Order
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
:	TokenNameCOLON	
FilteredQuery	TokenNameIdentifier	 Filtered Query
.	TokenNameDOT	
getFilteredScorer	TokenNameIdentifier	 get Filtered Scorer
(	TokenNameLPAREN	
subReaders	TokenNameIdentifier	 sub Readers
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
getSimilarity	TokenNameIdentifier	 get Similarity
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
weight	TokenNameIdentifier	 weight
,	TokenNameCOMMA	
weight	TokenNameIdentifier	 weight
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
scorer	TokenNameIdentifier	 scorer
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
scorer	TokenNameIdentifier	 scorer
.	TokenNameDOT	
score	TokenNameIdentifier	 score
(	TokenNameLPAREN	
collector	TokenNameIdentifier	 collector
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Expert: called to re-write queries into primitive queries. * @throws BooleanQuery.TooManyClauses */	TokenNameCOMMENT_JAVADOC	 Expert: called to re-write queries into primitive queries. @throws BooleanQuery.TooManyClauses 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
Query	TokenNameIdentifier	 Query
rewrite	TokenNameIdentifier	 rewrite
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
original	TokenNameIdentifier	 original
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
Query	TokenNameIdentifier	 Query
query	TokenNameIdentifier	 query
=	TokenNameEQUAL	
original	TokenNameIdentifier	 original
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
rewrittenQuery	TokenNameIdentifier	 rewritten Query
=	TokenNameEQUAL	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
rewrite	TokenNameIdentifier	 rewrite
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rewrittenQuery	TokenNameIdentifier	 rewritten Query
!=	TokenNameNOT_EQUAL	
query	TokenNameIdentifier	 query
;	TokenNameSEMICOLON	
rewrittenQuery	TokenNameIdentifier	 rewritten Query
=	TokenNameEQUAL	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
rewrite	TokenNameIdentifier	 rewrite
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
query	TokenNameIdentifier	 query
=	TokenNameEQUAL	
rewrittenQuery	TokenNameIdentifier	 rewritten Query
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
query	TokenNameIdentifier	 query
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Returns an Explanation that describes how <code>doc</code> scored against * <code>query</code>. * * <p>This is intended to be used in developing Similarity implementations, * and, for good performance, should not be displayed with every hit. * Computing an explanation is as expensive as executing the query over the * entire index. */	TokenNameCOMMENT_JAVADOC	 Returns an Explanation that describes how <code>doc</code> scored against <code>query</code>. * <p>This is intended to be used in developing Similarity implementations, and, for good performance, should not be displayed with every hit. Computing an explanation is as expensive as executing the query over the entire index. 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
Explanation	TokenNameIdentifier	 Explanation
explain	TokenNameIdentifier	 explain
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
int	TokenNameint	
doc	TokenNameIdentifier	 doc
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
explain	TokenNameIdentifier	 explain
(	TokenNameLPAREN	
createNormalizedWeight	TokenNameIdentifier	 create Normalized Weight
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
,	TokenNameCOMMA	
doc	TokenNameIdentifier	 doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Expert: low-level implementation method * Returns an Explanation that describes how <code>doc</code> scored against * <code>weight</code>. * * <p>This is intended to be used in developing Similarity implementations, * and, for good performance, should not be displayed with every hit. * Computing an explanation is as expensive as executing the query over the * entire index. * <p>Applications should call {@link Searcher#explain(Query, int)}. * @throws BooleanQuery.TooManyClauses */	TokenNameCOMMENT_JAVADOC	 Expert: low-level implementation method Returns an Explanation that describes how <code>doc</code> scored against <code>weight</code>. * <p>This is intended to be used in developing Similarity implementations, and, for good performance, should not be displayed with every hit. Computing an explanation is as expensive as executing the query over the entire index. <p>Applications should call {@link Searcher#explain(Query, int)}. @throws BooleanQuery.TooManyClauses 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
Explanation	TokenNameIdentifier	 Explanation
explain	TokenNameIdentifier	 explain
(	TokenNameLPAREN	
Weight	TokenNameIdentifier	 Weight
weight	TokenNameIdentifier	 weight
,	TokenNameCOMMA	
int	TokenNameint	
doc	TokenNameIdentifier	 doc
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
int	TokenNameint	
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
ReaderUtil	TokenNameIdentifier	 Reader Util
.	TokenNameDOT	
subIndex	TokenNameIdentifier	 sub Index
(	TokenNameLPAREN	
doc	TokenNameIdentifier	 doc
,	TokenNameCOMMA	
docStarts	TokenNameIdentifier	 doc Starts
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
deBasedDoc	TokenNameIdentifier	 de Based Doc
=	TokenNameEQUAL	
doc	TokenNameIdentifier	 doc
-	TokenNameMINUS	
docStarts	TokenNameIdentifier	 doc Starts
[	TokenNameLBRACKET	
n	TokenNameIdentifier	 n
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
weight	TokenNameIdentifier	 weight
.	TokenNameDOT	
explain	TokenNameIdentifier	 explain
(	TokenNameLPAREN	
subReaders	TokenNameIdentifier	 sub Readers
[	TokenNameLBRACKET	
n	TokenNameIdentifier	 n
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
deBasedDoc	TokenNameIdentifier	 de Based Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
fieldSortDoTrackScores	TokenNameIdentifier	 field Sort Do Track Scores
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
fieldSortDoMaxScore	TokenNameIdentifier	 field Sort Do Max Score
;	TokenNameSEMICOLON	
/** By default, no scores are computed when sorting by * field (using {@link #search(Query,Filter,int,Sort)}). * You can change that, per IndexSearcher instance, by * calling this method. Note that this will incur a CPU * cost. * * @param doTrackScores If true, then scores are * returned for every matching document in {@link * TopFieldDocs}. * * @param doMaxScore If true, then the max score for all * matching docs is computed. */	TokenNameCOMMENT_JAVADOC	 By default, no scores are computed when sorting by field (using {@link #search(Query,Filter,int,Sort)}). You can change that, per IndexSearcher instance, by calling this method. Note that this will incur a CPU cost. * @param doTrackScores If true, then scores are returned for every matching document in {@link TopFieldDocs}. * @param doMaxScore If true, then the max score for all matching docs is computed. 
public	TokenNamepublic	
void	TokenNamevoid	
setDefaultFieldSortScoring	TokenNameIdentifier	 set Default Field Sort Scoring
(	TokenNameLPAREN	
boolean	TokenNameboolean	
doTrackScores	TokenNameIdentifier	 do Track Scores
,	TokenNameCOMMA	
boolean	TokenNameboolean	
doMaxScore	TokenNameIdentifier	 do Max Score
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fieldSortDoTrackScores	TokenNameIdentifier	 field Sort Do Track Scores
=	TokenNameEQUAL	
doTrackScores	TokenNameIdentifier	 do Track Scores
;	TokenNameSEMICOLON	
fieldSortDoMaxScore	TokenNameIdentifier	 field Sort Do Max Score
=	TokenNameEQUAL	
doMaxScore	TokenNameIdentifier	 do Max Score
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
subSearchers	TokenNameIdentifier	 sub Searchers
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// propagate settings to subs 	TokenNameCOMMENT_LINE	propagate settings to subs 
for	TokenNamefor	
(	TokenNameLPAREN	
IndexSearcher	TokenNameIdentifier	 Index Searcher
sub	TokenNameIdentifier	 sub
:	TokenNameCOLON	
subSearchers	TokenNameIdentifier	 sub Searchers
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sub	TokenNameIdentifier	 sub
.	TokenNameDOT	
setDefaultFieldSortScoring	TokenNameIdentifier	 set Default Field Sort Scoring
(	TokenNameLPAREN	
doTrackScores	TokenNameIdentifier	 do Track Scores
,	TokenNameCOMMA	
doMaxScore	TokenNameIdentifier	 do Max Score
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Creates a normalized weight for a top-level {@link Query}. * The query is rewritten by this method and {@link Query#createWeight} called, * afterwards the {@link Weight} is normalized. The returned {@code Weight} * can then directly be used to get a {@link Scorer}. * @lucene.internal */	TokenNameCOMMENT_JAVADOC	 Creates a normalized weight for a top-level {@link Query}. The query is rewritten by this method and {@link Query#createWeight} called, afterwards the {@link Weight} is normalized. The returned {@code Weight} can then directly be used to get a {@link Scorer}. @lucene.internal 
public	TokenNamepublic	
Weight	TokenNameIdentifier	 Weight
createNormalizedWeight	TokenNameIdentifier	 create Normalized Weight
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
super	TokenNamesuper	
.	TokenNameDOT	
createNormalizedWeight	TokenNameIdentifier	 create Normalized Weight
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * A thread subclass for searching a single searchable */	TokenNameCOMMENT_JAVADOC	 A thread subclass for searching a single searchable 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
class	TokenNameclass	
MultiSearcherCallableNoSort	TokenNameIdentifier	 Multi Searcher Callable No Sort
implements	TokenNameimplements	
Callable	TokenNameIdentifier	 Callable
<	TokenNameLESS	
TopDocs	TokenNameIdentifier	 Top Docs
>	TokenNameGREATER	
{	TokenNameLBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
Lock	TokenNameIdentifier	 Lock
lock	TokenNameIdentifier	 lock
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
IndexSearcher	TokenNameIdentifier	 Index Searcher
searchable	TokenNameIdentifier	 searchable
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Weight	TokenNameIdentifier	 Weight
weight	TokenNameIdentifier	 weight
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Filter	TokenNameIdentifier	 Filter
filter	TokenNameIdentifier	 filter
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
ScoreDoc	TokenNameIdentifier	 Score Doc
after	TokenNameIdentifier	 after
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
nDocs	TokenNameIdentifier	 n Docs
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
HitQueue	TokenNameIdentifier	 Hit Queue
hq	TokenNameIdentifier	 hq
;	TokenNameSEMICOLON	
public	TokenNamepublic	
MultiSearcherCallableNoSort	TokenNameIdentifier	 Multi Searcher Callable No Sort
(	TokenNameLPAREN	
Lock	TokenNameIdentifier	 Lock
lock	TokenNameIdentifier	 lock
,	TokenNameCOMMA	
IndexSearcher	TokenNameIdentifier	 Index Searcher
searchable	TokenNameIdentifier	 searchable
,	TokenNameCOMMA	
Weight	TokenNameIdentifier	 Weight
weight	TokenNameIdentifier	 weight
,	TokenNameCOMMA	
Filter	TokenNameIdentifier	 Filter
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
ScoreDoc	TokenNameIdentifier	 Score Doc
after	TokenNameIdentifier	 after
,	TokenNameCOMMA	
int	TokenNameint	
nDocs	TokenNameIdentifier	 n Docs
,	TokenNameCOMMA	
HitQueue	TokenNameIdentifier	 Hit Queue
hq	TokenNameIdentifier	 hq
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
=	TokenNameEQUAL	
lock	TokenNameIdentifier	 lock
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
searchable	TokenNameIdentifier	 searchable
=	TokenNameEQUAL	
searchable	TokenNameIdentifier	 searchable
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
weight	TokenNameIdentifier	 weight
=	TokenNameEQUAL	
weight	TokenNameIdentifier	 weight
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
filter	TokenNameIdentifier	 filter
=	TokenNameEQUAL	
filter	TokenNameIdentifier	 filter
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
after	TokenNameIdentifier	 after
=	TokenNameEQUAL	
after	TokenNameIdentifier	 after
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
nDocs	TokenNameIdentifier	 n Docs
=	TokenNameEQUAL	
nDocs	TokenNameIdentifier	 n Docs
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
hq	TokenNameIdentifier	 hq
=	TokenNameEQUAL	
hq	TokenNameIdentifier	 hq
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
TopDocs	TokenNameIdentifier	 Top Docs
call	TokenNameIdentifier	 call
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
final	TokenNamefinal	
TopDocs	TokenNameIdentifier	 Top Docs
docs	TokenNameIdentifier	 docs
;	TokenNameSEMICOLON	
// we could call the 4-arg method, but we want to invoke the old method 	TokenNameCOMMENT_LINE	we could call the 4-arg method, but we want to invoke the old method 
// for backwards purposes unless someone is using the new searchAfter. 	TokenNameCOMMENT_LINE	for backwards purposes unless someone is using the new searchAfter. 
if	TokenNameif	
(	TokenNameLPAREN	
after	TokenNameIdentifier	 after
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
docs	TokenNameIdentifier	 docs
=	TokenNameEQUAL	
searchable	TokenNameIdentifier	 searchable
.	TokenNameDOT	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
weight	TokenNameIdentifier	 weight
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
nDocs	TokenNameIdentifier	 n Docs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
docs	TokenNameIdentifier	 docs
=	TokenNameEQUAL	
searchable	TokenNameIdentifier	 searchable
.	TokenNameDOT	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
weight	TokenNameIdentifier	 weight
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
after	TokenNameIdentifier	 after
,	TokenNameCOMMA	
nDocs	TokenNameIdentifier	 n Docs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
ScoreDoc	TokenNameIdentifier	 Score Doc
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
scoreDocs	TokenNameIdentifier	 score Docs
=	TokenNameEQUAL	
docs	TokenNameIdentifier	 docs
.	TokenNameDOT	
scoreDocs	TokenNameIdentifier	 score Docs
;	TokenNameSEMICOLON	
//it would be so nice if we had a thread-safe insert 	TokenNameCOMMENT_LINE	it would be so nice if we had a thread-safe insert 
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
scoreDocs	TokenNameIdentifier	 score Docs
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// merge scoreDocs into hq 	TokenNameCOMMENT_LINE	merge scoreDocs into hq 
final	TokenNamefinal	
ScoreDoc	TokenNameIdentifier	 Score Doc
scoreDoc	TokenNameIdentifier	 score Doc
=	TokenNameEQUAL	
scoreDocs	TokenNameIdentifier	 score Docs
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
scoreDoc	TokenNameIdentifier	 score Doc
==	TokenNameEQUAL_EQUAL	
hq	TokenNameIdentifier	 hq
.	TokenNameDOT	
insertWithOverflow	TokenNameIdentifier	 insert With Overflow
(	TokenNameLPAREN	
scoreDoc	TokenNameIdentifier	 score Doc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
docs	TokenNameIdentifier	 docs
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * A thread subclass for searching a single searchable */	TokenNameCOMMENT_JAVADOC	 A thread subclass for searching a single searchable 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
class	TokenNameclass	
MultiSearcherCallableWithSort	TokenNameIdentifier	 Multi Searcher Callable With Sort
implements	TokenNameimplements	
Callable	TokenNameIdentifier	 Callable
<	TokenNameLESS	
TopFieldDocs	TokenNameIdentifier	 Top Field Docs
>	TokenNameGREATER	
{	TokenNameLBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
Lock	TokenNameIdentifier	 Lock
lock	TokenNameIdentifier	 lock
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
IndexSearcher	TokenNameIdentifier	 Index Searcher
searchable	TokenNameIdentifier	 searchable
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Weight	TokenNameIdentifier	 Weight
weight	TokenNameIdentifier	 weight
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Filter	TokenNameIdentifier	 Filter
filter	TokenNameIdentifier	 filter
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
nDocs	TokenNameIdentifier	 n Docs
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
TopFieldCollector	TokenNameIdentifier	 Top Field Collector
hq	TokenNameIdentifier	 hq
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Sort	TokenNameIdentifier	 Sort
sort	TokenNameIdentifier	 sort
;	TokenNameSEMICOLON	
public	TokenNamepublic	
MultiSearcherCallableWithSort	TokenNameIdentifier	 Multi Searcher Callable With Sort
(	TokenNameLPAREN	
Lock	TokenNameIdentifier	 Lock
lock	TokenNameIdentifier	 lock
,	TokenNameCOMMA	
IndexSearcher	TokenNameIdentifier	 Index Searcher
searchable	TokenNameIdentifier	 searchable
,	TokenNameCOMMA	
Weight	TokenNameIdentifier	 Weight
weight	TokenNameIdentifier	 weight
,	TokenNameCOMMA	
Filter	TokenNameIdentifier	 Filter
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
int	TokenNameint	
nDocs	TokenNameIdentifier	 n Docs
,	TokenNameCOMMA	
TopFieldCollector	TokenNameIdentifier	 Top Field Collector
hq	TokenNameIdentifier	 hq
,	TokenNameCOMMA	
Sort	TokenNameIdentifier	 Sort
sort	TokenNameIdentifier	 sort
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
=	TokenNameEQUAL	
lock	TokenNameIdentifier	 lock
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
searchable	TokenNameIdentifier	 searchable
=	TokenNameEQUAL	
searchable	TokenNameIdentifier	 searchable
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
weight	TokenNameIdentifier	 weight
=	TokenNameEQUAL	
weight	TokenNameIdentifier	 weight
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
filter	TokenNameIdentifier	 filter
=	TokenNameEQUAL	
filter	TokenNameIdentifier	 filter
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
nDocs	TokenNameIdentifier	 n Docs
=	TokenNameEQUAL	
nDocs	TokenNameIdentifier	 n Docs
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
hq	TokenNameIdentifier	 hq
=	TokenNameEQUAL	
hq	TokenNameIdentifier	 hq
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
=	TokenNameEQUAL	
sort	TokenNameIdentifier	 sort
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
class	TokenNameclass	
FakeScorer	TokenNameIdentifier	 Fake Scorer
extends	TokenNameextends	
Scorer	TokenNameIdentifier	 Scorer
{	TokenNameLBRACE	
float	TokenNamefloat	
score	TokenNameIdentifier	 score
;	TokenNameSEMICOLON	
int	TokenNameint	
doc	TokenNameIdentifier	 doc
;	TokenNameSEMICOLON	
public	TokenNamepublic	
FakeScorer	TokenNameIdentifier	 Fake Scorer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
int	TokenNameint	
advance	TokenNameIdentifier	 advance
(	TokenNameLPAREN	
int	TokenNameint	
target	TokenNameIdentifier	 target
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
UnsupportedOperationException	TokenNameIdentifier	 Unsupported Operation Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
int	TokenNameint	
docID	TokenNameIdentifier	 doc ID
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
doc	TokenNameIdentifier	 doc
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
float	TokenNamefloat	
freq	TokenNameIdentifier	 freq
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
UnsupportedOperationException	TokenNameIdentifier	 Unsupported Operation Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
int	TokenNameint	
nextDoc	TokenNameIdentifier	 next Doc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
UnsupportedOperationException	TokenNameIdentifier	 Unsupported Operation Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
float	TokenNamefloat	
score	TokenNameIdentifier	 score
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
score	TokenNameIdentifier	 score
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
FakeScorer	TokenNameIdentifier	 Fake Scorer
fakeScorer	TokenNameIdentifier	 fake Scorer
=	TokenNameEQUAL	
new	TokenNamenew	
FakeScorer	TokenNameIdentifier	 Fake Scorer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
TopFieldDocs	TokenNameIdentifier	 Top Field Docs
call	TokenNameIdentifier	 call
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
final	TokenNamefinal	
TopFieldDocs	TokenNameIdentifier	 Top Field Docs
docs	TokenNameIdentifier	 docs
=	TokenNameEQUAL	
searchable	TokenNameIdentifier	 searchable
.	TokenNameDOT	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
weight	TokenNameIdentifier	 weight
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
nDocs	TokenNameIdentifier	 n Docs
,	TokenNameCOMMA	
sort	TokenNameIdentifier	 sort
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// If one of the Sort fields is FIELD_DOC, need to fix its values, so that 	TokenNameCOMMENT_LINE	If one of the Sort fields is FIELD_DOC, need to fix its values, so that 
// it will break ties by doc Id properly. Otherwise, it will compare to 	TokenNameCOMMENT_LINE	it will break ties by doc Id properly. Otherwise, it will compare to 
// 'relative' doc Ids, that belong to two different searchables. 	TokenNameCOMMENT_LINE	'relative' doc Ids, that belong to two different searchables. 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
docs	TokenNameIdentifier	 docs
.	TokenNameDOT	
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
docs	TokenNameIdentifier	 docs
.	TokenNameDOT	
fields	TokenNameIdentifier	 fields
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
SortField	TokenNameIdentifier	 Sort Field
.	TokenNameDOT	
DOC	TokenNameIdentifier	 DOC
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// iterate over the score docs and change their fields value 	TokenNameCOMMENT_LINE	iterate over the score docs and change their fields value 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j2	TokenNameIdentifier	 j2
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j2	TokenNameIdentifier	 j2
<	TokenNameLESS	
docs	TokenNameIdentifier	 docs
.	TokenNameDOT	
scoreDocs	TokenNameIdentifier	 score Docs
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
j2	TokenNameIdentifier	 j2
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
FieldDoc	TokenNameIdentifier	 Field Doc
fd	TokenNameIdentifier	 fd
=	TokenNameEQUAL	
(	TokenNameLPAREN	
FieldDoc	TokenNameIdentifier	 Field Doc
)	TokenNameRPAREN	
docs	TokenNameIdentifier	 docs
.	TokenNameDOT	
scoreDocs	TokenNameIdentifier	 score Docs
[	TokenNameLBRACKET	
j2	TokenNameIdentifier	 j2
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fd	TokenNameIdentifier	 fd
.	TokenNameDOT	
fields	TokenNameIdentifier	 fields
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Integer	TokenNameIdentifier	 Integer
)	TokenNameRPAREN	
fd	TokenNameIdentifier	 fd
.	TokenNameDOT	
fields	TokenNameIdentifier	 fields
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
.	TokenNameDOT	
intValue	TokenNameIdentifier	 int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
hq	TokenNameIdentifier	 hq
.	TokenNameDOT	
setNextReader	TokenNameIdentifier	 set Next Reader
(	TokenNameLPAREN	
searchable	TokenNameIdentifier	 searchable
.	TokenNameDOT	
getIndexReader	TokenNameIdentifier	 get Index Reader
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
searchable	TokenNameIdentifier	 searchable
.	TokenNameDOT	
docBase	TokenNameIdentifier	 doc Base
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
hq	TokenNameIdentifier	 hq
.	TokenNameDOT	
setScorer	TokenNameIdentifier	 set Scorer
(	TokenNameLPAREN	
fakeScorer	TokenNameIdentifier	 fake Scorer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
ScoreDoc	TokenNameIdentifier	 Score Doc
scoreDoc	TokenNameIdentifier	 score Doc
:	TokenNameCOLON	
docs	TokenNameIdentifier	 docs
.	TokenNameDOT	
scoreDocs	TokenNameIdentifier	 score Docs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
docID	TokenNameIdentifier	 doc ID
=	TokenNameEQUAL	
scoreDoc	TokenNameIdentifier	 score Doc
.	TokenNameDOT	
doc	TokenNameIdentifier	 doc
-	TokenNameMINUS	
searchable	TokenNameIdentifier	 searchable
.	TokenNameDOT	
docBase	TokenNameIdentifier	 doc Base
;	TokenNameSEMICOLON	
fakeScorer	TokenNameIdentifier	 fake Scorer
.	TokenNameDOT	
doc	TokenNameIdentifier	 doc
=	TokenNameEQUAL	
docID	TokenNameIdentifier	 doc ID
;	TokenNameSEMICOLON	
fakeScorer	TokenNameIdentifier	 fake Scorer
.	TokenNameDOT	
score	TokenNameIdentifier	 score
=	TokenNameEQUAL	
scoreDoc	TokenNameIdentifier	 score Doc
.	TokenNameDOT	
score	TokenNameIdentifier	 score
;	TokenNameSEMICOLON	
hq	TokenNameIdentifier	 hq
.	TokenNameDOT	
collect	TokenNameIdentifier	 collect
(	TokenNameLPAREN	
docID	TokenNameIdentifier	 doc ID
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
lock	TokenNameIdentifier	 lock
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
docs	TokenNameIdentifier	 docs
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * A helper class that wraps a {@link CompletionService} and provides an * iterable interface to the completed {@link Callable} instances. * * @param <T> * the type of the {@link Callable} return value */	TokenNameCOMMENT_JAVADOC	 A helper class that wraps a {@link CompletionService} and provides an iterable interface to the completed {@link Callable} instances. * @param <T> the type of the {@link Callable} return value 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
class	TokenNameclass	
ExecutionHelper	TokenNameIdentifier	 Execution Helper
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
implements	TokenNameimplements	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
,	TokenNameCOMMA	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
{	TokenNameLBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
CompletionService	TokenNameIdentifier	 Completion Service
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
service	TokenNameIdentifier	 service
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
numTasks	TokenNameIdentifier	 num Tasks
;	TokenNameSEMICOLON	
ExecutionHelper	TokenNameIdentifier	 Execution Helper
(	TokenNameLPAREN	
final	TokenNamefinal	
Executor	TokenNameIdentifier	 Executor
executor	TokenNameIdentifier	 executor
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
service	TokenNameIdentifier	 service
=	TokenNameEQUAL	
new	TokenNamenew	
ExecutorCompletionService	TokenNameIdentifier	 Executor Completion Service
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
(	TokenNameLPAREN	
executor	TokenNameIdentifier	 executor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
numTasks	TokenNameIdentifier	 num Tasks
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
submit	TokenNameIdentifier	 submit
(	TokenNameLPAREN	
Callable	TokenNameIdentifier	 Callable
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
task	TokenNameIdentifier	 task
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
service	TokenNameIdentifier	 service
.	TokenNameDOT	
submit	TokenNameIdentifier	 submit
(	TokenNameLPAREN	
task	TokenNameIdentifier	 task
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
numTasks	TokenNameIdentifier	 num Tasks
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
T	TokenNameIdentifier	 T
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
this	TokenNamethis	
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
NoSuchElementException	TokenNameIdentifier	 No Such Element Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
return	TokenNamereturn	
service	TokenNameIdentifier	 service
.	TokenNameDOT	
take	TokenNameIdentifier	 take
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
ThreadInterruptedException	TokenNameIdentifier	 Thread Interrupted Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ExecutionException	TokenNameIdentifier	 Execution Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
--	TokenNameMINUS_MINUS	
numTasks	TokenNameIdentifier	 num Tasks
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
UnsupportedOperationException	TokenNameIdentifier	 Unsupported Operation Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// use the shortcut here - this is only used in a private context 	TokenNameCOMMENT_LINE	use the shortcut here - this is only used in a private context 
return	TokenNamereturn	
this	TokenNamethis	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
String	TokenNameIdentifier	 String
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
"IndexSearcher("	TokenNameStringLiteral	IndexSearcher(
+	TokenNamePLUS	
reader	TokenNameIdentifier	 reader
+	TokenNamePLUS	
")"	TokenNameStringLiteral	)
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
