/* Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
ext	TokenNameIdentifier	 ext
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
codec	TokenNameIdentifier	 codec
.	TokenNameDOT	
tiff	TokenNameIdentifier	 tiff
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
Rectangle	TokenNameIdentifier	 Rectangle
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
Transparency	TokenNameIdentifier	 Transparency
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
color	TokenNameIdentifier	 color
.	TokenNameDOT	
ColorSpace	TokenNameIdentifier	 Color Space
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
ColorModel	TokenNameIdentifier	 Color Model
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
ComponentColorModel	TokenNameIdentifier	 Component Color Model
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
DataBuffer	TokenNameIdentifier	 Data Buffer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
DataBufferByte	TokenNameIdentifier	 Data Buffer Byte
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
DataBufferInt	TokenNameIdentifier	 Data Buffer Int
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
DataBufferShort	TokenNameIdentifier	 Data Buffer Short
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
DataBufferUShort	TokenNameIdentifier	 Data Buffer U Short
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
IndexColorModel	TokenNameIdentifier	 Index Color Model
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
MultiPixelPackedSampleModel	TokenNameIdentifier	 Multi Pixel Packed Sample Model
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
PixelInterleavedSampleModel	TokenNameIdentifier	 Pixel Interleaved Sample Model
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
Raster	TokenNameIdentifier	 Raster
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
SampleModel	TokenNameIdentifier	 Sample Model
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
WritableRaster	TokenNameIdentifier	 Writable Raster
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
ByteArrayInputStream	TokenNameIdentifier	 Byte Array Input Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
HashMap	TokenNameIdentifier	 Hash Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Map	TokenNameIdentifier	 Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
zip	TokenNameIdentifier	 zip
.	TokenNameDOT	
DataFormatException	TokenNameIdentifier	 Data Format Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
zip	TokenNameIdentifier	 zip
.	TokenNameDOT	
Inflater	TokenNameIdentifier	 Inflater
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
ext	TokenNameIdentifier	 ext
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
codec	TokenNameIdentifier	 codec
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
SeekableStream	TokenNameIdentifier	 Seekable Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
ext	TokenNameIdentifier	 ext
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
rendered	TokenNameIdentifier	 rendered
.	TokenNameDOT	
AbstractRed	TokenNameIdentifier	 Abstract Red
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
ext	TokenNameIdentifier	 ext
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
rendered	TokenNameIdentifier	 rendered
.	TokenNameDOT	
CachableRed	TokenNameIdentifier	 Cachable Red
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
sun	TokenNameIdentifier	 sun
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
codec	TokenNameIdentifier	 codec
.	TokenNameDOT	
jpeg	TokenNameIdentifier	 jpeg
.	TokenNameDOT	
JPEGCodec	TokenNameIdentifier	 JPEG Codec
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
sun	TokenNameIdentifier	 sun
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
codec	TokenNameIdentifier	 codec
.	TokenNameDOT	
jpeg	TokenNameIdentifier	 jpeg
.	TokenNameDOT	
JPEGDecodeParam	TokenNameIdentifier	 JPEG Decode Param
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
sun	TokenNameIdentifier	 sun
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
codec	TokenNameIdentifier	 codec
.	TokenNameDOT	
jpeg	TokenNameIdentifier	 jpeg
.	TokenNameDOT	
JPEGImageDecoder	TokenNameIdentifier	 JPEG Image Decoder
;	TokenNameSEMICOLON	
/** * * @version $Id: TIFFImage.java 498740 2007-01-22 18:35:57Z dvholten $ */	TokenNameCOMMENT_JAVADOC	 * @version $Id: TIFFImage.java 498740 2007-01-22 18:35:57Z dvholten $ 
public	TokenNamepublic	
class	TokenNameclass	
TIFFImage	TokenNameIdentifier	 TIFF Image
extends	TokenNameextends	
AbstractRed	TokenNameIdentifier	 Abstract Red
{	TokenNameLBRACE	
// Compression types 	TokenNameCOMMENT_LINE	Compression types 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
COMP_NONE	TokenNameIdentifier	 COMP  NONE
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
COMP_FAX_G3_1D	TokenNameIdentifier	 COMP  FAX  G3 1 D
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
COMP_FAX_G3_2D	TokenNameIdentifier	 COMP  FAX  G3 2 D
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
COMP_FAX_G4_2D	TokenNameIdentifier	 COMP  FAX  G4 2 D
=	TokenNameEQUAL	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
COMP_LZW	TokenNameIdentifier	 COMP  LZW
=	TokenNameEQUAL	
5	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
COMP_JPEG_OLD	TokenNameIdentifier	 COMP  JPEG  OLD
=	TokenNameEQUAL	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
COMP_JPEG_TTN2	TokenNameIdentifier	 COMP  JPEG  TT N2
=	TokenNameEQUAL	
7	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
COMP_PACKBITS	TokenNameIdentifier	 COMP  PACKBITS
=	TokenNameEQUAL	
32773	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
COMP_DEFLATE	TokenNameIdentifier	 COMP  DEFLATE
=	TokenNameEQUAL	
32946	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Image types 	TokenNameCOMMENT_LINE	Image types 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
TYPE_UNSUPPORTED	TokenNameIdentifier	 TYPE  UNSUPPORTED
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
TYPE_BILEVEL	TokenNameIdentifier	 TYPE  BILEVEL
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
TYPE_GRAY_4BIT	TokenNameIdentifier	 TYPE  GRAY 4 BIT
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
TYPE_GRAY	TokenNameIdentifier	 TYPE  GRAY
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
TYPE_GRAY_ALPHA	TokenNameIdentifier	 TYPE  GRAY  ALPHA
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
TYPE_PALETTE	TokenNameIdentifier	 TYPE  PALETTE
=	TokenNameEQUAL	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
TYPE_RGB	TokenNameIdentifier	 TYPE  RGB
=	TokenNameEQUAL	
5	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
TYPE_RGB_ALPHA	TokenNameIdentifier	 TYPE  RGB  ALPHA
=	TokenNameEQUAL	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
TYPE_YCBCR_SUB	TokenNameIdentifier	 TYPE  YCBCR  SUB
=	TokenNameEQUAL	
7	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
TYPE_GENERIC	TokenNameIdentifier	 TYPE  GENERIC
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Incidental tags 	TokenNameCOMMENT_LINE	Incidental tags 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
TIFF_JPEG_TABLES	TokenNameIdentifier	 TIFF  JPEG  TABLES
=	TokenNameEQUAL	
347	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
TIFF_YCBCR_SUBSAMPLING	TokenNameIdentifier	 TIFF  YCBCR  SUBSAMPLING
=	TokenNameEQUAL	
530	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
SeekableStream	TokenNameIdentifier	 Seekable Stream
stream	TokenNameIdentifier	 stream
;	TokenNameSEMICOLON	
int	TokenNameint	
tileSize	TokenNameIdentifier	 tile Size
;	TokenNameSEMICOLON	
int	TokenNameint	
tilesX	TokenNameIdentifier	 tiles X
,	TokenNameCOMMA	
tilesY	TokenNameIdentifier	 tiles Y
;	TokenNameSEMICOLON	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
tileOffsets	TokenNameIdentifier	 tile Offsets
;	TokenNameSEMICOLON	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
tileByteCounts	TokenNameIdentifier	 tile Byte Counts
;	TokenNameSEMICOLON	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
colormap	TokenNameIdentifier	 colormap
;	TokenNameSEMICOLON	
int	TokenNameint	
sampleSize	TokenNameIdentifier	 sample Size
;	TokenNameSEMICOLON	
int	TokenNameint	
compression	TokenNameIdentifier	 compression
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
palette	TokenNameIdentifier	 palette
;	TokenNameSEMICOLON	
int	TokenNameint	
numBands	TokenNameIdentifier	 num Bands
;	TokenNameSEMICOLON	
int	TokenNameint	
chromaSubH	TokenNameIdentifier	 chroma Sub H
;	TokenNameSEMICOLON	
int	TokenNameint	
chromaSubV	TokenNameIdentifier	 chroma Sub V
;	TokenNameSEMICOLON	
// Fax compression related variables 	TokenNameCOMMENT_LINE	Fax compression related variables 
long	TokenNamelong	
tiffT4Options	TokenNameIdentifier	 tiff T4 Options
;	TokenNameSEMICOLON	
long	TokenNamelong	
tiffT6Options	TokenNameIdentifier	 tiff T6 Options
;	TokenNameSEMICOLON	
int	TokenNameint	
fillOrder	TokenNameIdentifier	 fill Order
;	TokenNameSEMICOLON	
// LZW compression related variable 	TokenNameCOMMENT_LINE	LZW compression related variable 
int	TokenNameint	
predictor	TokenNameIdentifier	 predictor
;	TokenNameSEMICOLON	
// TTN2 JPEG related variables 	TokenNameCOMMENT_LINE	TTN2 JPEG related variables 
JPEGDecodeParam	TokenNameIdentifier	 JPEG Decode Param
decodeParam	TokenNameIdentifier	 decode Param
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
colorConvertJPEG	TokenNameIdentifier	 color Convert JPEG
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// DEFLATE variables 	TokenNameCOMMENT_LINE	DEFLATE variables 
Inflater	TokenNameIdentifier	 Inflater
inflater	TokenNameIdentifier	 inflater
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// Endian-ness indicator 	TokenNameCOMMENT_LINE	Endian-ness indicator 
boolean	TokenNameboolean	
isBigEndian	TokenNameIdentifier	 is Big Endian
;	TokenNameSEMICOLON	
int	TokenNameint	
imageType	TokenNameIdentifier	 image Type
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
isWhiteZero	TokenNameIdentifier	 is White Zero
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
int	TokenNameint	
dataType	TokenNameIdentifier	 data Type
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
decodePaletteAsShorts	TokenNameIdentifier	 decode Palette As Shorts
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
tiled	TokenNameIdentifier	 tiled
;	TokenNameSEMICOLON	
// Decoders 	TokenNameCOMMENT_LINE	Decoders 
private	TokenNameprivate	
TIFFFaxDecoder	TokenNameIdentifier	 TIFF Fax Decoder
decoder	TokenNameIdentifier	 decoder
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
TIFFLZWDecoder	TokenNameIdentifier	 TIFFLZW Decoder
lzwDecoder	TokenNameIdentifier	 lzw Decoder
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** * Decode a buffer of data into a Raster with the specified location. * * @param data buffer contain an interchange or abbreviated datastream. * @param decodeParam decoding parameters; may be null unless the * data buffer contains an abbreviated datastream in which case * it may not be null or an error will occur. * @param colorConvert whether to perform color conversion; in this * case that would be limited to YCbCr-to-RGB. * @param minX the X position of the returned Raster. * @param minY the Y position of the returned Raster. */	TokenNameCOMMENT_JAVADOC	 Decode a buffer of data into a Raster with the specified location. * @param data buffer contain an interchange or abbreviated datastream. @param decodeParam decoding parameters; may be null unless the data buffer contains an abbreviated datastream in which case it may not be null or an error will occur. @param colorConvert whether to perform color conversion; in this case that would be limited to YCbCr-to-RGB. @param minX the X position of the returned Raster. @param minY the Y position of the returned Raster. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Raster	TokenNameIdentifier	 Raster
decodeJPEG	TokenNameIdentifier	 decode JPEG
(	TokenNameLPAREN	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
JPEGDecodeParam	TokenNameIdentifier	 JPEG Decode Param
decodeParam	TokenNameIdentifier	 decode Param
,	TokenNameCOMMA	
boolean	TokenNameboolean	
colorConvert	TokenNameIdentifier	 color Convert
,	TokenNameCOMMA	
int	TokenNameint	
minX	TokenNameIdentifier	 min X
,	TokenNameCOMMA	
int	TokenNameint	
minY	TokenNameIdentifier	 min Y
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Create an InputStream from the compressed data array. 	TokenNameCOMMENT_LINE	Create an InputStream from the compressed data array. 
ByteArrayInputStream	TokenNameIdentifier	 Byte Array Input Stream
jpegStream	TokenNameIdentifier	 jpeg Stream
=	TokenNameEQUAL	
new	TokenNamenew	
ByteArrayInputStream	TokenNameIdentifier	 Byte Array Input Stream
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Create a decoder. 	TokenNameCOMMENT_LINE	Create a decoder. 
JPEGImageDecoder	TokenNameIdentifier	 JPEG Image Decoder
decoder	TokenNameIdentifier	 decoder
=	TokenNameEQUAL	
decodeParam	TokenNameIdentifier	 decode Param
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
JPEGCodec	TokenNameIdentifier	 JPEG Codec
.	TokenNameDOT	
createJPEGDecoder	TokenNameIdentifier	 create JPEG Decoder
(	TokenNameLPAREN	
jpegStream	TokenNameIdentifier	 jpeg Stream
)	TokenNameRPAREN	
:	TokenNameCOLON	
JPEGCodec	TokenNameIdentifier	 JPEG Codec
.	TokenNameDOT	
createJPEGDecoder	TokenNameIdentifier	 create JPEG Decoder
(	TokenNameLPAREN	
jpegStream	TokenNameIdentifier	 jpeg Stream
,	TokenNameCOMMA	
decodeParam	TokenNameIdentifier	 decode Param
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Decode the compressed data into a Raster. 	TokenNameCOMMENT_LINE	Decode the compressed data into a Raster. 
Raster	TokenNameIdentifier	 Raster
jpegRaster	TokenNameIdentifier	 jpeg Raster
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
jpegRaster	TokenNameIdentifier	 jpeg Raster
=	TokenNameEQUAL	
colorConvert	TokenNameIdentifier	 color Convert
?	TokenNameQUESTION	
decoder	TokenNameIdentifier	 decoder
.	TokenNameDOT	
decodeAsBufferedImage	TokenNameIdentifier	 decode As Buffered Image
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getWritableTile	TokenNameIdentifier	 get Writable Tile
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
:	TokenNameCOLON	
decoder	TokenNameIdentifier	 decoder
.	TokenNameDOT	
decodeAsRaster	TokenNameIdentifier	 decode As Raster
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ioe	TokenNameIdentifier	 ioe
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"TIFFImage13"	TokenNameStringLiteral	TIFFImage13
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Translate the decoded Raster to the specified location and return. 	TokenNameCOMMENT_LINE	Translate the decoded Raster to the specified location and return. 
return	TokenNamereturn	
jpegRaster	TokenNameIdentifier	 jpeg Raster
.	TokenNameDOT	
createTranslatedChild	TokenNameIdentifier	 create Translated Child
(	TokenNameLPAREN	
minX	TokenNameIdentifier	 min X
,	TokenNameCOMMA	
minY	TokenNameIdentifier	 min Y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Inflates <code>deflated</code> into <code>inflated</code> using the * <code>Inflater</code> constructed during class instantiation. */	TokenNameCOMMENT_JAVADOC	 Inflates <code>deflated</code> into <code>inflated</code> using the <code>Inflater</code> constructed during class instantiation. 
private	TokenNameprivate	
final	TokenNamefinal	
void	TokenNamevoid	
inflate	TokenNameIdentifier	 inflate
(	TokenNameLPAREN	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
deflated	TokenNameIdentifier	 deflated
,	TokenNameCOMMA	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
inflated	TokenNameIdentifier	 inflated
)	TokenNameRPAREN	
{	TokenNameLBRACE	
inflater	TokenNameIdentifier	 inflater
.	TokenNameDOT	
setInput	TokenNameIdentifier	 set Input
(	TokenNameLPAREN	
deflated	TokenNameIdentifier	 deflated
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
inflater	TokenNameIdentifier	 inflater
.	TokenNameDOT	
inflate	TokenNameIdentifier	 inflate
(	TokenNameLPAREN	
inflated	TokenNameIdentifier	 inflated
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
DataFormatException	TokenNameIdentifier	 Data Format Exception
dfe	TokenNameIdentifier	 dfe
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"TIFFImage17"	TokenNameStringLiteral	TIFFImage17
+	TokenNamePLUS	
": "	TokenNameStringLiteral	: 
+	TokenNamePLUS	
dfe	TokenNameIdentifier	 dfe
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
inflater	TokenNameIdentifier	 inflater
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
SampleModel	TokenNameIdentifier	 Sample Model
createPixelInterleavedSampleModel	TokenNameIdentifier	 create Pixel Interleaved Sample Model
(	TokenNameLPAREN	
int	TokenNameint	
dataType	TokenNameIdentifier	 data Type
,	TokenNameCOMMA	
int	TokenNameint	
tileWidth	TokenNameIdentifier	 tile Width
,	TokenNameCOMMA	
int	TokenNameint	
tileHeight	TokenNameIdentifier	 tile Height
,	TokenNameCOMMA	
int	TokenNameint	
bands	TokenNameIdentifier	 bands
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bandOffsets	TokenNameIdentifier	 band Offsets
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
bands	TokenNameIdentifier	 bands
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
bands	TokenNameIdentifier	 bands
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
bandOffsets	TokenNameIdentifier	 band Offsets
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
PixelInterleavedSampleModel	TokenNameIdentifier	 Pixel Interleaved Sample Model
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
,	TokenNameCOMMA	
tileWidth	TokenNameIdentifier	 tile Width
,	TokenNameCOMMA	
tileHeight	TokenNameIdentifier	 tile Height
,	TokenNameCOMMA	
bands	TokenNameIdentifier	 bands
,	TokenNameCOMMA	
tileWidth	TokenNameIdentifier	 tile Width
*	TokenNameMULTIPLY	
bands	TokenNameIdentifier	 bands
,	TokenNameCOMMA	
bandOffsets	TokenNameIdentifier	 band Offsets
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return as a long[] the value of a TIFF_LONG or TIFF_SHORT field. */	TokenNameCOMMENT_JAVADOC	 Return as a long[] the value of a TIFF_LONG or TIFF_SHORT field. 
private	TokenNameprivate	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getFieldAsLongs	TokenNameIdentifier	 get Field As Longs
(	TokenNameLPAREN	
TIFFField	TokenNameIdentifier	 TIFF Field
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_SHORT	TokenNameIdentifier	 TIFF  SHORT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
charValue	TokenNameIdentifier	 char Value
=	TokenNameEQUAL	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
getAsChars	TokenNameIdentifier	 get As Chars
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
new	TokenNamenew	
long	TokenNamelong	
[	TokenNameLBRACKET	
charValue	TokenNameIdentifier	 char Value
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
charValue	TokenNameIdentifier	 char Value
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
value	TokenNameIdentifier	 value
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
charValue	TokenNameIdentifier	 char Value
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
&	TokenNameAND	
0xffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_LONG	TokenNameIdentifier	 TIFF  LONG
)	TokenNameRPAREN	
{	TokenNameLBRACE	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
getAsLongs	TokenNameIdentifier	 get As Longs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Constructs a TIFFImage that acquires its data from a given * SeekableStream and reads from a particular IFD of the stream. * The index of the first IFD is 0. * * @param stream the SeekableStream to read from. * @param param an instance of TIFFDecodeParam, or null. * @param directory the index of the IFD to read from. */	TokenNameCOMMENT_JAVADOC	 Constructs a TIFFImage that acquires its data from a given SeekableStream and reads from a particular IFD of the stream. The index of the first IFD is 0. * @param stream the SeekableStream to read from. @param param an instance of TIFFDecodeParam, or null. @param directory the index of the IFD to read from. 
public	TokenNamepublic	
TIFFImage	TokenNameIdentifier	 TIFF Image
(	TokenNameLPAREN	
SeekableStream	TokenNameIdentifier	 Seekable Stream
stream	TokenNameIdentifier	 stream
,	TokenNameCOMMA	
TIFFDecodeParam	TokenNameIdentifier	 TIFF Decode Param
param	TokenNameIdentifier	 param
,	TokenNameCOMMA	
int	TokenNameint	
directory	TokenNameIdentifier	 directory
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
stream	TokenNameIdentifier	 stream
=	TokenNameEQUAL	
stream	TokenNameIdentifier	 stream
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
param	TokenNameIdentifier	 param
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
param	TokenNameIdentifier	 param
=	TokenNameEQUAL	
new	TokenNamenew	
TIFFDecodeParam	TokenNameIdentifier	 TIFF Decode Param
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
decodePaletteAsShorts	TokenNameIdentifier	 decode Palette As Shorts
=	TokenNameEQUAL	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
getDecodePaletteAsShorts	TokenNameIdentifier	 get Decode Palette As Shorts
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Read the specified directory. 	TokenNameCOMMENT_LINE	Read the specified directory. 
TIFFDirectory	TokenNameIdentifier	 TIFF Directory
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
getIFDOffset	TokenNameIdentifier	 get IFD Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
new	TokenNamenew	
TIFFDirectory	TokenNameIdentifier	 TIFF Directory
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
,	TokenNameCOMMA	
directory	TokenNameIdentifier	 directory
)	TokenNameRPAREN	
:	TokenNameCOLON	
new	TokenNamenew	
TIFFDirectory	TokenNameIdentifier	 TIFF Directory
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
,	TokenNameCOMMA	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
getIFDOffset	TokenNameIdentifier	 get IFD Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
longValue	TokenNameIdentifier	 long Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
directory	TokenNameIdentifier	 directory
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Get the number of samples per pixel 	TokenNameCOMMENT_LINE	Get the number of samples per pixel 
TIFFField	TokenNameIdentifier	 TIFF Field
sfield	TokenNameIdentifier	 sfield
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getField	TokenNameIdentifier	 get Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_SAMPLES_PER_PIXEL	TokenNameIdentifier	 TIFF  SAMPLES  PER  PIXEL
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
samplesPerPixel	TokenNameIdentifier	 samples Per Pixel
=	TokenNameEQUAL	
sfield	TokenNameIdentifier	 sfield
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
sfield	TokenNameIdentifier	 sfield
.	TokenNameDOT	
getAsLong	TokenNameIdentifier	 get As Long
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Read the TIFF_PLANAR_CONFIGURATION field 	TokenNameCOMMENT_LINE	Read the TIFF_PLANAR_CONFIGURATION field 
TIFFField	TokenNameIdentifier	 TIFF Field
planarConfigurationField	TokenNameIdentifier	 planar Configuration Field
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getField	TokenNameIdentifier	 get Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_PLANAR_CONFIGURATION	TokenNameIdentifier	 TIFF  PLANAR  CONFIGURATION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
planarConfiguration	TokenNameIdentifier	 planar Configuration
=	TokenNameEQUAL	
planarConfigurationField	TokenNameIdentifier	 planar Configuration Field
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
1	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
:	TokenNameCOLON	
planarConfigurationField	TokenNameIdentifier	 planar Configuration Field
.	TokenNameDOT	
getAsChars	TokenNameIdentifier	 get As Chars
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Support planar format (band sequential) only for 1 sample/pixel. 	TokenNameCOMMENT_LINE	Support planar format (band sequential) only for 1 sample/pixel. 
if	TokenNameif	
(	TokenNameLPAREN	
planarConfiguration	TokenNameIdentifier	 planar Configuration
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
samplesPerPixel	TokenNameIdentifier	 samples Per Pixel
!=	TokenNameNOT_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"TIFFImage0"	TokenNameStringLiteral	TIFFImage0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Read the TIFF_BITS_PER_SAMPLE field 	TokenNameCOMMENT_LINE	Read the TIFF_BITS_PER_SAMPLE field 
TIFFField	TokenNameIdentifier	 TIFF Field
bitsField	TokenNameIdentifier	 bits Field
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getField	TokenNameIdentifier	 get Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_BITS_PER_SAMPLE	TokenNameIdentifier	 TIFF  BITS  PER  SAMPLE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bitsPerSample	TokenNameIdentifier	 bits Per Sample
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
bitsField	TokenNameIdentifier	 bits Field
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bitsPerSample	TokenNameIdentifier	 bits Per Sample
=	TokenNameEQUAL	
bitsField	TokenNameIdentifier	 bits Field
.	TokenNameDOT	
getAsChars	TokenNameIdentifier	 get As Chars
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
bitsPerSample	TokenNameIdentifier	 bits Per Sample
=	TokenNameEQUAL	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
1	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
// Ensure that all samples have the same bit depth. 	TokenNameCOMMENT_LINE	Ensure that all samples have the same bit depth. 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
bitsPerSample	TokenNameIdentifier	 bits Per Sample
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
bitsPerSample	TokenNameIdentifier	 bits Per Sample
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
bitsPerSample	TokenNameIdentifier	 bits Per Sample
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"TIFFImage1"	TokenNameStringLiteral	TIFFImage1
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
sampleSize	TokenNameIdentifier	 sample Size
=	TokenNameEQUAL	
bitsPerSample	TokenNameIdentifier	 bits Per Sample
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// Read the TIFF_SAMPLE_FORMAT tag to see whether the data might be 	TokenNameCOMMENT_LINE	Read the TIFF_SAMPLE_FORMAT tag to see whether the data might be 
// signed or floating point 	TokenNameCOMMENT_LINE	signed or floating point 
TIFFField	TokenNameIdentifier	 TIFF Field
sampleFormatField	TokenNameIdentifier	 sample Format Field
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getField	TokenNameIdentifier	 get Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_SAMPLE_FORMAT	TokenNameIdentifier	 TIFF  SAMPLE  FORMAT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
sampleFormat	TokenNameIdentifier	 sample Format
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sampleFormatField	TokenNameIdentifier	 sample Format Field
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sampleFormat	TokenNameIdentifier	 sample Format
=	TokenNameEQUAL	
sampleFormatField	TokenNameIdentifier	 sample Format Field
.	TokenNameDOT	
getAsChars	TokenNameIdentifier	 get As Chars
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Check that all the samples have the same format 	TokenNameCOMMENT_LINE	Check that all the samples have the same format 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
l	TokenNameIdentifier	 l
<	TokenNameLESS	
sampleFormat	TokenNameIdentifier	 sample Format
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
l	TokenNameIdentifier	 l
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
sampleFormat	TokenNameIdentifier	 sample Format
[	TokenNameLBRACKET	
l	TokenNameIdentifier	 l
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
sampleFormat	TokenNameIdentifier	 sample Format
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"TIFFImage2"	TokenNameStringLiteral	TIFFImage2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
sampleFormat	TokenNameIdentifier	 sample Format
=	TokenNameEQUAL	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
1	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Set the data type based on the sample size and format. 	TokenNameCOMMENT_LINE	Set the data type based on the sample size and format. 
boolean	TokenNameboolean	
isValidDataFormat	TokenNameIdentifier	 is Valid Data Format
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
case	TokenNamecase	
4	TokenNameIntegerLiteral	
:	TokenNameCOLON	
case	TokenNamecase	
8	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sampleFormat	TokenNameIdentifier	 sample Format
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Ignore whether signed or unsigned: treat all as unsigned. 	TokenNameCOMMENT_LINE	Ignore whether signed or unsigned: treat all as unsigned. 
dataType	TokenNameIdentifier	 data Type
=	TokenNameEQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_BYTE	TokenNameIdentifier	 TYPE  BYTE
;	TokenNameSEMICOLON	
isValidDataFormat	TokenNameIdentifier	 is Valid Data Format
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
16	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sampleFormat	TokenNameIdentifier	 sample Format
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dataType	TokenNameIdentifier	 data Type
=	TokenNameEQUAL	
sampleFormat	TokenNameIdentifier	 sample Format
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
2	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_SHORT	TokenNameIdentifier	 TYPE  SHORT
:	TokenNameCOLON	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_USHORT	TokenNameIdentifier	 TYPE  USHORT
;	TokenNameSEMICOLON	
isValidDataFormat	TokenNameIdentifier	 is Valid Data Format
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
32	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sampleFormat	TokenNameIdentifier	 sample Format
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
isValidDataFormat	TokenNameIdentifier	 is Valid Data Format
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
else	TokenNameelse	
{	TokenNameLBRACE	
dataType	TokenNameIdentifier	 data Type
=	TokenNameEQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_INT	TokenNameIdentifier	 TYPE  INT
;	TokenNameSEMICOLON	
isValidDataFormat	TokenNameIdentifier	 is Valid Data Format
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isValidDataFormat	TokenNameIdentifier	 is Valid Data Format
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"TIFFImage3"	TokenNameStringLiteral	TIFFImage3
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Figure out what compression if any, is being used. 	TokenNameCOMMENT_LINE	Figure out what compression if any, is being used. 
TIFFField	TokenNameIdentifier	 TIFF Field
compField	TokenNameIdentifier	 comp Field
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getField	TokenNameIdentifier	 get Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_COMPRESSION	TokenNameIdentifier	 TIFF  COMPRESSION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
compression	TokenNameIdentifier	 compression
=	TokenNameEQUAL	
compField	TokenNameIdentifier	 comp Field
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
COMP_NONE	TokenNameIdentifier	 COMP  NONE
:	TokenNameCOLON	
compField	TokenNameIdentifier	 comp Field
.	TokenNameDOT	
getAsInt	TokenNameIdentifier	 get As Int
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Get the photometric interpretation. 	TokenNameCOMMENT_LINE	Get the photometric interpretation. 
int	TokenNameint	
photometricType	TokenNameIdentifier	 photometric Type
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getFieldAsLong	TokenNameIdentifier	 get Field As Long
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_PHOTOMETRIC_INTERPRETATION	TokenNameIdentifier	 TIFF  PHOTOMETRIC  INTERPRETATION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Determine which kind of image we are dealing with. 	TokenNameCOMMENT_LINE	Determine which kind of image we are dealing with. 
imageType	TokenNameIdentifier	 image Type
=	TokenNameEQUAL	
TYPE_UNSUPPORTED	TokenNameIdentifier	 TYPE  UNSUPPORTED
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
photometricType	TokenNameIdentifier	 photometric Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
// WhiteIsZero 	TokenNameCOMMENT_LINE	WhiteIsZero 
isWhiteZero	TokenNameIdentifier	 is White Zero
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
// BlackIsZero 	TokenNameCOMMENT_LINE	BlackIsZero 
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
samplesPerPixel	TokenNameIdentifier	 samples Per Pixel
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
imageType	TokenNameIdentifier	 image Type
=	TokenNameEQUAL	
TYPE_BILEVEL	TokenNameIdentifier	 TYPE  BILEVEL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
==	TokenNameEQUAL_EQUAL	
4	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
samplesPerPixel	TokenNameIdentifier	 samples Per Pixel
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
imageType	TokenNameIdentifier	 image Type
=	TokenNameEQUAL	
TYPE_GRAY_4BIT	TokenNameIdentifier	 TYPE  GRAY 4 BIT
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
%	TokenNameREMAINDER	
8	TokenNameIntegerLiteral	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
samplesPerPixel	TokenNameIdentifier	 samples Per Pixel
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
imageType	TokenNameIdentifier	 image Type
=	TokenNameEQUAL	
TYPE_GRAY	TokenNameIdentifier	 TYPE  GRAY
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
samplesPerPixel	TokenNameIdentifier	 samples Per Pixel
==	TokenNameEQUAL_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
imageType	TokenNameIdentifier	 image Type
=	TokenNameEQUAL	
TYPE_GRAY_ALPHA	TokenNameIdentifier	 TYPE  GRAY  ALPHA
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
imageType	TokenNameIdentifier	 image Type
=	TokenNameEQUAL	
TYPE_GENERIC	TokenNameIdentifier	 TYPE  GENERIC
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
2	TokenNameIntegerLiteral	
:	TokenNameCOLON	
// RGB 	TokenNameCOMMENT_LINE	RGB 
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
%	TokenNameREMAINDER	
8	TokenNameIntegerLiteral	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
samplesPerPixel	TokenNameIdentifier	 samples Per Pixel
==	TokenNameEQUAL_EQUAL	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
imageType	TokenNameIdentifier	 image Type
=	TokenNameEQUAL	
TYPE_RGB	TokenNameIdentifier	 TYPE  RGB
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
samplesPerPixel	TokenNameIdentifier	 samples Per Pixel
==	TokenNameEQUAL_EQUAL	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
imageType	TokenNameIdentifier	 image Type
=	TokenNameEQUAL	
TYPE_RGB_ALPHA	TokenNameIdentifier	 TYPE  RGB  ALPHA
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
imageType	TokenNameIdentifier	 image Type
=	TokenNameEQUAL	
TYPE_GENERIC	TokenNameIdentifier	 TYPE  GENERIC
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
3	TokenNameIntegerLiteral	
:	TokenNameCOLON	
// RGB Palette 	TokenNameCOMMENT_LINE	RGB Palette 
if	TokenNameif	
(	TokenNameLPAREN	
samplesPerPixel	TokenNameIdentifier	 samples Per Pixel
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
==	TokenNameEQUAL_EQUAL	
4	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
sampleSize	TokenNameIdentifier	 sample Size
==	TokenNameEQUAL_EQUAL	
8	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
sampleSize	TokenNameIdentifier	 sample Size
==	TokenNameEQUAL_EQUAL	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
imageType	TokenNameIdentifier	 image Type
=	TokenNameEQUAL	
TYPE_PALETTE	TokenNameIdentifier	 TYPE  PALETTE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
4	TokenNameIntegerLiteral	
:	TokenNameCOLON	
// Transparency mask 	TokenNameCOMMENT_LINE	Transparency mask 
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
samplesPerPixel	TokenNameIdentifier	 samples Per Pixel
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
imageType	TokenNameIdentifier	 image Type
=	TokenNameEQUAL	
TYPE_BILEVEL	TokenNameIdentifier	 TYPE  BILEVEL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
6	TokenNameIntegerLiteral	
:	TokenNameCOLON	
// YCbCr 	TokenNameCOMMENT_LINE	YCbCr 
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_JPEG_TTN2	TokenNameIdentifier	 COMP  JPEG  TT N2
&&	TokenNameAND_AND	
sampleSize	TokenNameIdentifier	 sample Size
==	TokenNameEQUAL_EQUAL	
8	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
samplesPerPixel	TokenNameIdentifier	 samples Per Pixel
==	TokenNameEQUAL_EQUAL	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Set color conversion flag. 	TokenNameCOMMENT_LINE	Set color conversion flag. 
colorConvertJPEG	TokenNameIdentifier	 color Convert JPEG
=	TokenNameEQUAL	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
getJPEGDecompressYCbCrToRGB	TokenNameIdentifier	 get JPEG Decompress Y Cb Cr To RGB
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Set type to RGB if color converting. 	TokenNameCOMMENT_LINE	Set type to RGB if color converting. 
imageType	TokenNameIdentifier	 image Type
=	TokenNameEQUAL	
colorConvertJPEG	TokenNameIdentifier	 color Convert JPEG
?	TokenNameQUESTION	
TYPE_RGB	TokenNameIdentifier	 TYPE  RGB
:	TokenNameCOLON	
TYPE_GENERIC	TokenNameIdentifier	 TYPE  GENERIC
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
TIFFField	TokenNameIdentifier	 TIFF Field
chromaField	TokenNameIdentifier	 chroma Field
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getField	TokenNameIdentifier	 get Field
(	TokenNameLPAREN	
TIFF_YCBCR_SUBSAMPLING	TokenNameIdentifier	 TIFF  YCBCR  SUBSAMPLING
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
chromaField	TokenNameIdentifier	 chroma Field
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
chromaSubH	TokenNameIdentifier	 chroma Sub H
=	TokenNameEQUAL	
chromaField	TokenNameIdentifier	 chroma Field
.	TokenNameDOT	
getAsInt	TokenNameIdentifier	 get As Int
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
chromaSubV	TokenNameIdentifier	 chroma Sub V
=	TokenNameEQUAL	
chromaField	TokenNameIdentifier	 chroma Field
.	TokenNameDOT	
getAsInt	TokenNameIdentifier	 get As Int
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
chromaSubH	TokenNameIdentifier	 chroma Sub H
=	TokenNameEQUAL	
chromaSubV	TokenNameIdentifier	 chroma Sub V
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
chromaSubH	TokenNameIdentifier	 chroma Sub H
*	TokenNameMULTIPLY	
chromaSubV	TokenNameIdentifier	 chroma Sub V
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
imageType	TokenNameIdentifier	 image Type
=	TokenNameEQUAL	
TYPE_GENERIC	TokenNameIdentifier	 TYPE  GENERIC
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
==	TokenNameEQUAL_EQUAL	
8	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
samplesPerPixel	TokenNameIdentifier	 samples Per Pixel
==	TokenNameEQUAL_EQUAL	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
imageType	TokenNameIdentifier	 image Type
=	TokenNameEQUAL	
TYPE_YCBCR_SUB	TokenNameIdentifier	 TYPE  YCBCR  SUB
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
// Other including CMYK, CIE L*a*b*, unknown. 	TokenNameCOMMENT_LINE	Other including CMYK, CIE L*a*b*, unknown. 
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
%	TokenNameREMAINDER	
8	TokenNameIntegerLiteral	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
imageType	TokenNameIdentifier	 image Type
=	TokenNameEQUAL	
TYPE_GENERIC	TokenNameIdentifier	 TYPE  GENERIC
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Bail out if not one of the supported types. 	TokenNameCOMMENT_LINE	Bail out if not one of the supported types. 
if	TokenNameif	
(	TokenNameLPAREN	
imageType	TokenNameIdentifier	 image Type
==	TokenNameEQUAL_EQUAL	
TYPE_UNSUPPORTED	TokenNameIdentifier	 TYPE  UNSUPPORTED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"TIFFImage4"	TokenNameStringLiteral	TIFFImage4
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Set basic image layout 	TokenNameCOMMENT_LINE	Set basic image layout 
Rectangle	TokenNameIdentifier	 Rectangle
bounds	TokenNameIdentifier	 bounds
=	TokenNameEQUAL	
new	TokenNamenew	
Rectangle	TokenNameIdentifier	 Rectangle
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getFieldAsLong	TokenNameIdentifier	 get Field As Long
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_IMAGE_WIDTH	TokenNameIdentifier	 TIFF  IMAGE  WIDTH
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getFieldAsLong	TokenNameIdentifier	 get Field As Long
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_IMAGE_LENGTH	TokenNameIdentifier	 TIFF  IMAGE  LENGTH
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Set a preliminary band count. This may be changed later as needed. 	TokenNameCOMMENT_LINE	Set a preliminary band count. This may be changed later as needed. 
numBands	TokenNameIdentifier	 num Bands
=	TokenNameEQUAL	
samplesPerPixel	TokenNameIdentifier	 samples Per Pixel
;	TokenNameSEMICOLON	
// Figure out if any extra samples are present. 	TokenNameCOMMENT_LINE	Figure out if any extra samples are present. 
TIFFField	TokenNameIdentifier	 TIFF Field
efield	TokenNameIdentifier	 efield
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getField	TokenNameIdentifier	 get Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_EXTRA_SAMPLES	TokenNameIdentifier	 TIFF  EXTRA  SAMPLES
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
extraSamples	TokenNameIdentifier	 extra Samples
=	TokenNameEQUAL	
efield	TokenNameIdentifier	 efield
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
efield	TokenNameIdentifier	 efield
.	TokenNameDOT	
getAsLong	TokenNameIdentifier	 get As Long
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
tileWidth	TokenNameIdentifier	 tile Width
,	TokenNameCOMMA	
tileHeight	TokenNameIdentifier	 tile Height
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getField	TokenNameIdentifier	 get Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_TILE_OFFSETS	TokenNameIdentifier	 TIFF  TILE  OFFSETS
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tiled	TokenNameIdentifier	 tiled
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// Image is in tiled format 	TokenNameCOMMENT_LINE	Image is in tiled format 
tileWidth	TokenNameIdentifier	 tile Width
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getFieldAsLong	TokenNameIdentifier	 get Field As Long
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_TILE_WIDTH	TokenNameIdentifier	 TIFF  TILE  WIDTH
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tileHeight	TokenNameIdentifier	 tile Height
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getFieldAsLong	TokenNameIdentifier	 get Field As Long
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_TILE_LENGTH	TokenNameIdentifier	 TIFF  TILE  LENGTH
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tileOffsets	TokenNameIdentifier	 tile Offsets
=	TokenNameEQUAL	
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getField	TokenNameIdentifier	 get Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_TILE_OFFSETS	TokenNameIdentifier	 TIFF  TILE  OFFSETS
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getAsLongs	TokenNameIdentifier	 get As Longs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tileByteCounts	TokenNameIdentifier	 tile Byte Counts
=	TokenNameEQUAL	
getFieldAsLongs	TokenNameIdentifier	 get Field As Longs
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getField	TokenNameIdentifier	 get Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_TILE_BYTE_COUNTS	TokenNameIdentifier	 TIFF  TILE  BYTE  COUNTS
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
tiled	TokenNameIdentifier	 tiled
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// Image is in stripped format, looks like tiles to us 	TokenNameCOMMENT_LINE	Image is in stripped format, looks like tiles to us 
// Note: Some legacy files may have tile width and height 	TokenNameCOMMENT_LINE	Note: Some legacy files may have tile width and height 
// written but use the strip offsets and byte counts fields 	TokenNameCOMMENT_LINE	written but use the strip offsets and byte counts fields 
// instead of the tile offsets and byte counts. Therefore 	TokenNameCOMMENT_LINE	instead of the tile offsets and byte counts. Therefore 
// we default here to the tile dimensions if they are written. 	TokenNameCOMMENT_LINE	we default here to the tile dimensions if they are written. 
tileWidth	TokenNameIdentifier	 tile Width
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getField	TokenNameIdentifier	 get Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_TILE_WIDTH	TokenNameIdentifier	 TIFF  TILE  WIDTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getFieldAsLong	TokenNameIdentifier	 get Field As Long
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_TILE_WIDTH	TokenNameIdentifier	 TIFF  TILE  WIDTH
)	TokenNameRPAREN	
:	TokenNameCOLON	
bounds	TokenNameIdentifier	 bounds
.	TokenNameDOT	
width	TokenNameIdentifier	 width
;	TokenNameSEMICOLON	
TIFFField	TokenNameIdentifier	 TIFF Field
field	TokenNameIdentifier	 field
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getField	TokenNameIdentifier	 get Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_ROWS_PER_STRIP	TokenNameIdentifier	 TIFF  ROWS  PER  STRIP
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Default is infinity (2^32 -1), basically the entire image 	TokenNameCOMMENT_LINE	Default is infinity (2^32 -1), basically the entire image 
tileHeight	TokenNameIdentifier	 tile Height
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getField	TokenNameIdentifier	 get Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_TILE_LENGTH	TokenNameIdentifier	 TIFF  TILE  LENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getFieldAsLong	TokenNameIdentifier	 get Field As Long
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_TILE_LENGTH	TokenNameIdentifier	 TIFF  TILE  LENGTH
)	TokenNameRPAREN	
:	TokenNameCOLON	
bounds	TokenNameIdentifier	 bounds
.	TokenNameDOT	
height	TokenNameIdentifier	 height
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
long	TokenNamelong	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
getAsLong	TokenNameIdentifier	 get As Long
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
infinity	TokenNameIdentifier	 infinity
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
infinity	TokenNameIdentifier	 infinity
=	TokenNameEQUAL	
(	TokenNameLPAREN	
infinity	TokenNameIdentifier	 infinity
<<	TokenNameLEFT_SHIFT	
32	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
l	TokenNameIdentifier	 l
==	TokenNameEQUAL_EQUAL	
infinity	TokenNameIdentifier	 infinity
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 2^32 - 1 (effectively infinity, entire image is 1 strip) 	TokenNameCOMMENT_LINE	2^32 - 1 (effectively infinity, entire image is 1 strip) 
tileHeight	TokenNameIdentifier	 tile Height
=	TokenNameEQUAL	
bounds	TokenNameIdentifier	 bounds
.	TokenNameDOT	
height	TokenNameIdentifier	 height
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
tileHeight	TokenNameIdentifier	 tile Height
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
l	TokenNameIdentifier	 l
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
TIFFField	TokenNameIdentifier	 TIFF Field
tileOffsetsField	TokenNameIdentifier	 tile Offsets Field
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getField	TokenNameIdentifier	 get Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_STRIP_OFFSETS	TokenNameIdentifier	 TIFF  STRIP  OFFSETS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
tileOffsetsField	TokenNameIdentifier	 tile Offsets Field
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"TIFFImage5"	TokenNameStringLiteral	TIFFImage5
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
tileOffsets	TokenNameIdentifier	 tile Offsets
=	TokenNameEQUAL	
getFieldAsLongs	TokenNameIdentifier	 get Field As Longs
(	TokenNameLPAREN	
tileOffsetsField	TokenNameIdentifier	 tile Offsets Field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
TIFFField	TokenNameIdentifier	 TIFF Field
tileByteCountsField	TokenNameIdentifier	 tile Byte Counts Field
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getField	TokenNameIdentifier	 get Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_STRIP_BYTE_COUNTS	TokenNameIdentifier	 TIFF  STRIP  BYTE  COUNTS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
tileByteCountsField	TokenNameIdentifier	 tile Byte Counts Field
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"TIFFImage6"	TokenNameStringLiteral	TIFFImage6
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
tileByteCounts	TokenNameIdentifier	 tile Byte Counts
=	TokenNameEQUAL	
getFieldAsLongs	TokenNameIdentifier	 get Field As Longs
(	TokenNameLPAREN	
tileByteCountsField	TokenNameIdentifier	 tile Byte Counts Field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Calculate number of tiles and the tileSize in bytes 	TokenNameCOMMENT_LINE	Calculate number of tiles and the tileSize in bytes 
tilesX	TokenNameIdentifier	 tiles X
=	TokenNameEQUAL	
(	TokenNameLPAREN	
bounds	TokenNameIdentifier	 bounds
.	TokenNameDOT	
width	TokenNameIdentifier	 width
+	TokenNamePLUS	
tileWidth	TokenNameIdentifier	 tile Width
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
tileWidth	TokenNameIdentifier	 tile Width
;	TokenNameSEMICOLON	
tilesY	TokenNameIdentifier	 tiles Y
=	TokenNameEQUAL	
(	TokenNameLPAREN	
bounds	TokenNameIdentifier	 bounds
.	TokenNameDOT	
height	TokenNameIdentifier	 height
+	TokenNamePLUS	
tileHeight	TokenNameIdentifier	 tile Height
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
tileHeight	TokenNameIdentifier	 tile Height
;	TokenNameSEMICOLON	
tileSize	TokenNameIdentifier	 tile Size
=	TokenNameEQUAL	
tileWidth	TokenNameIdentifier	 tile Width
*	TokenNameMULTIPLY	
tileHeight	TokenNameIdentifier	 tile Height
*	TokenNameMULTIPLY	
numBands	TokenNameIdentifier	 num Bands
;	TokenNameSEMICOLON	
// Check whether big endian or little endian format is used. 	TokenNameCOMMENT_LINE	Check whether big endian or little endian format is used. 
isBigEndian	TokenNameIdentifier	 is Big Endian
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
isBigEndian	TokenNameIdentifier	 is Big Endian
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TIFFField	TokenNameIdentifier	 TIFF Field
fillOrderField	TokenNameIdentifier	 fill Order Field
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getField	TokenNameIdentifier	 get Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_FILL_ORDER	TokenNameIdentifier	 TIFF  FILL  ORDER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fillOrderField	TokenNameIdentifier	 fill Order Field
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fillOrder	TokenNameIdentifier	 fill Order
=	TokenNameEQUAL	
fillOrderField	TokenNameIdentifier	 fill Order Field
.	TokenNameDOT	
getAsInt	TokenNameIdentifier	 get As Int
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Default Fill Order 	TokenNameCOMMENT_LINE	Default Fill Order 
fillOrder	TokenNameIdentifier	 fill Order
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
COMP_NONE	TokenNameIdentifier	 COMP  NONE
:	TokenNameCOLON	
case	TokenNamecase	
COMP_PACKBITS	TokenNameIdentifier	 COMP  PACKBITS
:	TokenNameCOLON	
// Do nothing. 	TokenNameCOMMENT_LINE	Do nothing. 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
COMP_DEFLATE	TokenNameIdentifier	 COMP  DEFLATE
:	TokenNameCOLON	
inflater	TokenNameIdentifier	 inflater
=	TokenNameEQUAL	
new	TokenNamenew	
Inflater	TokenNameIdentifier	 Inflater
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
COMP_FAX_G3_1D	TokenNameIdentifier	 COMP  FAX  G3 1 D
:	TokenNameCOLON	
case	TokenNamecase	
COMP_FAX_G3_2D	TokenNameIdentifier	 COMP  FAX  G3 2 D
:	TokenNameCOLON	
case	TokenNamecase	
COMP_FAX_G4_2D	TokenNameIdentifier	 COMP  FAX  G4 2 D
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
!=	TokenNameNOT_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"TIFFImage7"	TokenNameStringLiteral	TIFFImage7
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Fax T.4 compression options 	TokenNameCOMMENT_LINE	Fax T.4 compression options 
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
TIFFField	TokenNameIdentifier	 TIFF Field
t4OptionsField	TokenNameIdentifier	 t4 Options Field
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getField	TokenNameIdentifier	 get Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_T4_OPTIONS	TokenNameIdentifier	 TIFF  T4  OPTIONS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
t4OptionsField	TokenNameIdentifier	 t4 Options Field
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tiffT4Options	TokenNameIdentifier	 tiff T4 Options
=	TokenNameEQUAL	
t4OptionsField	TokenNameIdentifier	 t4 Options Field
.	TokenNameDOT	
getAsLong	TokenNameIdentifier	 get As Long
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Use default value 	TokenNameCOMMENT_LINE	Use default value 
tiffT4Options	TokenNameIdentifier	 tiff T4 Options
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Fax T.6 compression options 	TokenNameCOMMENT_LINE	Fax T.6 compression options 
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
TIFFField	TokenNameIdentifier	 TIFF Field
t6OptionsField	TokenNameIdentifier	 t6 Options Field
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getField	TokenNameIdentifier	 get Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_T6_OPTIONS	TokenNameIdentifier	 TIFF  T6  OPTIONS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
t6OptionsField	TokenNameIdentifier	 t6 Options Field
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tiffT6Options	TokenNameIdentifier	 tiff T6 Options
=	TokenNameEQUAL	
t6OptionsField	TokenNameIdentifier	 t6 Options Field
.	TokenNameDOT	
getAsLong	TokenNameIdentifier	 get As Long
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Use default value 	TokenNameCOMMENT_LINE	Use default value 
tiffT6Options	TokenNameIdentifier	 tiff T6 Options
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Fax encoding, need to create the Fax decoder. 	TokenNameCOMMENT_LINE	Fax encoding, need to create the Fax decoder. 
decoder	TokenNameIdentifier	 decoder
=	TokenNameEQUAL	
new	TokenNamenew	
TIFFFaxDecoder	TokenNameIdentifier	 TIFF Fax Decoder
(	TokenNameLPAREN	
fillOrder	TokenNameIdentifier	 fill Order
,	TokenNameCOMMA	
tileWidth	TokenNameIdentifier	 tile Width
,	TokenNameCOMMA	
tileHeight	TokenNameIdentifier	 tile Height
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
COMP_LZW	TokenNameIdentifier	 COMP  LZW
:	TokenNameCOLON	
// LZW compression used, need to create the LZW decoder. 	TokenNameCOMMENT_LINE	LZW compression used, need to create the LZW decoder. 
TIFFField	TokenNameIdentifier	 TIFF Field
predictorField	TokenNameIdentifier	 predictor Field
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getField	TokenNameIdentifier	 get Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_PREDICTOR	TokenNameIdentifier	 TIFF  PREDICTOR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
predictorField	TokenNameIdentifier	 predictor Field
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
predictor	TokenNameIdentifier	 predictor
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
predictor	TokenNameIdentifier	 predictor
=	TokenNameEQUAL	
predictorField	TokenNameIdentifier	 predictor Field
.	TokenNameDOT	
getAsInt	TokenNameIdentifier	 get As Int
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
predictor	TokenNameIdentifier	 predictor
!=	TokenNameNOT_EQUAL	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
predictor	TokenNameIdentifier	 predictor
!=	TokenNameNOT_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"TIFFImage8"	TokenNameStringLiteral	TIFFImage8
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
predictor	TokenNameIdentifier	 predictor
==	TokenNameEQUAL_EQUAL	
2	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
sampleSize	TokenNameIdentifier	 sample Size
!=	TokenNameNOT_EQUAL	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
+	TokenNamePLUS	
"TIFFImage9"	TokenNameStringLiteral	TIFFImage9
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
lzwDecoder	TokenNameIdentifier	 lzw Decoder
=	TokenNameEQUAL	
new	TokenNamenew	
TIFFLZWDecoder	TokenNameIdentifier	 TIFFLZW Decoder
(	TokenNameLPAREN	
tileWidth	TokenNameIdentifier	 tile Width
,	TokenNameCOMMA	
predictor	TokenNameIdentifier	 predictor
,	TokenNameCOMMA	
samplesPerPixel	TokenNameIdentifier	 samples Per Pixel
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
COMP_JPEG_OLD	TokenNameIdentifier	 COMP  JPEG  OLD
:	TokenNameCOLON	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"TIFFImage15"	TokenNameStringLiteral	TIFFImage15
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
COMP_JPEG_TTN2	TokenNameIdentifier	 COMP  JPEG  TT N2
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
==	TokenNameEQUAL_EQUAL	
8	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
imageType	TokenNameIdentifier	 image Type
==	TokenNameEQUAL_EQUAL	
TYPE_GRAY	TokenNameIdentifier	 TYPE  GRAY
&&	TokenNameAND_AND	
samplesPerPixel	TokenNameIdentifier	 samples Per Pixel
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
imageType	TokenNameIdentifier	 image Type
==	TokenNameEQUAL_EQUAL	
TYPE_PALETTE	TokenNameIdentifier	 TYPE  PALETTE
&&	TokenNameAND_AND	
samplesPerPixel	TokenNameIdentifier	 samples Per Pixel
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
imageType	TokenNameIdentifier	 image Type
==	TokenNameEQUAL_EQUAL	
TYPE_RGB	TokenNameIdentifier	 TYPE  RGB
&&	TokenNameAND_AND	
samplesPerPixel	TokenNameIdentifier	 samples Per Pixel
==	TokenNameEQUAL_EQUAL	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"TIFFImage16"	TokenNameStringLiteral	TIFFImage16
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Create decodeParam from JPEGTables field if present. 	TokenNameCOMMENT_LINE	Create decodeParam from JPEGTables field if present. 
if	TokenNameif	
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
isTagPresent	TokenNameIdentifier	 is Tag Present
(	TokenNameLPAREN	
TIFF_JPEG_TABLES	TokenNameIdentifier	 TIFF  JPEG  TABLES
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
TIFFField	TokenNameIdentifier	 TIFF Field
jpegTableField	TokenNameIdentifier	 jpeg Table Field
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getField	TokenNameIdentifier	 get Field
(	TokenNameLPAREN	
TIFF_JPEG_TABLES	TokenNameIdentifier	 TIFF  JPEG  TABLES
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jpegTable	TokenNameIdentifier	 jpeg Table
=	TokenNameEQUAL	
jpegTableField	TokenNameIdentifier	 jpeg Table Field
.	TokenNameDOT	
getAsBytes	TokenNameIdentifier	 get As Bytes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ByteArrayInputStream	TokenNameIdentifier	 Byte Array Input Stream
tableStream	TokenNameIdentifier	 table Stream
=	TokenNameEQUAL	
new	TokenNamenew	
ByteArrayInputStream	TokenNameIdentifier	 Byte Array Input Stream
(	TokenNameLPAREN	
jpegTable	TokenNameIdentifier	 jpeg Table
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
JPEGImageDecoder	TokenNameIdentifier	 JPEG Image Decoder
decoder	TokenNameIdentifier	 decoder
=	TokenNameEQUAL	
JPEGCodec	TokenNameIdentifier	 JPEG Codec
.	TokenNameDOT	
createJPEGDecoder	TokenNameIdentifier	 create JPEG Decoder
(	TokenNameLPAREN	
tableStream	TokenNameIdentifier	 table Stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
decoder	TokenNameIdentifier	 decoder
.	TokenNameDOT	
decodeAsRaster	TokenNameIdentifier	 decode As Raster
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
decodeParam	TokenNameIdentifier	 decode Param
=	TokenNameEQUAL	
decoder	TokenNameIdentifier	 decoder
.	TokenNameDOT	
getJPEGDecodeParam	TokenNameIdentifier	 get JPEG Decode Param
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"TIFFImage10"	TokenNameStringLiteral	TIFFImage10
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ColorModel	TokenNameIdentifier	 Color Model
colorModel	TokenNameIdentifier	 color Model
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
SampleModel	TokenNameIdentifier	 Sample Model
sampleModel	TokenNameIdentifier	 sample Model
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
imageType	TokenNameIdentifier	 image Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
TYPE_BILEVEL	TokenNameIdentifier	 TYPE  BILEVEL
:	TokenNameCOLON	
case	TokenNamecase	
TYPE_GRAY_4BIT	TokenNameIdentifier	 TYPE  GRAY 4 BIT
:	TokenNameCOLON	
sampleModel	TokenNameIdentifier	 sample Model
=	TokenNameEQUAL	
new	TokenNamenew	
MultiPixelPackedSampleModel	TokenNameIdentifier	 Multi Pixel Packed Sample Model
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
,	TokenNameCOMMA	
tileWidth	TokenNameIdentifier	 tile Width
,	TokenNameCOMMA	
tileHeight	TokenNameIdentifier	 tile Height
,	TokenNameCOMMA	
sampleSize	TokenNameIdentifier	 sample Size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
imageType	TokenNameIdentifier	 image Type
==	TokenNameEQUAL_EQUAL	
TYPE_BILEVEL	TokenNameIdentifier	 TYPE  BILEVEL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
map	TokenNameIdentifier	 map
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
isWhiteZero	TokenNameIdentifier	 is White Zero
?	TokenNameQUESTION	
255	TokenNameIntegerLiteral	
:	TokenNameCOLON	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
isWhiteZero	TokenNameIdentifier	 is White Zero
?	TokenNameQUESTION	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
255	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
colorModel	TokenNameIdentifier	 color Model
=	TokenNameEQUAL	
new	TokenNamenew	
IndexColorModel	TokenNameIdentifier	 Index Color Model
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
map	TokenNameIdentifier	 map
,	TokenNameCOMMA	
map	TokenNameIdentifier	 map
,	TokenNameCOMMA	
map	TokenNameIdentifier	 map
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
map	TokenNameIdentifier	 map
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
16	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isWhiteZero	TokenNameIdentifier	 is White Zero
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
map	TokenNameIdentifier	 map
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
map	TokenNameIdentifier	 map
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
255	TokenNameIntegerLiteral	
-	TokenNameMINUS	
(	TokenNameLPAREN	
16	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
map	TokenNameIdentifier	 map
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
map	TokenNameIdentifier	 map
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
16	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
colorModel	TokenNameIdentifier	 color Model
=	TokenNameEQUAL	
new	TokenNamenew	
IndexColorModel	TokenNameIdentifier	 Index Color Model
(	TokenNameLPAREN	
4	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
16	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
map	TokenNameIdentifier	 map
,	TokenNameCOMMA	
map	TokenNameIdentifier	 map
,	TokenNameCOMMA	
map	TokenNameIdentifier	 map
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
TYPE_GRAY	TokenNameIdentifier	 TYPE  GRAY
:	TokenNameCOLON	
case	TokenNamecase	
TYPE_GRAY_ALPHA	TokenNameIdentifier	 TYPE  GRAY  ALPHA
:	TokenNameCOLON	
case	TokenNamecase	
TYPE_RGB	TokenNameIdentifier	 TYPE  RGB
:	TokenNameCOLON	
case	TokenNamecase	
TYPE_RGB_ALPHA	TokenNameIdentifier	 TYPE  RGB  ALPHA
:	TokenNameCOLON	
// Create a pixel interleaved SampleModel with decreasing 	TokenNameCOMMENT_LINE	Create a pixel interleaved SampleModel with decreasing 
// band offsets. 	TokenNameCOMMENT_LINE	band offsets. 
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
reverseOffsets	TokenNameIdentifier	 reverse Offsets
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
numBands	TokenNameIdentifier	 num Bands
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numBands	TokenNameIdentifier	 num Bands
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reverseOffsets	TokenNameIdentifier	 reverse Offsets
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
numBands	TokenNameIdentifier	 num Bands
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
-	TokenNameMINUS	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
sampleModel	TokenNameIdentifier	 sample Model
=	TokenNameEQUAL	
new	TokenNamenew	
PixelInterleavedSampleModel	TokenNameIdentifier	 Pixel Interleaved Sample Model
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
,	TokenNameCOMMA	
tileWidth	TokenNameIdentifier	 tile Width
,	TokenNameCOMMA	
tileHeight	TokenNameIdentifier	 tile Height
,	TokenNameCOMMA	
numBands	TokenNameIdentifier	 num Bands
,	TokenNameCOMMA	
numBands	TokenNameIdentifier	 num Bands
*	TokenNameMULTIPLY	
tileWidth	TokenNameIdentifier	 tile Width
,	TokenNameCOMMA	
reverseOffsets	TokenNameIdentifier	 reverse Offsets
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
imageType	TokenNameIdentifier	 image Type
==	TokenNameEQUAL_EQUAL	
TYPE_GRAY	TokenNameIdentifier	 TYPE  GRAY
)	TokenNameRPAREN	
{	TokenNameLBRACE	
colorModel	TokenNameIdentifier	 color Model
=	TokenNameEQUAL	
new	TokenNamenew	
ComponentColorModel	TokenNameIdentifier	 Component Color Model
(	TokenNameLPAREN	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
CS_GRAY	TokenNameIdentifier	 CS  GRAY
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
sampleSize	TokenNameIdentifier	 sample Size
}	TokenNameRBRACE	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
Transparency	TokenNameIdentifier	 Transparency
.	TokenNameDOT	
OPAQUE	TokenNameIdentifier	 OPAQUE
,	TokenNameCOMMA	
dataType	TokenNameIdentifier	 data Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
imageType	TokenNameIdentifier	 image Type
==	TokenNameEQUAL_EQUAL	
TYPE_RGB	TokenNameIdentifier	 TYPE  RGB
)	TokenNameRPAREN	
{	TokenNameLBRACE	
colorModel	TokenNameIdentifier	 color Model
=	TokenNameEQUAL	
new	TokenNamenew	
ComponentColorModel	TokenNameIdentifier	 Component Color Model
(	TokenNameLPAREN	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
CS_sRGB	TokenNameIdentifier	 CS s RGB
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
sampleSize	TokenNameIdentifier	 sample Size
,	TokenNameCOMMA	
sampleSize	TokenNameIdentifier	 sample Size
,	TokenNameCOMMA	
sampleSize	TokenNameIdentifier	 sample Size
}	TokenNameRBRACE	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
Transparency	TokenNameIdentifier	 Transparency
.	TokenNameDOT	
OPAQUE	TokenNameIdentifier	 OPAQUE
,	TokenNameCOMMA	
dataType	TokenNameIdentifier	 data Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// hasAlpha 	TokenNameCOMMENT_LINE	hasAlpha 
// Transparency.OPAQUE signifies image data that is 	TokenNameCOMMENT_LINE	Transparency.OPAQUE signifies image data that is 
// completely opaque, meaning that all pixels have an alpha 	TokenNameCOMMENT_LINE	completely opaque, meaning that all pixels have an alpha 
// value of 1.0. So the extra band gets ignored, which is 	TokenNameCOMMENT_LINE	value of 1.0. So the extra band gets ignored, which is 
// what we want. 	TokenNameCOMMENT_LINE	what we want. 
int	TokenNameint	
transparency	TokenNameIdentifier	 transparency
=	TokenNameEQUAL	
Transparency	TokenNameIdentifier	 Transparency
.	TokenNameDOT	
OPAQUE	TokenNameIdentifier	 OPAQUE
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
extraSamples	TokenNameIdentifier	 extra Samples
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// associated (premultiplied) alpha 	TokenNameCOMMENT_LINE	associated (premultiplied) alpha 
transparency	TokenNameIdentifier	 transparency
=	TokenNameEQUAL	
Transparency	TokenNameIdentifier	 Transparency
.	TokenNameDOT	
TRANSLUCENT	TokenNameIdentifier	 TRANSLUCENT
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
extraSamples	TokenNameIdentifier	 extra Samples
==	TokenNameEQUAL_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// unassociated alpha 	TokenNameCOMMENT_LINE	unassociated alpha 
transparency	TokenNameIdentifier	 transparency
=	TokenNameEQUAL	
Transparency	TokenNameIdentifier	 Transparency
.	TokenNameDOT	
BITMASK	TokenNameIdentifier	 BITMASK
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
colorModel	TokenNameIdentifier	 color Model
=	TokenNameEQUAL	
createAlphaComponentColorModel	TokenNameIdentifier	 create Alpha Component Color Model
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
,	TokenNameCOMMA	
numBands	TokenNameIdentifier	 num Bands
,	TokenNameCOMMA	
extraSamples	TokenNameIdentifier	 extra Samples
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
transparency	TokenNameIdentifier	 transparency
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
TYPE_GENERIC	TokenNameIdentifier	 TYPE  GENERIC
:	TokenNameCOLON	
case	TokenNamecase	
TYPE_YCBCR_SUB	TokenNameIdentifier	 TYPE  YCBCR  SUB
:	TokenNameCOLON	
// For this case we can't display the image, so we create a 	TokenNameCOMMENT_LINE	For this case we can't display the image, so we create a 
// SampleModel with increasing bandOffsets, and keep the 	TokenNameCOMMENT_LINE	SampleModel with increasing bandOffsets, and keep the 
// ColorModel as null, as there is no appropriate ColorModel. 	TokenNameCOMMENT_LINE	ColorModel as null, as there is no appropriate ColorModel. 
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bandOffsets	TokenNameIdentifier	 band Offsets
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
numBands	TokenNameIdentifier	 num Bands
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numBands	TokenNameIdentifier	 num Bands
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bandOffsets	TokenNameIdentifier	 band Offsets
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
sampleModel	TokenNameIdentifier	 sample Model
=	TokenNameEQUAL	
new	TokenNamenew	
PixelInterleavedSampleModel	TokenNameIdentifier	 Pixel Interleaved Sample Model
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
,	TokenNameCOMMA	
tileWidth	TokenNameIdentifier	 tile Width
,	TokenNameCOMMA	
tileHeight	TokenNameIdentifier	 tile Height
,	TokenNameCOMMA	
numBands	TokenNameIdentifier	 num Bands
,	TokenNameCOMMA	
numBands	TokenNameIdentifier	 num Bands
*	TokenNameMULTIPLY	
tileWidth	TokenNameIdentifier	 tile Width
,	TokenNameCOMMA	
bandOffsets	TokenNameIdentifier	 band Offsets
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
colorModel	TokenNameIdentifier	 color Model
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
TYPE_PALETTE	TokenNameIdentifier	 TYPE  PALETTE
:	TokenNameCOLON	
// Get the colormap 	TokenNameCOMMENT_LINE	Get the colormap 
TIFFField	TokenNameIdentifier	 TIFF Field
cfield	TokenNameIdentifier	 cfield
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getField	TokenNameIdentifier	 get Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_COLORMAP	TokenNameIdentifier	 TIFF  COLORMAP
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cfield	TokenNameIdentifier	 cfield
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"TIFFImage11"	TokenNameStringLiteral	TIFFImage11
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
colormap	TokenNameIdentifier	 colormap
=	TokenNameEQUAL	
cfield	TokenNameIdentifier	 cfield
.	TokenNameDOT	
getAsChars	TokenNameIdentifier	 get As Chars
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Could be either 1 or 3 bands depending on whether we use 	TokenNameCOMMENT_LINE	Could be either 1 or 3 bands depending on whether we use 
// IndexColorModel or not. 	TokenNameCOMMENT_LINE	IndexColorModel or not. 
if	TokenNameif	
(	TokenNameLPAREN	
decodePaletteAsShorts	TokenNameIdentifier	 decode Palette As Shorts
)	TokenNameRPAREN	
{	TokenNameLBRACE	
numBands	TokenNameIdentifier	 num Bands
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// If no SampleFormat tag was specified and if the 	TokenNameCOMMENT_LINE	If no SampleFormat tag was specified and if the 
// sampleSize is less than or equal to 8, then the 	TokenNameCOMMENT_LINE	sampleSize is less than or equal to 8, then the 
// dataType was initially set to byte, but now we want to 	TokenNameCOMMENT_LINE	dataType was initially set to byte, but now we want to 
// expand the palette as shorts, so the dataType should 	TokenNameCOMMENT_LINE	expand the palette as shorts, so the dataType should 
// be ushort. 	TokenNameCOMMENT_LINE	be ushort. 
if	TokenNameif	
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
==	TokenNameEQUAL_EQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_BYTE	TokenNameIdentifier	 TYPE  BYTE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dataType	TokenNameIdentifier	 data Type
=	TokenNameEQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_USHORT	TokenNameIdentifier	 TYPE  USHORT
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Data will have to be unpacked into a 3 band short image 	TokenNameCOMMENT_LINE	Data will have to be unpacked into a 3 band short image 
// as we do not have a IndexColorModel that can deal with 	TokenNameCOMMENT_LINE	as we do not have a IndexColorModel that can deal with 
// a colormodel whose entries are of short data type. 	TokenNameCOMMENT_LINE	a colormodel whose entries are of short data type. 
sampleModel	TokenNameIdentifier	 sample Model
=	TokenNameEQUAL	
createPixelInterleavedSampleModel	TokenNameIdentifier	 create Pixel Interleaved Sample Model
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
,	TokenNameCOMMA	
tileWidth	TokenNameIdentifier	 tile Width
,	TokenNameCOMMA	
tileHeight	TokenNameIdentifier	 tile Height
,	TokenNameCOMMA	
numBands	TokenNameIdentifier	 num Bands
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
colorModel	TokenNameIdentifier	 color Model
=	TokenNameEQUAL	
new	TokenNamenew	
ComponentColorModel	TokenNameIdentifier	 Component Color Model
(	TokenNameLPAREN	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
CS_sRGB	TokenNameIdentifier	 CS s RGB
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
16	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
16	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
16	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
Transparency	TokenNameIdentifier	 Transparency
.	TokenNameDOT	
OPAQUE	TokenNameIdentifier	 OPAQUE
,	TokenNameCOMMA	
dataType	TokenNameIdentifier	 data Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
numBands	TokenNameIdentifier	 num Bands
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
==	TokenNameEQUAL_EQUAL	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Pixel data will not be unpacked, will use 	TokenNameCOMMENT_LINE	Pixel data will not be unpacked, will use 
// MPPSM to store packed data and 	TokenNameCOMMENT_LINE	MPPSM to store packed data and 
// IndexColorModel to do the unpacking. 	TokenNameCOMMENT_LINE	IndexColorModel to do the unpacking. 
sampleModel	TokenNameIdentifier	 sample Model
=	TokenNameEQUAL	
new	TokenNamenew	
MultiPixelPackedSampleModel	TokenNameIdentifier	 Multi Pixel Packed Sample Model
(	TokenNameLPAREN	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_BYTE	TokenNameIdentifier	 TYPE  BYTE
,	TokenNameCOMMA	
tileWidth	TokenNameIdentifier	 tile Width
,	TokenNameCOMMA	
tileHeight	TokenNameIdentifier	 tile Height
,	TokenNameCOMMA	
sampleSize	TokenNameIdentifier	 sample Size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
==	TokenNameEQUAL_EQUAL	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sampleModel	TokenNameIdentifier	 sample Model
=	TokenNameEQUAL	
createPixelInterleavedSampleModel	TokenNameIdentifier	 create Pixel Interleaved Sample Model
(	TokenNameLPAREN	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_BYTE	TokenNameIdentifier	 TYPE  BYTE
,	TokenNameCOMMA	
tileWidth	TokenNameIdentifier	 tile Width
,	TokenNameCOMMA	
tileHeight	TokenNameIdentifier	 tile Height
,	TokenNameCOMMA	
numBands	TokenNameIdentifier	 num Bands
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
==	TokenNameEQUAL_EQUAL	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Here datatype has to be unsigned since we 	TokenNameCOMMENT_LINE	Here datatype has to be unsigned since we 
// are storing indices into the 	TokenNameCOMMENT_LINE	are storing indices into the 
// IndexColorModel palette. Ofcourse the 	TokenNameCOMMENT_LINE	IndexColorModel palette. Ofcourse the 
// actual palette entries are allowed to be 	TokenNameCOMMENT_LINE	actual palette entries are allowed to be 
// negative. 	TokenNameCOMMENT_LINE	negative. 
dataType	TokenNameIdentifier	 data Type
=	TokenNameEQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_USHORT	TokenNameIdentifier	 TYPE  USHORT
;	TokenNameSEMICOLON	
sampleModel	TokenNameIdentifier	 sample Model
=	TokenNameEQUAL	
createPixelInterleavedSampleModel	TokenNameIdentifier	 create Pixel Interleaved Sample Model
(	TokenNameLPAREN	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_USHORT	TokenNameIdentifier	 TYPE  USHORT
,	TokenNameCOMMA	
tileWidth	TokenNameIdentifier	 tile Width
,	TokenNameCOMMA	
tileHeight	TokenNameIdentifier	 tile Height
,	TokenNameCOMMA	
numBands	TokenNameIdentifier	 num Bands
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
bandLength	TokenNameIdentifier	 band Length
=	TokenNameEQUAL	
colormap	TokenNameIdentifier	 colormap
.	TokenNameDOT	
length	TokenNameIdentifier	 length
/	TokenNameDIVIDE	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
bandLength	TokenNameIdentifier	 band Length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
bandLength	TokenNameIdentifier	 band Length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
bandLength	TokenNameIdentifier	 band Length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
gIndex	TokenNameIdentifier	 g Index
=	TokenNameEQUAL	
bandLength	TokenNameIdentifier	 band Length
;	TokenNameSEMICOLON	
int	TokenNameint	
bIndex	TokenNameIdentifier	 b Index
=	TokenNameEQUAL	
bandLength	TokenNameIdentifier	 band Length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
==	TokenNameEQUAL_EQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_SHORT	TokenNameIdentifier	 TYPE  SHORT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
bandLength	TokenNameIdentifier	 band Length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
decodeSigned16BitsTo8Bits	TokenNameIdentifier	 decode Signed16 Bits To8 Bits
(	TokenNameLPAREN	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
colormap	TokenNameIdentifier	 colormap
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
g	TokenNameIdentifier	 g
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
decodeSigned16BitsTo8Bits	TokenNameIdentifier	 decode Signed16 Bits To8 Bits
(	TokenNameLPAREN	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
colormap	TokenNameIdentifier	 colormap
[	TokenNameLBRACKET	
gIndex	TokenNameIdentifier	 g Index
+	TokenNamePLUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
b	TokenNameIdentifier	 b
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
decodeSigned16BitsTo8Bits	TokenNameIdentifier	 decode Signed16 Bits To8 Bits
(	TokenNameLPAREN	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
colormap	TokenNameIdentifier	 colormap
[	TokenNameLBRACKET	
bIndex	TokenNameIdentifier	 b Index
+	TokenNamePLUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
bandLength	TokenNameIdentifier	 band Length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
decode16BitsTo8Bits	TokenNameIdentifier	 decode16 Bits To8 Bits
(	TokenNameLPAREN	
colormap	TokenNameIdentifier	 colormap
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
&	TokenNameAND	
0xffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
g	TokenNameIdentifier	 g
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
decode16BitsTo8Bits	TokenNameIdentifier	 decode16 Bits To8 Bits
(	TokenNameLPAREN	
colormap	TokenNameIdentifier	 colormap
[	TokenNameLBRACKET	
gIndex	TokenNameIdentifier	 g Index
+	TokenNamePLUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
&	TokenNameAND	
0xffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
b	TokenNameIdentifier	 b
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
decode16BitsTo8Bits	TokenNameIdentifier	 decode16 Bits To8 Bits
(	TokenNameLPAREN	
colormap	TokenNameIdentifier	 colormap
[	TokenNameLBRACKET	
bIndex	TokenNameIdentifier	 b Index
+	TokenNamePLUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
&	TokenNameAND	
0xffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
colorModel	TokenNameIdentifier	 color Model
=	TokenNameEQUAL	
new	TokenNamenew	
IndexColorModel	TokenNameIdentifier	 Index Color Model
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
,	TokenNameCOMMA	
bandLength	TokenNameIdentifier	 band Length
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
g	TokenNameIdentifier	 g
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"TIFFImage4"	TokenNameStringLiteral	TIFFImage4
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Map	TokenNameIdentifier	 Map
properties	TokenNameIdentifier	 properties
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Set a property "tiff_directory". 	TokenNameCOMMENT_LINE	Set a property "tiff_directory". 
properties	TokenNameIdentifier	 properties
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
"tiff_directory"	TokenNameStringLiteral	tiff_directory
,	TokenNameCOMMA	
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// System.out.println("Constructed TIFF"); 	TokenNameCOMMENT_LINE	System.out.println("Constructed TIFF"); 
init	TokenNameIdentifier	 init
(	TokenNameLPAREN	
(	TokenNameLPAREN	
CachableRed	TokenNameIdentifier	 Cachable Red
)	TokenNameRPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
bounds	TokenNameIdentifier	 bounds
,	TokenNameCOMMA	
colorModel	TokenNameIdentifier	 color Model
,	TokenNameCOMMA	
sampleModel	TokenNameIdentifier	 sample Model
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
properties	TokenNameIdentifier	 properties
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Reads a private IFD from a given offset in the stream. This * method may be used to obtain IFDs that are referenced * only by private tag values. */	TokenNameCOMMENT_JAVADOC	 Reads a private IFD from a given offset in the stream. This method may be used to obtain IFDs that are referenced only by private tag values. 
public	TokenNamepublic	
TIFFDirectory	TokenNameIdentifier	 TIFF Directory
getPrivateIFD	TokenNameIdentifier	 get Private IFD
(	TokenNameLPAREN	
long	TokenNamelong	
offset	TokenNameIdentifier	 offset
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
TIFFDirectory	TokenNameIdentifier	 TIFF Directory
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
,	TokenNameCOMMA	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
WritableRaster	TokenNameIdentifier	 Writable Raster
copyData	TokenNameIdentifier	 copy Data
(	TokenNameLPAREN	
WritableRaster	TokenNameIdentifier	 Writable Raster
wr	TokenNameIdentifier	 wr
)	TokenNameRPAREN	
{	TokenNameLBRACE	
copyToRaster	TokenNameIdentifier	 copy To Raster
(	TokenNameLPAREN	
wr	TokenNameIdentifier	 wr
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
wr	TokenNameIdentifier	 wr
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns tile (tileX, tileY) as a Raster. */	TokenNameCOMMENT_JAVADOC	 Returns tile (tileX, tileY) as a Raster. 
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
Raster	TokenNameIdentifier	 Raster
getTile	TokenNameIdentifier	 get Tile
(	TokenNameLPAREN	
int	TokenNameint	
tileX	TokenNameIdentifier	 tile X
,	TokenNameCOMMA	
int	TokenNameint	
tileY	TokenNameIdentifier	 tile Y
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
tileX	TokenNameIdentifier	 tile X
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
tileX	TokenNameIdentifier	 tile X
>=	TokenNameGREATER_EQUAL	
tilesX	TokenNameIdentifier	 tiles X
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
tileY	TokenNameIdentifier	 tile Y
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
tileY	TokenNameIdentifier	 tile Y
>=	TokenNameGREATER_EQUAL	
tilesY	TokenNameIdentifier	 tiles Y
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"TIFFImage12"	TokenNameStringLiteral	TIFFImage12
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// System.out.println("Called TIFF getTile:" + tileX + "," + tileY); 	TokenNameCOMMENT_LINE	System.out.println("Called TIFF getTile:" + tileX + "," + tileY); 
// Get the data array out of the DataBuffer 	TokenNameCOMMENT_LINE	Get the data array out of the DataBuffer 
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bdata	TokenNameIdentifier	 bdata
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
short	TokenNameshort	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
sdata	TokenNameIdentifier	 sdata
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
idata	TokenNameIdentifier	 idata
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
SampleModel	TokenNameIdentifier	 Sample Model
sampleModel	TokenNameIdentifier	 sample Model
=	TokenNameEQUAL	
getSampleModel	TokenNameIdentifier	 get Sample Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
WritableRaster	TokenNameIdentifier	 Writable Raster
tile	TokenNameIdentifier	 tile
=	TokenNameEQUAL	
makeTile	TokenNameIdentifier	 make Tile
(	TokenNameLPAREN	
tileX	TokenNameIdentifier	 tile X
,	TokenNameCOMMA	
tileY	TokenNameIdentifier	 tile Y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DataBuffer	TokenNameIdentifier	 Data Buffer
buffer	TokenNameIdentifier	 buffer
=	TokenNameEQUAL	
tile	TokenNameIdentifier	 tile
.	TokenNameDOT	
getDataBuffer	TokenNameIdentifier	 get Data Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
dataType	TokenNameIdentifier	 data Type
=	TokenNameEQUAL	
sampleModel	TokenNameIdentifier	 sample Model
.	TokenNameDOT	
getDataType	TokenNameIdentifier	 get Data Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
==	TokenNameEQUAL_EQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_BYTE	TokenNameIdentifier	 TYPE  BYTE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bdata	TokenNameIdentifier	 bdata
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
DataBufferByte	TokenNameIdentifier	 Data Buffer Byte
)	TokenNameRPAREN	
buffer	TokenNameIdentifier	 buffer
)	TokenNameRPAREN	
.	TokenNameDOT	
getData	TokenNameIdentifier	 get Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
==	TokenNameEQUAL_EQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_USHORT	TokenNameIdentifier	 TYPE  USHORT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sdata	TokenNameIdentifier	 sdata
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
DataBufferUShort	TokenNameIdentifier	 Data Buffer U Short
)	TokenNameRPAREN	
buffer	TokenNameIdentifier	 buffer
)	TokenNameRPAREN	
.	TokenNameDOT	
getData	TokenNameIdentifier	 get Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
==	TokenNameEQUAL_EQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_SHORT	TokenNameIdentifier	 TYPE  SHORT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sdata	TokenNameIdentifier	 sdata
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
DataBufferShort	TokenNameIdentifier	 Data Buffer Short
)	TokenNameRPAREN	
buffer	TokenNameIdentifier	 buffer
)	TokenNameRPAREN	
.	TokenNameDOT	
getData	TokenNameIdentifier	 get Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
==	TokenNameEQUAL_EQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_INT	TokenNameIdentifier	 TYPE  INT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
idata	TokenNameIdentifier	 idata
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
DataBufferInt	TokenNameIdentifier	 Data Buffer Int
)	TokenNameRPAREN	
buffer	TokenNameIdentifier	 buffer
)	TokenNameRPAREN	
.	TokenNameDOT	
getData	TokenNameIdentifier	 get Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Variables used for swapping when converting from RGB to BGR 	TokenNameCOMMENT_LINE	Variables used for swapping when converting from RGB to BGR 
byte	TokenNamebyte	
bswap	TokenNameIdentifier	 bswap
;	TokenNameSEMICOLON	
short	TokenNameshort	
sswap	TokenNameIdentifier	 sswap
;	TokenNameSEMICOLON	
int	TokenNameint	
iswap	TokenNameIdentifier	 iswap
;	TokenNameSEMICOLON	
// Save original file pointer position and seek to tile data location. 	TokenNameCOMMENT_LINE	Save original file pointer position and seek to tile data location. 
long	TokenNamelong	
save_offset	TokenNameIdentifier	 save offset
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
save_offset	TokenNameIdentifier	 save offset
=	TokenNameEQUAL	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
getFilePointer	TokenNameIdentifier	 get File Pointer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
seek	TokenNameIdentifier	 seek
(	TokenNameLPAREN	
tileOffsets	TokenNameIdentifier	 tile Offsets
[	TokenNameLBRACKET	
tileY	TokenNameIdentifier	 tile Y
*	TokenNameMULTIPLY	
tilesX	TokenNameIdentifier	 tiles X
+	TokenNamePLUS	
tileX	TokenNameIdentifier	 tile X
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ioe	TokenNameIdentifier	 ioe
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"TIFFImage13"	TokenNameStringLiteral	TIFFImage13
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Number of bytes in this tile (strip) after compression. 	TokenNameCOMMENT_LINE	Number of bytes in this tile (strip) after compression. 
int	TokenNameint	
byteCount	TokenNameIdentifier	 byte Count
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
tileByteCounts	TokenNameIdentifier	 tile Byte Counts
[	TokenNameLBRACKET	
tileY	TokenNameIdentifier	 tile Y
*	TokenNameMULTIPLY	
tilesX	TokenNameIdentifier	 tiles X
+	TokenNamePLUS	
tileX	TokenNameIdentifier	 tile X
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// Find out the number of bytes in the current tile 	TokenNameCOMMENT_LINE	Find out the number of bytes in the current tile 
Rectangle	TokenNameIdentifier	 Rectangle
newRect	TokenNameIdentifier	 new Rect
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
tiled	TokenNameIdentifier	 tiled
)	TokenNameRPAREN	
newRect	TokenNameIdentifier	 new Rect
=	TokenNameEQUAL	
tile	TokenNameIdentifier	 tile
.	TokenNameDOT	
getBounds	TokenNameIdentifier	 get Bounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
newRect	TokenNameIdentifier	 new Rect
=	TokenNameEQUAL	
new	TokenNamenew	
Rectangle	TokenNameIdentifier	 Rectangle
(	TokenNameLPAREN	
tile	TokenNameIdentifier	 tile
.	TokenNameDOT	
getMinX	TokenNameIdentifier	 get Min X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
tile	TokenNameIdentifier	 tile
.	TokenNameDOT	
getMinY	TokenNameIdentifier	 get Min Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
tileWidth	TokenNameIdentifier	 tile Width
,	TokenNameCOMMA	
tileHeight	TokenNameIdentifier	 tile Height
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
unitsInThisTile	TokenNameIdentifier	 units In This Tile
=	TokenNameEQUAL	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
width	TokenNameIdentifier	 width
*	TokenNameMULTIPLY	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
height	TokenNameIdentifier	 height
*	TokenNameMULTIPLY	
numBands	TokenNameIdentifier	 num Bands
;	TokenNameSEMICOLON	
// Allocate read buffer if needed. 	TokenNameCOMMENT_LINE	Allocate read buffer if needed. 
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
data	TokenNameIdentifier	 data
=	TokenNameEQUAL	
compression	TokenNameIdentifier	 compression
!=	TokenNameNOT_EQUAL	
COMP_NONE	TokenNameIdentifier	 COMP  NONE
||	TokenNameOR_OR	
imageType	TokenNameIdentifier	 image Type
==	TokenNameEQUAL_EQUAL	
TYPE_PALETTE	TokenNameIdentifier	 TYPE  PALETTE
?	TokenNameQUESTION	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
byteCount	TokenNameIdentifier	 byte Count
]	TokenNameRBRACKET	
:	TokenNameCOLON	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// Read the data, uncompressing as needed. There are four cases: 	TokenNameCOMMENT_LINE	Read the data, uncompressing as needed. There are four cases: 
// bilevel, palette-RGB, 4-bit grayscale, and everything else. 	TokenNameCOMMENT_LINE	bilevel, palette-RGB, 4-bit grayscale, and everything else. 
if	TokenNameif	
(	TokenNameLPAREN	
imageType	TokenNameIdentifier	 image Type
==	TokenNameEQUAL_EQUAL	
TYPE_BILEVEL	TokenNameIdentifier	 TYPE  BILEVEL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// bilevel 	TokenNameCOMMENT_LINE	bilevel 
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_PACKBITS	TokenNameIdentifier	 COMP  PACKBITS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Since the decompressed data will still be packed 	TokenNameCOMMENT_LINE	Since the decompressed data will still be packed 
// 8 pixels into 1 byte, calculate bytesInThisTile 	TokenNameCOMMENT_LINE	8 pixels into 1 byte, calculate bytesInThisTile 
int	TokenNameint	
bytesInThisTile	TokenNameIdentifier	 bytes In This Tile
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
width	TokenNameIdentifier	 width
%	TokenNameREMAINDER	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bytesInThisTile	TokenNameIdentifier	 bytes In This Tile
=	TokenNameEQUAL	
(	TokenNameLPAREN	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
width	TokenNameIdentifier	 width
/	TokenNameDIVIDE	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
height	TokenNameIdentifier	 height
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
bytesInThisTile	TokenNameIdentifier	 bytes In This Tile
=	TokenNameEQUAL	
(	TokenNameLPAREN	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
width	TokenNameIdentifier	 width
/	TokenNameDIVIDE	
8	TokenNameIntegerLiteral	
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
height	TokenNameIdentifier	 height
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
decodePackbits	TokenNameIdentifier	 decode Packbits
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
bytesInThisTile	TokenNameIdentifier	 bytes In This Tile
,	TokenNameCOMMA	
bdata	TokenNameIdentifier	 bdata
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_LZW	TokenNameIdentifier	 COMP  LZW
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
lzwDecoder	TokenNameIdentifier	 lzw Decoder
.	TokenNameDOT	
decode	TokenNameIdentifier	 decode
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
bdata	TokenNameIdentifier	 bdata
,	TokenNameCOMMA	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
height	TokenNameIdentifier	 height
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_FAX_G3_1D	TokenNameIdentifier	 COMP  FAX  G3 1 D
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
decoder	TokenNameIdentifier	 decoder
.	TokenNameDOT	
decode1D	TokenNameIdentifier	 decode1 D
(	TokenNameLPAREN	
bdata	TokenNameIdentifier	 bdata
,	TokenNameCOMMA	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
height	TokenNameIdentifier	 height
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_FAX_G3_2D	TokenNameIdentifier	 COMP  FAX  G3 2 D
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
decoder	TokenNameIdentifier	 decoder
.	TokenNameDOT	
decode2D	TokenNameIdentifier	 decode2 D
(	TokenNameLPAREN	
bdata	TokenNameIdentifier	 bdata
,	TokenNameCOMMA	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
height	TokenNameIdentifier	 height
,	TokenNameCOMMA	
tiffT4Options	TokenNameIdentifier	 tiff T4 Options
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_FAX_G4_2D	TokenNameIdentifier	 COMP  FAX  G4 2 D
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
decoder	TokenNameIdentifier	 decoder
.	TokenNameDOT	
decodeT6	TokenNameIdentifier	 decode T6
(	TokenNameLPAREN	
bdata	TokenNameIdentifier	 bdata
,	TokenNameCOMMA	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
height	TokenNameIdentifier	 height
,	TokenNameCOMMA	
tiffT6Options	TokenNameIdentifier	 tiff T6 Options
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_DEFLATE	TokenNameIdentifier	 COMP  DEFLATE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
inflate	TokenNameIdentifier	 inflate
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
bdata	TokenNameIdentifier	 bdata
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_NONE	TokenNameIdentifier	 COMP  NONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
bdata	TokenNameIdentifier	 bdata
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
seek	TokenNameIdentifier	 seek
(	TokenNameLPAREN	
save_offset	TokenNameIdentifier	 save offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ioe	TokenNameIdentifier	 ioe
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"TIFFImage13"	TokenNameStringLiteral	TIFFImage13
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
imageType	TokenNameIdentifier	 image Type
==	TokenNameEQUAL_EQUAL	
TYPE_PALETTE	TokenNameIdentifier	 TYPE  PALETTE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// palette-RGB 	TokenNameCOMMENT_LINE	palette-RGB 
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
==	TokenNameEQUAL_EQUAL	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
decodePaletteAsShorts	TokenNameIdentifier	 decode Palette As Shorts
)	TokenNameRPAREN	
{	TokenNameLBRACE	
short	TokenNameshort	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
tempData	TokenNameIdentifier	 temp Data
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// At this point the data is 1 banded and will 	TokenNameCOMMENT_LINE	At this point the data is 1 banded and will 
// become 3 banded only after we've done the palette 	TokenNameCOMMENT_LINE	become 3 banded only after we've done the palette 
// lookup, since unitsInThisTile was calculated with 	TokenNameCOMMENT_LINE	lookup, since unitsInThisTile was calculated with 
// 3 bands, we need to divide this by 3. 	TokenNameCOMMENT_LINE	3 bands, we need to divide this by 3. 
int	TokenNameint	
unitsBeforeLookup	TokenNameIdentifier	 units Before Lookup
=	TokenNameEQUAL	
unitsInThisTile	TokenNameIdentifier	 units In This Tile
/	TokenNameDIVIDE	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Since unitsBeforeLookup is the number of shorts, 	TokenNameCOMMENT_LINE	Since unitsBeforeLookup is the number of shorts, 
// but we do our decompression in terms of bytes, we 	TokenNameCOMMENT_LINE	but we do our decompression in terms of bytes, we 
// need to multiply it by 2 in order to figure out 	TokenNameCOMMENT_LINE	need to multiply it by 2 in order to figure out 
// how many bytes we'll get after decompression. 	TokenNameCOMMENT_LINE	how many bytes we'll get after decompression. 
int	TokenNameint	
entries	TokenNameIdentifier	 entries
=	TokenNameEQUAL	
unitsBeforeLookup	TokenNameIdentifier	 units Before Lookup
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Read the data, if compressed, decode it, reset the pointer 	TokenNameCOMMENT_LINE	Read the data, if compressed, decode it, reset the pointer 
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_PACKBITS	TokenNameIdentifier	 COMP  PACKBITS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
byteArray	TokenNameIdentifier	 byte Array
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
entries	TokenNameIdentifier	 entries
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
decodePackbits	TokenNameIdentifier	 decode Packbits
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
entries	TokenNameIdentifier	 entries
,	TokenNameCOMMA	
byteArray	TokenNameIdentifier	 byte Array
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tempData	TokenNameIdentifier	 temp Data
=	TokenNameEQUAL	
new	TokenNamenew	
short	TokenNameshort	
[	TokenNameLBRACKET	
unitsBeforeLookup	TokenNameIdentifier	 units Before Lookup
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
interpretBytesAsShorts	TokenNameIdentifier	 interpret Bytes As Shorts
(	TokenNameLPAREN	
byteArray	TokenNameIdentifier	 byte Array
,	TokenNameCOMMA	
tempData	TokenNameIdentifier	 temp Data
,	TokenNameCOMMA	
unitsBeforeLookup	TokenNameIdentifier	 units Before Lookup
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_LZW	TokenNameIdentifier	 COMP  LZW
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Read in all the compressed data for this tile 	TokenNameCOMMENT_LINE	Read in all the compressed data for this tile 
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
byteArray	TokenNameIdentifier	 byte Array
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
entries	TokenNameIdentifier	 entries
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
lzwDecoder	TokenNameIdentifier	 lzw Decoder
.	TokenNameDOT	
decode	TokenNameIdentifier	 decode
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
byteArray	TokenNameIdentifier	 byte Array
,	TokenNameCOMMA	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
height	TokenNameIdentifier	 height
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tempData	TokenNameIdentifier	 temp Data
=	TokenNameEQUAL	
new	TokenNamenew	
short	TokenNameshort	
[	TokenNameLBRACKET	
unitsBeforeLookup	TokenNameIdentifier	 units Before Lookup
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
interpretBytesAsShorts	TokenNameIdentifier	 interpret Bytes As Shorts
(	TokenNameLPAREN	
byteArray	TokenNameIdentifier	 byte Array
,	TokenNameCOMMA	
tempData	TokenNameIdentifier	 temp Data
,	TokenNameCOMMA	
unitsBeforeLookup	TokenNameIdentifier	 units Before Lookup
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_DEFLATE	TokenNameIdentifier	 COMP  DEFLATE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
byteArray	TokenNameIdentifier	 byte Array
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
entries	TokenNameIdentifier	 entries
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
inflate	TokenNameIdentifier	 inflate
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
byteArray	TokenNameIdentifier	 byte Array
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tempData	TokenNameIdentifier	 temp Data
=	TokenNameEQUAL	
new	TokenNamenew	
short	TokenNameshort	
[	TokenNameLBRACKET	
unitsBeforeLookup	TokenNameIdentifier	 units Before Lookup
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
interpretBytesAsShorts	TokenNameIdentifier	 interpret Bytes As Shorts
(	TokenNameLPAREN	
byteArray	TokenNameIdentifier	 byte Array
,	TokenNameCOMMA	
tempData	TokenNameIdentifier	 temp Data
,	TokenNameCOMMA	
unitsBeforeLookup	TokenNameIdentifier	 units Before Lookup
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_NONE	TokenNameIdentifier	 COMP  NONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// byteCount tells us how many bytes are there 	TokenNameCOMMENT_LINE	byteCount tells us how many bytes are there 
// in this tile, but we need to read in shorts, 	TokenNameCOMMENT_LINE	in this tile, but we need to read in shorts, 
// which will take half the space, so while 	TokenNameCOMMENT_LINE	which will take half the space, so while 
// allocating we divide byteCount by 2. 	TokenNameCOMMENT_LINE	allocating we divide byteCount by 2. 
tempData	TokenNameIdentifier	 temp Data
=	TokenNameEQUAL	
new	TokenNamenew	
short	TokenNameshort	
[	TokenNameLBRACKET	
byteCount	TokenNameIdentifier	 byte Count
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
readShorts	TokenNameIdentifier	 read Shorts
(	TokenNameLPAREN	
byteCount	TokenNameIdentifier	 byte Count
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tempData	TokenNameIdentifier	 temp Data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
seek	TokenNameIdentifier	 seek
(	TokenNameLPAREN	
save_offset	TokenNameIdentifier	 save offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ioe	TokenNameIdentifier	 ioe
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"TIFFImage13"	TokenNameStringLiteral	TIFFImage13
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
==	TokenNameEQUAL_EQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_USHORT	TokenNameIdentifier	 TYPE  USHORT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Expand the palette image into an rgb image with ushort 	TokenNameCOMMENT_LINE	Expand the palette image into an rgb image with ushort 
// data type. 	TokenNameCOMMENT_LINE	data type. 
int	TokenNameint	
cmapValue	TokenNameIdentifier	 cmap Value
;	TokenNameSEMICOLON	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
lookup	TokenNameIdentifier	 lookup
,	TokenNameCOMMA	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
colormap	TokenNameIdentifier	 colormap
.	TokenNameDOT	
length	TokenNameIdentifier	 length
/	TokenNameDIVIDE	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
len2	TokenNameIdentifier	 len2
=	TokenNameEQUAL	
len	TokenNameIdentifier	 len
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
unitsBeforeLookup	TokenNameIdentifier	 units Before Lookup
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Get the index into the colormap 	TokenNameCOMMENT_LINE	Get the index into the colormap 
lookup	TokenNameIdentifier	 lookup
=	TokenNameEQUAL	
tempData	TokenNameIdentifier	 temp Data
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
&	TokenNameAND	
0xffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Get the blue value 	TokenNameCOMMENT_LINE	Get the blue value 
cmapValue	TokenNameIdentifier	 cmap Value
=	TokenNameEQUAL	
colormap	TokenNameIdentifier	 colormap
[	TokenNameLBRACKET	
lookup	TokenNameIdentifier	 lookup
+	TokenNamePLUS	
len2	TokenNameIdentifier	 len2
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
sdata	TokenNameIdentifier	 sdata
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
cmapValue	TokenNameIdentifier	 cmap Value
&	TokenNameAND	
0xffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Get the green value 	TokenNameCOMMENT_LINE	Get the green value 
cmapValue	TokenNameIdentifier	 cmap Value
=	TokenNameEQUAL	
colormap	TokenNameIdentifier	 colormap
[	TokenNameLBRACKET	
lookup	TokenNameIdentifier	 lookup
+	TokenNamePLUS	
len	TokenNameIdentifier	 len
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
sdata	TokenNameIdentifier	 sdata
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
cmapValue	TokenNameIdentifier	 cmap Value
&	TokenNameAND	
0xffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Get the red value 	TokenNameCOMMENT_LINE	Get the red value 
cmapValue	TokenNameIdentifier	 cmap Value
=	TokenNameEQUAL	
colormap	TokenNameIdentifier	 colormap
[	TokenNameLBRACKET	
lookup	TokenNameIdentifier	 lookup
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
sdata	TokenNameIdentifier	 sdata
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
cmapValue	TokenNameIdentifier	 cmap Value
&	TokenNameAND	
0xffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
==	TokenNameEQUAL_EQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_SHORT	TokenNameIdentifier	 TYPE  SHORT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Expand the palette image into an rgb image with 	TokenNameCOMMENT_LINE	Expand the palette image into an rgb image with 
// short data type. 	TokenNameCOMMENT_LINE	short data type. 
int	TokenNameint	
cmapValue	TokenNameIdentifier	 cmap Value
;	TokenNameSEMICOLON	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
lookup	TokenNameIdentifier	 lookup
,	TokenNameCOMMA	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
colormap	TokenNameIdentifier	 colormap
.	TokenNameDOT	
length	TokenNameIdentifier	 length
/	TokenNameDIVIDE	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
len2	TokenNameIdentifier	 len2
=	TokenNameEQUAL	
len	TokenNameIdentifier	 len
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
unitsBeforeLookup	TokenNameIdentifier	 units Before Lookup
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Get the index into the colormap 	TokenNameCOMMENT_LINE	Get the index into the colormap 
lookup	TokenNameIdentifier	 lookup
=	TokenNameEQUAL	
tempData	TokenNameIdentifier	 temp Data
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
&	TokenNameAND	
0xffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Get the blue value 	TokenNameCOMMENT_LINE	Get the blue value 
cmapValue	TokenNameIdentifier	 cmap Value
=	TokenNameEQUAL	
colormap	TokenNameIdentifier	 colormap
[	TokenNameLBRACKET	
lookup	TokenNameIdentifier	 lookup
+	TokenNamePLUS	
len2	TokenNameIdentifier	 len2
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
sdata	TokenNameIdentifier	 sdata
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
cmapValue	TokenNameIdentifier	 cmap Value
;	TokenNameSEMICOLON	
// Get the green value 	TokenNameCOMMENT_LINE	Get the green value 
cmapValue	TokenNameIdentifier	 cmap Value
=	TokenNameEQUAL	
colormap	TokenNameIdentifier	 colormap
[	TokenNameLBRACKET	
lookup	TokenNameIdentifier	 lookup
+	TokenNamePLUS	
len	TokenNameIdentifier	 len
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
sdata	TokenNameIdentifier	 sdata
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
cmapValue	TokenNameIdentifier	 cmap Value
;	TokenNameSEMICOLON	
// Get the red value 	TokenNameCOMMENT_LINE	Get the red value 
cmapValue	TokenNameIdentifier	 cmap Value
=	TokenNameEQUAL	
colormap	TokenNameIdentifier	 colormap
[	TokenNameLBRACKET	
lookup	TokenNameIdentifier	 lookup
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
sdata	TokenNameIdentifier	 sdata
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
cmapValue	TokenNameIdentifier	 cmap Value
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// No lookup being done here, when RGB values are needed, 	TokenNameCOMMENT_LINE	No lookup being done here, when RGB values are needed, 
// the associated IndexColorModel can be used to get them. 	TokenNameCOMMENT_LINE	the associated IndexColorModel can be used to get them. 
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_PACKBITS	TokenNameIdentifier	 COMP  PACKBITS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Since unitsInThisTile is the number of shorts, 	TokenNameCOMMENT_LINE	Since unitsInThisTile is the number of shorts, 
// but we do our decompression in terms of bytes, we 	TokenNameCOMMENT_LINE	but we do our decompression in terms of bytes, we 
// need to multiply unitsInThisTile by 2 in order to 	TokenNameCOMMENT_LINE	need to multiply unitsInThisTile by 2 in order to 
// figure out how many bytes we'll get after 	TokenNameCOMMENT_LINE	figure out how many bytes we'll get after 
// decompression. 	TokenNameCOMMENT_LINE	decompression. 
int	TokenNameint	
bytesInThisTile	TokenNameIdentifier	 bytes In This Tile
=	TokenNameEQUAL	
unitsInThisTile	TokenNameIdentifier	 units In This Tile
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
byteArray	TokenNameIdentifier	 byte Array
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
bytesInThisTile	TokenNameIdentifier	 bytes In This Tile
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
decodePackbits	TokenNameIdentifier	 decode Packbits
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
bytesInThisTile	TokenNameIdentifier	 bytes In This Tile
,	TokenNameCOMMA	
byteArray	TokenNameIdentifier	 byte Array
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
interpretBytesAsShorts	TokenNameIdentifier	 interpret Bytes As Shorts
(	TokenNameLPAREN	
byteArray	TokenNameIdentifier	 byte Array
,	TokenNameCOMMA	
sdata	TokenNameIdentifier	 sdata
,	TokenNameCOMMA	
unitsInThisTile	TokenNameIdentifier	 units In This Tile
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_LZW	TokenNameIdentifier	 COMP  LZW
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Since unitsInThisTile is the number of shorts, 	TokenNameCOMMENT_LINE	Since unitsInThisTile is the number of shorts, 
// but we do our decompression in terms of bytes, we 	TokenNameCOMMENT_LINE	but we do our decompression in terms of bytes, we 
// need to multiply unitsInThisTile by 2 in order to 	TokenNameCOMMENT_LINE	need to multiply unitsInThisTile by 2 in order to 
// figure out how many bytes we'll get after 	TokenNameCOMMENT_LINE	figure out how many bytes we'll get after 
// decompression. 	TokenNameCOMMENT_LINE	decompression. 
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
byteArray	TokenNameIdentifier	 byte Array
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
unitsInThisTile	TokenNameIdentifier	 units In This Tile
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
lzwDecoder	TokenNameIdentifier	 lzw Decoder
.	TokenNameDOT	
decode	TokenNameIdentifier	 decode
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
byteArray	TokenNameIdentifier	 byte Array
,	TokenNameCOMMA	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
height	TokenNameIdentifier	 height
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
interpretBytesAsShorts	TokenNameIdentifier	 interpret Bytes As Shorts
(	TokenNameLPAREN	
byteArray	TokenNameIdentifier	 byte Array
,	TokenNameCOMMA	
sdata	TokenNameIdentifier	 sdata
,	TokenNameCOMMA	
unitsInThisTile	TokenNameIdentifier	 units In This Tile
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_DEFLATE	TokenNameIdentifier	 COMP  DEFLATE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
byteArray	TokenNameIdentifier	 byte Array
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
unitsInThisTile	TokenNameIdentifier	 units In This Tile
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
inflate	TokenNameIdentifier	 inflate
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
byteArray	TokenNameIdentifier	 byte Array
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
interpretBytesAsShorts	TokenNameIdentifier	 interpret Bytes As Shorts
(	TokenNameLPAREN	
byteArray	TokenNameIdentifier	 byte Array
,	TokenNameCOMMA	
sdata	TokenNameIdentifier	 sdata
,	TokenNameCOMMA	
unitsInThisTile	TokenNameIdentifier	 units In This Tile
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_NONE	TokenNameIdentifier	 COMP  NONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
readShorts	TokenNameIdentifier	 read Shorts
(	TokenNameLPAREN	
byteCount	TokenNameIdentifier	 byte Count
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
sdata	TokenNameIdentifier	 sdata
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
seek	TokenNameIdentifier	 seek
(	TokenNameLPAREN	
save_offset	TokenNameIdentifier	 save offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ioe	TokenNameIdentifier	 ioe
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"TIFFImage13"	TokenNameStringLiteral	TIFFImage13
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
==	TokenNameEQUAL_EQUAL	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
decodePaletteAsShorts	TokenNameIdentifier	 decode Palette As Shorts
)	TokenNameRPAREN	
{	TokenNameLBRACE	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
tempData	TokenNameIdentifier	 temp Data
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// At this point the data is 1 banded and will 	TokenNameCOMMENT_LINE	At this point the data is 1 banded and will 
// become 3 banded only after we've done the palette 	TokenNameCOMMENT_LINE	become 3 banded only after we've done the palette 
// lookup, since unitsInThisTile was calculated with 	TokenNameCOMMENT_LINE	lookup, since unitsInThisTile was calculated with 
// 3 bands, we need to divide this by 3. 	TokenNameCOMMENT_LINE	3 bands, we need to divide this by 3. 
int	TokenNameint	
unitsBeforeLookup	TokenNameIdentifier	 units Before Lookup
=	TokenNameEQUAL	
unitsInThisTile	TokenNameIdentifier	 units In This Tile
/	TokenNameDIVIDE	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Read the data, if compressed, decode it, reset the pointer 	TokenNameCOMMENT_LINE	Read the data, if compressed, decode it, reset the pointer 
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_PACKBITS	TokenNameIdentifier	 COMP  PACKBITS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tempData	TokenNameIdentifier	 temp Data
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
unitsBeforeLookup	TokenNameIdentifier	 units Before Lookup
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
decodePackbits	TokenNameIdentifier	 decode Packbits
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
unitsBeforeLookup	TokenNameIdentifier	 units Before Lookup
,	TokenNameCOMMA	
tempData	TokenNameIdentifier	 temp Data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_LZW	TokenNameIdentifier	 COMP  LZW
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tempData	TokenNameIdentifier	 temp Data
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
unitsBeforeLookup	TokenNameIdentifier	 units Before Lookup
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
lzwDecoder	TokenNameIdentifier	 lzw Decoder
.	TokenNameDOT	
decode	TokenNameIdentifier	 decode
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
tempData	TokenNameIdentifier	 temp Data
,	TokenNameCOMMA	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
height	TokenNameIdentifier	 height
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_JPEG_TTN2	TokenNameIdentifier	 COMP  JPEG  TT N2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Raster	TokenNameIdentifier	 Raster
tempTile	TokenNameIdentifier	 temp Tile
=	TokenNameEQUAL	
decodeJPEG	TokenNameIdentifier	 decode JPEG
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
decodeParam	TokenNameIdentifier	 decode Param
,	TokenNameCOMMA	
colorConvertJPEG	TokenNameIdentifier	 color Convert JPEG
,	TokenNameCOMMA	
tile	TokenNameIdentifier	 tile
.	TokenNameDOT	
getMinX	TokenNameIdentifier	 get Min X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
tile	TokenNameIdentifier	 tile
.	TokenNameDOT	
getMinY	TokenNameIdentifier	 get Min Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
tempPixels	TokenNameIdentifier	 temp Pixels
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
unitsBeforeLookup	TokenNameIdentifier	 units Before Lookup
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
tempTile	TokenNameIdentifier	 temp Tile
.	TokenNameDOT	
getPixels	TokenNameIdentifier	 get Pixels
(	TokenNameLPAREN	
tile	TokenNameIdentifier	 tile
.	TokenNameDOT	
getMinX	TokenNameIdentifier	 get Min X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
tile	TokenNameIdentifier	 tile
.	TokenNameDOT	
getMinY	TokenNameIdentifier	 get Min Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
tile	TokenNameIdentifier	 tile
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
tile	TokenNameIdentifier	 tile
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
tempPixels	TokenNameIdentifier	 temp Pixels
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tempData	TokenNameIdentifier	 temp Data
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
unitsBeforeLookup	TokenNameIdentifier	 units Before Lookup
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
unitsBeforeLookup	TokenNameIdentifier	 units Before Lookup
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tempData	TokenNameIdentifier	 temp Data
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
tempPixels	TokenNameIdentifier	 temp Pixels
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_DEFLATE	TokenNameIdentifier	 COMP  DEFLATE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tempData	TokenNameIdentifier	 temp Data
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
unitsBeforeLookup	TokenNameIdentifier	 units Before Lookup
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
inflate	TokenNameIdentifier	 inflate
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
tempData	TokenNameIdentifier	 temp Data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_NONE	TokenNameIdentifier	 COMP  NONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tempData	TokenNameIdentifier	 temp Data
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
byteCount	TokenNameIdentifier	 byte Count
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
tempData	TokenNameIdentifier	 temp Data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
seek	TokenNameIdentifier	 seek
(	TokenNameLPAREN	
save_offset	TokenNameIdentifier	 save offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ioe	TokenNameIdentifier	 ioe
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"TIFFImage13"	TokenNameStringLiteral	TIFFImage13
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Expand the palette image into an rgb image with ushort 	TokenNameCOMMENT_LINE	Expand the palette image into an rgb image with ushort 
// data type. 	TokenNameCOMMENT_LINE	data type. 
int	TokenNameint	
cmapValue	TokenNameIdentifier	 cmap Value
;	TokenNameSEMICOLON	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
lookup	TokenNameIdentifier	 lookup
,	TokenNameCOMMA	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
colormap	TokenNameIdentifier	 colormap
.	TokenNameDOT	
length	TokenNameIdentifier	 length
/	TokenNameDIVIDE	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
len2	TokenNameIdentifier	 len2
=	TokenNameEQUAL	
len	TokenNameIdentifier	 len
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
unitsBeforeLookup	TokenNameIdentifier	 units Before Lookup
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Get the index into the colormap 	TokenNameCOMMENT_LINE	Get the index into the colormap 
lookup	TokenNameIdentifier	 lookup
=	TokenNameEQUAL	
tempData	TokenNameIdentifier	 temp Data
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Get the blue value 	TokenNameCOMMENT_LINE	Get the blue value 
cmapValue	TokenNameIdentifier	 cmap Value
=	TokenNameEQUAL	
colormap	TokenNameIdentifier	 colormap
[	TokenNameLBRACKET	
lookup	TokenNameIdentifier	 lookup
+	TokenNamePLUS	
len2	TokenNameIdentifier	 len2
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
sdata	TokenNameIdentifier	 sdata
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
cmapValue	TokenNameIdentifier	 cmap Value
&	TokenNameAND	
0xffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Get the green value 	TokenNameCOMMENT_LINE	Get the green value 
cmapValue	TokenNameIdentifier	 cmap Value
=	TokenNameEQUAL	
colormap	TokenNameIdentifier	 colormap
[	TokenNameLBRACKET	
lookup	TokenNameIdentifier	 lookup
+	TokenNamePLUS	
len	TokenNameIdentifier	 len
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
sdata	TokenNameIdentifier	 sdata
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
cmapValue	TokenNameIdentifier	 cmap Value
&	TokenNameAND	
0xffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Get the red value 	TokenNameCOMMENT_LINE	Get the red value 
cmapValue	TokenNameIdentifier	 cmap Value
=	TokenNameEQUAL	
colormap	TokenNameIdentifier	 colormap
[	TokenNameLBRACKET	
lookup	TokenNameIdentifier	 lookup
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
sdata	TokenNameIdentifier	 sdata
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
cmapValue	TokenNameIdentifier	 cmap Value
&	TokenNameAND	
0xffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// No lookup being done here, when RGB values are needed, 	TokenNameCOMMENT_LINE	No lookup being done here, when RGB values are needed, 
// the associated IndexColorModel can be used to get them. 	TokenNameCOMMENT_LINE	the associated IndexColorModel can be used to get them. 
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_PACKBITS	TokenNameIdentifier	 COMP  PACKBITS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
decodePackbits	TokenNameIdentifier	 decode Packbits
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
unitsInThisTile	TokenNameIdentifier	 units In This Tile
,	TokenNameCOMMA	
bdata	TokenNameIdentifier	 bdata
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_LZW	TokenNameIdentifier	 COMP  LZW
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
lzwDecoder	TokenNameIdentifier	 lzw Decoder
.	TokenNameDOT	
decode	TokenNameIdentifier	 decode
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
bdata	TokenNameIdentifier	 bdata
,	TokenNameCOMMA	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
height	TokenNameIdentifier	 height
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_JPEG_TTN2	TokenNameIdentifier	 COMP  JPEG  TT N2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tile	TokenNameIdentifier	 tile
.	TokenNameDOT	
setRect	TokenNameIdentifier	 set Rect
(	TokenNameLPAREN	
decodeJPEG	TokenNameIdentifier	 decode JPEG
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
decodeParam	TokenNameIdentifier	 decode Param
,	TokenNameCOMMA	
colorConvertJPEG	TokenNameIdentifier	 color Convert JPEG
,	TokenNameCOMMA	
tile	TokenNameIdentifier	 tile
.	TokenNameDOT	
getMinX	TokenNameIdentifier	 get Min X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
tile	TokenNameIdentifier	 tile
.	TokenNameDOT	
getMinY	TokenNameIdentifier	 get Min Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_DEFLATE	TokenNameIdentifier	 COMP  DEFLATE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
inflate	TokenNameIdentifier	 inflate
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
bdata	TokenNameIdentifier	 bdata
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_NONE	TokenNameIdentifier	 COMP  NONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
bdata	TokenNameIdentifier	 bdata
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
seek	TokenNameIdentifier	 seek
(	TokenNameLPAREN	
save_offset	TokenNameIdentifier	 save offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ioe	TokenNameIdentifier	 ioe
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"TIFFImage13"	TokenNameStringLiteral	TIFFImage13
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
==	TokenNameEQUAL_EQUAL	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
padding	TokenNameIdentifier	 padding
=	TokenNameEQUAL	
(	TokenNameLPAREN	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
width	TokenNameIdentifier	 width
%	TokenNameREMAINDER	
2	TokenNameIntegerLiteral	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
bytesPostDecoding	TokenNameIdentifier	 bytes Post Decoding
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
width	TokenNameIdentifier	 width
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
+	TokenNamePLUS	
padding	TokenNameIdentifier	 padding
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
height	TokenNameIdentifier	 height
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Output short images 	TokenNameCOMMENT_LINE	Output short images 
if	TokenNameif	
(	TokenNameLPAREN	
decodePaletteAsShorts	TokenNameIdentifier	 decode Palette As Shorts
)	TokenNameRPAREN	
{	TokenNameLBRACE	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
tempData	TokenNameIdentifier	 temp Data
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
seek	TokenNameIdentifier	 seek
(	TokenNameLPAREN	
save_offset	TokenNameIdentifier	 save offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ioe	TokenNameIdentifier	 ioe
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"TIFFImage13"	TokenNameStringLiteral	TIFFImage13
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// If compressed, decode the data. 	TokenNameCOMMENT_LINE	If compressed, decode the data. 
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_PACKBITS	TokenNameIdentifier	 COMP  PACKBITS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tempData	TokenNameIdentifier	 temp Data
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
bytesPostDecoding	TokenNameIdentifier	 bytes Post Decoding
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
decodePackbits	TokenNameIdentifier	 decode Packbits
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
bytesPostDecoding	TokenNameIdentifier	 bytes Post Decoding
,	TokenNameCOMMA	
tempData	TokenNameIdentifier	 temp Data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_LZW	TokenNameIdentifier	 COMP  LZW
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tempData	TokenNameIdentifier	 temp Data
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
bytesPostDecoding	TokenNameIdentifier	 bytes Post Decoding
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
lzwDecoder	TokenNameIdentifier	 lzw Decoder
.	TokenNameDOT	
decode	TokenNameIdentifier	 decode
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
tempData	TokenNameIdentifier	 temp Data
,	TokenNameCOMMA	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
height	TokenNameIdentifier	 height
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_DEFLATE	TokenNameIdentifier	 COMP  DEFLATE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tempData	TokenNameIdentifier	 temp Data
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
bytesPostDecoding	TokenNameIdentifier	 bytes Post Decoding
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
inflate	TokenNameIdentifier	 inflate
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
tempData	TokenNameIdentifier	 temp Data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_NONE	TokenNameIdentifier	 COMP  NONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tempData	TokenNameIdentifier	 temp Data
=	TokenNameEQUAL	
data	TokenNameIdentifier	 data
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
bytes	TokenNameIdentifier	 bytes
=	TokenNameEQUAL	
unitsInThisTile	TokenNameIdentifier	 units In This Tile
/	TokenNameDIVIDE	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Unpack the 2 pixels packed into each byte. 	TokenNameCOMMENT_LINE	Unpack the 2 pixels packed into each byte. 
data	TokenNameIdentifier	 data
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
bytes	TokenNameIdentifier	 bytes
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
srcCount	TokenNameIdentifier	 src Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
dstCount	TokenNameIdentifier	 dst Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
height	TokenNameIdentifier	 height
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
width	TokenNameIdentifier	 width
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
data	TokenNameIdentifier	 data
[	TokenNameLBRACKET	
dstCount	TokenNameIdentifier	 dst Count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
tempData	TokenNameIdentifier	 temp Data
[	TokenNameLBRACKET	
srcCount	TokenNameIdentifier	 src Count
]	TokenNameRBRACKET	
&	TokenNameAND	
0xf0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
data	TokenNameIdentifier	 data
[	TokenNameLBRACKET	
dstCount	TokenNameIdentifier	 dst Count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
tempData	TokenNameIdentifier	 temp Data
[	TokenNameLBRACKET	
srcCount	TokenNameIdentifier	 src Count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
&	TokenNameAND	
0x0f	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
padding	TokenNameIdentifier	 padding
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
data	TokenNameIdentifier	 data
[	TokenNameLBRACKET	
dstCount	TokenNameIdentifier	 dst Count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
tempData	TokenNameIdentifier	 temp Data
[	TokenNameLBRACKET	
srcCount	TokenNameIdentifier	 src Count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xf0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
int	TokenNameint	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
colormap	TokenNameIdentifier	 colormap
.	TokenNameDOT	
length	TokenNameIdentifier	 length
/	TokenNameDIVIDE	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
len2	TokenNameIdentifier	 len2
=	TokenNameEQUAL	
len	TokenNameIdentifier	 len
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
cmapValue	TokenNameIdentifier	 cmap Value
,	TokenNameCOMMA	
lookup	TokenNameIdentifier	 lookup
;	TokenNameSEMICOLON	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
bytes	TokenNameIdentifier	 bytes
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
lookup	TokenNameIdentifier	 lookup
=	TokenNameEQUAL	
data	TokenNameIdentifier	 data
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
cmapValue	TokenNameIdentifier	 cmap Value
=	TokenNameEQUAL	
colormap	TokenNameIdentifier	 colormap
[	TokenNameLBRACKET	
lookup	TokenNameIdentifier	 lookup
+	TokenNamePLUS	
len2	TokenNameIdentifier	 len2
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
sdata	TokenNameIdentifier	 sdata
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
cmapValue	TokenNameIdentifier	 cmap Value
&	TokenNameAND	
0xffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cmapValue	TokenNameIdentifier	 cmap Value
=	TokenNameEQUAL	
colormap	TokenNameIdentifier	 colormap
[	TokenNameLBRACKET	
lookup	TokenNameIdentifier	 lookup
+	TokenNamePLUS	
len	TokenNameIdentifier	 len
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
sdata	TokenNameIdentifier	 sdata
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
cmapValue	TokenNameIdentifier	 cmap Value
&	TokenNameAND	
0xffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cmapValue	TokenNameIdentifier	 cmap Value
=	TokenNameEQUAL	
colormap	TokenNameIdentifier	 colormap
[	TokenNameLBRACKET	
lookup	TokenNameIdentifier	 lookup
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
sdata	TokenNameIdentifier	 sdata
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
cmapValue	TokenNameIdentifier	 cmap Value
&	TokenNameAND	
0xffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Output byte values, use IndexColorModel for unpacking 	TokenNameCOMMENT_LINE	Output byte values, use IndexColorModel for unpacking 
try	TokenNametry	
{	TokenNameLBRACE	
// If compressed, decode the data. 	TokenNameCOMMENT_LINE	If compressed, decode the data. 
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_PACKBITS	TokenNameIdentifier	 COMP  PACKBITS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
decodePackbits	TokenNameIdentifier	 decode Packbits
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
bytesPostDecoding	TokenNameIdentifier	 bytes Post Decoding
,	TokenNameCOMMA	
bdata	TokenNameIdentifier	 bdata
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_LZW	TokenNameIdentifier	 COMP  LZW
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
lzwDecoder	TokenNameIdentifier	 lzw Decoder
.	TokenNameDOT	
decode	TokenNameIdentifier	 decode
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
bdata	TokenNameIdentifier	 bdata
,	TokenNameCOMMA	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
height	TokenNameIdentifier	 height
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_DEFLATE	TokenNameIdentifier	 COMP  DEFLATE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
inflate	TokenNameIdentifier	 inflate
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
bdata	TokenNameIdentifier	 bdata
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_NONE	TokenNameIdentifier	 COMP  NONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
bdata	TokenNameIdentifier	 bdata
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
seek	TokenNameIdentifier	 seek
(	TokenNameLPAREN	
save_offset	TokenNameIdentifier	 save offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ioe	TokenNameIdentifier	 ioe
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"TIFFImage13"	TokenNameStringLiteral	TIFFImage13
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
imageType	TokenNameIdentifier	 image Type
==	TokenNameEQUAL_EQUAL	
TYPE_GRAY_4BIT	TokenNameIdentifier	 TYPE  GRAY 4 BIT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 4-bit gray 	TokenNameCOMMENT_LINE	4-bit gray 
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_PACKBITS	TokenNameIdentifier	 COMP  PACKBITS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Since the decompressed data will still be packed 	TokenNameCOMMENT_LINE	Since the decompressed data will still be packed 
// 2 pixels into 1 byte, calculate bytesInThisTile 	TokenNameCOMMENT_LINE	2 pixels into 1 byte, calculate bytesInThisTile 
int	TokenNameint	
bytesInThisTile	TokenNameIdentifier	 bytes In This Tile
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
width	TokenNameIdentifier	 width
%	TokenNameREMAINDER	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bytesInThisTile	TokenNameIdentifier	 bytes In This Tile
=	TokenNameEQUAL	
(	TokenNameLPAREN	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
width	TokenNameIdentifier	 width
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
height	TokenNameIdentifier	 height
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
bytesInThisTile	TokenNameIdentifier	 bytes In This Tile
=	TokenNameEQUAL	
(	TokenNameLPAREN	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
width	TokenNameIdentifier	 width
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
height	TokenNameIdentifier	 height
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
decodePackbits	TokenNameIdentifier	 decode Packbits
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
bytesInThisTile	TokenNameIdentifier	 bytes In This Tile
,	TokenNameCOMMA	
bdata	TokenNameIdentifier	 bdata
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_LZW	TokenNameIdentifier	 COMP  LZW
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
lzwDecoder	TokenNameIdentifier	 lzw Decoder
.	TokenNameDOT	
decode	TokenNameIdentifier	 decode
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
bdata	TokenNameIdentifier	 bdata
,	TokenNameCOMMA	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
height	TokenNameIdentifier	 height
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_DEFLATE	TokenNameIdentifier	 COMP  DEFLATE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
inflate	TokenNameIdentifier	 inflate
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
bdata	TokenNameIdentifier	 bdata
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
bdata	TokenNameIdentifier	 bdata
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
seek	TokenNameIdentifier	 seek
(	TokenNameLPAREN	
save_offset	TokenNameIdentifier	 save offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ioe	TokenNameIdentifier	 ioe
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"TIFFImage13"	TokenNameStringLiteral	TIFFImage13
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// everything else 	TokenNameCOMMENT_LINE	everything else 
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
==	TokenNameEQUAL_EQUAL	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_NONE	TokenNameIdentifier	 COMP  NONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
bdata	TokenNameIdentifier	 bdata
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_LZW	TokenNameIdentifier	 COMP  LZW
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
lzwDecoder	TokenNameIdentifier	 lzw Decoder
.	TokenNameDOT	
decode	TokenNameIdentifier	 decode
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
bdata	TokenNameIdentifier	 bdata
,	TokenNameCOMMA	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
height	TokenNameIdentifier	 height
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_PACKBITS	TokenNameIdentifier	 COMP  PACKBITS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
decodePackbits	TokenNameIdentifier	 decode Packbits
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
unitsInThisTile	TokenNameIdentifier	 units In This Tile
,	TokenNameCOMMA	
bdata	TokenNameIdentifier	 bdata
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_JPEG_TTN2	TokenNameIdentifier	 COMP  JPEG  TT N2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tile	TokenNameIdentifier	 tile
.	TokenNameDOT	
setRect	TokenNameIdentifier	 set Rect
(	TokenNameLPAREN	
decodeJPEG	TokenNameIdentifier	 decode JPEG
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
decodeParam	TokenNameIdentifier	 decode Param
,	TokenNameCOMMA	
colorConvertJPEG	TokenNameIdentifier	 color Convert JPEG
,	TokenNameCOMMA	
tile	TokenNameIdentifier	 tile
.	TokenNameDOT	
getMinX	TokenNameIdentifier	 get Min X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
tile	TokenNameIdentifier	 tile
.	TokenNameDOT	
getMinY	TokenNameIdentifier	 get Min Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_DEFLATE	TokenNameIdentifier	 COMP  DEFLATE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
inflate	TokenNameIdentifier	 inflate
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
bdata	TokenNameIdentifier	 bdata
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
==	TokenNameEQUAL_EQUAL	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_NONE	TokenNameIdentifier	 COMP  NONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
readShorts	TokenNameIdentifier	 read Shorts
(	TokenNameLPAREN	
byteCount	TokenNameIdentifier	 byte Count
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
sdata	TokenNameIdentifier	 sdata
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_LZW	TokenNameIdentifier	 COMP  LZW
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Since unitsInThisTile is the number of shorts, 	TokenNameCOMMENT_LINE	Since unitsInThisTile is the number of shorts, 
// but we do our decompression in terms of bytes, we 	TokenNameCOMMENT_LINE	but we do our decompression in terms of bytes, we 
// need to multiply unitsInThisTile by 2 in order to 	TokenNameCOMMENT_LINE	need to multiply unitsInThisTile by 2 in order to 
// figure out how many bytes we'll get after 	TokenNameCOMMENT_LINE	figure out how many bytes we'll get after 
// decompression. 	TokenNameCOMMENT_LINE	decompression. 
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
byteArray	TokenNameIdentifier	 byte Array
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
unitsInThisTile	TokenNameIdentifier	 units In This Tile
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
lzwDecoder	TokenNameIdentifier	 lzw Decoder
.	TokenNameDOT	
decode	TokenNameIdentifier	 decode
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
byteArray	TokenNameIdentifier	 byte Array
,	TokenNameCOMMA	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
height	TokenNameIdentifier	 height
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
interpretBytesAsShorts	TokenNameIdentifier	 interpret Bytes As Shorts
(	TokenNameLPAREN	
byteArray	TokenNameIdentifier	 byte Array
,	TokenNameCOMMA	
sdata	TokenNameIdentifier	 sdata
,	TokenNameCOMMA	
unitsInThisTile	TokenNameIdentifier	 units In This Tile
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_PACKBITS	TokenNameIdentifier	 COMP  PACKBITS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Since unitsInThisTile is the number of shorts, 	TokenNameCOMMENT_LINE	Since unitsInThisTile is the number of shorts, 
// but we do our decompression in terms of bytes, we 	TokenNameCOMMENT_LINE	but we do our decompression in terms of bytes, we 
// need to multiply unitsInThisTile by 2 in order to 	TokenNameCOMMENT_LINE	need to multiply unitsInThisTile by 2 in order to 
// figure out how many bytes we'll get after 	TokenNameCOMMENT_LINE	figure out how many bytes we'll get after 
// decompression. 	TokenNameCOMMENT_LINE	decompression. 
int	TokenNameint	
bytesInThisTile	TokenNameIdentifier	 bytes In This Tile
=	TokenNameEQUAL	
unitsInThisTile	TokenNameIdentifier	 units In This Tile
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
byteArray	TokenNameIdentifier	 byte Array
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
bytesInThisTile	TokenNameIdentifier	 bytes In This Tile
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
decodePackbits	TokenNameIdentifier	 decode Packbits
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
bytesInThisTile	TokenNameIdentifier	 bytes In This Tile
,	TokenNameCOMMA	
byteArray	TokenNameIdentifier	 byte Array
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
interpretBytesAsShorts	TokenNameIdentifier	 interpret Bytes As Shorts
(	TokenNameLPAREN	
byteArray	TokenNameIdentifier	 byte Array
,	TokenNameCOMMA	
sdata	TokenNameIdentifier	 sdata
,	TokenNameCOMMA	
unitsInThisTile	TokenNameIdentifier	 units In This Tile
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_DEFLATE	TokenNameIdentifier	 COMP  DEFLATE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
byteArray	TokenNameIdentifier	 byte Array
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
unitsInThisTile	TokenNameIdentifier	 units In This Tile
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
inflate	TokenNameIdentifier	 inflate
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
byteArray	TokenNameIdentifier	 byte Array
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
interpretBytesAsShorts	TokenNameIdentifier	 interpret Bytes As Shorts
(	TokenNameLPAREN	
byteArray	TokenNameIdentifier	 byte Array
,	TokenNameCOMMA	
sdata	TokenNameIdentifier	 sdata
,	TokenNameCOMMA	
unitsInThisTile	TokenNameIdentifier	 units In This Tile
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
==	TokenNameEQUAL_EQUAL	
32	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
dataType	TokenNameIdentifier	 data Type
==	TokenNameEQUAL_EQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_INT	TokenNameIdentifier	 TYPE  INT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// redundant 	TokenNameCOMMENT_LINE	redundant 
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_NONE	TokenNameIdentifier	 COMP  NONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
readInts	TokenNameIdentifier	 read Ints
(	TokenNameLPAREN	
byteCount	TokenNameIdentifier	 byte Count
/	TokenNameDIVIDE	
4	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
idata	TokenNameIdentifier	 idata
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_LZW	TokenNameIdentifier	 COMP  LZW
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Since unitsInThisTile is the number of ints, 	TokenNameCOMMENT_LINE	Since unitsInThisTile is the number of ints, 
// but we do our decompression in terms of bytes, we 	TokenNameCOMMENT_LINE	but we do our decompression in terms of bytes, we 
// need to multiply unitsInThisTile by 4 in order to 	TokenNameCOMMENT_LINE	need to multiply unitsInThisTile by 4 in order to 
// figure out how many bytes we'll get after 	TokenNameCOMMENT_LINE	figure out how many bytes we'll get after 
// decompression. 	TokenNameCOMMENT_LINE	decompression. 
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
byteArray	TokenNameIdentifier	 byte Array
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
unitsInThisTile	TokenNameIdentifier	 units In This Tile
*	TokenNameMULTIPLY	
4	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
lzwDecoder	TokenNameIdentifier	 lzw Decoder
.	TokenNameDOT	
decode	TokenNameIdentifier	 decode
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
byteArray	TokenNameIdentifier	 byte Array
,	TokenNameCOMMA	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
height	TokenNameIdentifier	 height
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
interpretBytesAsInts	TokenNameIdentifier	 interpret Bytes As Ints
(	TokenNameLPAREN	
byteArray	TokenNameIdentifier	 byte Array
,	TokenNameCOMMA	
idata	TokenNameIdentifier	 idata
,	TokenNameCOMMA	
unitsInThisTile	TokenNameIdentifier	 units In This Tile
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_PACKBITS	TokenNameIdentifier	 COMP  PACKBITS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Since unitsInThisTile is the number of ints, 	TokenNameCOMMENT_LINE	Since unitsInThisTile is the number of ints, 
// but we do our decompression in terms of bytes, we 	TokenNameCOMMENT_LINE	but we do our decompression in terms of bytes, we 
// need to multiply unitsInThisTile by 4 in order to 	TokenNameCOMMENT_LINE	need to multiply unitsInThisTile by 4 in order to 
// figure out how many bytes we'll get after 	TokenNameCOMMENT_LINE	figure out how many bytes we'll get after 
// decompression. 	TokenNameCOMMENT_LINE	decompression. 
int	TokenNameint	
bytesInThisTile	TokenNameIdentifier	 bytes In This Tile
=	TokenNameEQUAL	
unitsInThisTile	TokenNameIdentifier	 units In This Tile
*	TokenNameMULTIPLY	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
byteArray	TokenNameIdentifier	 byte Array
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
bytesInThisTile	TokenNameIdentifier	 bytes In This Tile
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
decodePackbits	TokenNameIdentifier	 decode Packbits
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
bytesInThisTile	TokenNameIdentifier	 bytes In This Tile
,	TokenNameCOMMA	
byteArray	TokenNameIdentifier	 byte Array
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
interpretBytesAsInts	TokenNameIdentifier	 interpret Bytes As Ints
(	TokenNameLPAREN	
byteArray	TokenNameIdentifier	 byte Array
,	TokenNameCOMMA	
idata	TokenNameIdentifier	 idata
,	TokenNameCOMMA	
unitsInThisTile	TokenNameIdentifier	 units In This Tile
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_DEFLATE	TokenNameIdentifier	 COMP  DEFLATE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
byteArray	TokenNameIdentifier	 byte Array
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
unitsInThisTile	TokenNameIdentifier	 units In This Tile
*	TokenNameMULTIPLY	
4	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
inflate	TokenNameIdentifier	 inflate
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
byteArray	TokenNameIdentifier	 byte Array
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
interpretBytesAsInts	TokenNameIdentifier	 interpret Bytes As Ints
(	TokenNameLPAREN	
byteArray	TokenNameIdentifier	 byte Array
,	TokenNameCOMMA	
idata	TokenNameIdentifier	 idata
,	TokenNameCOMMA	
unitsInThisTile	TokenNameIdentifier	 units In This Tile
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
seek	TokenNameIdentifier	 seek
(	TokenNameLPAREN	
save_offset	TokenNameIdentifier	 save offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ioe	TokenNameIdentifier	 ioe
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"TIFFImage13"	TokenNameStringLiteral	TIFFImage13
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Modify the data for certain special cases. 	TokenNameCOMMENT_LINE	Modify the data for certain special cases. 
switch	TokenNameswitch	
(	TokenNameLPAREN	
imageType	TokenNameIdentifier	 image Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
TYPE_GRAY	TokenNameIdentifier	 TYPE  GRAY
:	TokenNameCOLON	
case	TokenNamecase	
TYPE_GRAY_ALPHA	TokenNameIdentifier	 TYPE  GRAY  ALPHA
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isWhiteZero	TokenNameIdentifier	 is White Zero
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Since we are using a ComponentColorModel with this 	TokenNameCOMMENT_LINE	Since we are using a ComponentColorModel with this 
// image, we need to change the WhiteIsZero data to 	TokenNameCOMMENT_LINE	image, we need to change the WhiteIsZero data to 
// BlackIsZero data so it will display properly. 	TokenNameCOMMENT_LINE	BlackIsZero data so it will display properly. 
if	TokenNameif	
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
==	TokenNameEQUAL_EQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_BYTE	TokenNameIdentifier	 TYPE  BYTE
&&	TokenNameAND_AND	
!	TokenNameNOT	
(	TokenNameLPAREN	
getColorModel	TokenNameIdentifier	 get Color Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
instanceof	TokenNameinstanceof	
IndexColorModel	TokenNameIdentifier	 Index Color Model
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
l	TokenNameIdentifier	 l
<	TokenNameLESS	
bdata	TokenNameIdentifier	 bdata
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
l	TokenNameIdentifier	 l
+=	TokenNamePLUS_EQUAL	
numBands	TokenNameIdentifier	 num Bands
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bdata	TokenNameIdentifier	 bdata
[	TokenNameLBRACKET	
l	TokenNameIdentifier	 l
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
255	TokenNameIntegerLiteral	
-	TokenNameMINUS	
bdata	TokenNameIdentifier	 bdata
[	TokenNameLBRACKET	
l	TokenNameIdentifier	 l
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
==	TokenNameEQUAL_EQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_USHORT	TokenNameIdentifier	 TYPE  USHORT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
ushortMax	TokenNameIdentifier	 ushort Max
=	TokenNameEQUAL	
Short	TokenNameIdentifier	 Short
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
-	TokenNameMINUS	
Short	TokenNameIdentifier	 Short
.	TokenNameDOT	
MIN_VALUE	TokenNameIdentifier	 MIN  VALUE
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
l	TokenNameIdentifier	 l
<	TokenNameLESS	
sdata	TokenNameIdentifier	 sdata
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
l	TokenNameIdentifier	 l
+=	TokenNamePLUS_EQUAL	
numBands	TokenNameIdentifier	 num Bands
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sdata	TokenNameIdentifier	 sdata
[	TokenNameLBRACKET	
l	TokenNameIdentifier	 l
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
ushortMax	TokenNameIdentifier	 ushort Max
-	TokenNameMINUS	
sdata	TokenNameIdentifier	 sdata
[	TokenNameLBRACKET	
l	TokenNameIdentifier	 l
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
==	TokenNameEQUAL_EQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_SHORT	TokenNameIdentifier	 TYPE  SHORT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
l	TokenNameIdentifier	 l
<	TokenNameLESS	
sdata	TokenNameIdentifier	 sdata
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
l	TokenNameIdentifier	 l
+=	TokenNamePLUS_EQUAL	
numBands	TokenNameIdentifier	 num Bands
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sdata	TokenNameIdentifier	 sdata
[	TokenNameLBRACKET	
l	TokenNameIdentifier	 l
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
~	TokenNameTWIDDLE	
sdata	TokenNameIdentifier	 sdata
[	TokenNameLBRACKET	
l	TokenNameIdentifier	 l
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
==	TokenNameEQUAL_EQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_INT	TokenNameIdentifier	 TYPE  INT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
uintMax	TokenNameIdentifier	 uint Max
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
long	TokenNamelong	
)	TokenNameRPAREN	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
-	TokenNameMINUS	
(	TokenNameLPAREN	
long	TokenNamelong	
)	TokenNameRPAREN	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MIN_VALUE	TokenNameIdentifier	 MIN  VALUE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
l	TokenNameIdentifier	 l
<	TokenNameLESS	
idata	TokenNameIdentifier	 idata
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
l	TokenNameIdentifier	 l
+=	TokenNamePLUS_EQUAL	
numBands	TokenNameIdentifier	 num Bands
)	TokenNameRPAREN	
{	TokenNameLBRACE	
idata	TokenNameIdentifier	 idata
[	TokenNameLBRACKET	
l	TokenNameIdentifier	 l
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
uintMax	TokenNameIdentifier	 uint Max
-	TokenNameMINUS	
idata	TokenNameIdentifier	 idata
[	TokenNameLBRACKET	
l	TokenNameIdentifier	 l
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
TYPE_RGB	TokenNameIdentifier	 TYPE  RGB
:	TokenNameCOLON	
// Change RGB to BGR order, as Java2D displays that faster. 	TokenNameCOMMENT_LINE	Change RGB to BGR order, as Java2D displays that faster. 
// Unnecessary for JPEG-in-TIFF as the decoder handles it. 	TokenNameCOMMENT_LINE	Unnecessary for JPEG-in-TIFF as the decoder handles it. 
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
==	TokenNameEQUAL_EQUAL	
8	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
compression	TokenNameIdentifier	 compression
!=	TokenNameNOT_EQUAL	
COMP_JPEG_TTN2	TokenNameIdentifier	 COMP  JPEG  TT N2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
unitsInThisTile	TokenNameIdentifier	 units In This Tile
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
+=	TokenNamePLUS_EQUAL	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bswap	TokenNameIdentifier	 bswap
=	TokenNameEQUAL	
bdata	TokenNameIdentifier	 bdata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
bdata	TokenNameIdentifier	 bdata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
bdata	TokenNameIdentifier	 bdata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
bdata	TokenNameIdentifier	 bdata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
bswap	TokenNameIdentifier	 bswap
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
==	TokenNameEQUAL_EQUAL	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
unitsInThisTile	TokenNameIdentifier	 units In This Tile
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
+=	TokenNamePLUS_EQUAL	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sswap	TokenNameIdentifier	 sswap
=	TokenNameEQUAL	
sdata	TokenNameIdentifier	 sdata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
sdata	TokenNameIdentifier	 sdata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
sdata	TokenNameIdentifier	 sdata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
sdata	TokenNameIdentifier	 sdata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
sswap	TokenNameIdentifier	 sswap
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
==	TokenNameEQUAL_EQUAL	
32	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
==	TokenNameEQUAL_EQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_INT	TokenNameIdentifier	 TYPE  INT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
unitsInThisTile	TokenNameIdentifier	 units In This Tile
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
+=	TokenNamePLUS_EQUAL	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
iswap	TokenNameIdentifier	 iswap
=	TokenNameEQUAL	
idata	TokenNameIdentifier	 idata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
idata	TokenNameIdentifier	 idata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
idata	TokenNameIdentifier	 idata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
idata	TokenNameIdentifier	 idata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
iswap	TokenNameIdentifier	 iswap
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
TYPE_RGB_ALPHA	TokenNameIdentifier	 TYPE  RGB  ALPHA
:	TokenNameCOLON	
// Convert from RGBA to ABGR for Java2D 	TokenNameCOMMENT_LINE	Convert from RGBA to ABGR for Java2D 
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
==	TokenNameEQUAL_EQUAL	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
unitsInThisTile	TokenNameIdentifier	 units In This Tile
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
+=	TokenNamePLUS_EQUAL	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Swap R and A 	TokenNameCOMMENT_LINE	Swap R and A 
bswap	TokenNameIdentifier	 bswap
=	TokenNameEQUAL	
bdata	TokenNameIdentifier	 bdata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
bdata	TokenNameIdentifier	 bdata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
bdata	TokenNameIdentifier	 bdata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
3	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
bdata	TokenNameIdentifier	 bdata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
3	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
bswap	TokenNameIdentifier	 bswap
;	TokenNameSEMICOLON	
// Swap G and B 	TokenNameCOMMENT_LINE	Swap G and B 
bswap	TokenNameIdentifier	 bswap
=	TokenNameEQUAL	
bdata	TokenNameIdentifier	 bdata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
bdata	TokenNameIdentifier	 bdata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
bdata	TokenNameIdentifier	 bdata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
bdata	TokenNameIdentifier	 bdata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
bswap	TokenNameIdentifier	 bswap
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
==	TokenNameEQUAL_EQUAL	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
unitsInThisTile	TokenNameIdentifier	 units In This Tile
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
+=	TokenNamePLUS_EQUAL	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Swap R and A 	TokenNameCOMMENT_LINE	Swap R and A 
sswap	TokenNameIdentifier	 sswap
=	TokenNameEQUAL	
sdata	TokenNameIdentifier	 sdata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
sdata	TokenNameIdentifier	 sdata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
sdata	TokenNameIdentifier	 sdata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
3	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
sdata	TokenNameIdentifier	 sdata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
3	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
sswap	TokenNameIdentifier	 sswap
;	TokenNameSEMICOLON	
// Swap G and B 	TokenNameCOMMENT_LINE	Swap G and B 
sswap	TokenNameIdentifier	 sswap
=	TokenNameEQUAL	
sdata	TokenNameIdentifier	 sdata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
sdata	TokenNameIdentifier	 sdata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
sdata	TokenNameIdentifier	 sdata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
sdata	TokenNameIdentifier	 sdata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
sswap	TokenNameIdentifier	 sswap
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
==	TokenNameEQUAL_EQUAL	
32	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
==	TokenNameEQUAL_EQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_INT	TokenNameIdentifier	 TYPE  INT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
unitsInThisTile	TokenNameIdentifier	 units In This Tile
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
+=	TokenNamePLUS_EQUAL	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Swap R and A 	TokenNameCOMMENT_LINE	Swap R and A 
iswap	TokenNameIdentifier	 iswap
=	TokenNameEQUAL	
idata	TokenNameIdentifier	 idata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
idata	TokenNameIdentifier	 idata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
idata	TokenNameIdentifier	 idata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
3	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
idata	TokenNameIdentifier	 idata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
3	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
iswap	TokenNameIdentifier	 iswap
;	TokenNameSEMICOLON	
// Swap G and B 	TokenNameCOMMENT_LINE	Swap G and B 
iswap	TokenNameIdentifier	 iswap
=	TokenNameEQUAL	
idata	TokenNameIdentifier	 idata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
idata	TokenNameIdentifier	 idata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
idata	TokenNameIdentifier	 idata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
idata	TokenNameIdentifier	 idata
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
iswap	TokenNameIdentifier	 iswap
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
TYPE_YCBCR_SUB	TokenNameIdentifier	 TYPE  YCBCR  SUB
:	TokenNameCOLON	
// Post-processing for YCbCr with subsampled chrominance: 	TokenNameCOMMENT_LINE	Post-processing for YCbCr with subsampled chrominance: 
// simply replicate the chroma channels for displayability. 	TokenNameCOMMENT_LINE	simply replicate the chroma channels for displayability. 
int	TokenNameint	
pixelsPerDataUnit	TokenNameIdentifier	 pixels Per Data Unit
=	TokenNameEQUAL	
chromaSubH	TokenNameIdentifier	 chroma Sub H
*	TokenNameMULTIPLY	
chromaSubV	TokenNameIdentifier	 chroma Sub V
;	TokenNameSEMICOLON	
int	TokenNameint	
numH	TokenNameIdentifier	 num H
=	TokenNameEQUAL	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
width	TokenNameIdentifier	 width
/	TokenNameDIVIDE	
chromaSubH	TokenNameIdentifier	 chroma Sub H
;	TokenNameSEMICOLON	
int	TokenNameint	
numV	TokenNameIdentifier	 num V
=	TokenNameEQUAL	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
height	TokenNameIdentifier	 height
/	TokenNameDIVIDE	
chromaSubV	TokenNameIdentifier	 chroma Sub V
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
tempData	TokenNameIdentifier	 temp Data
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
numH	TokenNameIdentifier	 num H
*	TokenNameMULTIPLY	
numV	TokenNameIdentifier	 num V
*	TokenNameMULTIPLY	
(	TokenNameLPAREN	
pixelsPerDataUnit	TokenNameIdentifier	 pixels Per Data Unit
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
bdata	TokenNameIdentifier	 bdata
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tempData	TokenNameIdentifier	 temp Data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tempData	TokenNameIdentifier	 temp Data
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
samplesPerDataUnit	TokenNameIdentifier	 samples Per Data Unit
=	TokenNameEQUAL	
pixelsPerDataUnit	TokenNameIdentifier	 pixels Per Data Unit
*	TokenNameMULTIPLY	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
pixels	TokenNameIdentifier	 pixels
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
samplesPerDataUnit	TokenNameIdentifier	 samples Per Data Unit
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
bOffset	TokenNameIdentifier	 b Offset
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
offsetCb	TokenNameIdentifier	 offset Cb
=	TokenNameEQUAL	
pixelsPerDataUnit	TokenNameIdentifier	 pixels Per Data Unit
;	TokenNameSEMICOLON	
int	TokenNameint	
offsetCr	TokenNameIdentifier	 offset Cr
=	TokenNameEQUAL	
offsetCb	TokenNameIdentifier	 offset Cb
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
y	TokenNameIdentifier	 y
=	TokenNameEQUAL	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
y	TokenNameIdentifier	 y
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
numV	TokenNameIdentifier	 num V
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
x	TokenNameIdentifier	 x
=	TokenNameEQUAL	
newRect	TokenNameIdentifier	 new Rect
.	TokenNameDOT	
x	TokenNameIdentifier	 x
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numH	TokenNameIdentifier	 num H
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
Cb	TokenNameIdentifier	 Cb
=	TokenNameEQUAL	
tempData	TokenNameIdentifier	 temp Data
[	TokenNameLBRACKET	
bOffset	TokenNameIdentifier	 b Offset
+	TokenNamePLUS	
offsetCb	TokenNameIdentifier	 offset Cb
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
Cr	TokenNameIdentifier	 Cr
=	TokenNameEQUAL	
tempData	TokenNameIdentifier	 temp Data
[	TokenNameLBRACKET	
bOffset	TokenNameIdentifier	 b Offset
+	TokenNamePLUS	
offsetCr	TokenNameIdentifier	 offset Cr
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
k	TokenNameIdentifier	 k
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
k	TokenNameIdentifier	 k
<	TokenNameLESS	
samplesPerDataUnit	TokenNameIdentifier	 samples Per Data Unit
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pixels	TokenNameIdentifier	 pixels
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
tempData	TokenNameIdentifier	 temp Data
[	TokenNameLBRACKET	
bOffset	TokenNameIdentifier	 b Offset
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
pixels	TokenNameIdentifier	 pixels
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
Cb	TokenNameIdentifier	 Cb
;	TokenNameSEMICOLON	
pixels	TokenNameIdentifier	 pixels
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
Cr	TokenNameIdentifier	 Cr
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
bOffset	TokenNameIdentifier	 b Offset
+=	TokenNamePLUS_EQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
tile	TokenNameIdentifier	 tile
.	TokenNameDOT	
setPixels	TokenNameIdentifier	 set Pixels
(	TokenNameLPAREN	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
y	TokenNameIdentifier	 y
,	TokenNameCOMMA	
chromaSubH	TokenNameIdentifier	 chroma Sub H
,	TokenNameCOMMA	
chromaSubV	TokenNameIdentifier	 chroma Sub V
,	TokenNameCOMMA	
pixels	TokenNameIdentifier	 pixels
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
x	TokenNameIdentifier	 x
+=	TokenNamePLUS_EQUAL	
chromaSubH	TokenNameIdentifier	 chroma Sub H
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
y	TokenNameIdentifier	 y
+=	TokenNamePLUS_EQUAL	
chromaSubV	TokenNameIdentifier	 chroma Sub V
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
tile	TokenNameIdentifier	 tile
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
readShorts	TokenNameIdentifier	 read Shorts
(	TokenNameLPAREN	
int	TokenNameint	
shortCount	TokenNameIdentifier	 short Count
,	TokenNameCOMMA	
short	TokenNameshort	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
shortArray	TokenNameIdentifier	 short Array
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Since each short consists of 2 bytes, we need a 	TokenNameCOMMENT_LINE	Since each short consists of 2 bytes, we need a 
// byte array of double size 	TokenNameCOMMENT_LINE	byte array of double size 
int	TokenNameint	
byteCount	TokenNameIdentifier	 byte Count
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
shortCount	TokenNameIdentifier	 short Count
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
byteArray	TokenNameIdentifier	 byte Array
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
byteCount	TokenNameIdentifier	 byte Count
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
byteArray	TokenNameIdentifier	 byte Array
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ioe	TokenNameIdentifier	 ioe
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"TIFFImage13"	TokenNameStringLiteral	TIFFImage13
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
interpretBytesAsShorts	TokenNameIdentifier	 interpret Bytes As Shorts
(	TokenNameLPAREN	
byteArray	TokenNameIdentifier	 byte Array
,	TokenNameCOMMA	
shortArray	TokenNameIdentifier	 short Array
,	TokenNameCOMMA	
shortCount	TokenNameIdentifier	 short Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
readInts	TokenNameIdentifier	 read Ints
(	TokenNameLPAREN	
int	TokenNameint	
intCount	TokenNameIdentifier	 int Count
,	TokenNameCOMMA	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
intArray	TokenNameIdentifier	 int Array
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Since each int consists of 4 bytes, we need a 	TokenNameCOMMENT_LINE	Since each int consists of 4 bytes, we need a 
// byte array of quadruple size 	TokenNameCOMMENT_LINE	byte array of quadruple size 
int	TokenNameint	
byteCount	TokenNameIdentifier	 byte Count
=	TokenNameEQUAL	
4	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
intCount	TokenNameIdentifier	 int Count
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
byteArray	TokenNameIdentifier	 byte Array
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
byteCount	TokenNameIdentifier	 byte Count
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
readFully	TokenNameIdentifier	 read Fully
(	TokenNameLPAREN	
byteArray	TokenNameIdentifier	 byte Array
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
byteCount	TokenNameIdentifier	 byte Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ioe	TokenNameIdentifier	 ioe
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"TIFFImage13"	TokenNameStringLiteral	TIFFImage13
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
interpretBytesAsInts	TokenNameIdentifier	 interpret Bytes As Ints
(	TokenNameLPAREN	
byteArray	TokenNameIdentifier	 byte Array
,	TokenNameCOMMA	
intArray	TokenNameIdentifier	 int Array
,	TokenNameCOMMA	
intCount	TokenNameIdentifier	 int Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Method to interpret a byte array to a short array, depending on 	TokenNameCOMMENT_LINE	Method to interpret a byte array to a short array, depending on 
// whether the bytes are stored in a big endian or little endian format. 	TokenNameCOMMENT_LINE	whether the bytes are stored in a big endian or little endian format. 
private	TokenNameprivate	
void	TokenNamevoid	
interpretBytesAsShorts	TokenNameIdentifier	 interpret Bytes As Shorts
(	TokenNameLPAREN	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
byteArray	TokenNameIdentifier	 byte Array
,	TokenNameCOMMA	
short	TokenNameshort	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
shortArray	TokenNameIdentifier	 short Array
,	TokenNameCOMMA	
int	TokenNameint	
shortCount	TokenNameIdentifier	 short Count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
firstByte	TokenNameIdentifier	 first Byte
,	TokenNameCOMMA	
secondByte	TokenNameIdentifier	 second Byte
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBigEndian	TokenNameIdentifier	 is Big Endian
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
shortCount	TokenNameIdentifier	 short Count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
firstByte	TokenNameIdentifier	 first Byte
=	TokenNameEQUAL	
byteArray	TokenNameIdentifier	 byte Array
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
secondByte	TokenNameIdentifier	 second Byte
=	TokenNameEQUAL	
byteArray	TokenNameIdentifier	 byte Array
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
shortArray	TokenNameIdentifier	 short Array
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
firstByte	TokenNameIdentifier	 first Byte
<<	TokenNameLEFT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
+	TokenNamePLUS	
secondByte	TokenNameIdentifier	 second Byte
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
shortCount	TokenNameIdentifier	 short Count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
firstByte	TokenNameIdentifier	 first Byte
=	TokenNameEQUAL	
byteArray	TokenNameIdentifier	 byte Array
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
secondByte	TokenNameIdentifier	 second Byte
=	TokenNameEQUAL	
byteArray	TokenNameIdentifier	 byte Array
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
shortArray	TokenNameIdentifier	 short Array
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
secondByte	TokenNameIdentifier	 second Byte
<<	TokenNameLEFT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
+	TokenNamePLUS	
firstByte	TokenNameIdentifier	 first Byte
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Method to interpret a byte array to a int array, depending on 	TokenNameCOMMENT_LINE	Method to interpret a byte array to a int array, depending on 
// whether the bytes are stored in a big endian or little endian format. 	TokenNameCOMMENT_LINE	whether the bytes are stored in a big endian or little endian format. 
private	TokenNameprivate	
void	TokenNamevoid	
interpretBytesAsInts	TokenNameIdentifier	 interpret Bytes As Ints
(	TokenNameLPAREN	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
byteArray	TokenNameIdentifier	 byte Array
,	TokenNameCOMMA	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
intArray	TokenNameIdentifier	 int Array
,	TokenNameCOMMA	
int	TokenNameint	
intCount	TokenNameIdentifier	 int Count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBigEndian	TokenNameIdentifier	 is Big Endian
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
intCount	TokenNameIdentifier	 int Count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
intArray	TokenNameIdentifier	 int Array
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
byteArray	TokenNameIdentifier	 byte Array
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
<<	TokenNameLEFT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
byteArray	TokenNameIdentifier	 byte Array
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
<<	TokenNameLEFT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
byteArray	TokenNameIdentifier	 byte Array
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
<<	TokenNameLEFT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
byteArray	TokenNameIdentifier	 byte Array
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
intCount	TokenNameIdentifier	 int Count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
intArray	TokenNameIdentifier	 int Array
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
byteArray	TokenNameIdentifier	 byte Array
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
byteArray	TokenNameIdentifier	 byte Array
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
<<	TokenNameLEFT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
byteArray	TokenNameIdentifier	 byte Array
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
<<	TokenNameLEFT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
byteArray	TokenNameIdentifier	 byte Array
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
<<	TokenNameLEFT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Uncompress packbits compressed image data. 	TokenNameCOMMENT_LINE	Uncompress packbits compressed image data. 
private	TokenNameprivate	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
decodePackbits	TokenNameIdentifier	 decode Packbits
(	TokenNameLPAREN	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
int	TokenNameint	
arraySize	TokenNameIdentifier	 array Size
,	TokenNameCOMMA	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
dst	TokenNameIdentifier	 dst
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
dst	TokenNameIdentifier	 dst
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dst	TokenNameIdentifier	 dst
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
arraySize	TokenNameIdentifier	 array Size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
srcCount	TokenNameIdentifier	 src Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
dstCount	TokenNameIdentifier	 dst Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
repeat	TokenNameIdentifier	 repeat
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
dstCount	TokenNameIdentifier	 dst Count
<	TokenNameLESS	
arraySize	TokenNameIdentifier	 array Size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
data	TokenNameIdentifier	 data
[	TokenNameLBRACKET	
srcCount	TokenNameIdentifier	 src Count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
b	TokenNameIdentifier	 b
<=	TokenNameLESS_EQUAL	
127	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// literal run packet 	TokenNameCOMMENT_LINE	literal run packet 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dst	TokenNameIdentifier	 dst
[	TokenNameLBRACKET	
dstCount	TokenNameIdentifier	 dst Count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
data	TokenNameIdentifier	 data
[	TokenNameLBRACKET	
srcCount	TokenNameIdentifier	 src Count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
<=	TokenNameLESS_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
b	TokenNameIdentifier	 b
>=	TokenNameGREATER_EQUAL	
-	TokenNameMINUS	
127	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 2 byte encoded run packet 	TokenNameCOMMENT_LINE	2 byte encoded run packet 
repeat	TokenNameIdentifier	 repeat
=	TokenNameEQUAL	
data	TokenNameIdentifier	 data
[	TokenNameLBRACKET	
srcCount	TokenNameIdentifier	 src Count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
(	TokenNameLPAREN	
-	TokenNameMINUS	
b	TokenNameIdentifier	 b
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dst	TokenNameIdentifier	 dst
[	TokenNameLBRACKET	
dstCount	TokenNameIdentifier	 dst Count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
repeat	TokenNameIdentifier	 repeat
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// no-op packet. Do nothing 	TokenNameCOMMENT_LINE	no-op packet. Do nothing 
srcCount	TokenNameIdentifier	 src Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
ArrayIndexOutOfBoundsException	TokenNameIdentifier	 Array Index Out Of Bounds Exception
ae	TokenNameIdentifier	 ae
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"TIFFImage14"	TokenNameStringLiteral	TIFFImage14
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
dst	TokenNameIdentifier	 dst
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Need a createColorModel(). 	TokenNameCOMMENT_LINE	Need a createColorModel(). 
// Create ComponentColorModel for TYPE_RGB images 	TokenNameCOMMENT_LINE	Create ComponentColorModel for TYPE_RGB images 
private	TokenNameprivate	
ComponentColorModel	TokenNameIdentifier	 Component Color Model
createAlphaComponentColorModel	TokenNameIdentifier	 create Alpha Component Color Model
(	TokenNameLPAREN	
int	TokenNameint	
dataType	TokenNameIdentifier	 data Type
,	TokenNameCOMMA	
int	TokenNameint	
numBands	TokenNameIdentifier	 num Bands
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isAlphaPremultiplied	TokenNameIdentifier	 is Alpha Premultiplied
,	TokenNameCOMMA	
int	TokenNameint	
transparency	TokenNameIdentifier	 transparency
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ComponentColorModel	TokenNameIdentifier	 Component Color Model
ccm	TokenNameIdentifier	 ccm
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
RGBBits	TokenNameIdentifier	 RGB Bits
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
ColorSpace	TokenNameIdentifier	 Color Space
cs	TokenNameIdentifier	 cs
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
numBands	TokenNameIdentifier	 num Bands
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
2	TokenNameIntegerLiteral	
:	TokenNameCOLON	
// gray+alpha 	TokenNameCOMMENT_LINE	gray+alpha 
cs	TokenNameIdentifier	 cs
=	TokenNameEQUAL	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
CS_GRAY	TokenNameIdentifier	 CS  GRAY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
4	TokenNameIntegerLiteral	
:	TokenNameCOLON	
// RGB+alpha 	TokenNameCOMMENT_LINE	RGB+alpha 
cs	TokenNameIdentifier	 cs
=	TokenNameEQUAL	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
CS_sRGB	TokenNameIdentifier	 CS s RGB
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
componentSize	TokenNameIdentifier	 component Size
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_BYTE	TokenNameIdentifier	 TYPE  BYTE
:	TokenNameCOLON	
componentSize	TokenNameIdentifier	 component Size
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_USHORT	TokenNameIdentifier	 TYPE  USHORT
:	TokenNameCOLON	
case	TokenNamecase	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_SHORT	TokenNameIdentifier	 TYPE  SHORT
:	TokenNameCOLON	
componentSize	TokenNameIdentifier	 component Size
=	TokenNameEQUAL	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_INT	TokenNameIdentifier	 TYPE  INT
:	TokenNameCOLON	
componentSize	TokenNameIdentifier	 component Size
=	TokenNameEQUAL	
32	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
RGBBits	TokenNameIdentifier	 RGB Bits
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
numBands	TokenNameIdentifier	 num Bands
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numBands	TokenNameIdentifier	 num Bands
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
RGBBits	TokenNameIdentifier	 RGB Bits
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
componentSize	TokenNameIdentifier	 component Size
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ccm	TokenNameIdentifier	 ccm
=	TokenNameEQUAL	
new	TokenNamenew	
ComponentColorModel	TokenNameIdentifier	 Component Color Model
(	TokenNameLPAREN	
cs	TokenNameIdentifier	 cs
,	TokenNameCOMMA	
RGBBits	TokenNameIdentifier	 RGB Bits
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
isAlphaPremultiplied	TokenNameIdentifier	 is Alpha Premultiplied
,	TokenNameCOMMA	
transparency	TokenNameIdentifier	 transparency
,	TokenNameCOMMA	
dataType	TokenNameIdentifier	 data Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
ccm	TokenNameIdentifier	 ccm
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
