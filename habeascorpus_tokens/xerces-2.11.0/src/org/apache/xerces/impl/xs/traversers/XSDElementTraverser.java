/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
traversers	TokenNameIdentifier	 traversers
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Locale	TokenNameIdentifier	 Locale
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
ValidatedInfo	TokenNameIdentifier	 Validated Info
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSAnnotationImpl	TokenNameIdentifier	 XS Annotation Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSConstraints	TokenNameIdentifier	 XS Constraints
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
XInt	TokenNameIdentifier	 X Int
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
DOMUtil	TokenNameIdentifier	 DOM Util
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
SymbolTable	TokenNameIdentifier	 Symbol Table
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
XMLChar	TokenNameIdentifier	 XML Char
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
QName	TokenNameIdentifier	 Q Name
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSConstants	TokenNameIdentifier	 XS Constants
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSObject	TokenNameIdentifier	 XS Object
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSObjectList	TokenNameIdentifier	 XS Object List
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Attr	TokenNameIdentifier	 Attr
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Element	TokenNameIdentifier	 Element
;	TokenNameSEMICOLON	
/** * The element declaration schema component traverser. * <element * abstract = boolean : false * block = (#all | List of (extension | restriction | substitution)) * default = string * final = (#all | List of (extension | restriction)) * fixed = string * form = (qualified | unqualified) * id = ID * maxOccurs = (nonNegativeInteger | unbounded) : 1 * minOccurs = nonNegativeInteger : 1 * name = NCName * nillable = boolean : false * ref = QName * substitutionGroup = QName * type = QName * {any attributes with non-schema namespace . . .}> * Content: (annotation?, ((simpleType | complexType)?, (unique | key | keyref)*)) * </element> * * @xerces.internal * * @author Sandy Gao, IBM * * @version $Id: XSDElementTraverser.java 821931 2009-10-05 17:42:57Z sandygao $ */	TokenNameCOMMENT_JAVADOC	 The element declaration schema component traverser. <element abstract = boolean : false block = (#all | List of (extension | restriction | substitution)) default = string final = (#all | List of (extension | restriction)) fixed = string form = (qualified | unqualified) id = ID maxOccurs = (nonNegativeInteger | unbounded) : 1 minOccurs = nonNegativeInteger : 1 name = NCName nillable = boolean : false ref = QName substitutionGroup = QName type = QName {any attributes with non-schema namespace . . .}> Content: (annotation?, ((simpleType | complexType)?, (unique | key | keyref)*)) </element> * @xerces.internal * @author Sandy Gao, IBM * @version $Id: XSDElementTraverser.java 821931 2009-10-05 17:42:57Z sandygao $ 
class	TokenNameclass	
XSDElementTraverser	TokenNameIdentifier	 XSD Element Traverser
extends	TokenNameextends	
XSDAbstractTraverser	TokenNameIdentifier	 XSD Abstract Traverser
{	TokenNameLBRACE	
protected	TokenNameprotected	
final	TokenNamefinal	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
fTempElementDecl	TokenNameIdentifier	 f Temp Element Decl
=	TokenNameEQUAL	
new	TokenNamenew	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// this controls what happens when a local element is encountered. 	TokenNameCOMMENT_LINE	this controls what happens when a local element is encountered. 
// We may not encounter all local elements when first parsing. 	TokenNameCOMMENT_LINE	We may not encounter all local elements when first parsing. 
boolean	TokenNameboolean	
fDeferTraversingLocalElements	TokenNameIdentifier	 f Defer Traversing Local Elements
;	TokenNameSEMICOLON	
XSDElementTraverser	TokenNameIdentifier	 XSD Element Traverser
(	TokenNameLPAREN	
XSDHandler	TokenNameIdentifier	 XSD Handler
handler	TokenNameIdentifier	 handler
,	TokenNameCOMMA	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
gAttrCheck	TokenNameIdentifier	 g Attr Check
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
handler	TokenNameIdentifier	 handler
,	TokenNameCOMMA	
gAttrCheck	TokenNameIdentifier	 g Attr Check
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Traverse a locally declared element (or an element reference). * * To handle the recursive cases efficiently, we delay the traversal * and return an empty particle node. We'll fill in this particle node * later after we've done with all the global declarations. * This method causes a number of data structures in the schema handler to be filled in. * * @param elmDecl * @param schemaDoc * @param grammar * @return the particle */	TokenNameCOMMENT_JAVADOC	 Traverse a locally declared element (or an element reference). * To handle the recursive cases efficiently, we delay the traversal and return an empty particle node. We'll fill in this particle node later after we've done with all the global declarations. This method causes a number of data structures in the schema handler to be filled in. * @param elmDecl @param schemaDoc @param grammar @return the particle 
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
traverseLocal	TokenNameIdentifier	 traverse Local
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
elmDecl	TokenNameIdentifier	 elm Decl
,	TokenNameCOMMA	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
grammar	TokenNameIdentifier	 grammar
,	TokenNameCOMMA	
int	TokenNameint	
allContextFlags	TokenNameIdentifier	 all Context Flags
,	TokenNameCOMMA	
XSObject	TokenNameIdentifier	 XS Object
parent	TokenNameIdentifier	 parent
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
particle	TokenNameIdentifier	 particle
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
fDeclPool	TokenNameIdentifier	 f Decl Pool
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
particle	TokenNameIdentifier	 particle
=	TokenNameEQUAL	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
fDeclPool	TokenNameIdentifier	 f Decl Pool
.	TokenNameDOT	
getParticleDecl	TokenNameIdentifier	 get Particle Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
particle	TokenNameIdentifier	 particle
=	TokenNameEQUAL	
new	TokenNamenew	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDeferTraversingLocalElements	TokenNameIdentifier	 f Defer Traversing Local Elements
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// The only thing we care about now is whether this element has 	TokenNameCOMMENT_LINE	The only thing we care about now is whether this element has 
// minOccurs=0. This affects (if the element appears in a complex 	TokenNameCOMMENT_LINE	minOccurs=0. This affects (if the element appears in a complex 
// type) whether a type has emptiable content. 	TokenNameCOMMENT_LINE	type) whether a type has emptiable content. 
particle	TokenNameIdentifier	 particle
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
=	TokenNameEQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ELEMENT	TokenNameIdentifier	 PARTICLE  ELEMENT
;	TokenNameSEMICOLON	
Attr	TokenNameIdentifier	 Attr
attr	TokenNameIdentifier	 attr
=	TokenNameEQUAL	
elmDecl	TokenNameIdentifier	 elm Decl
.	TokenNameDOT	
getAttributeNode	TokenNameIdentifier	 get Attribute Node
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATT_MINOCCURS	TokenNameIdentifier	 ATT  MINOCCURS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
attr	TokenNameIdentifier	 attr
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
min	TokenNameIdentifier	 min
=	TokenNameEQUAL	
attr	TokenNameIdentifier	 attr
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
int	TokenNameint	
m	TokenNameIdentifier	 m
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
parseInt	TokenNameIdentifier	 parse Int
(	TokenNameLPAREN	
XMLChar	TokenNameIdentifier	 XML Char
.	TokenNameDOT	
trim	TokenNameIdentifier	 trim
(	TokenNameLPAREN	
min	TokenNameIdentifier	 min
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
m	TokenNameIdentifier	 m
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
particle	TokenNameIdentifier	 particle
.	TokenNameDOT	
fMinOccurs	TokenNameIdentifier	 f Min Occurs
=	TokenNameEQUAL	
m	TokenNameIdentifier	 m
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
NumberFormatException	TokenNameIdentifier	 Number Format Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
fillInLocalElemInfo	TokenNameIdentifier	 fill In Local Elem Info
(	TokenNameLPAREN	
elmDecl	TokenNameIdentifier	 elm Decl
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
allContextFlags	TokenNameIdentifier	 all Context Flags
,	TokenNameCOMMA	
parent	TokenNameIdentifier	 parent
,	TokenNameCOMMA	
particle	TokenNameIdentifier	 particle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
traverseLocal	TokenNameIdentifier	 traverse Local
(	TokenNameLPAREN	
particle	TokenNameIdentifier	 particle
,	TokenNameCOMMA	
elmDecl	TokenNameIdentifier	 elm Decl
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
,	TokenNameCOMMA	
allContextFlags	TokenNameIdentifier	 all Context Flags
,	TokenNameCOMMA	
parent	TokenNameIdentifier	 parent
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// If it's an empty particle, return null. 	TokenNameCOMMENT_LINE	If it's an empty particle, return null. 
if	TokenNameif	
(	TokenNameLPAREN	
particle	TokenNameIdentifier	 particle
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_EMPTY	TokenNameIdentifier	 PARTICLE  EMPTY
)	TokenNameRPAREN	
particle	TokenNameIdentifier	 particle
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
particle	TokenNameIdentifier	 particle
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Traverse a locally declared element (or an element reference). * * This is the real traversal method. It's called after we've done with * all the global declarations. * * @param index */	TokenNameCOMMENT_JAVADOC	 Traverse a locally declared element (or an element reference). * This is the real traversal method. It's called after we've done with all the global declarations. * @param index 
protected	TokenNameprotected	
void	TokenNamevoid	
traverseLocal	TokenNameIdentifier	 traverse Local
(	TokenNameLPAREN	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
particle	TokenNameIdentifier	 particle
,	TokenNameCOMMA	
Element	TokenNameIdentifier	 Element
elmDecl	TokenNameIdentifier	 elm Decl
,	TokenNameCOMMA	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
grammar	TokenNameIdentifier	 grammar
,	TokenNameCOMMA	
int	TokenNameint	
allContextFlags	TokenNameIdentifier	 all Context Flags
,	TokenNameCOMMA	
XSObject	TokenNameIdentifier	 XS Object
parent	TokenNameIdentifier	 parent
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
localNSDecls	TokenNameIdentifier	 local NS Decls
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
localNSDecls	TokenNameIdentifier	 local NS Decls
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fNamespaceSupport	TokenNameIdentifier	 f Namespace Support
.	TokenNameDOT	
setEffectiveContext	TokenNameIdentifier	 set Effective Context
(	TokenNameLPAREN	
localNSDecls	TokenNameIdentifier	 local NS Decls
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// General Attribute Checking 	TokenNameCOMMENT_LINE	General Attribute Checking 
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
attrValues	TokenNameIdentifier	 attr Values
=	TokenNameEQUAL	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
checkAttributes	TokenNameIdentifier	 check Attributes
(	TokenNameLPAREN	
elmDecl	TokenNameIdentifier	 elm Decl
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
QName	TokenNameIdentifier	 Q Name
refAtt	TokenNameIdentifier	 ref Att
=	TokenNameEQUAL	
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
)	TokenNameRPAREN	
attrValues	TokenNameIdentifier	 attr Values
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_REF	TokenNameIdentifier	 ATTIDX  REF
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
XInt	TokenNameIdentifier	 X Int
minAtt	TokenNameIdentifier	 min Att
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XInt	TokenNameIdentifier	 X Int
)	TokenNameRPAREN	
attrValues	TokenNameIdentifier	 attr Values
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_MINOCCURS	TokenNameIdentifier	 ATTIDX  MINOCCURS
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
XInt	TokenNameIdentifier	 X Int
maxAtt	TokenNameIdentifier	 max Att
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XInt	TokenNameIdentifier	 X Int
)	TokenNameRPAREN	
attrValues	TokenNameIdentifier	 attr Values
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_MAXOCCURS	TokenNameIdentifier	 ATTIDX  MAXOCCURS
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
element	TokenNameIdentifier	 element
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
XSAnnotationImpl	TokenNameIdentifier	 XS Annotation Impl
annotation	TokenNameIdentifier	 annotation
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
elmDecl	TokenNameIdentifier	 elm Decl
.	TokenNameDOT	
getAttributeNode	TokenNameIdentifier	 get Attribute Node
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATT_REF	TokenNameIdentifier	 ATT  REF
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
refAtt	TokenNameIdentifier	 ref Att
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
getGlobalDecl	TokenNameIdentifier	 get Global Decl
(	TokenNameLPAREN	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
XSDHandler	TokenNameIdentifier	 XSD Handler
.	TokenNameDOT	
ELEMENT_TYPE	TokenNameIdentifier	 ELEMENT  TYPE
,	TokenNameCOMMA	
refAtt	TokenNameIdentifier	 ref Att
,	TokenNameCOMMA	
elmDecl	TokenNameIdentifier	 elm Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Element	TokenNameIdentifier	 Element
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getFirstChildElement	TokenNameIdentifier	 get First Child Element
(	TokenNameLPAREN	
elmDecl	TokenNameIdentifier	 elm Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ANNOTATION	TokenNameIdentifier	 ELT  ANNOTATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
annotation	TokenNameIdentifier	 annotation
=	TokenNameEQUAL	
traverseAnnotationDecl	TokenNameIdentifier	 traverse Annotation Decl
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
attrValues	TokenNameIdentifier	 attr Values
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
text	TokenNameIdentifier	 text
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getSyntheticAnnotation	TokenNameIdentifier	 get Synthetic Annotation
(	TokenNameLPAREN	
elmDecl	TokenNameIdentifier	 elm Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
annotation	TokenNameIdentifier	 annotation
=	TokenNameEQUAL	
traverseSyntheticAnnotation	TokenNameIdentifier	 traverse Synthetic Annotation
(	TokenNameLPAREN	
elmDecl	TokenNameIdentifier	 elm Decl
,	TokenNameCOMMA	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
attrValues	TokenNameIdentifier	 attr Values
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Element Declaration Representation OK 	TokenNameCOMMENT_LINE	Element Declaration Representation OK 
// 2 If the item's parent is not <schema>, then all of the following must be true: 	TokenNameCOMMENT_LINE	2 If the item's parent is not <schema>, then all of the following must be true: 
// 2.1 One of ref or name must be present, but not both. 	TokenNameCOMMENT_LINE	2.1 One of ref or name must be present, but not both. 
// 2.2 If ref is present, then all of <complexType>, <simpleType>, <key>, <keyref>, <unique>, nillable, default, fixed, form, block and type must be absent, i.e. only minOccurs, maxOccurs, id are allowed in addition to ref, along with <annotation>. 	TokenNameCOMMENT_LINE	2.2 If ref is present, then all of <complexType>, <simpleType>, <key>, <keyref>, <unique>, nillable, default, fixed, form, block and type must be absent, i.e. only minOccurs, maxOccurs, id are allowed in addition to ref, along with <annotation>. 
if	TokenNameif	
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"src-element.2.2"	TokenNameStringLiteral	src-element.2.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
refAtt	TokenNameIdentifier	 ref Att
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
=	TokenNameEQUAL	
traverseNamedElement	TokenNameIdentifier	 traverse Named Element
(	TokenNameLPAREN	
elmDecl	TokenNameIdentifier	 elm Decl
,	TokenNameCOMMA	
attrValues	TokenNameIdentifier	 attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
parent	TokenNameIdentifier	 parent
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
particle	TokenNameIdentifier	 particle
.	TokenNameDOT	
fMinOccurs	TokenNameIdentifier	 f Min Occurs
=	TokenNameEQUAL	
minAtt	TokenNameIdentifier	 min Att
.	TokenNameDOT	
intValue	TokenNameIdentifier	 int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
particle	TokenNameIdentifier	 particle
.	TokenNameDOT	
fMaxOccurs	TokenNameIdentifier	 f Max Occurs
=	TokenNameEQUAL	
maxAtt	TokenNameIdentifier	 max Att
.	TokenNameDOT	
intValue	TokenNameIdentifier	 int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
particle	TokenNameIdentifier	 particle
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
=	TokenNameEQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ELEMENT	TokenNameIdentifier	 PARTICLE  ELEMENT
;	TokenNameSEMICOLON	
particle	TokenNameIdentifier	 particle
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
=	TokenNameEQUAL	
element	TokenNameIdentifier	 element
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
particle	TokenNameIdentifier	 particle
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
=	TokenNameEQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_EMPTY	TokenNameIdentifier	 PARTICLE  EMPTY
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
refAtt	TokenNameIdentifier	 ref Att
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSObjectList	TokenNameIdentifier	 XS Object List
annotations	TokenNameIdentifier	 annotations
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
annotation	TokenNameIdentifier	 annotation
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
annotations	TokenNameIdentifier	 annotations
=	TokenNameEQUAL	
new	TokenNamenew	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
)	TokenNameRPAREN	
annotations	TokenNameIdentifier	 annotations
)	TokenNameRPAREN	
.	TokenNameDOT	
addXSObject	TokenNameIdentifier	 add XS Object
(	TokenNameLPAREN	
annotation	TokenNameIdentifier	 annotation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
annotations	TokenNameIdentifier	 annotations
=	TokenNameEQUAL	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
.	TokenNameDOT	
EMPTY_LIST	TokenNameIdentifier	 EMPTY  LIST
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
particle	TokenNameIdentifier	 particle
.	TokenNameDOT	
fAnnotations	TokenNameIdentifier	 f Annotations
=	TokenNameEQUAL	
annotations	TokenNameIdentifier	 annotations
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
particle	TokenNameIdentifier	 particle
.	TokenNameDOT	
fAnnotations	TokenNameIdentifier	 f Annotations
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fAnnotations	TokenNameIdentifier	 f Annotations
:	TokenNameCOLON	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
.	TokenNameDOT	
EMPTY_LIST	TokenNameIdentifier	 EMPTY  LIST
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Long	TokenNameIdentifier	 Long
defaultVals	TokenNameIdentifier	 default Vals
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Long	TokenNameIdentifier	 Long
)	TokenNameRPAREN	
attrValues	TokenNameIdentifier	 attr Values
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_FROMDEFAULT	TokenNameIdentifier	 ATTIDX  FROMDEFAULT
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
checkOccurrences	TokenNameIdentifier	 check Occurrences
(	TokenNameLPAREN	
particle	TokenNameIdentifier	 particle
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ELEMENT	TokenNameIdentifier	 ELT  ELEMENT
,	TokenNameCOMMA	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
)	TokenNameRPAREN	
elmDecl	TokenNameIdentifier	 elm Decl
.	TokenNameDOT	
getParentNode	TokenNameIdentifier	 get Parent Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
allContextFlags	TokenNameIdentifier	 all Context Flags
,	TokenNameCOMMA	
defaultVals	TokenNameIdentifier	 default Vals
.	TokenNameDOT	
longValue	TokenNameIdentifier	 long Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
attrValues	TokenNameIdentifier	 attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Traverse a globally declared element. * * @param elmDecl * @param schemaDoc * @param grammar * @return the element declaration */	TokenNameCOMMENT_JAVADOC	 Traverse a globally declared element. * @param elmDecl @param schemaDoc @param grammar @return the element declaration 
XSElementDecl	TokenNameIdentifier	 XS Element Decl
traverseGlobal	TokenNameIdentifier	 traverse Global
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
elmDecl	TokenNameIdentifier	 elm Decl
,	TokenNameCOMMA	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// General Attribute Checking' 	TokenNameCOMMENT_LINE	General Attribute Checking' 
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
attrValues	TokenNameIdentifier	 attr Values
=	TokenNameEQUAL	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
checkAttributes	TokenNameIdentifier	 check Attributes
(	TokenNameLPAREN	
elmDecl	TokenNameIdentifier	 elm Decl
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
element	TokenNameIdentifier	 element
=	TokenNameEQUAL	
traverseNamedElement	TokenNameIdentifier	 traverse Named Element
(	TokenNameLPAREN	
elmDecl	TokenNameIdentifier	 elm Decl
,	TokenNameCOMMA	
attrValues	TokenNameIdentifier	 attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
attrValues	TokenNameIdentifier	 attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
element	TokenNameIdentifier	 element
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Traverse a globally declared element. * * @param elmDecl * @param attrValues * @param schemaDoc * @param grammar * @param isGlobal * @return the element declaration */	TokenNameCOMMENT_JAVADOC	 Traverse a globally declared element. * @param elmDecl @param attrValues @param schemaDoc @param grammar @param isGlobal @return the element declaration 
XSElementDecl	TokenNameIdentifier	 XS Element Decl
traverseNamedElement	TokenNameIdentifier	 traverse Named Element
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
elmDecl	TokenNameIdentifier	 elm Decl
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
attrValues	TokenNameIdentifier	 attr Values
,	TokenNameCOMMA	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
grammar	TokenNameIdentifier	 grammar
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isGlobal	TokenNameIdentifier	 is Global
,	TokenNameCOMMA	
XSObject	TokenNameIdentifier	 XS Object
parent	TokenNameIdentifier	 parent
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Boolean	TokenNameIdentifier	 Boolean
abstractAtt	TokenNameIdentifier	 abstract Att
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Boolean	TokenNameIdentifier	 Boolean
)	TokenNameRPAREN	
attrValues	TokenNameIdentifier	 attr Values
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_ABSTRACT	TokenNameIdentifier	 ATTIDX  ABSTRACT
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
XInt	TokenNameIdentifier	 X Int
blockAtt	TokenNameIdentifier	 block Att
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XInt	TokenNameIdentifier	 X Int
)	TokenNameRPAREN	
attrValues	TokenNameIdentifier	 attr Values
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_BLOCK	TokenNameIdentifier	 ATTIDX  BLOCK
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
defaultAtt	TokenNameIdentifier	 default Att
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
attrValues	TokenNameIdentifier	 attr Values
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_DEFAULT	TokenNameIdentifier	 ATTIDX  DEFAULT
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
XInt	TokenNameIdentifier	 X Int
finalAtt	TokenNameIdentifier	 final Att
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XInt	TokenNameIdentifier	 X Int
)	TokenNameRPAREN	
attrValues	TokenNameIdentifier	 attr Values
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_FINAL	TokenNameIdentifier	 ATTIDX  FINAL
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
fixedAtt	TokenNameIdentifier	 fixed Att
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
attrValues	TokenNameIdentifier	 attr Values
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_FIXED	TokenNameIdentifier	 ATTIDX  FIXED
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
XInt	TokenNameIdentifier	 X Int
formAtt	TokenNameIdentifier	 form Att
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XInt	TokenNameIdentifier	 X Int
)	TokenNameRPAREN	
attrValues	TokenNameIdentifier	 attr Values
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_FORM	TokenNameIdentifier	 ATTIDX  FORM
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
nameAtt	TokenNameIdentifier	 name Att
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
attrValues	TokenNameIdentifier	 attr Values
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_NAME	TokenNameIdentifier	 ATTIDX  NAME
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
Boolean	TokenNameIdentifier	 Boolean
nillableAtt	TokenNameIdentifier	 nillable Att
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Boolean	TokenNameIdentifier	 Boolean
)	TokenNameRPAREN	
attrValues	TokenNameIdentifier	 attr Values
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_NILLABLE	TokenNameIdentifier	 ATTIDX  NILLABLE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
QName	TokenNameIdentifier	 Q Name
subGroupAtt	TokenNameIdentifier	 sub Group Att
=	TokenNameEQUAL	
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
)	TokenNameRPAREN	
attrValues	TokenNameIdentifier	 attr Values
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_SUBSGROUP	TokenNameIdentifier	 ATTIDX  SUBSGROUP
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
QName	TokenNameIdentifier	 Q Name
typeAtt	TokenNameIdentifier	 type Att
=	TokenNameEQUAL	
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
)	TokenNameRPAREN	
attrValues	TokenNameIdentifier	 attr Values
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_TYPE	TokenNameIdentifier	 ATTIDX  TYPE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// Step 1: get declaration information 	TokenNameCOMMENT_LINE	Step 1: get declaration information 
XSElementDecl	TokenNameIdentifier	 XS Element Decl
element	TokenNameIdentifier	 element
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
fDeclPool	TokenNameIdentifier	 f Decl Pool
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
=	TokenNameEQUAL	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
fDeclPool	TokenNameIdentifier	 f Decl Pool
.	TokenNameDOT	
getElementDecl	TokenNameIdentifier	 get Element Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
=	TokenNameEQUAL	
new	TokenNamenew	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// get 'name' 	TokenNameCOMMENT_LINE	get 'name' 
if	TokenNameif	
(	TokenNameLPAREN	
nameAtt	TokenNameIdentifier	 name Att
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
=	TokenNameEQUAL	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
.	TokenNameDOT	
addSymbol	TokenNameIdentifier	 add Symbol
(	TokenNameLPAREN	
nameAtt	TokenNameIdentifier	 name Att
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// get 'target namespace' 	TokenNameCOMMENT_LINE	get 'target namespace' 
if	TokenNameif	
(	TokenNameLPAREN	
isGlobal	TokenNameIdentifier	 is Global
)	TokenNameRPAREN	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
=	TokenNameEQUAL	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
;	TokenNameSEMICOLON	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
setIsGlobal	TokenNameIdentifier	 set Is Global
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
parent	TokenNameIdentifier	 parent
instanceof	TokenNameinstanceof	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
setIsLocal	TokenNameIdentifier	 set Is Local
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
parent	TokenNameIdentifier	 parent
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
formAtt	TokenNameIdentifier	 form Att
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
formAtt	TokenNameIdentifier	 form Att
.	TokenNameDOT	
intValue	TokenNameIdentifier	 int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
FORM_QUALIFIED	TokenNameIdentifier	 FORM  QUALIFIED
)	TokenNameRPAREN	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
=	TokenNameEQUAL	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
;	TokenNameSEMICOLON	
else	TokenNameelse	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fAreLocalElementsQualified	TokenNameIdentifier	 f Are Local Elements Qualified
)	TokenNameRPAREN	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
=	TokenNameEQUAL	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// get 'block', 'final', 'nillable', 'abstract' 	TokenNameCOMMENT_LINE	get 'block', 'final', 'nillable', 'abstract' 
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fBlock	TokenNameIdentifier	 f Block
=	TokenNameEQUAL	
blockAtt	TokenNameIdentifier	 block Att
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fBlockDefault	TokenNameIdentifier	 f Block Default
:	TokenNameCOLON	
blockAtt	TokenNameIdentifier	 block Att
.	TokenNameDOT	
shortValue	TokenNameIdentifier	 short Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fFinal	TokenNameIdentifier	 f Final
=	TokenNameEQUAL	
finalAtt	TokenNameIdentifier	 final Att
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fFinalDefault	TokenNameIdentifier	 f Final Default
:	TokenNameCOLON	
finalAtt	TokenNameIdentifier	 final Att
.	TokenNameDOT	
shortValue	TokenNameIdentifier	 short Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// discard valid Block/Final 'Default' values that are invalid for Block/Final 	TokenNameCOMMENT_LINE	discard valid Block/Final 'Default' values that are invalid for Block/Final 
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fBlock	TokenNameIdentifier	 f Block
&=	TokenNameAND_EQUAL	
(	TokenNameLPAREN	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_EXTENSION	TokenNameIdentifier	 DERIVATION  EXTENSION
|	TokenNameOR	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
|	TokenNameOR	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_SUBSTITUTION	TokenNameIdentifier	 DERIVATION  SUBSTITUTION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fFinal	TokenNameIdentifier	 f Final
&=	TokenNameAND_EQUAL	
(	TokenNameLPAREN	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_EXTENSION	TokenNameIdentifier	 DERIVATION  EXTENSION
|	TokenNameOR	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nillableAtt	TokenNameIdentifier	 nillable Att
.	TokenNameDOT	
booleanValue	TokenNameIdentifier	 boolean Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
setIsNillable	TokenNameIdentifier	 set Is Nillable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
abstractAtt	TokenNameIdentifier	 abstract Att
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
abstractAtt	TokenNameIdentifier	 abstract Att
.	TokenNameDOT	
booleanValue	TokenNameIdentifier	 boolean Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
setIsAbstract	TokenNameIdentifier	 set Is Abstract
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// get 'value constraint' 	TokenNameCOMMENT_LINE	get 'value constraint' 
if	TokenNameif	
(	TokenNameLPAREN	
fixedAtt	TokenNameIdentifier	 fixed Att
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
=	TokenNameEQUAL	
new	TokenNamenew	
ValidatedInfo	TokenNameIdentifier	 Validated Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
.	TokenNameDOT	
normalizedValue	TokenNameIdentifier	 normalized Value
=	TokenNameEQUAL	
fixedAtt	TokenNameIdentifier	 fixed Att
;	TokenNameSEMICOLON	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
setConstraintType	TokenNameIdentifier	 set Constraint Type
(	TokenNameLPAREN	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
VC_FIXED	TokenNameIdentifier	 VC  FIXED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
defaultAtt	TokenNameIdentifier	 default Att
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
=	TokenNameEQUAL	
new	TokenNamenew	
ValidatedInfo	TokenNameIdentifier	 Validated Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
.	TokenNameDOT	
normalizedValue	TokenNameIdentifier	 normalized Value
=	TokenNameEQUAL	
defaultAtt	TokenNameIdentifier	 default Att
;	TokenNameSEMICOLON	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
setConstraintType	TokenNameIdentifier	 set Constraint Type
(	TokenNameLPAREN	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
VC_DEFAULT	TokenNameIdentifier	 VC  DEFAULT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
setConstraintType	TokenNameIdentifier	 set Constraint Type
(	TokenNameLPAREN	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
VC_NONE	TokenNameIdentifier	 VC  NONE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// get 'substitutionGroup affiliation' 	TokenNameCOMMENT_LINE	get 'substitutionGroup affiliation' 
if	TokenNameif	
(	TokenNameLPAREN	
subGroupAtt	TokenNameIdentifier	 sub Group Att
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fSubGroup	TokenNameIdentifier	 f Sub Group
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
getGlobalDecl	TokenNameIdentifier	 get Global Decl
(	TokenNameLPAREN	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
XSDHandler	TokenNameIdentifier	 XSD Handler
.	TokenNameDOT	
ELEMENT_TYPE	TokenNameIdentifier	 ELEMENT  TYPE
,	TokenNameCOMMA	
subGroupAtt	TokenNameIdentifier	 sub Group Att
,	TokenNameCOMMA	
elmDecl	TokenNameIdentifier	 elm Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// get 'annotation' 	TokenNameCOMMENT_LINE	get 'annotation' 
Element	TokenNameIdentifier	 Element
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getFirstChildElement	TokenNameIdentifier	 get First Child Element
(	TokenNameLPAREN	
elmDecl	TokenNameIdentifier	 elm Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XSAnnotationImpl	TokenNameIdentifier	 XS Annotation Impl
annotation	TokenNameIdentifier	 annotation
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ANNOTATION	TokenNameIdentifier	 ELT  ANNOTATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
annotation	TokenNameIdentifier	 annotation
=	TokenNameEQUAL	
traverseAnnotationDecl	TokenNameIdentifier	 traverse Annotation Decl
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
attrValues	TokenNameIdentifier	 attr Values
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
text	TokenNameIdentifier	 text
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getSyntheticAnnotation	TokenNameIdentifier	 get Synthetic Annotation
(	TokenNameLPAREN	
elmDecl	TokenNameIdentifier	 elm Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
annotation	TokenNameIdentifier	 annotation
=	TokenNameEQUAL	
traverseSyntheticAnnotation	TokenNameIdentifier	 traverse Synthetic Annotation
(	TokenNameLPAREN	
elmDecl	TokenNameIdentifier	 elm Decl
,	TokenNameCOMMA	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
attrValues	TokenNameIdentifier	 attr Values
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
XSObjectList	TokenNameIdentifier	 XS Object List
annotations	TokenNameIdentifier	 annotations
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
annotation	TokenNameIdentifier	 annotation
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
annotations	TokenNameIdentifier	 annotations
=	TokenNameEQUAL	
new	TokenNamenew	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
)	TokenNameRPAREN	
annotations	TokenNameIdentifier	 annotations
)	TokenNameRPAREN	
.	TokenNameDOT	
addXSObject	TokenNameIdentifier	 add XS Object
(	TokenNameLPAREN	
annotation	TokenNameIdentifier	 annotation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
annotations	TokenNameIdentifier	 annotations
=	TokenNameEQUAL	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
.	TokenNameDOT	
EMPTY_LIST	TokenNameIdentifier	 EMPTY  LIST
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fAnnotations	TokenNameIdentifier	 f Annotations
=	TokenNameEQUAL	
annotations	TokenNameIdentifier	 annotations
;	TokenNameSEMICOLON	
// get 'type definition' 	TokenNameCOMMENT_LINE	get 'type definition' 
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
elementType	TokenNameIdentifier	 element Type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
haveAnonType	TokenNameIdentifier	 have Anon Type
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// Handle Anonymous type if there is one 	TokenNameCOMMENT_LINE	Handle Anonymous type if there is one 
if	TokenNameif	
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
childName	TokenNameIdentifier	 child Name
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
childName	TokenNameIdentifier	 child Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_COMPLEXTYPE	TokenNameIdentifier	 ELT  COMPLEXTYPE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
elementType	TokenNameIdentifier	 element Type
=	TokenNameEQUAL	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
fComplexTypeTraverser	TokenNameIdentifier	 f Complex Type Traverser
.	TokenNameDOT	
traverseLocal	TokenNameIdentifier	 traverse Local
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
haveAnonType	TokenNameIdentifier	 have Anon Type
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
childName	TokenNameIdentifier	 child Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_SIMPLETYPE	TokenNameIdentifier	 ELT  SIMPLETYPE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
elementType	TokenNameIdentifier	 element Type
=	TokenNameEQUAL	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
fSimpleTypeTraverser	TokenNameIdentifier	 f Simple Type Traverser
.	TokenNameDOT	
traverseLocal	TokenNameIdentifier	 traverse Local
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
haveAnonType	TokenNameIdentifier	 have Anon Type
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Handler type attribute 	TokenNameCOMMENT_LINE	Handler type attribute 
if	TokenNameif	
(	TokenNameLPAREN	
elementType	TokenNameIdentifier	 element Type
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
typeAtt	TokenNameIdentifier	 type Att
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
elementType	TokenNameIdentifier	 element Type
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
)	TokenNameRPAREN	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
getGlobalDecl	TokenNameIdentifier	 get Global Decl
(	TokenNameLPAREN	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
XSDHandler	TokenNameIdentifier	 XSD Handler
.	TokenNameDOT	
TYPEDECL_TYPE	TokenNameIdentifier	 TYPEDECL  TYPE
,	TokenNameCOMMA	
typeAtt	TokenNameIdentifier	 type Att
,	TokenNameCOMMA	
elmDecl	TokenNameIdentifier	 elm Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
elementType	TokenNameIdentifier	 element Type
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fUnresolvedTypeName	TokenNameIdentifier	 f Unresolved Type Name
=	TokenNameEQUAL	
typeAtt	TokenNameIdentifier	 type Att
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Get it from the substitutionGroup declaration 	TokenNameCOMMENT_LINE	Get it from the substitutionGroup declaration 
if	TokenNameif	
(	TokenNameLPAREN	
elementType	TokenNameIdentifier	 element Type
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fSubGroup	TokenNameIdentifier	 f Sub Group
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
elementType	TokenNameIdentifier	 element Type
=	TokenNameEQUAL	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fSubGroup	TokenNameIdentifier	 f Sub Group
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
elementType	TokenNameIdentifier	 element Type
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
elementType	TokenNameIdentifier	 element Type
=	TokenNameEQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnyType	TokenNameIdentifier	 f Any Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
=	TokenNameEQUAL	
elementType	TokenNameIdentifier	 element Type
;	TokenNameSEMICOLON	
// get 'identity constraint' 	TokenNameCOMMENT_LINE	get 'identity constraint' 
// see if there's something here; it had better be key, keyref or unique. 	TokenNameCOMMENT_LINE	see if there's something here; it had better be key, keyref or unique. 
if	TokenNameif	
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
childName	TokenNameIdentifier	 child Name
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
childName	TokenNameIdentifier	 child Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_KEY	TokenNameIdentifier	 ELT  KEY
)	TokenNameRPAREN	
||	TokenNameOR_OR	
childName	TokenNameIdentifier	 child Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_KEYREF	TokenNameIdentifier	 ELT  KEYREF
)	TokenNameRPAREN	
||	TokenNameOR_OR	
childName	TokenNameIdentifier	 child Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_UNIQUE	TokenNameIdentifier	 ELT  UNIQUE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
childName	TokenNameIdentifier	 child Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_KEY	TokenNameIdentifier	 ELT  KEY
)	TokenNameRPAREN	
||	TokenNameOR_OR	
childName	TokenNameIdentifier	 child Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_UNIQUE	TokenNameIdentifier	 ELT  UNIQUE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// need to set <key>/<unique> to hidden before traversing it, 	TokenNameCOMMENT_LINE	need to set <key>/<unique> to hidden before traversing it, 
// because it has global scope 	TokenNameCOMMENT_LINE	because it has global scope 
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
setHidden	TokenNameIdentifier	 set Hidden
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
fHiddenNodes	TokenNameIdentifier	 f Hidden Nodes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
fUniqueOrKeyTraverser	TokenNameIdentifier	 f Unique Or Key Traverser
.	TokenNameDOT	
traverse	TokenNameIdentifier	 traverse
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getAttrValue	TokenNameIdentifier	 get Attr Value
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATT_NAME	TokenNameIdentifier	 ATT  NAME
)	TokenNameRPAREN	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
checkForDuplicateNames	TokenNameIdentifier	 check For Duplicate Names
(	TokenNameLPAREN	
(	TokenNameLPAREN	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getAttrValue	TokenNameIdentifier	 get Attr Value
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATT_NAME	TokenNameIdentifier	 ATT  NAME
)	TokenNameRPAREN	
:	TokenNameCOLON	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getAttrValue	TokenNameIdentifier	 get Attr Value
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATT_NAME	TokenNameIdentifier	 ATT  NAME
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
ATTRIBUTE_TYPE	TokenNameIdentifier	 ATTRIBUTE  TYPE
,	TokenNameCOMMA	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
getIDRegistry	TokenNameIdentifier	 get ID Registry
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
getIDRegistry_sub	TokenNameIdentifier	 get ID Registry sub
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
childName	TokenNameIdentifier	 child Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_KEYREF	TokenNameIdentifier	 ELT  KEYREF
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
storeKeyRef	TokenNameIdentifier	 store Key Ref
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
childName	TokenNameIdentifier	 child Name
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Step 3: check against schema for schemas 	TokenNameCOMMENT_LINE	Step 3: check against schema for schemas 
// required attributes 	TokenNameCOMMENT_LINE	required attributes 
if	TokenNameif	
(	TokenNameLPAREN	
nameAtt	TokenNameIdentifier	 name Att
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isGlobal	TokenNameIdentifier	 is Global
)	TokenNameRPAREN	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"s4s-att-must-appear"	TokenNameStringLiteral	s4s-att-must-appear
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ELEMENT	TokenNameIdentifier	 ELT  ELEMENT
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATT_NAME	TokenNameIdentifier	 ATT  NAME
}	TokenNameRBRACE	
,	TokenNameCOMMA	
elmDecl	TokenNameIdentifier	 elm Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"src-element.2.1"	TokenNameStringLiteral	src-element.2.1
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
elmDecl	TokenNameIdentifier	 elm Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
nameAtt	TokenNameIdentifier	 name Att
=	TokenNameEQUAL	
NO_NAME	TokenNameIdentifier	 NO  NAME
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// element 	TokenNameCOMMENT_LINE	element 
if	TokenNameif	
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"s4s-elt-must-match.1"	TokenNameStringLiteral	s4s-elt-must-match.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
nameAtt	TokenNameIdentifier	 name Att
,	TokenNameCOMMA	
"(annotation?, (simpleType | complexType)?, (unique | key | keyref)*))"	TokenNameStringLiteral	(annotation?, (simpleType | complexType)?, (unique | key | keyref)*))
,	TokenNameCOMMA	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Step 4: check 3.3.3 constraints 	TokenNameCOMMENT_LINE	Step 4: check 3.3.3 constraints 
// src-element 	TokenNameCOMMENT_LINE	src-element 
// 1 default and fixed must not both be present. 	TokenNameCOMMENT_LINE	1 default and fixed must not both be present. 
if	TokenNameif	
(	TokenNameLPAREN	
defaultAtt	TokenNameIdentifier	 default Att
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
fixedAtt	TokenNameIdentifier	 fixed Att
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"src-element.1"	TokenNameStringLiteral	src-element.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
nameAtt	TokenNameIdentifier	 name Att
}	TokenNameRBRACE	
,	TokenNameCOMMA	
elmDecl	TokenNameIdentifier	 elm Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 2 If the item's parent is not <schema>, then all of the following must be true: 	TokenNameCOMMENT_LINE	2 If the item's parent is not <schema>, then all of the following must be true: 
// 2.1 One of ref or name must be present, but not both. 	TokenNameCOMMENT_LINE	2.1 One of ref or name must be present, but not both. 
// This is checked in XSAttributeChecker 	TokenNameCOMMENT_LINE	This is checked in XSAttributeChecker 
// 2.2 If ref is present, then all of <complexType>, <simpleType>, <key>, <keyref>, <unique>, nillable, default, fixed, form, block and type must be absent, i.e. only minOccurs, maxOccurs, id are allowed in addition to ref, along with <annotation>. 	TokenNameCOMMENT_LINE	2.2 If ref is present, then all of <complexType>, <simpleType>, <key>, <keyref>, <unique>, nillable, default, fixed, form, block and type must be absent, i.e. only minOccurs, maxOccurs, id are allowed in addition to ref, along with <annotation>. 
// Attributes are checked in XSAttributeChecker, elements are checked in "traverse" method 	TokenNameCOMMENT_LINE	Attributes are checked in XSAttributeChecker, elements are checked in "traverse" method 
// 3 type and either <simpleType> or <complexType> are mutually exclusive. 	TokenNameCOMMENT_LINE	3 type and either <simpleType> or <complexType> are mutually exclusive. 
if	TokenNameif	
(	TokenNameLPAREN	
haveAnonType	TokenNameIdentifier	 have Anon Type
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
typeAtt	TokenNameIdentifier	 type Att
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"src-element.3"	TokenNameStringLiteral	src-element.3
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
nameAtt	TokenNameIdentifier	 name Att
}	TokenNameRBRACE	
,	TokenNameCOMMA	
elmDecl	TokenNameIdentifier	 elm Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Step 5: check 3.3.6 constraints 	TokenNameCOMMENT_LINE	Step 5: check 3.3.6 constraints 
// check for NOTATION type 	TokenNameCOMMENT_LINE	check for NOTATION type 
checkNotationType	TokenNameIdentifier	 check Notation Type
(	TokenNameLPAREN	
nameAtt	TokenNameIdentifier	 name Att
,	TokenNameCOMMA	
elementType	TokenNameIdentifier	 element Type
,	TokenNameCOMMA	
elmDecl	TokenNameIdentifier	 elm Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// e-props-correct 	TokenNameCOMMENT_LINE	e-props-correct 
// 2 If there is a {value constraint}, the canonical lexical representation of its value must be valid with respect to the {type definition} as defined in Element Default Valid (Immediate) (3.3.6). 	TokenNameCOMMENT_LINE	2 If there is a {value constraint}, the canonical lexical representation of its value must be valid with respect to the {type definition} as defined in Element Default Valid (Immediate) (3.3.6). 
if	TokenNameif	
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fValidationState	TokenNameIdentifier	 f Validation State
.	TokenNameDOT	
setNamespaceSupport	TokenNameIdentifier	 set Namespace Support
(	TokenNameLPAREN	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fNamespaceSupport	TokenNameIdentifier	 f Namespace Support
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
XSConstraints	TokenNameIdentifier	 XS Constraints
.	TokenNameDOT	
ElementDefaultValidImmediate	TokenNameIdentifier	 Element Default Valid Immediate
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
,	TokenNameCOMMA	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
.	TokenNameDOT	
normalizedValue	TokenNameIdentifier	 normalized Value
,	TokenNameCOMMA	
fValidationState	TokenNameIdentifier	 f Validation State
,	TokenNameCOMMA	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"e-props-correct.2"	TokenNameStringLiteral	e-props-correct.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
nameAtt	TokenNameIdentifier	 name Att
,	TokenNameCOMMA	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
.	TokenNameDOT	
normalizedValue	TokenNameIdentifier	 normalized Value
}	TokenNameRBRACE	
,	TokenNameCOMMA	
elmDecl	TokenNameIdentifier	 elm Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
setConstraintType	TokenNameIdentifier	 set Constraint Type
(	TokenNameLPAREN	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
VC_NONE	TokenNameIdentifier	 VC  NONE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// 4 If there is an {substitution group affiliation}, the {type definition} of the element declaration must be validly derived from the {type definition} of the {substitution group affiliation}, given the value of the {substitution group exclusions} of the {substitution group affiliation}, as defined in Type Derivation OK (Complex) (3.4.6) (if the {type definition} is complex) or as defined in Type Derivation OK (Simple) (3.14.6) (if the {type definition} is simple). 	TokenNameCOMMENT_LINE	4 If there is an {substitution group affiliation}, the {type definition} of the element declaration must be validly derived from the {type definition} of the {substitution group affiliation}, given the value of the {substitution group exclusions} of the {substitution group affiliation}, as defined in Type Derivation OK (Complex) (3.4.6) (if the {type definition} is complex) or as defined in Type Derivation OK (Simple) (3.14.6) (if the {type definition} is simple). 
if	TokenNameif	
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fSubGroup	TokenNameIdentifier	 f Sub Group
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
XSConstraints	TokenNameIdentifier	 XS Constraints
.	TokenNameDOT	
checkTypeDerivationOk	TokenNameIdentifier	 check Type Derivation Ok
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
,	TokenNameCOMMA	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fSubGroup	TokenNameIdentifier	 f Sub Group
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
,	TokenNameCOMMA	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fSubGroup	TokenNameIdentifier	 f Sub Group
.	TokenNameDOT	
fFinal	TokenNameIdentifier	 f Final
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"e-props-correct.4"	TokenNameStringLiteral	e-props-correct.4
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
nameAtt	TokenNameIdentifier	 name Att
,	TokenNameCOMMA	
subGroupAtt	TokenNameIdentifier	 sub Group Att
.	TokenNameDOT	
prefix	TokenNameIdentifier	 prefix
+	TokenNamePLUS	
":"	TokenNameStringLiteral	:
+	TokenNamePLUS	
subGroupAtt	TokenNameIdentifier	 sub Group Att
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
}	TokenNameRBRACE	
,	TokenNameCOMMA	
elmDecl	TokenNameIdentifier	 elm Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fSubGroup	TokenNameIdentifier	 f Sub Group
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// 5 If the {type definition} or {type definition}'s {content type} is or is derived from ID then there must not be a {value constraint}. 	TokenNameCOMMENT_LINE	5 If the {type definition} or {type definition}'s {content type} is or is derived from ID then there must not be a {value constraint}. 
if	TokenNameif	
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
elementType	TokenNameIdentifier	 element Type
.	TokenNameDOT	
getTypeCategory	TokenNameIdentifier	 get Type Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
.	TokenNameDOT	
SIMPLE_TYPE	TokenNameIdentifier	 SIMPLE  TYPE
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
)	TokenNameRPAREN	
elementType	TokenNameIdentifier	 element Type
)	TokenNameRPAREN	
.	TokenNameDOT	
isIDType	TokenNameIdentifier	 is ID Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
elementType	TokenNameIdentifier	 element Type
.	TokenNameDOT	
getTypeCategory	TokenNameIdentifier	 get Type Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
.	TokenNameDOT	
COMPLEX_TYPE	TokenNameIdentifier	 COMPLEX  TYPE
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
elementType	TokenNameIdentifier	 element Type
)	TokenNameRPAREN	
.	TokenNameDOT	
containsTypeID	TokenNameIdentifier	 contains Type ID
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"e-props-correct.5"	TokenNameStringLiteral	e-props-correct.5
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
elmDecl	TokenNameIdentifier	 elm Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
setConstraintType	TokenNameIdentifier	 set Constraint Type
(	TokenNameLPAREN	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
VC_NONE	TokenNameIdentifier	 VC  NONE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Element without a name. Return null. 	TokenNameCOMMENT_LINE	Element without a name. Return null. 
if	TokenNameif	
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// Step 5: register the element decl to the grammar 	TokenNameCOMMENT_LINE	Step 5: register the element decl to the grammar 
if	TokenNameif	
(	TokenNameLPAREN	
isGlobal	TokenNameIdentifier	 is Global
)	TokenNameRPAREN	
{	TokenNameLBRACE	
grammar	TokenNameIdentifier	 grammar
.	TokenNameDOT	
addGlobalElementDeclAll	TokenNameIdentifier	 add Global Element Decl All
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
grammar	TokenNameIdentifier	 grammar
.	TokenNameDOT	
getGlobalElementDecl	TokenNameIdentifier	 get Global Element Decl
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
grammar	TokenNameIdentifier	 grammar
.	TokenNameDOT	
addGlobalElementDecl	TokenNameIdentifier	 add Global Element Decl
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// we also add the element to the tolerate duplicates list as well 	TokenNameCOMMENT_LINE	we also add the element to the tolerate duplicates list as well 
final	TokenNamefinal	
String	TokenNameIdentifier	 String
loc	TokenNameIdentifier	 loc
=	TokenNameEQUAL	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
schemaDocument2SystemId	TokenNameIdentifier	 schema Document2 System Id
(	TokenNameLPAREN	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
element2	TokenNameIdentifier	 element2
=	TokenNameEQUAL	
grammar	TokenNameIdentifier	 grammar
.	TokenNameDOT	
getGlobalElementDecl	TokenNameIdentifier	 get Global Element Decl
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
loc	TokenNameIdentifier	 loc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
element2	TokenNameIdentifier	 element2
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
grammar	TokenNameIdentifier	 grammar
.	TokenNameDOT	
addGlobalElementDecl	TokenNameIdentifier	 add Global Element Decl
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
loc	TokenNameIdentifier	 loc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if we are tolerating duplicates, and we found a duplicate declaration 	TokenNameCOMMENT_LINE	if we are tolerating duplicates, and we found a duplicate declaration 
// use the duplicate one instead 	TokenNameCOMMENT_LINE	use the duplicate one instead 
if	TokenNameif	
(	TokenNameLPAREN	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
fTolerateDuplicates	TokenNameIdentifier	 f Tolerate Duplicates
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
element2	TokenNameIdentifier	 element2
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
=	TokenNameEQUAL	
element2	TokenNameIdentifier	 element2
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
addGlobalElementDecl	TokenNameIdentifier	 add Global Element Decl
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
element	TokenNameIdentifier	 element
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
void	TokenNamevoid	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
SymbolTable	TokenNameIdentifier	 Symbol Table
symbolTable	TokenNameIdentifier	 symbol Table
,	TokenNameCOMMA	
boolean	TokenNameboolean	
validateAnnotations	TokenNameIdentifier	 validate Annotations
,	TokenNameCOMMA	
Locale	TokenNameIdentifier	 Locale
locale	TokenNameIdentifier	 locale
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
symbolTable	TokenNameIdentifier	 symbol Table
,	TokenNameCOMMA	
validateAnnotations	TokenNameIdentifier	 validate Annotations
,	TokenNameCOMMA	
locale	TokenNameIdentifier	 locale
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fDeferTraversingLocalElements	TokenNameIdentifier	 f Defer Traversing Local Elements
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// reset() 	TokenNameCOMMENT_LINE	reset() 
}	TokenNameRBRACE	
